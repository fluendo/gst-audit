/**
 * Gst REST API
 * Version: 1.0
 * Auto-generated by girest-client-generator
 */

// Base types
export type Pointer = string;

// Configuration for API server location
let apiConfig = {
  host: 'localhost',
  port: 9000,
  basePath: '',
  get baseUrl(): string {
    return `http://${this.host}:${this.port}`;
  },
  get normalizedBasePath(): string {
    return this.basePath && !this.basePath.startsWith('/') ? `/${this.basePath}` : this.basePath;
  },
  get fullBaseUrl(): string {
    return `http://${this.host}:${this.port}${this.normalizedBasePath}`;
  },
};

/**
 * Update the API server configuration
 * @param config New configuration with host, port, and/or basePath
 */
export function setApiConfig(config: { host?: string; port?: number; basePath?: string }): void {
  if (config.host !== undefined) {
    apiConfig.host = config.host;
  }
  if (config.port !== undefined) {
    apiConfig.port = config.port;
  }
  if (config.basePath !== undefined) {
    apiConfig.basePath = config.basePath;
  }

  // Reinitialize callback EventSource with new URL
  if (typeof EventSource !== 'undefined' && (config.host !== undefined || config.port !== undefined || config.basePath !== undefined)) {
    initializeCallbackSource();
  }
}

/**
 * Get the current API server configuration
 */
export function getApiConfig(): { host: string; port: number; basePath: string; baseUrl: string } {
  return {
    host: apiConfig.host,
    port: apiConfig.port,
    basePath: apiConfig.basePath,
    baseUrl: apiConfig.baseUrl
  };
}

// FinalizationRegistry for automatic cleanup of GObject instances
const objectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Object/ptr,' + ptr + '/unref')
    .catch(err => console.error('Failed to unref object:', ptr, err));
});

// FinalizationRegistry for automatic cleanup of struct instances
const gobjecttypeinterfaceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/TypeInterface/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectTypeInterface:', ptr, err));
});
const gobjectvalueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Value/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectValue:', ptr, err));
});
const glibvariantRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Variant/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibVariant:', ptr, err));
});
const glibvarianttypeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/VariantType/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibVariantType:', ptr, err));
});
const glibbytesRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Bytes/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibBytes:', ptr, err));
});
const gobjectclosureRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Closure/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectClosure:', ptr, err));
});
const gobjectcclosureRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/CClosure/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectCClosure:', ptr, err));
});
const gobjectparamspecpoolRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/ParamSpecPool/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectParamSpecPool:', ptr, err));
});
const gobjectvaluearrayRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/ValueArray/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectValueArray:', ptr, err));
});
const glibsourceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Source/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSource:', ptr, err));
});
const glibmaincontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MainContext/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMainContext:', ptr, err));
});
const glibcondRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Cond/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibCond:', ptr, err));
});
const glibtimevalRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TimeVal/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTimeVal:', ptr, err));
});
const gmodulemoduleRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GModule/Module/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GModuleModule:', ptr, err));
});
const gliballocatorRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Allocator/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibAllocator:', ptr, err));
});
const glibasyncqueueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/AsyncQueue/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibAsyncQueue:', ptr, err));
});
const glibbookmarkfileRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/BookmarkFile/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibBookmarkFile:', ptr, err));
});
const glibdatetimeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/DateTime/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibDateTime:', ptr, err));
});
const glibtimezoneRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TimeZone/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTimeZone:', ptr, err));
});
const glibbytearrayRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/ByteArray/free')
    .catch(err => console.error('Failed to free GLibByteArray:', ptr, err));
});
const glibcacheRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Cache/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibCache:', ptr, err));
});
const glibchecksumRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Checksum/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibChecksum:', ptr, err));
});
const glibcompletionRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Completion/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibCompletion:', ptr, err));
});
const glibdateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Date/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibDate:', ptr, err));
});
const glibdirRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Dir/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibDir:', ptr, err));
});
const gliberrorRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Error/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibError:', ptr, err));
});
const glibhashtableRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/HashTable/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibHashTable:', ptr, err));
});
const glibhashtableiterRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/HashTableIter/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibHashTableIter:', ptr, err));
});
const glibhmacRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Hmac/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibHmac:', ptr, err));
});
const glibhooklistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/HookList/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibHookList:', ptr, err));
});
const glibhookRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Hook/free')
    .catch(err => console.error('Failed to free GLibHook:', ptr, err));
});
const glibiochannelRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/IOChannel/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibIOChannel:', ptr, err));
});
const glibstringRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/String/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibString:', ptr, err));
});
const glibkeyfileRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/KeyFile/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibKeyFile:', ptr, err));
});
const gliblistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/List/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibList:', ptr, err));
});
const glibmainloopRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MainLoop/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMainLoop:', ptr, err));
});
const glibmappedfileRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MappedFile/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMappedFile:', ptr, err));
});
const glibmarkupparsecontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MarkupParseContext/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMarkupParseContext:', ptr, err));
});
const glibmatchinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MatchInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMatchInfo:', ptr, err));
});
const glibregexRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Regex/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRegex:', ptr, err));
});
const glibmemchunkRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MemChunk/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMemChunk:', ptr, err));
});
const glibnodeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Node/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibNode:', ptr, err));
});
const glibonceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Once/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibOnce:', ptr, err));
});
const gliboptiongroupRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/OptionGroup/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibOptionGroup:', ptr, err));
});
const gliboptioncontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/OptionContext/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibOptionContext:', ptr, err));
});
const glibpathbufRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/PathBuf/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibPathBuf:', ptr, err));
});
const glibpatternspecRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/PatternSpec/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibPatternSpec:', ptr, err));
});
const glibprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Private/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibPrivate:', ptr, err));
});
const glibqueueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Queue/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibQueue:', ptr, err));
});
const glibrwlockRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/RWLock/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRWLock:', ptr, err));
});
const glibrandRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Rand/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRand:', ptr, err));
});
const glibrecmutexRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/RecMutex/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRecMutex:', ptr, err));
});
const glibrelationRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Relation/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRelation:', ptr, err));
});
const glibslistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/SList/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSList:', ptr, err));
});
const glibscannerRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Scanner/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibScanner:', ptr, err));
});
const glibsequenceiterRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/SequenceIter/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSequenceIter:', ptr, err));
});
const glibsequenceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Sequence/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSequence:', ptr, err));
});
const glibstringchunkRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/StringChunk/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibStringChunk:', ptr, err));
});
const glibstrvbuilderRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/StrvBuilder/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibStrvBuilder:', ptr, err));
});
const glibtestcaseRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TestCase/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTestCase:', ptr, err));
});
const glibtestlogbufferRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TestLogBuffer/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTestLogBuffer:', ptr, err));
});
const glibtestlogmsgRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TestLogMsg/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTestLogMsg:', ptr, err));
});
const glibtestsuiteRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TestSuite/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTestSuite:', ptr, err));
});
const glibthreadRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Thread/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibThread:', ptr, err));
});
const glibthreadpoolRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/ThreadPool/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibThreadPool:', ptr, err));
});
const glibtimerRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Timer/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTimer:', ptr, err));
});
const glibtrashstackRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TrashStack/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTrashStack:', ptr, err));
});
const glibtreeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Tree/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTree:', ptr, err));
});
const glibtreenodeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TreeNode/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTreeNode:', ptr, err));
});
const glibtuplesRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Tuples/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTuples:', ptr, err));
});
const gliburiRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Uri/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibUri:', ptr, err));
});
const gliburiparamsiterRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/UriParamsIter/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibUriParamsIter:', ptr, err));
});
const glibvariantbuilderRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/VariantBuilder/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibVariantBuilder:', ptr, err));
});
const glibvariantdictRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/VariantDict/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibVariantDict:', ptr, err));
});
const gstallocationparamsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/AllocationParams/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstAllocationParams:', ptr, err));
});
const gstmemoryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Memory/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMemory:', ptr, err));
});
const gstatomicqueueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/AtomicQueue/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstAtomicQueue:', ptr, err));
});
const gststructureRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Structure/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstStructure:', ptr, err));
});
const gstdatetimeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/DateTime/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstDateTime:', ptr, err));
});
const gststaticpadtemplateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/StaticPadTemplate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstStaticPadTemplate:', ptr, err));
});
const gstcapsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Caps/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstCaps:', ptr, err));
});
const gstcapsfeaturesRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/CapsFeatures/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstCapsFeatures:', ptr, err));
});
const gstpadprobeinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/PadProbeInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPadProbeInfo:', ptr, err));
});
const gstbufferRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Buffer/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstBuffer:', ptr, err));
});
const gstcustommetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/CustomMeta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstCustomMeta:', ptr, err));
});
const gstmetainfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/MetaInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMetaInfo:', ptr, err));
});
const gstmetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Meta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMeta:', ptr, err));
});
const gstparentbuffermetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ParentBufferMeta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstParentBufferMeta:', ptr, err));
});
const gstprotectionmetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ProtectionMeta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstProtectionMeta:', ptr, err));
});
const gstreferencetimestampmetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ReferenceTimestampMeta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstReferenceTimestampMeta:', ptr, err));
});
const gstbufferlistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/BufferList/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstBufferList:', ptr, err));
});
const gsteventRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Event/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstEvent:', ptr, err));
});
const gstiteratorRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Iterator/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstIterator:', ptr, err));
});
const gstsegmentRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Segment/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstSegment:', ptr, err));
});
const gstmessageRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Message/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMessage:', ptr, err));
});
const gstcontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Context/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstContext:', ptr, err));
});
const gsttaglistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/TagList/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstTagList:', ptr, err));
});
const gstsampleRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Sample/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstSample:', ptr, err));
});
const gsttocRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Toc/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstToc:', ptr, err));
});
const gsttocentryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/TocEntry/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstTocEntry:', ptr, err));
});
const gstqueryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Query/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstQuery:', ptr, err));
});
const gstdebugcategoryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/DebugCategory/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstDebugCategory:', ptr, err));
});
const gstdebugmessageRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/DebugMessage/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstDebugMessage:', ptr, err));
});
const gstminiobjectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/MiniObject/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMiniObject:', ptr, err));
});
const gstparsecontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ParseContext/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstParseContext:', ptr, err));
});
const gstpollfdRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/PollFD/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPollFD:', ptr, err));
});
const gstpollRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Poll/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPoll:', ptr, err));
});
const gstpromiseRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Promise/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPromise:', ptr, err));
});
const gststaticcapsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/StaticCaps/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstStaticCaps:', ptr, err));
});
const gsttypefindRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/TypeFind/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstTypeFind:', ptr, err));
});
const gsturiRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Uri/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstUri:', ptr, err));
});

// Callback dispatcher for handling callbacks from the server
const callbackDispatcher = new Map<string, Function>();

let callbackSource: EventSource | null = null;
let isReinitializing = false;

function initializeCallbackSource(): void {
  // Prevent concurrent reinitialization
  if (isReinitializing) {
    return;
  }
  isReinitializing = true;
  
  // Close existing EventSource if it exists
  if (callbackSource) {
    callbackSource.close();
    callbackSource = null;
  }
  
  // Initialize callback dispatcher with EventSource
  if (typeof EventSource !== 'undefined') {
    callbackSource = new EventSource(apiConfig.fullBaseUrl + '/GIRest/callbacks');
    callbackSource.onmessage = (ev) => {
      try {
        const json = JSON.parse(ev.data);
        const cb = callbackDispatcher.get(json.id.toString());
        if (cb) {
          cb(...Object.values(json.data));
        }
      } catch (error) {
        console.error('Error processing callback:', error);
      }
    };
    callbackSource.onerror = (error) => {
      console.error('Callback EventSource error:', error);
    };
    callbackSource.onopen = () => {
      isReinitializing = false;
    };
  } else {
    isReinitializing = false;
  }
}


export type GLibAsciiType = "alnum" | "alpha" | "cntrl" | "digit" | "graph" | "lower" | "print" | "punct" | "space" | "upper" | "xdigit";
export type GLibBookmarkFileError = "invalid_uri" | "invalid_value" | "app_not_registered" | "uri_not_found" | "read" | "unknown_encoding" | "write" | "file_not_found";
export type GLibChecksumType = "md5" | "sha1" | "sha256" | "sha512" | "sha384";
export type GLibChildWatchFunc = (pid: number, wait_status: number, user_data: Pointer) => void;
export type GLibCompareDataFunc = (a: Pointer, b: Pointer, user_data: Pointer) => number;
export type GLibCompareFunc = (a: Pointer, b: Pointer) => number;
export type GLibConvertError = "no_conversion" | "illegal_sequence" | "failed" | "partial_input" | "bad_uri" | "not_absolute_path" | "no_memory" | "embedded_nul";
export type GLibDataForeachFunc = (key_id: number, data_: Pointer, user_data: Pointer) => void;
export type GLibDateDMY = "day" | "month" | "year";
export type GLibDateMonth = "bad_month" | "january" | "february" | "march" | "april" | "may" | "june" | "july" | "august" | "september" | "october" | "november" | "december";
export type GLibDateWeekday = "bad_weekday" | "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";
export type GLibDestroyNotify = (data_: Pointer) => void;
export type GLibErrorClearFunc = (error_: Pointer) => void;
export type GLibErrorCopyFunc = (src_error: Pointer, dest_error: Pointer) => void;
export type GLibErrorInitFunc = (error_: Pointer) => void;
export type GLibErrorType = "unknown" | "unexp_eof" | "unexp_eof_in_string" | "unexp_eof_in_comment" | "non_digit_in_const" | "digit_radix" | "float_radix" | "float_malformed";
export type GLibFileError = "exist" | "isdir" | "acces" | "nametoolong" | "noent" | "notdir" | "nxio" | "nodev" | "rofs" | "txtbsy" | "fault" | "loop" | "nospc" | "nomem" | "mfile" | "nfile" | "badf" | "inval" | "pipe" | "again" | "intr" | "io" | "perm" | "nosys" | "failed";
export type GLibFileSetContentsFlags = "none" | "consistent" | "durable" | "only_existing";
export type GLibFileTest = "is_regular" | "is_symlink" | "is_dir" | "is_executable" | "exists";
export type GLibFormatSizeFlags = "default" | "long_format" | "iec_units" | "bits" | "only_value" | "only_unit";
export type GLibFunc = (data_: Pointer, user_data: Pointer) => void;
export type GLibHFunc = (key: Pointer, value_: Pointer, user_data: Pointer) => void;
export type GLibHRFunc = (key: Pointer, value_: Pointer, user_data: Pointer) => boolean;
export type GLibHookCheckMarshaller = (hook: GLibHook, marshal_data: Pointer) => boolean;
export type GLibHookCompareFunc = (new_hook: GLibHook, sibling: GLibHook) => number;
export type GLibHookFlagMask = "active" | "in_call" | "mask";
export type GLibHookMarshaller = (hook: GLibHook, marshal_data: Pointer) => void;
export type GLibIOChannelError = "fbig" | "inval" | "io" | "isdir" | "nospc" | "nxio" | "overflow" | "pipe" | "failed";
export namespace GLibIOCondition {
  export const IN: 'in' = 'in';
  export const OUT: 'out' = 'out';
  export const PRI: 'pri' = 'pri';
  export const ERR: 'err' = 'err';
  export const HUP: 'hup' = 'hup';
  export const NVAL: 'nval' = 'nval';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOCondition/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GLibIOConditionValue = "in" | "out" | "pri" | "err" | "hup" | "nval";
export type GLibIOError = "none" | "again" | "inval" | "unknown";
export type GLibIOFlags = "none" | "append" | "nonblock" | "is_readable" | "is_writable" | "is_writeable" | "is_seekable" | "mask" | "get_mask" | "set_mask";
export type GLibIOFunc = (source: GLibIOChannel, condition: GLibIOConditionValue, data_: Pointer) => boolean;
export type GLibIOStatus = "error" | "normal" | "eof" | "again";
export type GLibKeyFileError = "unknown_encoding" | "parse" | "not_found" | "key_not_found" | "group_not_found" | "invalid_value";
export type GLibKeyFileFlags = "none" | "keep_comments" | "keep_translations";
export type GLibLogFunc = (log_domain: string, log_level: GLibLogLevelFlags, message: string, user_data: Pointer) => void;
export type GLibLogLevelFlags = "flag_recursion" | "flag_fatal" | "level_error" | "level_critical" | "level_warning" | "level_message" | "level_info" | "level_debug" | "level_mask";
export type GLibLogWriterOutput = "handled" | "unhandled";
export type GLibMainContextFlags = "none" | "ownerless_polling";
export type GLibMarkupCollectType = "invalid" | "string" | "strdup" | "boolean" | "tristate" | "optional";
export type GLibMarkupError = "bad_utf8" | "empty" | "parse" | "unknown_element" | "unknown_attribute" | "invalid_content" | "missing_attribute";
export type GLibMarkupParseFlags = "default_flags" | "do_not_use_this_unsupported_flag" | "treat_cdata_as_text" | "prefix_error_position" | "ignore_qualified";
export type GLibNodeForeachFunc = (node: GLibNode, data_: Pointer) => void;
export type GLibNodeTraverseFunc = (node: GLibNode, data_: Pointer) => boolean;
export namespace GLibNormalizeMode {
  export const DEFAULT: 'default' = 'default';
  export const NFD: 'nfd' = 'nfd';
  export const DEFAULT_COMPOSE: 'default_compose' = 'default_compose';
  export const NFC: 'nfc' = 'nfc';
  export const ALL: 'all' = 'all';
  export const NFKD: 'nfkd' = 'nfkd';
  export const ALL_COMPOSE: 'all_compose' = 'all_compose';
  export const NFKC: 'nfkc' = 'nfkc';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/NormalizeMode/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GLibNormalizeModeValue = "default" | "nfd" | "default_compose" | "nfc" | "all" | "nfkd" | "all_compose" | "nfkc";
export type GLibNumberParserError = "invalid" | "out_of_bounds";
export type GLibOnceStatus = "notcalled" | "progress" | "ready";
export type GLibOptionArg = "none" | "string" | "int" | "callback" | "filename" | "string_array" | "filename_array" | "double" | "int64";
export type GLibOptionError = "unknown_option" | "bad_value" | "failed";
export type GLibOptionFlags = "none" | "hidden" | "in_main" | "reverse" | "no_arg" | "filename" | "optional_arg" | "noalias";
export type GLibRegexCompileFlags = "default" | "caseless" | "multiline" | "dotall" | "extended" | "anchored" | "dollar_endonly" | "ungreedy" | "raw" | "no_auto_capture" | "optimize" | "firstline" | "dupnames" | "newline_cr" | "newline_lf" | "newline_crlf" | "newline_anycrlf" | "bsr_anycrlf" | "javascript_compat";
export type GLibRegexError = "compile" | "optimize" | "replace" | "match" | "internal" | "stray_backslash" | "missing_control_char" | "unrecognized_escape" | "quantifiers_out_of_order" | "quantifier_too_big" | "unterminated_character_class" | "invalid_escape_in_character_class" | "range_out_of_order" | "nothing_to_repeat" | "unrecognized_character" | "posix_named_class_outside_class" | "unmatched_parenthesis" | "inexistent_subpattern_reference" | "unterminated_comment" | "expression_too_large" | "memory_error" | "variable_length_lookbehind" | "malformed_condition" | "too_many_conditional_branches" | "assertion_expected" | "unknown_posix_class_name" | "posix_collating_elements_not_supported" | "hex_code_too_large" | "invalid_condition" | "single_byte_match_in_lookbehind" | "infinite_loop" | "missing_subpattern_name_terminator" | "duplicate_subpattern_name" | "malformed_property" | "unknown_property" | "subpattern_name_too_long" | "too_many_subpatterns" | "invalid_octal_value" | "too_many_branches_in_define" | "define_repetion" | "inconsistent_newline_options" | "missing_back_reference" | "invalid_relative_reference" | "backtracking_control_verb_argument_forbidden" | "unknown_backtracking_control_verb" | "number_too_big" | "missing_subpattern_name" | "missing_digit" | "invalid_data_character" | "extra_subpattern_name" | "backtracking_control_verb_argument_required" | "invalid_control_char" | "missing_name" | "not_supported_in_class" | "too_many_forward_references" | "name_too_long" | "character_value_too_large";
export type GLibRegexEvalCallback = (match_info: GLibMatchInfo, result_: GLibString, user_data: Pointer) => boolean;
export type GLibRegexMatchFlags = "default" | "anchored" | "notbol" | "noteol" | "notempty" | "partial" | "newline_cr" | "newline_lf" | "newline_crlf" | "newline_any" | "newline_anycrlf" | "bsr_anycrlf" | "bsr_any" | "partial_soft" | "partial_hard" | "notempty_atstart";
export type GLibSeekType = "cur" | "set" | "end";
export type GLibSequenceIterCompareFunc = (a: GLibSequenceIter, b: GLibSequenceIter, data_: Pointer) => number;
export type GLibShellError = "bad_quoting" | "empty_string" | "failed";
export type GLibSliceConfig = "always_malloc" | "bypass_magazines" | "working_set_msecs" | "color_increment" | "chunk_sizes" | "contention_counter";
export type GLibSourceFunc = (user_data: Pointer) => boolean;
export type GLibSpawnChildSetupFunc = (data_: Pointer) => void;
export type GLibSpawnError = "fork" | "read" | "chdir" | "acces" | "perm" | "too_big" | "2big" | "noexec" | "nametoolong" | "noent" | "nomem" | "notdir" | "loop" | "txtbusy" | "io" | "nfile" | "mfile" | "inval" | "isdir" | "libbad" | "failed";
export type GLibSpawnFlags = "default" | "leave_descriptors_open" | "do_not_reap_child" | "search_path" | "stdout_to_dev_null" | "stderr_to_dev_null" | "child_inherits_stdin" | "file_and_argv_zero" | "search_path_from_envp" | "cloexec_pipes" | "child_inherits_stdout" | "child_inherits_stderr" | "stdin_from_dev_null";
export type GLibTestDataFunc = (user_data: Pointer) => void;
export type GLibTestFileType = "dist" | "built";
export type GLibTestFunc = () => void;
export type GLibTestLogType = "none" | "error" | "start_binary" | "list_case" | "skip_case" | "start_case" | "stop_case" | "min_result" | "max_result" | "message" | "start_suite" | "stop_suite";
export type GLibTestResult = "success" | "skipped" | "failure" | "incomplete";
export type GLibTestSubprocessFlags = "default" | "inherit_stdin" | "inherit_stdout" | "inherit_stderr";
export type GLibTestTrapFlags = "default" | "silence_stdout" | "silence_stderr" | "inherit_stdin";
export type GLibThreadError = "thread_error_again";
export type GLibThreadFunc = (data_: Pointer) => void;
export type GLibTimeType = "standard" | "daylight" | "universal";
export type GLibTokenType = "eof" | "left_paren" | "right_paren" | "left_curly" | "right_curly" | "left_brace" | "right_brace" | "equal_sign" | "comma" | "none" | "error" | "char" | "binary" | "octal" | "int" | "hex" | "float" | "string" | "symbol" | "identifier" | "identifier_null" | "comment_single" | "comment_multi";
export type GLibTranslateFunc = (str: string, data_: Pointer) => string;
export type GLibTraverseFlags = "leaves" | "non_leaves" | "all" | "mask" | "leafs" | "non_leafs";
export type GLibTraverseFunc = (key: Pointer, value_: Pointer, data_: Pointer) => boolean;
export type GLibTraverseNodeFunc = (node: GLibTreeNode, data_: Pointer) => boolean;
export type GLibTraverseType = "in_order" | "pre_order" | "post_order" | "level_order";
export namespace GLibUnicodeBreakType {
  export const MANDATORY: 'mandatory' = 'mandatory';
  export const CARRIAGE_RETURN: 'carriage_return' = 'carriage_return';
  export const LINE_FEED: 'line_feed' = 'line_feed';
  export const COMBINING_MARK: 'combining_mark' = 'combining_mark';
  export const SURROGATE: 'surrogate' = 'surrogate';
  export const ZERO_WIDTH_SPACE: 'zero_width_space' = 'zero_width_space';
  export const INSEPARABLE: 'inseparable' = 'inseparable';
  export const NON_BREAKING_GLUE: 'non_breaking_glue' = 'non_breaking_glue';
  export const CONTINGENT: 'contingent' = 'contingent';
  export const SPACE: 'space' = 'space';
  export const AFTER: 'after' = 'after';
  export const BEFORE: 'before' = 'before';
  export const BEFORE_AND_AFTER: 'before_and_after' = 'before_and_after';
  export const HYPHEN: 'hyphen' = 'hyphen';
  export const NON_STARTER: 'non_starter' = 'non_starter';
  export const OPEN_PUNCTUATION: 'open_punctuation' = 'open_punctuation';
  export const CLOSE_PUNCTUATION: 'close_punctuation' = 'close_punctuation';
  export const QUOTATION: 'quotation' = 'quotation';
  export const EXCLAMATION: 'exclamation' = 'exclamation';
  export const IDEOGRAPHIC: 'ideographic' = 'ideographic';
  export const NUMERIC: 'numeric' = 'numeric';
  export const INFIX_SEPARATOR: 'infix_separator' = 'infix_separator';
  export const SYMBOL: 'symbol' = 'symbol';
  export const ALPHABETIC: 'alphabetic' = 'alphabetic';
  export const PREFIX: 'prefix' = 'prefix';
  export const POSTFIX: 'postfix' = 'postfix';
  export const COMPLEX_CONTEXT: 'complex_context' = 'complex_context';
  export const AMBIGUOUS: 'ambiguous' = 'ambiguous';
  export const UNKNOWN: 'unknown' = 'unknown';
  export const NEXT_LINE: 'next_line' = 'next_line';
  export const WORD_JOINER: 'word_joiner' = 'word_joiner';
  export const HANGUL_L_JAMO: 'hangul_l_jamo' = 'hangul_l_jamo';
  export const HANGUL_V_JAMO: 'hangul_v_jamo' = 'hangul_v_jamo';
  export const HANGUL_T_JAMO: 'hangul_t_jamo' = 'hangul_t_jamo';
  export const HANGUL_LV_SYLLABLE: 'hangul_lv_syllable' = 'hangul_lv_syllable';
  export const HANGUL_LVT_SYLLABLE: 'hangul_lvt_syllable' = 'hangul_lvt_syllable';
  export const CLOSE_PARANTHESIS: 'close_paranthesis' = 'close_paranthesis';
  export const CLOSE_PARENTHESIS: 'close_parenthesis' = 'close_parenthesis';
  export const CONDITIONAL_JAPANESE_STARTER: 'conditional_japanese_starter' = 'conditional_japanese_starter';
  export const HEBREW_LETTER: 'hebrew_letter' = 'hebrew_letter';
  export const REGIONAL_INDICATOR: 'regional_indicator' = 'regional_indicator';
  export const EMOJI_BASE: 'emoji_base' = 'emoji_base';
  export const EMOJI_MODIFIER: 'emoji_modifier' = 'emoji_modifier';
  export const ZERO_WIDTH_JOINER: 'zero_width_joiner' = 'zero_width_joiner';
  export const AKSARA: 'aksara' = 'aksara';
  export const AKSARA_PRE_BASE: 'aksara_pre_base' = 'aksara_pre_base';
  export const AKSARA_START: 'aksara_start' = 'aksara_start';
  export const VIRAMA_FINAL: 'virama_final' = 'virama_final';
  export const VIRAMA: 'virama' = 'virama';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeBreakType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GLibUnicodeBreakTypeValue = "mandatory" | "carriage_return" | "line_feed" | "combining_mark" | "surrogate" | "zero_width_space" | "inseparable" | "non_breaking_glue" | "contingent" | "space" | "after" | "before" | "before_and_after" | "hyphen" | "non_starter" | "open_punctuation" | "close_punctuation" | "quotation" | "exclamation" | "ideographic" | "numeric" | "infix_separator" | "symbol" | "alphabetic" | "prefix" | "postfix" | "complex_context" | "ambiguous" | "unknown" | "next_line" | "word_joiner" | "hangul_l_jamo" | "hangul_v_jamo" | "hangul_t_jamo" | "hangul_lv_syllable" | "hangul_lvt_syllable" | "close_paranthesis" | "close_parenthesis" | "conditional_japanese_starter" | "hebrew_letter" | "regional_indicator" | "emoji_base" | "emoji_modifier" | "zero_width_joiner" | "aksara" | "aksara_pre_base" | "aksara_start" | "virama_final" | "virama";
export namespace GLibUnicodeScript {
  export const INVALID_CODE: 'invalid_code' = 'invalid_code';
  export const COMMON: 'common' = 'common';
  export const INHERITED: 'inherited' = 'inherited';
  export const ARABIC: 'arabic' = 'arabic';
  export const ARMENIAN: 'armenian' = 'armenian';
  export const BENGALI: 'bengali' = 'bengali';
  export const BOPOMOFO: 'bopomofo' = 'bopomofo';
  export const CHEROKEE: 'cherokee' = 'cherokee';
  export const COPTIC: 'coptic' = 'coptic';
  export const CYRILLIC: 'cyrillic' = 'cyrillic';
  export const DESERET: 'deseret' = 'deseret';
  export const DEVANAGARI: 'devanagari' = 'devanagari';
  export const ETHIOPIC: 'ethiopic' = 'ethiopic';
  export const GEORGIAN: 'georgian' = 'georgian';
  export const GOTHIC: 'gothic' = 'gothic';
  export const GREEK: 'greek' = 'greek';
  export const GUJARATI: 'gujarati' = 'gujarati';
  export const GURMUKHI: 'gurmukhi' = 'gurmukhi';
  export const HAN: 'han' = 'han';
  export const HANGUL: 'hangul' = 'hangul';
  export const HEBREW: 'hebrew' = 'hebrew';
  export const HIRAGANA: 'hiragana' = 'hiragana';
  export const KANNADA: 'kannada' = 'kannada';
  export const KATAKANA: 'katakana' = 'katakana';
  export const KHMER: 'khmer' = 'khmer';
  export const LAO: 'lao' = 'lao';
  export const LATIN: 'latin' = 'latin';
  export const MALAYALAM: 'malayalam' = 'malayalam';
  export const MONGOLIAN: 'mongolian' = 'mongolian';
  export const MYANMAR: 'myanmar' = 'myanmar';
  export const OGHAM: 'ogham' = 'ogham';
  export const OLD_ITALIC: 'old_italic' = 'old_italic';
  export const ORIYA: 'oriya' = 'oriya';
  export const RUNIC: 'runic' = 'runic';
  export const SINHALA: 'sinhala' = 'sinhala';
  export const SYRIAC: 'syriac' = 'syriac';
  export const TAMIL: 'tamil' = 'tamil';
  export const TELUGU: 'telugu' = 'telugu';
  export const THAANA: 'thaana' = 'thaana';
  export const THAI: 'thai' = 'thai';
  export const TIBETAN: 'tibetan' = 'tibetan';
  export const CANADIAN_ABORIGINAL: 'canadian_aboriginal' = 'canadian_aboriginal';
  export const YI: 'yi' = 'yi';
  export const TAGALOG: 'tagalog' = 'tagalog';
  export const HANUNOO: 'hanunoo' = 'hanunoo';
  export const BUHID: 'buhid' = 'buhid';
  export const TAGBANWA: 'tagbanwa' = 'tagbanwa';
  export const BRAILLE: 'braille' = 'braille';
  export const CYPRIOT: 'cypriot' = 'cypriot';
  export const LIMBU: 'limbu' = 'limbu';
  export const OSMANYA: 'osmanya' = 'osmanya';
  export const SHAVIAN: 'shavian' = 'shavian';
  export const LINEAR_B: 'linear_b' = 'linear_b';
  export const TAI_LE: 'tai_le' = 'tai_le';
  export const UGARITIC: 'ugaritic' = 'ugaritic';
  export const NEW_TAI_LUE: 'new_tai_lue' = 'new_tai_lue';
  export const BUGINESE: 'buginese' = 'buginese';
  export const GLAGOLITIC: 'glagolitic' = 'glagolitic';
  export const TIFINAGH: 'tifinagh' = 'tifinagh';
  export const SYLOTI_NAGRI: 'syloti_nagri' = 'syloti_nagri';
  export const OLD_PERSIAN: 'old_persian' = 'old_persian';
  export const KHAROSHTHI: 'kharoshthi' = 'kharoshthi';
  export const UNKNOWN: 'unknown' = 'unknown';
  export const BALINESE: 'balinese' = 'balinese';
  export const CUNEIFORM: 'cuneiform' = 'cuneiform';
  export const PHOENICIAN: 'phoenician' = 'phoenician';
  export const PHAGS_PA: 'phags_pa' = 'phags_pa';
  export const NKO: 'nko' = 'nko';
  export const KAYAH_LI: 'kayah_li' = 'kayah_li';
  export const LEPCHA: 'lepcha' = 'lepcha';
  export const REJANG: 'rejang' = 'rejang';
  export const SUNDANESE: 'sundanese' = 'sundanese';
  export const SAURASHTRA: 'saurashtra' = 'saurashtra';
  export const CHAM: 'cham' = 'cham';
  export const OL_CHIKI: 'ol_chiki' = 'ol_chiki';
  export const VAI: 'vai' = 'vai';
  export const CARIAN: 'carian' = 'carian';
  export const LYCIAN: 'lycian' = 'lycian';
  export const LYDIAN: 'lydian' = 'lydian';
  export const AVESTAN: 'avestan' = 'avestan';
  export const BAMUM: 'bamum' = 'bamum';
  export const EGYPTIAN_HIEROGLYPHS: 'egyptian_hieroglyphs' = 'egyptian_hieroglyphs';
  export const IMPERIAL_ARAMAIC: 'imperial_aramaic' = 'imperial_aramaic';
  export const INSCRIPTIONAL_PAHLAVI: 'inscriptional_pahlavi' = 'inscriptional_pahlavi';
  export const INSCRIPTIONAL_PARTHIAN: 'inscriptional_parthian' = 'inscriptional_parthian';
  export const JAVANESE: 'javanese' = 'javanese';
  export const KAITHI: 'kaithi' = 'kaithi';
  export const LISU: 'lisu' = 'lisu';
  export const MEETEI_MAYEK: 'meetei_mayek' = 'meetei_mayek';
  export const OLD_SOUTH_ARABIAN: 'old_south_arabian' = 'old_south_arabian';
  export const OLD_TURKIC: 'old_turkic' = 'old_turkic';
  export const SAMARITAN: 'samaritan' = 'samaritan';
  export const TAI_THAM: 'tai_tham' = 'tai_tham';
  export const TAI_VIET: 'tai_viet' = 'tai_viet';
  export const BATAK: 'batak' = 'batak';
  export const BRAHMI: 'brahmi' = 'brahmi';
  export const MANDAIC: 'mandaic' = 'mandaic';
  export const CHAKMA: 'chakma' = 'chakma';
  export const MEROITIC_CURSIVE: 'meroitic_cursive' = 'meroitic_cursive';
  export const MEROITIC_HIEROGLYPHS: 'meroitic_hieroglyphs' = 'meroitic_hieroglyphs';
  export const MIAO: 'miao' = 'miao';
  export const SHARADA: 'sharada' = 'sharada';
  export const SORA_SOMPENG: 'sora_sompeng' = 'sora_sompeng';
  export const TAKRI: 'takri' = 'takri';
  export const BASSA_VAH: 'bassa_vah' = 'bassa_vah';
  export const CAUCASIAN_ALBANIAN: 'caucasian_albanian' = 'caucasian_albanian';
  export const DUPLOYAN: 'duployan' = 'duployan';
  export const ELBASAN: 'elbasan' = 'elbasan';
  export const GRANTHA: 'grantha' = 'grantha';
  export const KHOJKI: 'khojki' = 'khojki';
  export const KHUDAWADI: 'khudawadi' = 'khudawadi';
  export const LINEAR_A: 'linear_a' = 'linear_a';
  export const MAHAJANI: 'mahajani' = 'mahajani';
  export const MANICHAEAN: 'manichaean' = 'manichaean';
  export const MENDE_KIKAKUI: 'mende_kikakui' = 'mende_kikakui';
  export const MODI: 'modi' = 'modi';
  export const MRO: 'mro' = 'mro';
  export const NABATAEAN: 'nabataean' = 'nabataean';
  export const OLD_NORTH_ARABIAN: 'old_north_arabian' = 'old_north_arabian';
  export const OLD_PERMIC: 'old_permic' = 'old_permic';
  export const PAHAWH_HMONG: 'pahawh_hmong' = 'pahawh_hmong';
  export const PALMYRENE: 'palmyrene' = 'palmyrene';
  export const PAU_CIN_HAU: 'pau_cin_hau' = 'pau_cin_hau';
  export const PSALTER_PAHLAVI: 'psalter_pahlavi' = 'psalter_pahlavi';
  export const SIDDHAM: 'siddham' = 'siddham';
  export const TIRHUTA: 'tirhuta' = 'tirhuta';
  export const WARANG_CITI: 'warang_citi' = 'warang_citi';
  export const AHOM: 'ahom' = 'ahom';
  export const ANATOLIAN_HIEROGLYPHS: 'anatolian_hieroglyphs' = 'anatolian_hieroglyphs';
  export const HATRAN: 'hatran' = 'hatran';
  export const MULTANI: 'multani' = 'multani';
  export const OLD_HUNGARIAN: 'old_hungarian' = 'old_hungarian';
  export const SIGNWRITING: 'signwriting' = 'signwriting';
  export const ADLAM: 'adlam' = 'adlam';
  export const BHAIKSUKI: 'bhaiksuki' = 'bhaiksuki';
  export const MARCHEN: 'marchen' = 'marchen';
  export const NEWA: 'newa' = 'newa';
  export const OSAGE: 'osage' = 'osage';
  export const TANGUT: 'tangut' = 'tangut';
  export const MASARAM_GONDI: 'masaram_gondi' = 'masaram_gondi';
  export const NUSHU: 'nushu' = 'nushu';
  export const SOYOMBO: 'soyombo' = 'soyombo';
  export const ZANABAZAR_SQUARE: 'zanabazar_square' = 'zanabazar_square';
  export const DOGRA: 'dogra' = 'dogra';
  export const GUNJALA_GONDI: 'gunjala_gondi' = 'gunjala_gondi';
  export const HANIFI_ROHINGYA: 'hanifi_rohingya' = 'hanifi_rohingya';
  export const MAKASAR: 'makasar' = 'makasar';
  export const MEDEFAIDRIN: 'medefaidrin' = 'medefaidrin';
  export const OLD_SOGDIAN: 'old_sogdian' = 'old_sogdian';
  export const SOGDIAN: 'sogdian' = 'sogdian';
  export const ELYMAIC: 'elymaic' = 'elymaic';
  export const NANDINAGARI: 'nandinagari' = 'nandinagari';
  export const NYIAKENG_PUACHUE_HMONG: 'nyiakeng_puachue_hmong' = 'nyiakeng_puachue_hmong';
  export const WANCHO: 'wancho' = 'wancho';
  export const CHORASMIAN: 'chorasmian' = 'chorasmian';
  export const DIVES_AKURU: 'dives_akuru' = 'dives_akuru';
  export const KHITAN_SMALL_SCRIPT: 'khitan_small_script' = 'khitan_small_script';
  export const YEZIDI: 'yezidi' = 'yezidi';
  export const CYPRO_MINOAN: 'cypro_minoan' = 'cypro_minoan';
  export const OLD_UYGHUR: 'old_uyghur' = 'old_uyghur';
  export const TANGSA: 'tangsa' = 'tangsa';
  export const TOTO: 'toto' = 'toto';
  export const VITHKUQI: 'vithkuqi' = 'vithkuqi';
  export const MATH: 'math' = 'math';
  export const KAWI: 'kawi' = 'kawi';
  export const NAG_MUNDARI: 'nag_mundari' = 'nag_mundari';
  export async function from_iso15924(iso15924: number): Promise<GLibUnicodeScriptValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeScript/from_iso15924`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iso15924', String(iso15924));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_iso15924(script: GLibUnicodeScriptValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeScript/to_iso15924`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('script', String(script));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeScript/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GLibUnicodeScriptValue = "invalid_code" | "common" | "inherited" | "arabic" | "armenian" | "bengali" | "bopomofo" | "cherokee" | "coptic" | "cyrillic" | "deseret" | "devanagari" | "ethiopic" | "georgian" | "gothic" | "greek" | "gujarati" | "gurmukhi" | "han" | "hangul" | "hebrew" | "hiragana" | "kannada" | "katakana" | "khmer" | "lao" | "latin" | "malayalam" | "mongolian" | "myanmar" | "ogham" | "old_italic" | "oriya" | "runic" | "sinhala" | "syriac" | "tamil" | "telugu" | "thaana" | "thai" | "tibetan" | "canadian_aboriginal" | "yi" | "tagalog" | "hanunoo" | "buhid" | "tagbanwa" | "braille" | "cypriot" | "limbu" | "osmanya" | "shavian" | "linear_b" | "tai_le" | "ugaritic" | "new_tai_lue" | "buginese" | "glagolitic" | "tifinagh" | "syloti_nagri" | "old_persian" | "kharoshthi" | "unknown" | "balinese" | "cuneiform" | "phoenician" | "phags_pa" | "nko" | "kayah_li" | "lepcha" | "rejang" | "sundanese" | "saurashtra" | "cham" | "ol_chiki" | "vai" | "carian" | "lycian" | "lydian" | "avestan" | "bamum" | "egyptian_hieroglyphs" | "imperial_aramaic" | "inscriptional_pahlavi" | "inscriptional_parthian" | "javanese" | "kaithi" | "lisu" | "meetei_mayek" | "old_south_arabian" | "old_turkic" | "samaritan" | "tai_tham" | "tai_viet" | "batak" | "brahmi" | "mandaic" | "chakma" | "meroitic_cursive" | "meroitic_hieroglyphs" | "miao" | "sharada" | "sora_sompeng" | "takri" | "bassa_vah" | "caucasian_albanian" | "duployan" | "elbasan" | "grantha" | "khojki" | "khudawadi" | "linear_a" | "mahajani" | "manichaean" | "mende_kikakui" | "modi" | "mro" | "nabataean" | "old_north_arabian" | "old_permic" | "pahawh_hmong" | "palmyrene" | "pau_cin_hau" | "psalter_pahlavi" | "siddham" | "tirhuta" | "warang_citi" | "ahom" | "anatolian_hieroglyphs" | "hatran" | "multani" | "old_hungarian" | "signwriting" | "adlam" | "bhaiksuki" | "marchen" | "newa" | "osage" | "tangut" | "masaram_gondi" | "nushu" | "soyombo" | "zanabazar_square" | "dogra" | "gunjala_gondi" | "hanifi_rohingya" | "makasar" | "medefaidrin" | "old_sogdian" | "sogdian" | "elymaic" | "nandinagari" | "nyiakeng_puachue_hmong" | "wancho" | "chorasmian" | "dives_akuru" | "khitan_small_script" | "yezidi" | "cypro_minoan" | "old_uyghur" | "tangsa" | "toto" | "vithkuqi" | "math" | "kawi" | "nag_mundari";
export namespace GLibUnicodeType {
  export const CONTROL: 'control' = 'control';
  export const FORMAT: 'format' = 'format';
  export const UNASSIGNED: 'unassigned' = 'unassigned';
  export const PRIVATE_USE: 'private_use' = 'private_use';
  export const SURROGATE: 'surrogate' = 'surrogate';
  export const LOWERCASE_LETTER: 'lowercase_letter' = 'lowercase_letter';
  export const MODIFIER_LETTER: 'modifier_letter' = 'modifier_letter';
  export const OTHER_LETTER: 'other_letter' = 'other_letter';
  export const TITLECASE_LETTER: 'titlecase_letter' = 'titlecase_letter';
  export const UPPERCASE_LETTER: 'uppercase_letter' = 'uppercase_letter';
  export const SPACING_MARK: 'spacing_mark' = 'spacing_mark';
  export const ENCLOSING_MARK: 'enclosing_mark' = 'enclosing_mark';
  export const NON_SPACING_MARK: 'non_spacing_mark' = 'non_spacing_mark';
  export const DECIMAL_NUMBER: 'decimal_number' = 'decimal_number';
  export const LETTER_NUMBER: 'letter_number' = 'letter_number';
  export const OTHER_NUMBER: 'other_number' = 'other_number';
  export const CONNECT_PUNCTUATION: 'connect_punctuation' = 'connect_punctuation';
  export const DASH_PUNCTUATION: 'dash_punctuation' = 'dash_punctuation';
  export const CLOSE_PUNCTUATION: 'close_punctuation' = 'close_punctuation';
  export const FINAL_PUNCTUATION: 'final_punctuation' = 'final_punctuation';
  export const INITIAL_PUNCTUATION: 'initial_punctuation' = 'initial_punctuation';
  export const OTHER_PUNCTUATION: 'other_punctuation' = 'other_punctuation';
  export const OPEN_PUNCTUATION: 'open_punctuation' = 'open_punctuation';
  export const CURRENCY_SYMBOL: 'currency_symbol' = 'currency_symbol';
  export const MODIFIER_SYMBOL: 'modifier_symbol' = 'modifier_symbol';
  export const MATH_SYMBOL: 'math_symbol' = 'math_symbol';
  export const OTHER_SYMBOL: 'other_symbol' = 'other_symbol';
  export const LINE_SEPARATOR: 'line_separator' = 'line_separator';
  export const PARAGRAPH_SEPARATOR: 'paragraph_separator' = 'paragraph_separator';
  export const SPACE_SEPARATOR: 'space_separator' = 'space_separator';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GLibUnicodeTypeValue = "control" | "format" | "unassigned" | "private_use" | "surrogate" | "lowercase_letter" | "modifier_letter" | "other_letter" | "titlecase_letter" | "uppercase_letter" | "spacing_mark" | "enclosing_mark" | "non_spacing_mark" | "decimal_number" | "letter_number" | "other_number" | "connect_punctuation" | "dash_punctuation" | "close_punctuation" | "final_punctuation" | "initial_punctuation" | "other_punctuation" | "open_punctuation" | "currency_symbol" | "modifier_symbol" | "math_symbol" | "other_symbol" | "line_separator" | "paragraph_separator" | "space_separator";
export type GLibUnixFDSourceFunc = (fd: number, condition: GLibIOConditionValue, user_data: Pointer) => boolean;
export type GLibUnixPipeEnd = "read" | "write";
export type GLibUriError = "failed" | "bad_scheme" | "bad_user" | "bad_password" | "bad_auth_params" | "bad_host" | "bad_port" | "bad_path" | "bad_query" | "bad_fragment";
export type GLibUriFlags = "none" | "parse_relaxed" | "has_password" | "has_auth_params" | "encoded" | "non_dns" | "encoded_query" | "encoded_path" | "encoded_fragment" | "scheme_normalize";
export type GLibUriHideFlags = "none" | "userinfo" | "password" | "auth_params" | "query" | "fragment";
export type GLibUriParamsFlags = "none" | "case_insensitive" | "www_form" | "parse_relaxed";
export type GLibUserDirectory = "directory_desktop" | "directory_documents" | "directory_download" | "directory_music" | "directory_pictures" | "directory_public_share" | "directory_templates" | "directory_videos" | "n_directories";
export type GLibVariantClass = "boolean" | "byte" | "int16" | "uint16" | "int32" | "uint32" | "int64" | "uint64" | "handle" | "double" | "string" | "object_path" | "signature" | "variant" | "maybe" | "array" | "tuple" | "dict_entry";
export type GLibVariantParseError = "failed" | "basic_type_expected" | "cannot_infer_type" | "definite_type_expected" | "input_not_at_end" | "invalid_character" | "invalid_format_string" | "invalid_object_path" | "invalid_signature" | "invalid_type_string" | "no_common_type" | "number_out_of_range" | "number_too_big" | "type_error" | "unexpected_token" | "unknown_keyword" | "unterminated_string_constant" | "value_expected" | "recursion";
export type GLibVoidFunc = () => void;
export type GModuleModuleError = "failed" | "check_failed";
export type GModuleModuleFlags = "lazy" | "local" | "mask";
export namespace GObjectBindingFlags {
  export const DEFAULT: 'default' = 'default';
  export const BIDIRECTIONAL: 'bidirectional' = 'bidirectional';
  export const SYNC_CREATE: 'sync_create' = 'sync_create';
  export const INVERT_BOOLEAN: 'invert_boolean' = 'invert_boolean';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GObjectBindingFlagsValue = "default" | "bidirectional" | "sync_create" | "invert_boolean";
export type GObjectBoxedCopyFunc = (boxed: Pointer) => void;
export type GObjectBoxedFreeFunc = (boxed: Pointer) => void;
export type GObjectCallback = () => void;
export type GObjectClosureMarshal = (closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: Pointer, invocation_hint: Pointer, marshal_data: Pointer) => void;
export type GObjectConnectFlags = "default" | "after" | "swapped";
export namespace GObjectIOCondition {
  export const IN: 'in' = 'in';
  export const OUT: 'out' = 'out';
  export const PRI: 'pri' = 'pri';
  export const ERR: 'err' = 'err';
  export const HUP: 'hup' = 'hup';
  export const NVAL: 'nval' = 'nval';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/IOCondition/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GObjectIOConditionValue = "in" | "out" | "pri" | "err" | "hup" | "nval";
export type GObjectParamFlags = "readable" | "writable" | "readwrite" | "construct" | "construct_only" | "lax_validation" | "static_name" | "private" | "static_nick" | "static_blurb" | "explicit_notify" | "deprecated";
export type GObjectSignalAccumulator = (ihint: GObjectSignalInvocationHint, return_accu: GObjectValue, handler_return: GObjectValue, data_: Pointer) => boolean;
export type GObjectSignalEmissionHook = (ihint: GObjectSignalInvocationHint, n_param_values: number, param_values: Pointer, data_: Pointer) => boolean;
export type GObjectSignalFlags = "run_first" | "run_last" | "run_cleanup" | "no_recurse" | "detailed" | "action" | "no_hooks" | "must_collect" | "deprecated" | "accumulator_first_run";
export type GObjectSignalMatchType = "id" | "detail" | "closure" | "func" | "data" | "unblocked";
export type GObjectTypeDebugFlags = "none" | "objects" | "signals" | "instance_count" | "mask";
export type GObjectTypeFlags = "none" | "abstract" | "value_abstract" | "final" | "deprecated";
export type GObjectTypeFundamentalFlags = "classed" | "instantiatable" | "derivable" | "deep_derivable";
export namespace GstAllocatorFlags {
  export const CUSTOM_ALLOC: 'custom_alloc' = 'custom_alloc';
  export const NO_COPY: 'no_copy' = 'no_copy';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocatorFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstAllocatorFlagsValue = "custom_alloc" | "no_copy" | "last";
export namespace GstBinFlags {
  export const NO_RESYNC: 'no_resync' = 'no_resync';
  export const STREAMS_AWARE: 'streams_aware' = 'streams_aware';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BinFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstBinFlagsValue = "no_resync" | "streams_aware" | "last";
export namespace GstBufferCopyFlags {
  export const NONE: 'none' = 'none';
  export const FLAGS: 'flags' = 'flags';
  export const TIMESTAMPS: 'timestamps' = 'timestamps';
  export const META: 'meta' = 'meta';
  export const MEMORY: 'memory' = 'memory';
  export const MERGE: 'merge' = 'merge';
  export const DEEP: 'deep' = 'deep';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferCopyFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstBufferCopyFlagsValue = "none" | "flags" | "timestamps" | "meta" | "memory" | "merge" | "deep";
export namespace GstBufferFlags {
  export const LIVE: 'live' = 'live';
  export const DECODE_ONLY: 'decode_only' = 'decode_only';
  export const DISCONT: 'discont' = 'discont';
  export const RESYNC: 'resync' = 'resync';
  export const CORRUPTED: 'corrupted' = 'corrupted';
  export const MARKER: 'marker' = 'marker';
  export const HEADER: 'header' = 'header';
  export const GAP: 'gap' = 'gap';
  export const DROPPABLE: 'droppable' = 'droppable';
  export const DELTA_UNIT: 'delta_unit' = 'delta_unit';
  export const TAG_MEMORY: 'tag_memory' = 'tag_memory';
  export const SYNC_AFTER: 'sync_after' = 'sync_after';
  export const NON_DROPPABLE: 'non_droppable' = 'non_droppable';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstBufferFlagsValue = "live" | "decode_only" | "discont" | "resync" | "corrupted" | "marker" | "header" | "gap" | "droppable" | "delta_unit" | "tag_memory" | "sync_after" | "non_droppable" | "last";
export type GstBufferForeachMetaFunc = (buffer: GstBuffer, meta: GstMeta, user_data: Pointer) => boolean;
export type GstBufferListFunc = (buffer: GstBuffer, idx: number, user_data: Pointer) => boolean;
export namespace GstBufferPoolAcquireFlags {
  export const NONE: 'none' = 'none';
  export const KEY_UNIT: 'key_unit' = 'key_unit';
  export const DONTWAIT: 'dontwait' = 'dontwait';
  export const DISCONT: 'discont' = 'discont';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPoolAcquireFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstBufferPoolAcquireFlagsValue = "none" | "key_unit" | "dontwait" | "discont" | "last";
export namespace GstBufferingMode {
  export const STREAM: 'stream' = 'stream';
  export const DOWNLOAD: 'download' = 'download';
  export const TIMESHIFT: 'timeshift' = 'timeshift';
  export const LIVE: 'live' = 'live';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferingMode/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstBufferingModeValue = "stream" | "download" | "timeshift" | "live";
export namespace GstBusFlags {
  export const FLUSHING: 'flushing' = 'flushing';
  export const FLAG_LAST: 'flag_last' = 'flag_last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BusFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstBusFlagsValue = "flushing" | "flag_last";
export type GstBusFunc = (bus: GstBus, message: GstMessage, user_data: Pointer) => boolean;
export type GstBusSyncHandler = (bus: GstBus, message: GstMessage, user_data: Pointer) => GstBusSyncReplyValue;
export namespace GstBusSyncReply {
  export const DROP: 'drop' = 'drop';
  export const PASS: 'pass' = 'pass';
  export const ASYNC: 'async' = 'async';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BusSyncReply/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstBusSyncReplyValue = "drop" | "pass" | "async";
export type GstCapsFilterMapFunc = (features: GstCapsFeatures, structure: GstStructure, user_data: Pointer) => boolean;
export namespace GstCapsFlags {
  export const ANY: 'any' = 'any';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstCapsFlagsValue = "any";
export type GstCapsForeachFunc = (features: GstCapsFeatures, structure: GstStructure, user_data: Pointer) => boolean;
export namespace GstCapsIntersectMode {
  export const ZIG_ZAG: 'zig_zag' = 'zig_zag';
  export const FIRST: 'first' = 'first';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsIntersectMode/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstCapsIntersectModeValue = "zig_zag" | "first";
export type GstCapsMapFunc = (features: GstCapsFeatures, structure: GstStructure, user_data: Pointer) => boolean;
export type GstClockCallback = (clock: GstClock, time: number, id: Pointer, user_data: Pointer) => boolean;
export namespace GstClockEntryType {
  export const SINGLE: 'single' = 'single';
  export const PERIODIC: 'periodic' = 'periodic';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ClockEntryType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstClockEntryTypeValue = "single" | "periodic";
export namespace GstClockFlags {
  export const CAN_DO_SINGLE_SYNC: 'can_do_single_sync' = 'can_do_single_sync';
  export const CAN_DO_SINGLE_ASYNC: 'can_do_single_async' = 'can_do_single_async';
  export const CAN_DO_PERIODIC_SYNC: 'can_do_periodic_sync' = 'can_do_periodic_sync';
  export const CAN_DO_PERIODIC_ASYNC: 'can_do_periodic_async' = 'can_do_periodic_async';
  export const CAN_SET_RESOLUTION: 'can_set_resolution' = 'can_set_resolution';
  export const CAN_SET_MASTER: 'can_set_master' = 'can_set_master';
  export const NEEDS_STARTUP_SYNC: 'needs_startup_sync' = 'needs_startup_sync';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ClockFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstClockFlagsValue = "can_do_single_sync" | "can_do_single_async" | "can_do_periodic_sync" | "can_do_periodic_async" | "can_set_resolution" | "can_set_master" | "needs_startup_sync" | "last";
export namespace GstClockReturn {
  export const OK: 'ok' = 'ok';
  export const EARLY: 'early' = 'early';
  export const UNSCHEDULED: 'unscheduled' = 'unscheduled';
  export const BUSY: 'busy' = 'busy';
  export const BADTIME: 'badtime' = 'badtime';
  export const ERROR: 'error' = 'error';
  export const UNSUPPORTED: 'unsupported' = 'unsupported';
  export const DONE: 'done' = 'done';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ClockReturn/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstClockReturnValue = "ok" | "early" | "unscheduled" | "busy" | "badtime" | "error" | "unsupported" | "done";
export namespace GstClockType {
  export const REALTIME: 'realtime' = 'realtime';
  export const MONOTONIC: 'monotonic' = 'monotonic';
  export const OTHER: 'other' = 'other';
  export const TAI: 'tai' = 'tai';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ClockType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstClockTypeValue = "realtime" | "monotonic" | "other" | "tai";
export namespace GstCoreError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const STATE_CHANGE: 'state_change' = 'state_change';
  export const PAD: 'pad' = 'pad';
  export const THREAD: 'thread' = 'thread';
  export const NEGOTIATION: 'negotiation' = 'negotiation';
  export const EVENT: 'event' = 'event';
  export const SEEK: 'seek' = 'seek';
  export const CAPS: 'caps' = 'caps';
  export const TAG: 'tag' = 'tag';
  export const MISSING_PLUGIN: 'missing_plugin' = 'missing_plugin';
  export const CLOCK: 'clock' = 'clock';
  export const DISABLED: 'disabled' = 'disabled';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CoreError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CoreError/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstCoreErrorValue = "failed" | "too_lazy" | "not_implemented" | "state_change" | "pad" | "thread" | "negotiation" | "event" | "seek" | "caps" | "tag" | "missing_plugin" | "clock" | "disabled" | "num_errors";
export type GstCustomMetaTransformFunction = (transbuf: GstBuffer, meta: GstCustomMeta, buffer: GstBuffer, type_: number, data_: Pointer, user_data: Pointer) => boolean;
export namespace GstDebugColorFlags {
  export const FG_BLACK: 'fg_black' = 'fg_black';
  export const FG_RED: 'fg_red' = 'fg_red';
  export const FG_GREEN: 'fg_green' = 'fg_green';
  export const FG_YELLOW: 'fg_yellow' = 'fg_yellow';
  export const FG_BLUE: 'fg_blue' = 'fg_blue';
  export const FG_MAGENTA: 'fg_magenta' = 'fg_magenta';
  export const FG_CYAN: 'fg_cyan' = 'fg_cyan';
  export const FG_WHITE: 'fg_white' = 'fg_white';
  export const BG_BLACK: 'bg_black' = 'bg_black';
  export const BG_RED: 'bg_red' = 'bg_red';
  export const BG_GREEN: 'bg_green' = 'bg_green';
  export const BG_YELLOW: 'bg_yellow' = 'bg_yellow';
  export const BG_BLUE: 'bg_blue' = 'bg_blue';
  export const BG_MAGENTA: 'bg_magenta' = 'bg_magenta';
  export const BG_CYAN: 'bg_cyan' = 'bg_cyan';
  export const BG_WHITE: 'bg_white' = 'bg_white';
  export const BOLD: 'bold' = 'bold';
  export const UNDERLINE: 'underline' = 'underline';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugColorFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstDebugColorFlagsValue = "fg_black" | "fg_red" | "fg_green" | "fg_yellow" | "fg_blue" | "fg_magenta" | "fg_cyan" | "fg_white" | "bg_black" | "bg_red" | "bg_green" | "bg_yellow" | "bg_blue" | "bg_magenta" | "bg_cyan" | "bg_white" | "bold" | "underline";
export namespace GstDebugColorMode {
  export const OFF: 'off' = 'off';
  export const ON: 'on' = 'on';
  export const UNIX: 'unix' = 'unix';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugColorMode/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstDebugColorModeValue = "off" | "on" | "unix";
export namespace GstDebugGraphDetails {
  export const MEDIA_TYPE: 'media_type' = 'media_type';
  export const CAPS_DETAILS: 'caps_details' = 'caps_details';
  export const NON_DEFAULT_PARAMS: 'non_default_params' = 'non_default_params';
  export const STATES: 'states' = 'states';
  export const FULL_PARAMS: 'full_params' = 'full_params';
  export const ALL: 'all' = 'all';
  export const VERBOSE: 'verbose' = 'verbose';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugGraphDetails/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstDebugGraphDetailsValue = "media_type" | "caps_details" | "non_default_params" | "states" | "full_params" | "all" | "verbose";
export namespace GstDebugLevel {
  export const NONE: 'none' = 'none';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const FIXME: 'fixme' = 'fixme';
  export const INFO: 'info' = 'info';
  export const DEBUG: 'debug' = 'debug';
  export const LOG: 'log' = 'log';
  export const TRACE: 'trace' = 'trace';
  export const MEMDUMP: 'memdump' = 'memdump';
  export const COUNT: 'count' = 'count';
  export async function get_name(level: GstDebugLevelValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugLevel/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugLevel/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstDebugLevelValue = "none" | "error" | "warning" | "fixme" | "info" | "debug" | "log" | "trace" | "memdump" | "count";
export type GstElementCallAsyncFunc = (element: GstElement, user_data: Pointer) => void;
export namespace GstElementFlags {
  export const LOCKED_STATE: 'locked_state' = 'locked_state';
  export const SINK: 'sink' = 'sink';
  export const SOURCE: 'source' = 'source';
  export const PROVIDE_CLOCK: 'provide_clock' = 'provide_clock';
  export const REQUIRE_CLOCK: 'require_clock' = 'require_clock';
  export const INDEXABLE: 'indexable' = 'indexable';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstElementFlagsValue = "locked_state" | "sink" | "source" | "provide_clock" | "require_clock" | "indexable" | "last";
export type GstElementForeachPadFunc = (element: GstElement, pad: GstPad, user_data: Pointer) => boolean;
export namespace GstEventType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const FLUSH_START: 'flush_start' = 'flush_start';
  export const FLUSH_STOP: 'flush_stop' = 'flush_stop';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const CAPS: 'caps' = 'caps';
  export const SEGMENT: 'segment' = 'segment';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const TAG: 'tag' = 'tag';
  export const BUFFERSIZE: 'buffersize' = 'buffersize';
  export const SINK_MESSAGE: 'sink_message' = 'sink_message';
  export const STREAM_GROUP_DONE: 'stream_group_done' = 'stream_group_done';
  export const EOS: 'eos' = 'eos';
  export const TOC: 'toc' = 'toc';
  export const PROTECTION: 'protection' = 'protection';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const GAP: 'gap' = 'gap';
  export const INSTANT_RATE_CHANGE: 'instant_rate_change' = 'instant_rate_change';
  export const QOS: 'qos' = 'qos';
  export const SEEK: 'seek' = 'seek';
  export const NAVIGATION: 'navigation' = 'navigation';
  export const LATENCY: 'latency' = 'latency';
  export const STEP: 'step' = 'step';
  export const RECONFIGURE: 'reconfigure' = 'reconfigure';
  export const TOC_SELECT: 'toc_select' = 'toc_select';
  export const SELECT_STREAMS: 'select_streams' = 'select_streams';
  export const INSTANT_RATE_SYNC_TIME: 'instant_rate_sync_time' = 'instant_rate_sync_time';
  export const CUSTOM_UPSTREAM: 'custom_upstream' = 'custom_upstream';
  export const CUSTOM_DOWNSTREAM: 'custom_downstream' = 'custom_downstream';
  export const CUSTOM_DOWNSTREAM_OOB: 'custom_downstream_oob' = 'custom_downstream_oob';
  export const CUSTOM_DOWNSTREAM_STICKY: 'custom_downstream_sticky' = 'custom_downstream_sticky';
  export const CUSTOM_BOTH: 'custom_both' = 'custom_both';
  export const CUSTOM_BOTH_OOB: 'custom_both_oob' = 'custom_both_oob';
  export async function get_flags(type_: GstEventTypeValue): Promise<GstEventTypeFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_name(type_: GstEventTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_sticky_ordering(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/to_sticky_ordering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstEventTypeValue = "unknown" | "flush_start" | "flush_stop" | "stream_start" | "caps" | "segment" | "stream_collection" | "tag" | "buffersize" | "sink_message" | "stream_group_done" | "eos" | "toc" | "protection" | "segment_done" | "gap" | "instant_rate_change" | "qos" | "seek" | "navigation" | "latency" | "step" | "reconfigure" | "toc_select" | "select_streams" | "instant_rate_sync_time" | "custom_upstream" | "custom_downstream" | "custom_downstream_oob" | "custom_downstream_sticky" | "custom_both" | "custom_both_oob";
export namespace GstEventTypeFlags {
  export const UPSTREAM: 'upstream' = 'upstream';
  export const DOWNSTREAM: 'downstream' = 'downstream';
  export const SERIALIZED: 'serialized' = 'serialized';
  export const STICKY: 'sticky' = 'sticky';
  export const STICKY_MULTI: 'sticky_multi' = 'sticky_multi';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventTypeFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstEventTypeFlagsValue = "upstream" | "downstream" | "serialized" | "sticky" | "sticky_multi";
export namespace GstFlowReturn {
  export const CUSTOM_SUCCESS_2: 'custom_success_2' = 'custom_success_2';
  export const CUSTOM_SUCCESS_1: 'custom_success_1' = 'custom_success_1';
  export const CUSTOM_SUCCESS: 'custom_success' = 'custom_success';
  export const OK: 'ok' = 'ok';
  export const NOT_LINKED: 'not_linked' = 'not_linked';
  export const FLUSHING: 'flushing' = 'flushing';
  export const EOS: 'eos' = 'eos';
  export const NOT_NEGOTIATED: 'not_negotiated' = 'not_negotiated';
  export const ERROR: 'error' = 'error';
  export const NOT_SUPPORTED: 'not_supported' = 'not_supported';
  export const CUSTOM_ERROR: 'custom_error' = 'custom_error';
  export const CUSTOM_ERROR_1: 'custom_error_1' = 'custom_error_1';
  export const CUSTOM_ERROR_2: 'custom_error_2' = 'custom_error_2';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/FlowReturn/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstFlowReturnValue = "custom_success_2" | "custom_success_1" | "custom_success" | "ok" | "not_linked" | "flushing" | "eos" | "not_negotiated" | "error" | "not_supported" | "custom_error" | "custom_error_1" | "custom_error_2";
export namespace GstFormat {
  export const UNDEFINED: 'undefined' = 'undefined';
  export const DEFAULT: 'default' = 'default';
  export const BYTES: 'bytes' = 'bytes';
  export const TIME: 'time' = 'time';
  export const BUFFERS: 'buffers' = 'buffers';
  export const PERCENT: 'percent' = 'percent';
  export async function get_by_nick(nick: string): Promise<GstFormatValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/get_by_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_details(format: GstFormatValue): Promise<GstFormatDefinition> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/get_details`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_name(format: GstFormatValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function iterate_definitions(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/iterate_definitions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function register(nick: string, description: string): Promise<GstFormatValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(format: GstFormatValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstFormatValue = "undefined" | "default" | "bytes" | "time" | "buffers" | "percent";
export namespace GstGapFlags {
  export const DATA: 'data' = 'data';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GapFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstGapFlagsValue = "data";
export type GstIteratorFoldFunction = (item: GObjectValue, ret: GObjectValue, user_data: Pointer) => boolean;
export type GstIteratorForeachFunction = (item: GObjectValue, user_data: Pointer) => void;
export namespace GstIteratorItem {
  export const SKIP: 'skip' = 'skip';
  export const PASS: 'pass' = 'pass';
  export const END: 'end' = 'end';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/IteratorItem/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstIteratorItemValue = "skip" | "pass" | "end";
export namespace GstIteratorResult {
  export const DONE: 'done' = 'done';
  export const OK: 'ok' = 'ok';
  export const RESYNC: 'resync' = 'resync';
  export const ERROR: 'error' = 'error';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/IteratorResult/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstIteratorResultValue = "done" | "ok" | "resync" | "error";
export namespace GstLibraryError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const INIT: 'init' = 'init';
  export const SHUTDOWN: 'shutdown' = 'shutdown';
  export const SETTINGS: 'settings' = 'settings';
  export const ENCODE: 'encode' = 'encode';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/LibraryError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/LibraryError/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstLibraryErrorValue = "failed" | "too_lazy" | "init" | "shutdown" | "settings" | "encode" | "num_errors";
export namespace GstLockFlags {
  export const READ: 'read' = 'read';
  export const WRITE: 'write' = 'write';
  export const EXCLUSIVE: 'exclusive' = 'exclusive';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/LockFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstLockFlagsValue = "read" | "write" | "exclusive" | "last";
export type GstLogFunction = (category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, object: GObjectObject, message: GstDebugMessage, user_data: Pointer) => void;
export namespace GstMapFlags {
  export const READ: 'read' = 'read';
  export const WRITE: 'write' = 'write';
  export const FLAG_LAST: 'flag_last' = 'flag_last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MapFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstMapFlagsValue = "read" | "write" | "flag_last";
export namespace GstMemoryFlags {
  export const READONLY: 'readonly' = 'readonly';
  export const NO_SHARE: 'no_share' = 'no_share';
  export const ZERO_PREFIXED: 'zero_prefixed' = 'zero_prefixed';
  export const ZERO_PADDED: 'zero_padded' = 'zero_padded';
  export const PHYSICALLY_CONTIGUOUS: 'physically_contiguous' = 'physically_contiguous';
  export const NOT_MAPPABLE: 'not_mappable' = 'not_mappable';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MemoryFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstMemoryFlagsValue = "readonly" | "no_share" | "zero_prefixed" | "zero_padded" | "physically_contiguous" | "not_mappable" | "last";
export namespace GstMessageType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const EOS: 'eos' = 'eos';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const INFO: 'info' = 'info';
  export const TAG: 'tag' = 'tag';
  export const BUFFERING: 'buffering' = 'buffering';
  export const STATE_CHANGED: 'state_changed' = 'state_changed';
  export const STATE_DIRTY: 'state_dirty' = 'state_dirty';
  export const STEP_DONE: 'step_done' = 'step_done';
  export const CLOCK_PROVIDE: 'clock_provide' = 'clock_provide';
  export const CLOCK_LOST: 'clock_lost' = 'clock_lost';
  export const NEW_CLOCK: 'new_clock' = 'new_clock';
  export const STRUCTURE_CHANGE: 'structure_change' = 'structure_change';
  export const STREAM_STATUS: 'stream_status' = 'stream_status';
  export const APPLICATION: 'application' = 'application';
  export const ELEMENT: 'element' = 'element';
  export const SEGMENT_START: 'segment_start' = 'segment_start';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const DURATION_CHANGED: 'duration_changed' = 'duration_changed';
  export const LATENCY: 'latency' = 'latency';
  export const ASYNC_START: 'async_start' = 'async_start';
  export const ASYNC_DONE: 'async_done' = 'async_done';
  export const REQUEST_STATE: 'request_state' = 'request_state';
  export const STEP_START: 'step_start' = 'step_start';
  export const QOS: 'qos' = 'qos';
  export const PROGRESS: 'progress' = 'progress';
  export const TOC: 'toc' = 'toc';
  export const RESET_TIME: 'reset_time' = 'reset_time';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const NEED_CONTEXT: 'need_context' = 'need_context';
  export const HAVE_CONTEXT: 'have_context' = 'have_context';
  export const EXTENDED: 'extended' = 'extended';
  export const DEVICE_ADDED: 'device_added' = 'device_added';
  export const DEVICE_REMOVED: 'device_removed' = 'device_removed';
  export const PROPERTY_NOTIFY: 'property_notify' = 'property_notify';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const STREAMS_SELECTED: 'streams_selected' = 'streams_selected';
  export const REDIRECT: 'redirect' = 'redirect';
  export const DEVICE_CHANGED: 'device_changed' = 'device_changed';
  export const INSTANT_RATE_REQUEST: 'instant_rate_request' = 'instant_rate_request';
  export const ANY: 'any' = 'any';
  export async function get_name(type_: GstMessageTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MessageType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(type_: GstMessageTypeValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MessageType/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MessageType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstMessageTypeValue = "unknown" | "eos" | "error" | "warning" | "info" | "tag" | "buffering" | "state_changed" | "state_dirty" | "step_done" | "clock_provide" | "clock_lost" | "new_clock" | "structure_change" | "stream_status" | "application" | "element" | "segment_start" | "segment_done" | "duration_changed" | "latency" | "async_start" | "async_done" | "request_state" | "step_start" | "qos" | "progress" | "toc" | "reset_time" | "stream_start" | "need_context" | "have_context" | "extended" | "device_added" | "device_removed" | "property_notify" | "stream_collection" | "streams_selected" | "redirect" | "device_changed" | "instant_rate_request" | "any";
export namespace GstMetaFlags {
  export const NONE: 'none' = 'none';
  export const READONLY: 'readonly' = 'readonly';
  export const POOLED: 'pooled' = 'pooled';
  export const LOCKED: 'locked' = 'locked';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstMetaFlagsValue = "none" | "readonly" | "pooled" | "locked" | "last";
export namespace GstMiniObjectFlags {
  export const LOCKABLE: 'lockable' = 'lockable';
  export const LOCK_READONLY: 'lock_readonly' = 'lock_readonly';
  export const MAY_BE_LEAKED: 'may_be_leaked' = 'may_be_leaked';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObjectFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstMiniObjectFlagsValue = "lockable" | "lock_readonly" | "may_be_leaked" | "last";
export namespace GstObjectFlags {
  export const MAY_BE_LEAKED: 'may_be_leaked' = 'may_be_leaked';
  export const CONSTRUCTED: 'constructed' = 'constructed';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ObjectFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstObjectFlagsValue = "may_be_leaked" | "constructed" | "last";
export type GstPadActivateFunction = (pad: GstPad, parent: GstObject) => boolean;
export type GstPadActivateModeFunction = (pad: GstPad, parent: GstObject, mode: GstPadModeValue, active: boolean) => boolean;
export type GstPadChainFunction = (pad: GstPad, parent: GstObject, buffer: GstBuffer) => GstFlowReturnValue;
export type GstPadChainListFunction = (pad: GstPad, parent: GstObject, list: GstBufferList) => GstFlowReturnValue;
export namespace GstPadDirection {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const SRC: 'src' = 'src';
  export const SINK: 'sink' = 'sink';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadDirection/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadDirectionValue = "unknown" | "src" | "sink";
export type GstPadEventFullFunction = (pad: GstPad, parent: GstObject, event: GstEvent) => GstFlowReturnValue;
export type GstPadEventFunction = (pad: GstPad, parent: GstObject, event: GstEvent) => boolean;
export namespace GstPadFlags {
  export const BLOCKED: 'blocked' = 'blocked';
  export const FLUSHING: 'flushing' = 'flushing';
  export const EOS: 'eos' = 'eos';
  export const BLOCKING: 'blocking' = 'blocking';
  export const NEED_PARENT: 'need_parent' = 'need_parent';
  export const NEED_RECONFIGURE: 'need_reconfigure' = 'need_reconfigure';
  export const PENDING_EVENTS: 'pending_events' = 'pending_events';
  export const FIXED_CAPS: 'fixed_caps' = 'fixed_caps';
  export const PROXY_CAPS: 'proxy_caps' = 'proxy_caps';
  export const PROXY_ALLOCATION: 'proxy_allocation' = 'proxy_allocation';
  export const PROXY_SCHEDULING: 'proxy_scheduling' = 'proxy_scheduling';
  export const ACCEPT_INTERSECT: 'accept_intersect' = 'accept_intersect';
  export const ACCEPT_TEMPLATE: 'accept_template' = 'accept_template';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadFlagsValue = "blocked" | "flushing" | "eos" | "blocking" | "need_parent" | "need_reconfigure" | "pending_events" | "fixed_caps" | "proxy_caps" | "proxy_allocation" | "proxy_scheduling" | "accept_intersect" | "accept_template" | "last";
export type GstPadForwardFunction = (pad: GstPad, user_data: Pointer) => boolean;
export type GstPadGetRangeFunction = (pad: GstPad, parent: GstObject, offset: number, length: number, buffer: GstBuffer) => GstFlowReturnValue;
export type GstPadIterIntLinkFunction = (pad: GstPad, parent: GstObject) => GstIterator;
export namespace GstPadLinkCheck {
  export const NOTHING: 'nothing' = 'nothing';
  export const HIERARCHY: 'hierarchy' = 'hierarchy';
  export const TEMPLATE_CAPS: 'template_caps' = 'template_caps';
  export const CAPS: 'caps' = 'caps';
  export const NO_RECONFIGURE: 'no_reconfigure' = 'no_reconfigure';
  export const DEFAULT: 'default' = 'default';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadLinkCheck/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadLinkCheckValue = "nothing" | "hierarchy" | "template_caps" | "caps" | "no_reconfigure" | "default";
export type GstPadLinkFunction = (pad: GstPad, parent: GstObject, peer: GstPad) => GstPadLinkReturnValue;
export namespace GstPadLinkReturn {
  export const OK: 'ok' = 'ok';
  export const WRONG_HIERARCHY: 'wrong_hierarchy' = 'wrong_hierarchy';
  export const WAS_LINKED: 'was_linked' = 'was_linked';
  export const WRONG_DIRECTION: 'wrong_direction' = 'wrong_direction';
  export const NOFORMAT: 'noformat' = 'noformat';
  export const NOSCHED: 'nosched' = 'nosched';
  export const REFUSED: 'refused' = 'refused';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadLinkReturn/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadLinkReturnValue = "ok" | "wrong_hierarchy" | "was_linked" | "wrong_direction" | "noformat" | "nosched" | "refused";
export namespace GstPadMode {
  export const NONE: 'none' = 'none';
  export const PUSH: 'push' = 'push';
  export const PULL: 'pull' = 'pull';
  export async function get_name(mode: GstPadModeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadMode/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadMode/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadModeValue = "none" | "push" | "pull";
export namespace GstPadPresence {
  export const ALWAYS: 'always' = 'always';
  export const SOMETIMES: 'sometimes' = 'sometimes';
  export const REQUEST: 'request' = 'request';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadPresence/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadPresenceValue = "always" | "sometimes" | "request";
export type GstPadProbeCallback = (pad: GstPad, info: GstPadProbeInfo, user_data: Pointer) => GstPadProbeReturnValue;
export namespace GstPadProbeReturn {
  export const DROP: 'drop' = 'drop';
  export const OK: 'ok' = 'ok';
  export const REMOVE: 'remove' = 'remove';
  export const PASS: 'pass' = 'pass';
  export const HANDLED: 'handled' = 'handled';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeReturn/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadProbeReturnValue = "drop" | "ok" | "remove" | "pass" | "handled";
export namespace GstPadProbeType {
  export const INVALID: 'invalid' = 'invalid';
  export const IDLE: 'idle' = 'idle';
  export const BLOCK: 'block' = 'block';
  export const BUFFER: 'buffer' = 'buffer';
  export const BUFFER_LIST: 'buffer_list' = 'buffer_list';
  export const EVENT_DOWNSTREAM: 'event_downstream' = 'event_downstream';
  export const EVENT_UPSTREAM: 'event_upstream' = 'event_upstream';
  export const EVENT_FLUSH: 'event_flush' = 'event_flush';
  export const QUERY_DOWNSTREAM: 'query_downstream' = 'query_downstream';
  export const QUERY_UPSTREAM: 'query_upstream' = 'query_upstream';
  export const PUSH: 'push' = 'push';
  export const PULL: 'pull' = 'pull';
  export const BLOCKING: 'blocking' = 'blocking';
  export const DATA_DOWNSTREAM: 'data_downstream' = 'data_downstream';
  export const DATA_UPSTREAM: 'data_upstream' = 'data_upstream';
  export const DATA_BOTH: 'data_both' = 'data_both';
  export const BLOCK_DOWNSTREAM: 'block_downstream' = 'block_downstream';
  export const BLOCK_UPSTREAM: 'block_upstream' = 'block_upstream';
  export const EVENT_BOTH: 'event_both' = 'event_both';
  export const QUERY_BOTH: 'query_both' = 'query_both';
  export const ALL_BOTH: 'all_both' = 'all_both';
  export const SCHEDULING: 'scheduling' = 'scheduling';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadProbeTypeValue = "invalid" | "idle" | "block" | "buffer" | "buffer_list" | "event_downstream" | "event_upstream" | "event_flush" | "query_downstream" | "query_upstream" | "push" | "pull" | "blocking" | "data_downstream" | "data_upstream" | "data_both" | "block_downstream" | "block_upstream" | "event_both" | "query_both" | "all_both" | "scheduling";
export type GstPadQueryFunction = (pad: GstPad, parent: GstObject, query: GstQuery) => boolean;
export type GstPadStickyEventsForeachFunction = (pad: GstPad, event: GstEvent, user_data: Pointer) => boolean;
export namespace GstPadTemplateFlags {
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplateFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadTemplateFlagsValue = "last";
export type GstPadUnlinkFunction = (pad: GstPad, parent: GstObject) => void;
export namespace GstParseError {
  export const SYNTAX: 'syntax' = 'syntax';
  export const NO_SUCH_ELEMENT: 'no_such_element' = 'no_such_element';
  export const NO_SUCH_PROPERTY: 'no_such_property' = 'no_such_property';
  export const LINK: 'link' = 'link';
  export const COULD_NOT_SET_PROPERTY: 'could_not_set_property' = 'could_not_set_property';
  export const EMPTY_BIN: 'empty_bin' = 'empty_bin';
  export const EMPTY: 'empty' = 'empty';
  export const DELAYED_LINK: 'delayed_link' = 'delayed_link';
  export async function quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseError/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstParseErrorValue = "syntax" | "no_such_element" | "no_such_property" | "link" | "could_not_set_property" | "empty_bin" | "empty" | "delayed_link";
export namespace GstParseFlags {
  export const NONE: 'none' = 'none';
  export const FATAL_ERRORS: 'fatal_errors' = 'fatal_errors';
  export const NO_SINGLE_ELEMENT_BINS: 'no_single_element_bins' = 'no_single_element_bins';
  export const PLACE_IN_BIN: 'place_in_bin' = 'place_in_bin';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstParseFlagsValue = "none" | "fatal_errors" | "no_single_element_bins" | "place_in_bin";
export namespace GstPipelineFlags {
  export const FIXED_CLOCK: 'fixed_clock' = 'fixed_clock';
  export const LAST: 'last' = 'last';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PipelineFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPipelineFlagsValue = "fixed_clock" | "last";
export namespace GstPluginAPIFlags {
  export const MEMBERS: 'members' = 'members';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginAPIFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPluginAPIFlagsValue = "members";
export namespace GstPluginDependencyFlags {
  export const NONE: 'none' = 'none';
  export const RECURSE: 'recurse' = 'recurse';
  export const PATHS_ARE_DEFAULT_ONLY: 'paths_are_default_only' = 'paths_are_default_only';
  export const FILE_NAME_IS_SUFFIX: 'file_name_is_suffix' = 'file_name_is_suffix';
  export const FILE_NAME_IS_PREFIX: 'file_name_is_prefix' = 'file_name_is_prefix';
  export const PATHS_ARE_RELATIVE_TO_EXE: 'paths_are_relative_to_exe' = 'paths_are_relative_to_exe';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginDependencyFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPluginDependencyFlagsValue = "none" | "recurse" | "paths_are_default_only" | "file_name_is_suffix" | "file_name_is_prefix" | "paths_are_relative_to_exe";
export namespace GstPluginError {
  export const MODULE: 'module' = 'module';
  export const DEPENDENCIES: 'dependencies' = 'dependencies';
  export const NAME_MISMATCH: 'name_mismatch' = 'name_mismatch';
  export async function quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginError/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPluginErrorValue = "module" | "dependencies" | "name_mismatch";
export type GstPluginFeatureFilter = (feature: GstPluginFeature, user_data: Pointer) => boolean;
export type GstPluginFilter = (plugin: GstPlugin, user_data: Pointer) => boolean;
export namespace GstPluginFlags {
  export const CACHED: 'cached' = 'cached';
  export const BLACKLISTED: 'blacklisted' = 'blacklisted';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPluginFlagsValue = "cached" | "blacklisted";
export type GstPluginInitFullFunc = (plugin: GstPlugin, user_data: Pointer) => boolean;
export type GstPluginInitFunc = (plugin: GstPlugin) => boolean;
export namespace GstProgressType {
  export const START: 'start' = 'start';
  export const CONTINUE: 'continue' = 'continue';
  export const COMPLETE: 'complete' = 'complete';
  export const CANCELED: 'canceled' = 'canceled';
  export const ERROR: 'error' = 'error';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProgressType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstProgressTypeValue = "start" | "continue" | "complete" | "canceled" | "error";
export type GstPromiseChangeFunc = (promise: GstPromise, user_data: Pointer) => void;
export namespace GstPromiseResult {
  export const PENDING: 'pending' = 'pending';
  export const INTERRUPTED: 'interrupted' = 'interrupted';
  export const REPLIED: 'replied' = 'replied';
  export const EXPIRED: 'expired' = 'expired';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PromiseResult/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPromiseResultValue = "pending" | "interrupted" | "replied" | "expired";
export namespace GstQOSType {
  export const OVERFLOW: 'overflow' = 'overflow';
  export const UNDERFLOW: 'underflow' = 'underflow';
  export const THROTTLE: 'throttle' = 'throttle';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QOSType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstQOSTypeValue = "overflow" | "underflow" | "throttle";
export namespace GstQueryType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const POSITION: 'position' = 'position';
  export const DURATION: 'duration' = 'duration';
  export const LATENCY: 'latency' = 'latency';
  export const JITTER: 'jitter' = 'jitter';
  export const RATE: 'rate' = 'rate';
  export const SEEKING: 'seeking' = 'seeking';
  export const SEGMENT: 'segment' = 'segment';
  export const CONVERT: 'convert' = 'convert';
  export const FORMATS: 'formats' = 'formats';
  export const BUFFERING: 'buffering' = 'buffering';
  export const CUSTOM: 'custom' = 'custom';
  export const URI: 'uri' = 'uri';
  export const ALLOCATION: 'allocation' = 'allocation';
  export const SCHEDULING: 'scheduling' = 'scheduling';
  export const ACCEPT_CAPS: 'accept_caps' = 'accept_caps';
  export const CAPS: 'caps' = 'caps';
  export const DRAIN: 'drain' = 'drain';
  export const CONTEXT: 'context' = 'context';
  export const BITRATE: 'bitrate' = 'bitrate';
  export const SELECTABLE: 'selectable' = 'selectable';
  export async function get_flags(type_: GstQueryTypeValue): Promise<GstQueryTypeFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryType/get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_name(type_: GstQueryTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(type_: GstQueryTypeValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryType/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstQueryTypeValue = "unknown" | "position" | "duration" | "latency" | "jitter" | "rate" | "seeking" | "segment" | "convert" | "formats" | "buffering" | "custom" | "uri" | "allocation" | "scheduling" | "accept_caps" | "caps" | "drain" | "context" | "bitrate" | "selectable";
export namespace GstQueryTypeFlags {
  export const UPSTREAM: 'upstream' = 'upstream';
  export const DOWNSTREAM: 'downstream' = 'downstream';
  export const SERIALIZED: 'serialized' = 'serialized';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryTypeFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstQueryTypeFlagsValue = "upstream" | "downstream" | "serialized";
export namespace GstRank {
  export const NONE: 'none' = 'none';
  export const MARGINAL: 'marginal' = 'marginal';
  export const SECONDARY: 'secondary' = 'secondary';
  export const PRIMARY: 'primary' = 'primary';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Rank/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstRankValue = "none" | "marginal" | "secondary" | "primary";
export namespace GstResourceError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_FOUND: 'not_found' = 'not_found';
  export const BUSY: 'busy' = 'busy';
  export const OPEN_READ: 'open_read' = 'open_read';
  export const OPEN_WRITE: 'open_write' = 'open_write';
  export const OPEN_READ_WRITE: 'open_read_write' = 'open_read_write';
  export const CLOSE: 'close' = 'close';
  export const READ: 'read' = 'read';
  export const WRITE: 'write' = 'write';
  export const SEEK: 'seek' = 'seek';
  export const SYNC: 'sync' = 'sync';
  export const SETTINGS: 'settings' = 'settings';
  export const NO_SPACE_LEFT: 'no_space_left' = 'no_space_left';
  export const NOT_AUTHORIZED: 'not_authorized' = 'not_authorized';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ResourceError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ResourceError/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstResourceErrorValue = "failed" | "too_lazy" | "not_found" | "busy" | "open_read" | "open_write" | "open_read_write" | "close" | "read" | "write" | "seek" | "sync" | "settings" | "no_space_left" | "not_authorized" | "num_errors";
export namespace GstSchedulingFlags {
  export const SEEKABLE: 'seekable' = 'seekable';
  export const SEQUENTIAL: 'sequential' = 'sequential';
  export const BANDWIDTH_LIMITED: 'bandwidth_limited' = 'bandwidth_limited';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SchedulingFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstSchedulingFlagsValue = "seekable" | "sequential" | "bandwidth_limited";
export namespace GstSearchMode {
  export const EXACT: 'exact' = 'exact';
  export const BEFORE: 'before' = 'before';
  export const AFTER: 'after' = 'after';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SearchMode/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstSearchModeValue = "exact" | "before" | "after";
export namespace GstSeekFlags {
  export const NONE: 'none' = 'none';
  export const FLUSH: 'flush' = 'flush';
  export const ACCURATE: 'accurate' = 'accurate';
  export const KEY_UNIT: 'key_unit' = 'key_unit';
  export const SEGMENT: 'segment' = 'segment';
  export const TRICKMODE: 'trickmode' = 'trickmode';
  export const SKIP: 'skip' = 'skip';
  export const SNAP_BEFORE: 'snap_before' = 'snap_before';
  export const SNAP_AFTER: 'snap_after' = 'snap_after';
  export const SNAP_NEAREST: 'snap_nearest' = 'snap_nearest';
  export const TRICKMODE_KEY_UNITS: 'trickmode_key_units' = 'trickmode_key_units';
  export const TRICKMODE_NO_AUDIO: 'trickmode_no_audio' = 'trickmode_no_audio';
  export const TRICKMODE_FORWARD_PREDICTED: 'trickmode_forward_predicted' = 'trickmode_forward_predicted';
  export const INSTANT_RATE_CHANGE: 'instant_rate_change' = 'instant_rate_change';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SeekFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstSeekFlagsValue = "none" | "flush" | "accurate" | "key_unit" | "segment" | "trickmode" | "skip" | "snap_before" | "snap_after" | "snap_nearest" | "trickmode_key_units" | "trickmode_no_audio" | "trickmode_forward_predicted" | "instant_rate_change";
export namespace GstSeekType {
  export const NONE: 'none' = 'none';
  export const SET: 'set' = 'set';
  export const END: 'end' = 'end';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SeekType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstSeekTypeValue = "none" | "set" | "end";
export namespace GstSegmentFlags {
  export const NONE: 'none' = 'none';
  export const RESET: 'reset' = 'reset';
  export const TRICKMODE: 'trickmode' = 'trickmode';
  export const SKIP: 'skip' = 'skip';
  export const SEGMENT: 'segment' = 'segment';
  export const TRICKMODE_KEY_UNITS: 'trickmode_key_units' = 'trickmode_key_units';
  export const TRICKMODE_FORWARD_PREDICTED: 'trickmode_forward_predicted' = 'trickmode_forward_predicted';
  export const TRICKMODE_NO_AUDIO: 'trickmode_no_audio' = 'trickmode_no_audio';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SegmentFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstSegmentFlagsValue = "none" | "reset" | "trickmode" | "skip" | "segment" | "trickmode_key_units" | "trickmode_forward_predicted" | "trickmode_no_audio";
export namespace GstSerializeFlags {
  export const NONE: 'none' = 'none';
  export const BACKWARD_COMPAT: 'backward_compat' = 'backward_compat';
  export const STRICT: 'strict' = 'strict';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SerializeFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstSerializeFlagsValue = "none" | "backward_compat" | "strict";
export namespace GstStackTraceFlags {
  export const NONE: 'none' = 'none';
  export const FULL: 'full' = 'full';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StackTraceFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStackTraceFlagsValue = "none" | "full";
export namespace GstState {
  export const VOID_PENDING: 'void_pending' = 'void_pending';
  export const NULL: 'null' = 'null';
  export const READY: 'ready' = 'ready';
  export const PAUSED: 'paused' = 'paused';
  export const PLAYING: 'playing' = 'playing';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/State/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStateValue = "void_pending" | "null" | "ready" | "paused" | "playing";
export namespace GstStateChange {
  export const NULL_TO_READY: 'null_to_ready' = 'null_to_ready';
  export const READY_TO_PAUSED: 'ready_to_paused' = 'ready_to_paused';
  export const PAUSED_TO_PLAYING: 'paused_to_playing' = 'paused_to_playing';
  export const PLAYING_TO_PAUSED: 'playing_to_paused' = 'playing_to_paused';
  export const PAUSED_TO_READY: 'paused_to_ready' = 'paused_to_ready';
  export const READY_TO_NULL: 'ready_to_null' = 'ready_to_null';
  export const NULL_TO_NULL: 'null_to_null' = 'null_to_null';
  export const READY_TO_READY: 'ready_to_ready' = 'ready_to_ready';
  export const PAUSED_TO_PAUSED: 'paused_to_paused' = 'paused_to_paused';
  export const PLAYING_TO_PLAYING: 'playing_to_playing' = 'playing_to_playing';
  export async function get_name(transition: GstStateChangeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StateChange/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('transition', String(transition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StateChange/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStateChangeValue = "null_to_ready" | "ready_to_paused" | "paused_to_playing" | "playing_to_paused" | "paused_to_ready" | "ready_to_null" | "null_to_null" | "ready_to_ready" | "paused_to_paused" | "playing_to_playing";
export namespace GstStateChangeReturn {
  export const FAILURE: 'failure' = 'failure';
  export const SUCCESS: 'success' = 'success';
  export const ASYNC: 'async' = 'async';
  export const NO_PREROLL: 'no_preroll' = 'no_preroll';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StateChangeReturn/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStateChangeReturnValue = "failure" | "success" | "async" | "no_preroll";
export namespace GstStreamError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const TYPE_NOT_FOUND: 'type_not_found' = 'type_not_found';
  export const WRONG_TYPE: 'wrong_type' = 'wrong_type';
  export const CODEC_NOT_FOUND: 'codec_not_found' = 'codec_not_found';
  export const DECODE: 'decode' = 'decode';
  export const ENCODE: 'encode' = 'encode';
  export const DEMUX: 'demux' = 'demux';
  export const MUX: 'mux' = 'mux';
  export const FORMAT: 'format' = 'format';
  export const DECRYPT: 'decrypt' = 'decrypt';
  export const DECRYPT_NOKEY: 'decrypt_nokey' = 'decrypt_nokey';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamError/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStreamErrorValue = "failed" | "too_lazy" | "not_implemented" | "type_not_found" | "wrong_type" | "codec_not_found" | "decode" | "encode" | "demux" | "mux" | "format" | "decrypt" | "decrypt_nokey" | "num_errors";
export namespace GstStreamFlags {
  export const NONE: 'none' = 'none';
  export const SPARSE: 'sparse' = 'sparse';
  export const SELECT: 'select' = 'select';
  export const UNSELECT: 'unselect' = 'unselect';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStreamFlagsValue = "none" | "sparse" | "select" | "unselect";
export namespace GstStreamStatusType {
  export const CREATE: 'create' = 'create';
  export const ENTER: 'enter' = 'enter';
  export const LEAVE: 'leave' = 'leave';
  export const DESTROY: 'destroy' = 'destroy';
  export const START: 'start' = 'start';
  export const PAUSE: 'pause' = 'pause';
  export const STOP: 'stop' = 'stop';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamStatusType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStreamStatusTypeValue = "create" | "enter" | "leave" | "destroy" | "start" | "pause" | "stop";
export namespace GstStreamType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const AUDIO: 'audio' = 'audio';
  export const VIDEO: 'video' = 'video';
  export const CONTAINER: 'container' = 'container';
  export const TEXT: 'text' = 'text';
  export async function get_name(stype: GstStreamTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stype', String(stype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStreamTypeValue = "unknown" | "audio" | "video" | "container" | "text";
export namespace GstStructureChangeType {
  export const LINK: 'link' = 'link';
  export const UNLINK: 'unlink' = 'unlink';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StructureChangeType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStructureChangeTypeValue = "link" | "unlink";
export type GstStructureFilterMapFunc = (field_id: number, value_: GObjectValue, user_data: Pointer) => boolean;
export type GstStructureForeachFunc = (field_id: number, value_: GObjectValue, user_data: Pointer) => boolean;
export type GstStructureMapFunc = (field_id: number, value_: GObjectValue, user_data: Pointer) => boolean;
export namespace GstTagFlag {
  export const UNDEFINED: 'undefined' = 'undefined';
  export const META: 'meta' = 'meta';
  export const ENCODED: 'encoded' = 'encoded';
  export const DECODED: 'decoded' = 'decoded';
  export const COUNT: 'count' = 'count';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagFlag/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTagFlagValue = "undefined" | "meta" | "encoded" | "decoded" | "count";
export type GstTagForeachFunc = (list: GstTagList, tag: string, user_data: Pointer) => void;
export namespace GstTagMergeMode {
  export const UNDEFINED: 'undefined' = 'undefined';
  export const REPLACE_ALL: 'replace_all' = 'replace_all';
  export const REPLACE: 'replace' = 'replace';
  export const APPEND: 'append' = 'append';
  export const PREPEND: 'prepend' = 'prepend';
  export const KEEP: 'keep' = 'keep';
  export const KEEP_ALL: 'keep_all' = 'keep_all';
  export const COUNT: 'count' = 'count';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagMergeMode/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTagMergeModeValue = "undefined" | "replace_all" | "replace" | "append" | "prepend" | "keep" | "keep_all" | "count";
export namespace GstTagScope {
  export const STREAM: 'stream' = 'stream';
  export const GLOBAL: 'global' = 'global';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagScope/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTagScopeValue = "stream" | "global";
export type GstTaskFunction = (user_data: Pointer) => void;
export type GstTaskPoolFunction = (user_data: Pointer) => void;
export namespace GstTaskState {
  export const STARTED: 'started' = 'started';
  export const STOPPED: 'stopped' = 'stopped';
  export const PAUSED: 'paused' = 'paused';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskState/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTaskStateValue = "started" | "stopped" | "paused";
export type GstTaskThreadFunc = (task: GstTask, thread: GLibThread, user_data: Pointer) => void;
export namespace GstTocEntryType {
  export const ANGLE: 'angle' = 'angle';
  export const VERSION: 'version' = 'version';
  export const EDITION: 'edition' = 'edition';
  export const INVALID: 'invalid' = 'invalid';
  export const TITLE: 'title' = 'title';
  export const TRACK: 'track' = 'track';
  export const CHAPTER: 'chapter' = 'chapter';
  export async function get_nick(type_: GstTocEntryTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntryType/get_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntryType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTocEntryTypeValue = "angle" | "version" | "edition" | "invalid" | "title" | "track" | "chapter";
export namespace GstTocLoopType {
  export const NONE: 'none' = 'none';
  export const FORWARD: 'forward' = 'forward';
  export const REVERSE: 'reverse' = 'reverse';
  export const PING_PONG: 'ping_pong' = 'ping_pong';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocLoopType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTocLoopTypeValue = "none" | "forward" | "reverse" | "ping_pong";
export namespace GstTocScope {
  export const GLOBAL: 'global' = 'global';
  export const CURRENT: 'current' = 'current';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocScope/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTocScopeValue = "global" | "current";
export namespace GstTracerValueFlags {
  export const NONE: 'none' = 'none';
  export const OPTIONAL: 'optional' = 'optional';
  export const AGGREGATED: 'aggregated' = 'aggregated';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerValueFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTracerValueFlagsValue = "none" | "optional" | "aggregated";
export namespace GstTracerValueScope {
  export const PROCESS: 'process' = 'process';
  export const THREAD: 'thread' = 'thread';
  export const ELEMENT: 'element' = 'element';
  export const PAD: 'pad' = 'pad';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerValueScope/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTracerValueScopeValue = "process" | "thread" | "element" | "pad";
export type GstTypeFindFunction = (find: GstTypeFind, user_data: Pointer) => void;
export namespace GstTypeFindProbability {
  export const NONE: 'none' = 'none';
  export const MINIMUM: 'minimum' = 'minimum';
  export const POSSIBLE: 'possible' = 'possible';
  export const LIKELY: 'likely' = 'likely';
  export const NEARLY_CERTAIN: 'nearly_certain' = 'nearly_certain';
  export const MAXIMUM: 'maximum' = 'maximum';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindProbability/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTypeFindProbabilityValue = "none" | "minimum" | "possible" | "likely" | "nearly_certain" | "maximum";
export namespace GstURIError {
  export const UNSUPPORTED_PROTOCOL: 'unsupported_protocol' = 'unsupported_protocol';
  export const BAD_URI: 'bad_uri' = 'bad_uri';
  export const BAD_STATE: 'bad_state' = 'bad_state';
  export const BAD_REFERENCE: 'bad_reference' = 'bad_reference';
  export async function quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/URIError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/URIError/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstURIErrorValue = "unsupported_protocol" | "bad_uri" | "bad_state" | "bad_reference";
export namespace GstURIType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const SINK: 'sink' = 'sink';
  export const SRC: 'src' = 'src';
  export async function get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/URIType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstURITypeValue = "unknown" | "sink" | "src";

export class GLibAllocator {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gliballocatorRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gliballocatorRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Allocator/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibAllocator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Allocator/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibAllocator();
    Object.assign(instance, data.return || data);
    return instance;
  }

}
export class GLibArray {
  ptr!: Pointer;


}
export class GLibAsyncQueue {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibasyncqueueRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibasyncqueueRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibAsyncQueue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibAsyncQueue();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async length(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async length_unlocked(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/length_unlocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/lock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async pop(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async pop_unlocked(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/pop_unlocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push_front(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_front`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push_front_unlocked(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_front_unlocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push_sorted(func: GLibCompareDataFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_sorted`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async push_sorted_unlocked(func: GLibCompareDataFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_sorted_unlocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async push_unlocked(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_unlocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref_unlocked(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/ref_unlocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_unlocked(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/remove_unlocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async sort(func: GLibCompareDataFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/sort`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async sort_unlocked(func: GLibCompareDataFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/sort_unlocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async timed_pop(end_time: GLibTimeVal): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/timed_pop`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (end_time && typeof end_time === 'object' && 'ptr' in end_time) {
      url.searchParams.append('end_time', 'ptr,' + end_time.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async timed_pop_unlocked(end_time: GLibTimeVal): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/timed_pop_unlocked`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (end_time && typeof end_time === 'object' && 'ptr' in end_time) {
      url.searchParams.append('end_time', 'ptr,' + end_time.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async timeout_pop(timeout: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/timeout_pop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async timeout_pop_unlocked(timeout: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/timeout_pop_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async try_pop(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/try_pop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async try_pop_unlocked(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/try_pop_unlocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unlock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/unlock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref_and_unlock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/unref_and_unlock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibBookmarkFile {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibbookmarkfileRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibbookmarkfileRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibBookmarkFile> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibBookmarkFile();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_application(uri: string, name?: string, exec?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/add_application`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Primitive parameter
    if (exec !== undefined) url.searchParams.append('exec', String(exec));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_group(uri: string, group: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/add_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('group', String(group));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async copy(): Promise<GLibBookmarkFile> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBookmarkFile(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_added(uri: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_added`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_added_date_time(uri: string): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_added_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_app_info(uri: string, name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_app_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_application_info(uri: string, name: string, stamp: GLibDateTime): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_application_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (stamp && typeof stamp === 'object' && 'ptr' in stamp) {
      url.searchParams.append('stamp', 'ptr,' + stamp.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_applications(uri: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_applications`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_description(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_groups(uri: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_groups`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_icon(uri: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_icon`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_is_private(uri: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_is_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_mime_type(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_mime_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_modified(uri: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_modified`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_modified_date_time(uri: string): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_modified_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_title(uri?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_title`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uris(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_uris`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_visited(uri: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_visited`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_visited_date_time(uri: string): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_visited_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_application(uri: string, name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/has_application`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_group(uri: string, group: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/has_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('group', String(group));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_item(uri: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/has_item`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load_from_data(data_: Pointer, length: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/load_from_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load_from_data_dirs(file: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/load_from_data_dirs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file', String(file));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load_from_file(filename: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/load_from_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async move_item(old_uri: string, new_uri?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/move_item`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('old_uri', String(old_uri));
    // Primitive parameter
    if (new_uri !== undefined) url.searchParams.append('new_uri', String(new_uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_application(uri: string, name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/remove_application`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_group(uri: string, group: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/remove_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('group', String(group));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_item(uri: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/remove_item`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_added(uri: string, added: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_added`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('added', String(added));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_added_date_time(uri: string, added: GLibDateTime): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_added_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Object with explode=false: serialize as comma-separated
    if (added && typeof added === 'object' && 'ptr' in added) {
      url.searchParams.append('added', 'ptr,' + added.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_app_info(uri: string, name: string, exec: string, count: number, stamp: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_app_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('exec', String(exec));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    // Primitive parameter
    url.searchParams.append('stamp', String(stamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_application_info(uri: string, name: string, exec: string, count: number, stamp?: GLibDateTime): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_application_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('exec', String(exec));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    // Object with explode=false: serialize as comma-separated
    if (stamp !== undefined && typeof stamp === 'object' && 'ptr' in stamp) {
      url.searchParams.append('stamp', 'ptr,' + stamp.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_description(description: string, uri?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_description`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_groups(uri: string, length: number, groups?: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_groups`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    if (groups !== undefined) url.searchParams.append('groups', String(groups));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_icon(uri: string, mime_type: string, href?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_icon`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    if (href !== undefined) url.searchParams.append('href', String(href));
    // Primitive parameter
    url.searchParams.append('mime_type', String(mime_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_is_private(uri: string, is_private: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_is_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('is_private', String(is_private));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_mime_type(uri: string, mime_type: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_mime_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('mime_type', String(mime_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_modified(uri: string, modified: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_modified`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('modified', String(modified));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_modified_date_time(uri: string, modified: GLibDateTime): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_modified_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Object with explode=false: serialize as comma-separated
    if (modified && typeof modified === 'object' && 'ptr' in modified) {
      url.searchParams.append('modified', 'ptr,' + modified.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_title(title: string, uri?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_title`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('title', String(title));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_visited(uri: string, visited: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_visited`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('visited', String(visited));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_visited_date_time(uri: string, visited: GLibDateTime): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_visited_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Object with explode=false: serialize as comma-separated
    if (visited && typeof visited === 'object' && 'ptr' in visited) {
      url.searchParams.append('visited', 'ptr,' + visited.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async to_data(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/to_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_file(filename: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/to_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibByteArray {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibbytearrayRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibbytearrayRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }


  static async append(array: Pointer, data_: number, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/append`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async free_to_bytes(array: Pointer): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/free_to_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async new(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async new_take(data_: Pointer, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/new_take`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async prepend(array: Pointer, data_: number, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/prepend`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async ref(array: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async remove_index(array: Pointer, index_: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/remove_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async remove_index_fast(array: Pointer, index_: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/remove_index_fast`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async remove_range(array: Pointer, index_: number, length: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/remove_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async set_size(array: Pointer, length: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/set_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async sized_new(reserved_size: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/sized_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('reserved_size', String(reserved_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async sort(array: Pointer, compare_func: GLibCompareFunc): Promise<{ compare_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/sort`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.compare_func !== undefined) {
      callbackDispatcher.set(data.compare_func.toString(), compare_func);
    }
    return data;
  }
  static async sort_with_data(array: Pointer, compare_func: GLibCompareDataFunc): Promise<{ compare_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/sort_with_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.compare_func !== undefined) {
      callbackDispatcher.set(data.compare_func.toString(), compare_func);
    }
    return data;
  }
  static async steal(array: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async unref(array: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibBytes {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibbytesRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibbytesRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(size: number, data_?: Pointer): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibBytes();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_take(size: number, data_?: Pointer): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/new_take`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibBytes();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async compare(bytes2: GLibBytes): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes2 && typeof bytes2 === 'object' && 'ptr' in bytes2) {
      url.searchParams.append('bytes2', 'ptr,' + bytes2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async equal(bytes2: GLibBytes): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes2 && typeof bytes2 === 'object' && 'ptr' in bytes2) {
      url.searchParams.append('bytes2', 'ptr,' + bytes2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_data(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/get_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_region(element_size: number, offset: number, n_elements: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/get_region`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('element_size', String(element_size));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('n_elements', String(n_elements));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async new_from_bytes(offset: number, length: number): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/new_from_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ref(): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref_to_array(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/unref_to_array`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unref_to_data(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/unref_to_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibCache {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibcacheRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibcacheRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibCache> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibCache();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async insert(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async key_foreach(func: GLibHFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/key_foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async remove(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async value_foreach(func: GLibHFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/value_foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
}
export class GLibChecksum {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibchecksumRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibchecksumRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(checksum_type: GLibChecksumType): Promise<GLibChecksum> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibChecksum();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GLibChecksum> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibChecksum(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reset(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/reset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async update(data_: Pointer, length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/update`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async type_get_length(checksum_type: GLibChecksumType): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/type_get_length`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibCompletion {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibcompletionRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibcompletionRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibCompletion> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibCompletion();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clear_items(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/clear_items`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async complete_utf8(prefix: string, new_prefix: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/complete_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('prefix', String(prefix));
    // Primitive parameter
    url.searchParams.append('new_prefix', String(new_prefix));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibCond {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibcondRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibcondRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibCond> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibCond();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async broadcast(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/broadcast`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async clear(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async init(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async signal(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/signal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait(mutex: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mutex', String(mutex));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait_until(mutex: Pointer, end_time: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/wait_until`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mutex', String(mutex));
    // Primitive parameter
    url.searchParams.append('end_time', String(end_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibData {
  ptr!: Pointer;


}
export class GLibDate {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibdateRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibdateRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibDate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_dmy(day: number, month: GLibDateMonth, year: number): Promise<GLibDate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/new_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_julian(julian_day: number): Promise<GLibDate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/new_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_day', String(julian_day));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDate();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_days(n_days: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/add_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_days', String(n_days));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_months(n_months: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/add_months`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_months', String(n_months));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_years(n_years: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/add_years`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_years', String(n_years));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async clamp(min_date: GLibDate, max_date: GLibDate): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/clamp`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (min_date && typeof min_date === 'object' && 'ptr' in min_date) {
      url.searchParams.append('min_date', 'ptr,' + min_date.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (max_date && typeof max_date === 'object' && 'ptr' in max_date) {
      url.searchParams.append('max_date', 'ptr,' + max_date.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async clear(n_dates: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_dates', String(n_dates));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async compare(rhs: GLibDate): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (rhs && typeof rhs === 'object' && 'ptr' in rhs) {
      url.searchParams.append('rhs', 'ptr,' + rhs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GLibDate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDate(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async days_between(date2: GLibDate): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/days_between`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (date2 && typeof date2 === 'object' && 'ptr' in date2) {
      url.searchParams.append('date2', 'ptr,' + date2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_day`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day_of_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_day_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_iso8601_week_of_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_iso8601_week_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_julian(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_julian`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_monday_week_of_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_monday_week_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_month(): Promise<GLibDateMonth> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sunday_week_of_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_sunday_week_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_weekday(): Promise<GLibDateWeekday> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_weekday`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_first_of_month(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/is_first_of_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_last_of_month(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/is_last_of_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async order(date2: GLibDate): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/order`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (date2 && typeof date2 === 'object' && 'ptr' in date2) {
      url.searchParams.append('date2', 'ptr,' + date2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_day(day: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_day`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_dmy(day: number, month: GLibDateMonth, y: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('y', String(y));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_julian(julian_date: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_date', String(julian_date));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_month(month: GLibDateMonth): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_parse(str: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_time(time_: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time_', String(time_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_time_t(timet: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_time_t`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timet', String(timet));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_time_val(timeval: GLibTimeVal): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_time_val`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (timeval && typeof timeval === 'object' && 'ptr' in timeval) {
      url.searchParams.append('timeval', 'ptr,' + timeval.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_year(year: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async subtract_days(n_days: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/subtract_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_days', String(n_days));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async subtract_months(n_months: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/subtract_months`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_months', String(n_months));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async subtract_years(n_years: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/subtract_years`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_years', String(n_years));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async to_struct_tm(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/to_struct_tm`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async valid(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/valid`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_days_in_month(month: GLibDateMonth, year: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/get_days_in_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_monday_weeks_in_year(year: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/get_monday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_sunday_weeks_in_year(year: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/get_sunday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async is_leap_year(year: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/is_leap_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async strftime(s: string, slen: number, format: string, date: GLibDate): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/strftime`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s', String(s));
    // Primitive parameter
    url.searchParams.append('slen', String(slen));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Object with explode=false: serialize as comma-separated
    if (date && typeof date === 'object' && 'ptr' in date) {
      url.searchParams.append('date', 'ptr,' + date.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async valid_day(day: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_day`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async valid_dmy(day: number, month: GLibDateMonth, year: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async valid_julian(julian_date: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_date', String(julian_date));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async valid_month(month: GLibDateMonth): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async valid_weekday(weekday: GLibDateWeekday): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_weekday`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('weekday', String(weekday));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async valid_year(year: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibDateTime {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibdatetimeRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibdatetimeRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(tz: GLibTimeZone, year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tz && typeof tz === 'object' && 'ptr' in tz) {
      url.searchParams.append('tz', 'ptr,' + tz.ptr);
    }
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_iso8601(text: string, default_tz?: GLibTimeZone): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_iso8601`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Object with explode=false: serialize as comma-separated
    if (default_tz !== undefined && typeof default_tz === 'object' && 'ptr' in default_tz) {
      url.searchParams.append('default_tz', 'ptr,' + default_tz.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_timeval_local(tv: GLibTimeVal): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_timeval_local`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tv && typeof tv === 'object' && 'ptr' in tv) {
      url.searchParams.append('tv', 'ptr,' + tv.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_timeval_utc(tv: GLibTimeVal): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_timeval_utc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tv && typeof tv === 'object' && 'ptr' in tv) {
      url.searchParams.append('tv', 'ptr,' + tv.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_local(t: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_unix_local`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('t', String(t));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_local_usec(usecs: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_unix_local_usec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_utc(t: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_unix_utc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('t', String(t));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_utc_usec(usecs: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_unix_utc_usec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_local(year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_local`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now(tz: GLibTimeZone): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_now`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tz && typeof tz === 'object' && 'ptr' in tz) {
      url.searchParams.append('tz', 'ptr,' + tz.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now_local(): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_now_local`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now_utc(): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_now_utc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_utc(year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_utc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(timespan: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timespan', String(timespan));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_days(days: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('days', String(days));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_full(years: number, months: number, days: number, hours: number, minutes: number, seconds: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('years', String(years));
    // Primitive parameter
    url.searchParams.append('months', String(months));
    // Primitive parameter
    url.searchParams.append('days', String(days));
    // Primitive parameter
    url.searchParams.append('hours', String(hours));
    // Primitive parameter
    url.searchParams.append('minutes', String(minutes));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_hours(hours: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_hours`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hours', String(hours));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_minutes(minutes: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_minutes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('minutes', String(minutes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_months(months: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_months`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('months', String(months));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_seconds(seconds: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_seconds`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_weeks(weeks: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_weeks`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('weeks', String(weeks));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_years(years: number): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_years`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('years', String(years));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async compare(dt2: GLibDateTime): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dt2 && typeof dt2 === 'object' && 'ptr' in dt2) {
      url.searchParams.append('dt2', 'ptr,' + dt2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async difference(begin: GLibDateTime): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/difference`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async equal(dt2: GLibDateTime): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dt2 && typeof dt2 === 'object' && 'ptr' in dt2) {
      url.searchParams.append('dt2', 'ptr,' + dt2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async format(format: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/format`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async format_iso8601(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/format_iso8601`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day_of_month(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_day_of_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day_of_week(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_day_of_week`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day_of_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_day_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_hour(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_hour`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_microsecond(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_microsecond`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_minute(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_minute`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_month(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_second(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_second`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_seconds(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_seconds`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_timezone(): Promise<GLibTimeZone> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_timezone`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTimeZone(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_timezone_abbreviation(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_timezone_abbreviation`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_utc_offset(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_utc_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_week_numbering_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_week_numbering_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_week_of_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_week_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_ymd(): Promise<{ year?: number; month?: number; day?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_ymd`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_daylight_savings(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/is_daylight_savings`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_local(): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_local`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_timeval(tv: GLibTimeVal): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_timeval`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tv && typeof tv === 'object' && 'ptr' in tv) {
      url.searchParams.append('tv', 'ptr,' + tv.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_timezone(tz: GLibTimeZone): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_timezone`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tz && typeof tz === 'object' && 'ptr' in tz) {
      url.searchParams.append('tz', 'ptr,' + tz.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_unix(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_unix`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_unix_usec(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_unix_usec`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_utc(): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_utc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibDebugKey {
  ptr!: Pointer;


}
export class GLibDir {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibdirRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibdirRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async open(path: string, flags: number): Promise<GLibDir> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/open`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDir();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async close(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/close`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async read_name(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/read_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibDir> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDir(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async rewind(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/rewind`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async make_tmp(tmpl?: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/make_tmp`, apiConfig.baseUrl);
    // Primitive parameter
    if (tmpl !== undefined) url.searchParams.append('tmpl', String(tmpl));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibError {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gliberrorRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gliberrorRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_literal(domain: number, code: number, message: string): Promise<GLibError> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/new_literal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibError();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async matches(domain: number, code: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/matches`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async domain_register(error_type_name: string, error_type_private_size: number, error_type_init: GLibErrorInitFunc, error_type_copy: GLibErrorCopyFunc, error_type_clear: GLibErrorClearFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/domain_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error_type_name', String(error_type_name));
    // Primitive parameter
    url.searchParams.append('error_type_private_size', String(error_type_private_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.error_type_init !== undefined) {
      callbackDispatcher.set(data.error_type_init.toString(), error_type_init);
    }
    if (data.error_type_copy !== undefined) {
      callbackDispatcher.set(data.error_type_copy.toString(), error_type_copy);
    }
    if (data.error_type_clear !== undefined) {
      callbackDispatcher.set(data.error_type_clear.toString(), error_type_clear);
    }
    return data.return;
  }
  static async domain_register_static(error_type_name: string, error_type_private_size: number, error_type_init: GLibErrorInitFunc, error_type_copy: GLibErrorCopyFunc, error_type_clear: GLibErrorClearFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/domain_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error_type_name', String(error_type_name));
    // Primitive parameter
    url.searchParams.append('error_type_private_size', String(error_type_private_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.error_type_init !== undefined) {
      callbackDispatcher.set(data.error_type_init.toString(), error_type_init);
    }
    if (data.error_type_copy !== undefined) {
      callbackDispatcher.set(data.error_type_copy.toString(), error_type_copy);
    }
    if (data.error_type_clear !== undefined) {
      callbackDispatcher.set(data.error_type_clear.toString(), error_type_clear);
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibHashTable {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibhashtableRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibhashtableRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibHashTable> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibHashTable();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async add(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async contains(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async destroy(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/destroy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async find(hash_table: Pointer, predicate: GLibHRFunc): Promise<{ predicate?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.predicate !== undefined) {
      callbackDispatcher.set(data.predicate.toString(), predicate);
    }
    return data;
  }
  static async foreach(hash_table: Pointer, func: GLibHFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/foreach`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  static async foreach_remove(hash_table: Pointer, func: GLibHRFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/foreach_remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  static async foreach_steal(hash_table: Pointer, func: GLibHRFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/foreach_steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  static async insert(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async lookup(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async lookup_extended(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/lookup_extended`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async new_similar(other_hash_table: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/new_similar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('other_hash_table', String(other_hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async ref(hash_table: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async remove(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async remove_all(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/remove_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async replace(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/replace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async size(hash_table: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async steal(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async steal_all(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/steal_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async steal_extended(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/steal_extended`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async unref(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibHashTableIter {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibhashtableiterRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibhashtableiterRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibHashTableIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibHashTableIter();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_hash_table(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/get_hash_table`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async init(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async next(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/steal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibHmac {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibhmacRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibhmacRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(digest_type: GLibChecksumType, key: Pointer, key_len: number): Promise<GLibHmac> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('digest_type', String(digest_type));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('key_len', String(key_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibHmac();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GLibHmac> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibHmac(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_digest(buffer: Pointer, digest_len: number): Promise<{ digest_len?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/get_digest`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buffer', String(buffer));
    // Primitive parameter
    url.searchParams.append('digest_len', String(digest_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async get_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibHmac> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibHmac(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async update(data_: Pointer, length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/update`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibHook {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibhookRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibhookRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibHook> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibHook();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async compare_ids(sibling: GLibHook): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/compare_ids`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sibling && typeof sibling === 'object' && 'ptr' in sibling) {
      url.searchParams.append('sibling', 'ptr,' + sibling.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async destroy(hook_list: GLibHookList, hook_id: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/destroy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('hook_id', String(hook_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async destroy_link(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/destroy_link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async insert_before(hook_list: GLibHookList, hook: GLibHook, sibling?: GLibHook): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/insert_before`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (sibling !== undefined && typeof sibling === 'object' && 'ptr' in sibling) {
      url.searchParams.append('sibling', 'ptr,' + sibling.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async insert_sorted(hook_list: GLibHookList, hook: GLibHook, func: GLibHookCompareFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/insert_sorted`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  static async prepend(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/prepend`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async unref(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/unref`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibHookList {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibhooklistRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibhooklistRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibHookList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibHookList();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clear(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async init(hook_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hook_size', String(hook_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async invoke(may_recurse: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/invoke`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_recurse', String(may_recurse));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async invoke_check(may_recurse: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/invoke_check`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_recurse', String(may_recurse));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async marshal(may_recurse: boolean, marshaller: GLibHookMarshaller): Promise<{ marshaller?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/marshal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_recurse', String(may_recurse));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.marshaller !== undefined) {
      callbackDispatcher.set(data.marshaller.toString(), marshaller);
    }
    return data;
  }
  async marshal_check(may_recurse: boolean, marshaller: GLibHookCheckMarshaller): Promise<{ marshaller?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/marshal_check`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_recurse', String(may_recurse));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.marshaller !== undefined) {
      callbackDispatcher.set(data.marshaller.toString(), marshaller);
    }
    return data;
  }
}
export class GLibIOChannel {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibiochannelRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibiochannelRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_file(filename: Pointer, mode: string): Promise<GLibIOChannel> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/new_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibIOChannel();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async unix_new(fd: number): Promise<GLibIOChannel> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/unix_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibIOChannel();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async close(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/close`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async flush(): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/flush`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_buffer_condition(): Promise<GLibIOConditionValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_buffer_condition`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_buffer_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_buffer_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_buffered(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_buffered`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_close_on_unref(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_close_on_unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_encoding(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_encoding`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_flags(): Promise<GLibIOFlags> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_line_term(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_line_term`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async init(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async read(buf: string, count: number, bytes_read: number): Promise<GLibIOError> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buf', String(buf));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    // Primitive parameter
    url.searchParams.append('bytes_read', String(bytes_read));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async read_chars(count: number): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_chars`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('count', String(count));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async read_line(): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_line`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async read_line_string(buffer: GLibString, terminator_pos?: number): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_line_string`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Primitive parameter
    if (terminator_pos !== undefined) url.searchParams.append('terminator_pos', String(terminator_pos));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async read_to_end(): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_to_end`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async read_unichar(): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_unichar`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibIOChannel> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibIOChannel(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async seek(offset: number, type_: GLibSeekType): Promise<GLibIOError> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async seek_position(offset: number, type_: GLibSeekType): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/seek_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_buffer_size(size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_buffer_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffered(buffered: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_buffered`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buffered', String(buffered));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_close_on_unref(do_close: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_close_on_unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('do_close', String(do_close));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_encoding(encoding?: string): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_encoding`, apiConfig.baseUrl);
    // Primitive parameter
    if (encoding !== undefined) url.searchParams.append('encoding', String(encoding));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flags(flags: GLibIOFlags): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_line_term(length: number, line_term?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_line_term`, apiConfig.baseUrl);
    // Primitive parameter
    if (line_term !== undefined) url.searchParams.append('line_term', String(line_term));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async shutdown(flush: boolean): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/shutdown`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unix_get_fd(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/unix_get_fd`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async write(buf: string, count: number, bytes_written: number): Promise<GLibIOError> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/write`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buf', String(buf));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    // Primitive parameter
    url.searchParams.append('bytes_written', String(bytes_written));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async write_chars(buf: Pointer, count: number): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/write_chars`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buf', String(buf));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async write_unichar(thechar: Pointer): Promise<GLibIOStatus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/write_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('thechar', String(thechar));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async error_from_errno(en: number): Promise<GLibIOChannelError> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/error_from_errno`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('en', String(en));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibIOFuncs {
  ptr!: Pointer;


}
export class GLibKeyFile {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibkeyfileRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibkeyfileRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibKeyFile> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibKeyFile();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_boolean(group_name: string, key: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boolean_list(group_name: string, key: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_boolean_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_comment(group_name?: string, key?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_comment`, apiConfig.baseUrl);
    // Primitive parameter
    if (group_name !== undefined) url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double(group_name: string, key: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double_list(group_name: string, key: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_double_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_groups(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_groups`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64(group_name: string, key: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_integer(group_name: string, key: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_integer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_integer_list(group_name: string, key: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_integer_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_keys(group_name: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_keys`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_locale_for_key(group_name: string, key: string, locale?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_locale_for_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    if (locale !== undefined) url.searchParams.append('locale', String(locale));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_locale_string(group_name: string, key: string, locale?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_locale_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    if (locale !== undefined) url.searchParams.append('locale', String(locale));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_locale_string_list(group_name: string, key: string, locale?: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_locale_string_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    if (locale !== undefined) url.searchParams.append('locale', String(locale));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_start_group(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_start_group`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string(group_name: string, key: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string_list(group_name: string, key: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_string_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64(group_name: string, key: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(group_name: string, key: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_group(group_name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/has_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load_from_bytes(bytes: GLibBytes, flags: GLibKeyFileFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_bytes`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes && typeof bytes === 'object' && 'ptr' in bytes) {
      url.searchParams.append('bytes', 'ptr,' + bytes.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load_from_data(data_: string, length: number, flags: GLibKeyFileFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load_from_data_dirs(file: Pointer, flags: GLibKeyFileFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_data_dirs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load_from_dirs(file: Pointer, search_dirs: Pointer, flags: GLibKeyFileFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_dirs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('search_dirs', String(search_dirs));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load_from_file(file: Pointer, flags: GLibKeyFileFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_comment(group_name?: string, key?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/remove_comment`, apiConfig.baseUrl);
    // Primitive parameter
    if (group_name !== undefined) url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_group(group_name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/remove_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_key(group_name: string, key: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/remove_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async save_to_file(filename: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/save_to_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_boolean(group_name: string, key: string, value_: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_boolean_list(group_name: string, key: string, list: Pointer, length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_boolean_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_comment(comment: string, group_name?: string, key?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_comment`, apiConfig.baseUrl);
    // Primitive parameter
    if (group_name !== undefined) url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('comment', String(comment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_double(group_name: string, key: string, value_: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_double_list(group_name: string, key: string, list: Pointer, length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_double_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_int64(group_name: string, key: string, value_: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_integer(group_name: string, key: string, value_: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_integer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_integer_list(group_name: string, key: string, list: Pointer, length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_integer_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_list_separator(separator: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_list_separator`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('separator', String(separator));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_locale_string(group_name: string, key: string, locale: string, string: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_locale_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('locale', String(locale));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_locale_string_list(group_name: string, key: string, locale: string, list: Pointer, length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_locale_string_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('locale', String(locale));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_string(group_name: string, key: string, string: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_string_list(group_name: string, key: string, list: Pointer, length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_string_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uint64(group_name: string, key: string, value_: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_value(group_name: string, key: string, value_: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async to_data(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/to_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibList {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gliblistRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gliblistRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibList();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async pop_allocator(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/pop_allocator`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async push_allocator(allocator: GLibAllocator): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibLogField {
  ptr!: Pointer;


}
export class GLibMainContext {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibmaincontextRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibmaincontextRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibMainContext();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_with_flags(flags: GLibMainContextFlags): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/new_with_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibMainContext();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async acquire(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/acquire`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_poll(fd: GLibPollFD, priority: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/add_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async check(max_priority: number, fds: Pointer, n_fds: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/check`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_priority', String(max_priority));
    // Primitive parameter
    url.searchParams.append('fds', String(fds));
    // Primitive parameter
    url.searchParams.append('n_fds', String(n_fds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dispatch(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/dispatch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async find_source_by_funcs_user_data(funcs: GLibSourceFuncs): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/find_source_by_funcs_user_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async find_source_by_id(source_id: number): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/find_source_by_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_id', String(source_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async find_source_by_user_data(): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/find_source_by_user_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async invoke_full(priority: number, function_: GLibSourceFunc): Promise<{ function_?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/invoke_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.function !== undefined) {
      callbackDispatcher.set(data.function.toString(), function_);
    }
    return data;
  }
  async is_owner(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/is_owner`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iteration(may_block: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/iteration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_block', String(may_block));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pending(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/pending`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pop_thread_default(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/pop_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async prepare(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/prepare`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push_thread_default(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/push_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async query(max_priority: number, n_fds: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/query`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_priority', String(max_priority));
    // Primitive parameter
    url.searchParams.append('n_fds', String(n_fds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async release(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/release`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_poll(fd: GLibPollFD): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/remove_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait(cond: GLibCond, mutex: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (cond && typeof cond === 'object' && 'ptr' in cond) {
      url.searchParams.append('cond', 'ptr,' + cond.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mutex', String(mutex));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async wakeup(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/wakeup`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async default(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_thread_default(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/get_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async ref_thread_default(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ref_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibMainLoop {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibmainloopRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibmainloopRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(is_running: boolean, context?: GLibMainContext): Promise<GLibMainLoop> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('is_running', String(is_running));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibMainLoop();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_context(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/get_context`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_running(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/is_running`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async quit(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/quit`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GLibMainLoop> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainLoop(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async run(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/run`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibMappedFile {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibmappedfileRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibmappedfileRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(filename: Pointer, writable: boolean): Promise<GLibMappedFile> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('writable', String(writable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibMappedFile();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_fd(fd: number, writable: boolean): Promise<GLibMappedFile> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/new_from_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('writable', String(writable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibMappedFile();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_bytes(): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/get_bytes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_contents(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/get_contents`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_length(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/get_length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibMappedFile> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMappedFile(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibMarkupParseContext {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibmarkupparsecontextRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibmarkupparsecontextRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(parser: GLibMarkupParser, flags: GLibMarkupParseFlags, user_data_dnotify: GLibDestroyNotify): Promise<GLibMarkupParseContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parser && typeof parser === 'object' && 'ptr' in parser) {
      url.searchParams.append('parser', 'ptr,' + parser.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.user_data_dnotify !== undefined) {
      callbackDispatcher.set(data.user_data_dnotify.toString(), user_data_dnotify);
    }
    const instance = new GLibMarkupParseContext();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async end_parse(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/end_parse`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_element(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/get_element`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_element_stack(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/get_element_stack`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_position(): Promise<{ line_number?: number; char_number?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/get_position`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async get_user_data(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/get_user_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse(text: string, text_len: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    url.searchParams.append('text_len', String(text_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pop(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push(parser: GLibMarkupParser): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parser && typeof parser === 'object' && 'ptr' in parser) {
      url.searchParams.append('parser', 'ptr,' + parser.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GLibMarkupParseContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMarkupParseContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibMarkupParser {
  ptr!: Pointer;


}
export class GLibMatchInfo {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibmatchinfoRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibmatchinfoRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibMatchInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibMatchInfo();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async expand_references(string_to_expand: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/expand_references`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string_to_expand', String(string_to_expand));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fetch(match_num: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('match_num', String(match_num));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fetch_all(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch_all`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fetch_named(name: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch_named`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fetch_named_pos(name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch_named_pos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fetch_pos(match_num: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch_pos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('match_num', String(match_num));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_match_count(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/get_match_count`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_regex(): Promise<GLibRegex> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/get_regex`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibRegex(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_partial_match(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/is_partial_match`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async matches(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/matches`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async next(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibMatchInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMatchInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibMemChunk {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibmemchunkRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibmemchunkRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibMemChunk> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibMemChunk();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async alloc(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/alloc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async alloc0(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/alloc0`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async clean(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/clean`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async print(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/print`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async reset(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/reset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async info(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibMemVTable {
  ptr!: Pointer;


}
export class GLibNode {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibnodeRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibnodeRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibNode();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async child_index(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/child_index`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async child_position(child: GLibNode): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/child_position`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child && typeof child === 'object' && 'ptr' in child) {
      url.searchParams.append('child', 'ptr,' + child.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async children_foreach(flags: GLibTraverseFlags, func: GLibNodeForeachFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/children_foreach`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async depth(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/depth`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_ancestor(descendant: GLibNode): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/is_ancestor`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (descendant && typeof descendant === 'object' && 'ptr' in descendant) {
      url.searchParams.append('descendant', 'ptr,' + descendant.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async max_height(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/max_height`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async n_children(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/n_children`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async n_nodes(flags: GLibTraverseFlags): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/n_nodes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reverse_children(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/reverse_children`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async traverse(order: GLibTraverseType, flags: GLibTraverseFlags, max_depth: number, func: GLibNodeTraverseFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/traverse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('order', String(order));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('max_depth', String(max_depth));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async unlink(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/unlink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async pop_allocator(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/pop_allocator`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async push_allocator(allocator: GLibAllocator): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibOnce {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibonceRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibonceRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibOnce> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibOnce();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async init_enter(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_enter`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async init_enter_impl(location: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_enter_impl`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async init_enter_pointer(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_enter_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async init_leave(result_: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_leave`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('result', String(result_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async init_leave_pointer(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_leave_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibOptionContext {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gliboptioncontextRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gliboptioncontextRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibOptionContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibOptionContext();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_group(group: GLibOptionGroup): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/add_group`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (group && typeof group === 'object' && 'ptr' in group) {
      url.searchParams.append('group', 'ptr,' + group.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_main_entries(entries: Pointer, translation_domain?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/add_main_entries`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('entries', String(entries));
    // Primitive parameter
    if (translation_domain !== undefined) url.searchParams.append('translation_domain', String(translation_domain));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_description(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_help(main_help: boolean, group?: GLibOptionGroup): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_help`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('main_help', String(main_help));
    // Object with explode=false: serialize as comma-separated
    if (group !== undefined && typeof group === 'object' && 'ptr' in group) {
      url.searchParams.append('group', 'ptr,' + group.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_help_enabled(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_help_enabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_ignore_unknown_options(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_ignore_unknown_options`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_main_group(): Promise<GLibOptionGroup> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_main_group`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibOptionGroup(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_strict_posix(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_strict_posix`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_summary(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_summary`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse(argc: number, argv: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('argc', String(argc));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_strv(arguments_: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/parse_strv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arguments', String(arguments_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_description(description?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_description`, apiConfig.baseUrl);
    // Primitive parameter
    if (description !== undefined) url.searchParams.append('description', String(description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_help_enabled(help_enabled: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_help_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('help_enabled', String(help_enabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_ignore_unknown_options(ignore_unknown: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_ignore_unknown_options`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ignore_unknown', String(ignore_unknown));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_main_group(group: GLibOptionGroup): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_main_group`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (group && typeof group === 'object' && 'ptr' in group) {
      url.searchParams.append('group', 'ptr,' + group.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_strict_posix(strict_posix: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_strict_posix`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strict_posix', String(strict_posix));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_summary(summary?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_summary`, apiConfig.baseUrl);
    // Primitive parameter
    if (summary !== undefined) url.searchParams.append('summary', String(summary));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_translate_func(func: GLibTranslateFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_translate_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async set_translation_domain(domain: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_translation_domain`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibOptionEntry {
  ptr!: Pointer;


}
export class GLibOptionGroup {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gliboptiongroupRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gliboptiongroupRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(name: string, description: string, help_description: string, destroy: GLibDestroyNotify): Promise<GLibOptionGroup> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    // Primitive parameter
    url.searchParams.append('help_description', String(help_description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.destroy !== undefined) {
      callbackDispatcher.set(data.destroy.toString(), destroy);
    }
    const instance = new GLibOptionGroup();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_entries(entries: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/add_entries`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('entries', String(entries));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GLibOptionGroup> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibOptionGroup(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_translate_func(func: GLibTranslateFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/set_translate_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async set_translation_domain(domain: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/set_translation_domain`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibPathBuf {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibpathbufRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibpathbufRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibPathBuf> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibPathBuf();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clear(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async clear_to_path(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/clear_to_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async free_to_path(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/free_to_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async init(): Promise<GLibPathBuf> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibPathBuf(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async init_from_path(path?: Pointer): Promise<GLibPathBuf> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/init_from_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibPathBuf(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async pop(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push(path: Pointer): Promise<GLibPathBuf> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibPathBuf(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_extension(extension?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/set_extension`, apiConfig.baseUrl);
    // Primitive parameter
    if (extension !== undefined) url.searchParams.append('extension', String(extension));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_filename(file_name: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/set_filename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_path(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/to_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async equal(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/equal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibPatternSpec {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibpatternspecRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibpatternspecRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(pattern: string): Promise<GLibPatternSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibPatternSpec();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GLibPatternSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibPatternSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async equal(pspec2: GLibPatternSpec): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec2 && typeof pspec2 === 'object' && 'ptr' in pspec2) {
      url.searchParams.append('pspec2', 'ptr,' + pspec2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async match(string_length: number, string: string, string_reversed?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/match`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string_length', String(string_length));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (string_reversed !== undefined) url.searchParams.append('string_reversed', String(string_reversed));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async match_string(string: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/match_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibPollFD {
  ptr!: Pointer;


}
export class GLibPrivate {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibprivateRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibprivateRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibPrivate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibPrivate();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/set`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibPtrArray {
  ptr!: Pointer;


}
export class GLibQueue {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibqueueRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibqueueRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibQueue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibQueue();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clear(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async clear_full(free_func: GLibDestroyNotify): Promise<{ free_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/clear_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.free_func !== undefined) {
      callbackDispatcher.set(data.free_func.toString(), free_func);
    }
    return data;
  }
  async foreach(func: GLibFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async free_full(free_func: GLibDestroyNotify): Promise<{ free_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/free_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.free_func !== undefined) {
      callbackDispatcher.set(data.free_func.toString(), free_func);
    }
    return data;
  }
  async get_length(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/get_length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async index(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/index`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async init(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async insert_sorted(func: GLibCompareDataFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/insert_sorted`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async is_empty(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek_head(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/peek_head`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async peek_nth(n: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/peek_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n', String(n));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async peek_tail(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/peek_tail`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async pop_head(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/pop_head`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async pop_nth(n: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/pop_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n', String(n));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async pop_tail(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/pop_tail`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push_head(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/push_head`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push_nth(n: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/push_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n', String(n));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push_tail(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/push_tail`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_all(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/remove_all`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reverse(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/reverse`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sort(compare_func: GLibCompareDataFunc): Promise<{ compare_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/sort`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.compare_func !== undefined) {
      callbackDispatcher.set(data.compare_func.toString(), compare_func);
    }
    return data;
  }
}
export class GLibRWLock {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibrwlockRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibrwlockRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibRWLock> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibRWLock();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clear(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async init(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async reader_lock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/reader_lock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async reader_trylock(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/reader_trylock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reader_unlock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/reader_unlock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async writer_lock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/writer_lock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async writer_trylock(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/writer_trylock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async writer_unlock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/writer_unlock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibRand {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibrandRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibrandRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibRand> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibRand();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_with_seed(seed: number): Promise<GLibRand> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/new_with_seed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibRand();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_with_seed_array(seed: number, seed_length: number): Promise<GLibRand> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/new_with_seed_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    // Primitive parameter
    url.searchParams.append('seed_length', String(seed_length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibRand();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GLibRand> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibRand(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async double(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/double`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async double_range(begin: number, end: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/double_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async int(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/int`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async int_range(begin: number, end: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/int_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_seed(seed: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/set_seed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_seed_array(seed: number, seed_length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/set_seed_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    // Primitive parameter
    url.searchParams.append('seed_length', String(seed_length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibRecMutex {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibrecmutexRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibrecmutexRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibRecMutex> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibRecMutex();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clear(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async init(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async lock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/lock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async trylock(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/trylock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unlock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/unlock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibRegex {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibregexRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibregexRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(pattern: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<GLibRegex> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibRegex();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_capture_count(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_capture_count`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_compile_flags(): Promise<GLibRegexCompileFlags> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_compile_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_has_cr_or_lf(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_has_cr_or_lf`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_match_flags(): Promise<GLibRegexMatchFlags> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_match_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_max_backref(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_max_backref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_max_lookbehind(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_max_lookbehind`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pattern(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_pattern`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string_number(name: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_string_number`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async match(string: string, match_options: GLibRegexMatchFlags, match_info: GLibMatchInfo): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/match`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Object with explode=false: serialize as comma-separated
    if (match_info && typeof match_info === 'object' && 'ptr' in match_info) {
      url.searchParams.append('match_info', 'ptr,' + match_info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async match_all(string: string, match_options: GLibRegexMatchFlags, match_info: GLibMatchInfo): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/match_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Object with explode=false: serialize as comma-separated
    if (match_info && typeof match_info === 'object' && 'ptr' in match_info) {
      url.searchParams.append('match_info', 'ptr,' + match_info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async match_all_full(string: Pointer, string_len: number, start_position: number, match_options: GLibRegexMatchFlags, match_info: GLibMatchInfo): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/match_all_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Object with explode=false: serialize as comma-separated
    if (match_info && typeof match_info === 'object' && 'ptr' in match_info) {
      url.searchParams.append('match_info', 'ptr,' + match_info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async match_full(string: Pointer, string_len: number, start_position: number, match_options: GLibRegexMatchFlags, match_info: GLibMatchInfo): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/match_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Object with explode=false: serialize as comma-separated
    if (match_info && typeof match_info === 'object' && 'ptr' in match_info) {
      url.searchParams.append('match_info', 'ptr,' + match_info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibRegex> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibRegex(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async replace(string: Pointer, string_len: number, start_position: number, replacement: string, match_options: GLibRegexMatchFlags): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('replacement', String(replacement));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async replace_eval(string: Pointer, string_len: number, start_position: number, match_options: GLibRegexMatchFlags, eval_: GLibRegexEvalCallback): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/replace_eval`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.eval !== undefined) {
      callbackDispatcher.set(data.eval.toString(), eval_);
    }
    return data.return;
  }
  async replace_literal(string: Pointer, string_len: number, start_position: number, replacement: string, match_options: GLibRegexMatchFlags): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/replace_literal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('replacement', String(replacement));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async split(string: string, match_options: GLibRegexMatchFlags): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/split`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async split_full(string: Pointer, string_len: number, start_position: number, match_options: GLibRegexMatchFlags, max_tokens: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/split_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Primitive parameter
    url.searchParams.append('max_tokens', String(max_tokens));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async check_replacement(replacement: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/check_replacement`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('replacement', String(replacement));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async escape_nul(string: string, length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/escape_nul`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async escape_string(string: string, length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/escape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async match_simple(pattern: string, string: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/match_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async split_simple(pattern: string, string: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/split_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibRelation {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibrelationRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibrelationRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibRelation> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibRelation();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async count(field: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/count`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async delete(field: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/delete`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async print(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/print`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibSList {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibslistRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibslistRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibSList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibSList();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async pop_allocator(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/pop_allocator`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async push_allocator(allocator: GLibAllocator): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibScanner {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibscannerRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibscannerRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibScanner> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibScanner();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async cur_line(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/cur_line`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async cur_position(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/cur_position`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async cur_token(): Promise<GLibTokenType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/cur_token`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async eof(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/eof`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_next_token(): Promise<GLibTokenType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/get_next_token`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async input_file(input_fd: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/input_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('input_fd', String(input_fd));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async input_text(text: string, text_len: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/input_text`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    url.searchParams.append('text_len', String(text_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async lookup_symbol(symbol: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/lookup_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('symbol', String(symbol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async peek_next_token(): Promise<GLibTokenType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/peek_next_token`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async scope_add_symbol(scope_id: number, symbol: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/scope_add_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    // Primitive parameter
    url.searchParams.append('symbol', String(symbol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async scope_foreach_symbol(scope_id: number, func: GLibHFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/scope_foreach_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async scope_lookup_symbol(scope_id: number, symbol: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/scope_lookup_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    // Primitive parameter
    url.searchParams.append('symbol', String(symbol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async scope_remove_symbol(scope_id: number, symbol: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/scope_remove_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    // Primitive parameter
    url.searchParams.append('symbol', String(symbol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_scope(scope_id: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/set_scope`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async sync_file_offset(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/sync_file_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unexp_token(expected_token: GLibTokenType, identifier_spec: string, symbol_spec: string, symbol_name: string, message: string, is_error: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/unexp_token`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('expected_token', String(expected_token));
    // Primitive parameter
    url.searchParams.append('identifier_spec', String(identifier_spec));
    // Primitive parameter
    url.searchParams.append('symbol_spec', String(symbol_spec));
    // Primitive parameter
    url.searchParams.append('symbol_name', String(symbol_name));
    // Primitive parameter
    url.searchParams.append('message', String(message));
    // Primitive parameter
    url.searchParams.append('is_error', String(is_error));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibScannerConfig {
  ptr!: Pointer;


}
export class GLibSequence {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibsequenceRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibsequenceRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibSequence> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibSequence();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append(): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async foreach(func: GLibFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async get_begin_iter(): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/get_begin_iter`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_end_iter(): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/get_end_iter`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_iter_at_pos(pos: number): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/get_iter_at_pos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_length(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/get_length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async insert_sorted(cmp_func: GLibCompareDataFunc): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/insert_sorted`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.cmp_func !== undefined) {
      callbackDispatcher.set(data.cmp_func.toString(), cmp_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert_sorted_iter(iter_cmp: GLibSequenceIterCompareFunc): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/insert_sorted_iter`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.iter_cmp !== undefined) {
      callbackDispatcher.set(data.iter_cmp.toString(), iter_cmp);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_empty(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lookup(cmp_func: GLibCompareDataFunc): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/lookup`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.cmp_func !== undefined) {
      callbackDispatcher.set(data.cmp_func.toString(), cmp_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async lookup_iter(iter_cmp: GLibSequenceIterCompareFunc): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/lookup_iter`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.iter_cmp !== undefined) {
      callbackDispatcher.set(data.iter_cmp.toString(), iter_cmp);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend(): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/prepend`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async search(cmp_func: GLibCompareDataFunc): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/search`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.cmp_func !== undefined) {
      callbackDispatcher.set(data.cmp_func.toString(), cmp_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async search_iter(iter_cmp: GLibSequenceIterCompareFunc): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/search_iter`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.iter_cmp !== undefined) {
      callbackDispatcher.set(data.iter_cmp.toString(), iter_cmp);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async sort(cmp_func: GLibCompareDataFunc): Promise<{ cmp_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/sort`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.cmp_func !== undefined) {
      callbackDispatcher.set(data.cmp_func.toString(), cmp_func);
    }
    return data;
  }
  async sort_iter(cmp_func: GLibSequenceIterCompareFunc): Promise<{ cmp_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/sort_iter`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.cmp_func !== undefined) {
      callbackDispatcher.set(data.cmp_func.toString(), cmp_func);
    }
    return data;
  }
  static async foreach_range(begin: GLibSequenceIter, end: GLibSequenceIter, func: GLibFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/foreach_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  static async get(iter: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/get`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async insert_before(iter: GLibSequenceIter): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/insert_before`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async move(src: GLibSequenceIter, dest: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/move`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async move_range(dest: GLibSequenceIter, begin: GLibSequenceIter, end: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/move_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async range_get_midpoint(begin: GLibSequenceIter, end: GLibSequenceIter): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/range_get_midpoint`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async remove(iter: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async remove_range(begin: GLibSequenceIter, end: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/remove_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async set(iter: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/set`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async sort_changed(iter: GLibSequenceIter, cmp_func: GLibCompareDataFunc): Promise<{ cmp_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/sort_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.cmp_func !== undefined) {
      callbackDispatcher.set(data.cmp_func.toString(), cmp_func);
    }
    return data;
  }
  static async sort_changed_iter(iter: GLibSequenceIter, iter_cmp: GLibSequenceIterCompareFunc): Promise<{ iter_cmp?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/sort_changed_iter`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.iter_cmp !== undefined) {
      callbackDispatcher.set(data.iter_cmp.toString(), iter_cmp);
    }
    return data;
  }
  static async swap(a: GLibSequenceIter, b: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/swap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (a && typeof a === 'object' && 'ptr' in a) {
      url.searchParams.append('a', 'ptr,' + a.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (b && typeof b === 'object' && 'ptr' in b) {
      url.searchParams.append('b', 'ptr,' + b.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibSequenceIter {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibsequenceiterRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibsequenceiterRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibSequenceIter();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async compare(b: GLibSequenceIter): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (b && typeof b === 'object' && 'ptr' in b) {
      url.searchParams.append('b', 'ptr,' + b.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_position(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/get_position`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sequence(): Promise<GLibSequence> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/get_sequence`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequence(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_begin(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/is_begin`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_end(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/is_end`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async move(delta: number): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/move`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('delta', String(delta));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async next(): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prev(): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/prev`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GLibSource {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibsourceRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibsourceRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(source_funcs: GLibSourceFuncs, struct_size: number): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (source_funcs && typeof source_funcs === 'object' && 'ptr' in source_funcs) {
      url.searchParams.append('source_funcs', 'ptr,' + source_funcs.ptr);
    }
    // Primitive parameter
    url.searchParams.append('struct_size', String(struct_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibSource();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_child_source(child_source: GLibSource): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/add_child_source`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_source && typeof child_source === 'object' && 'ptr' in child_source) {
      url.searchParams.append('child_source', 'ptr,' + child_source.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_poll(fd: GLibPollFD): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/add_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_unix_fd(fd: number, events: GLibIOConditionValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/add_unix_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('events', String(events));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async attach(context?: GLibMainContext): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/attach`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_can_recurse(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_can_recurse`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_context(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_context`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_current_time(timeval: GLibTimeVal): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_current_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (timeval && typeof timeval === 'object' && 'ptr' in timeval) {
      url.searchParams.append('timeval', 'ptr,' + timeval.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_id(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_priority(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_priority`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_ready_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_ready_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_destroyed(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/is_destroyed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async modify_unix_fd(new_events: GLibIOConditionValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/modify_unix_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('new_events', String(new_events));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async query_unix_fd(): Promise<GLibIOConditionValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/query_unix_fd`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove_child_source(child_source: GLibSource): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/remove_child_source`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_source && typeof child_source === 'object' && 'ptr' in child_source) {
      url.searchParams.append('child_source', 'ptr,' + child_source.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_poll(fd: GLibPollFD): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/remove_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_unix_fd(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/remove_unix_fd`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_callback(func: GLibSourceFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_callback`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async set_callback_indirect(callback_funcs: GLibSourceCallbackFuncs): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_callback_indirect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (callback_funcs && typeof callback_funcs === 'object' && 'ptr' in callback_funcs) {
      url.searchParams.append('callback_funcs', 'ptr,' + callback_funcs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_can_recurse(can_recurse: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_can_recurse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('can_recurse', String(can_recurse));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_funcs(funcs: GLibSourceFuncs): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_funcs`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_name(name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_priority(priority: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_priority`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_ready_time(ready_time: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_ready_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ready_time', String(ready_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_static_name(name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_static_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async remove(tag: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async remove_by_funcs_user_data(funcs: GLibSourceFuncs): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/remove_by_funcs_user_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async remove_by_user_data(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/remove_by_user_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async set_name_by_id(tag: number, name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/set_name_by_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibSourceCallbackFuncs {
  ptr!: Pointer;


}
export class GLibSourceFuncs {
  ptr!: Pointer;


}
export class GLibSourcePrivate {
  ptr!: Pointer;


}
export class GLibStatBuf {
  ptr!: Pointer;


}
export class GLibString {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibstringRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibstringRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(init?: string): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (init !== undefined) url.searchParams.append('init', String(init));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibString();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_len(init: string, len: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/new_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('init', String(init));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibString();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_take(init?: string): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/new_take`, apiConfig.baseUrl);
    // Primitive parameter
    if (init !== undefined) url.searchParams.append('init', String(init));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibString();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async sized_new(dfl_size: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/sized_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dfl_size', String(dfl_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibString();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append(val: string): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async append_c(c: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append_c`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async append_len(val: string, len: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async append_unichar(wc: Pointer): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('wc', String(wc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async append_uri_escaped(unescaped: string, reserved_chars_allowed: string, allow_utf8: boolean): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append_uri_escaped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    // Primitive parameter
    url.searchParams.append('allow_utf8', String(allow_utf8));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ascii_down(): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/ascii_down`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ascii_up(): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/ascii_up`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async assign(rval: string): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/assign`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rval', String(rval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async down(): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/down`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async equal(v2: GLibString): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (v2 && typeof v2 === 'object' && 'ptr' in v2) {
      url.searchParams.append('v2', 'ptr,' + v2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async erase(pos: number, len: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/erase`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async free_and_steal(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/free_and_steal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async free_to_bytes(): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/free_to_bytes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async insert(pos: number, val: string): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert_c(pos: number, c: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/insert_c`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert_len(pos: number, val: string, len: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/insert_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert_unichar(pos: number, wc: Pointer): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/insert_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('wc', String(wc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async overwrite(pos: number, val: string): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/overwrite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async overwrite_len(pos: number, val: string, len: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/overwrite_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend(val: string): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/prepend`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend_c(c: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/prepend_c`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend_len(val: string, len: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/prepend_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend_unichar(wc: Pointer): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/prepend_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('wc', String(wc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async replace(find: string, replace: string, limit: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('find', String(find));
    // Primitive parameter
    url.searchParams.append('replace', String(replace));
    // Primitive parameter
    url.searchParams.append('limit', String(limit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_size(len: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/set_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async truncate(len: number): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/truncate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async up(): Promise<GLibString> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/up`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibString(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibStringChunk {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibstringchunkRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibstringchunkRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibStringChunk> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibStringChunk();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clear(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async insert(string: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async insert_const(string: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/insert_const`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async insert_len(string: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/insert_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibStrvBuilder {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibstrvbuilderRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibstrvbuilderRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibStrvBuilder> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibStrvBuilder();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(value_: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async addv(value_: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/addv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async end(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/end`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibStrvBuilder> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibStrvBuilder(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async take(value_: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/take`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibTestCase {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtestcaseRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtestcaseRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestCase/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTestCase> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestCase/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTestCase();
    Object.assign(instance, data.return || data);
    return instance;
  }

}
export class GLibTestConfig {
  ptr!: Pointer;


}
export class GLibTestLogBuffer {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtestlogbufferRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtestlogbufferRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogBuffer/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTestLogBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogBuffer/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTestLogBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async push(n_bytes: number, bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogBuffer/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    // Primitive parameter
    url.searchParams.append('bytes', String(bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibTestLogMsg {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtestlogmsgRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtestlogmsgRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTestLogMsg> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTestLogMsg();
    Object.assign(instance, data.return || data);
    return instance;
  }

}
export class GLibTestSuite {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtestsuiteRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtestsuiteRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestSuite/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTestSuite> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestSuite/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTestSuite();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(test_case: GLibTestCase): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestSuite/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (test_case && typeof test_case === 'object' && 'ptr' in test_case) {
      url.searchParams.append('test_case', 'ptr,' + test_case.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_suite(nestedsuite: GLibTestSuite): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestSuite/ptr,${this.ptr}/add_suite`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (nestedsuite && typeof nestedsuite === 'object' && 'ptr' in nestedsuite) {
      url.searchParams.append('nestedsuite', 'ptr,' + nestedsuite.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibThread {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibthreadRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibthreadRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(func: GLibThreadFunc, name?: string): Promise<GLibThread> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    const instance = new GLibThread();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async try_new(func: GLibThreadFunc, name?: string): Promise<GLibThread> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/try_new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    const instance = new GLibThread();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async join(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GLibThread> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibThread(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async exit(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/exit`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async self(): Promise<GLibThread> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/self`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibThread(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async yield(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/yield`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibThreadPool {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibthreadpoolRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibthreadpoolRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibThreadPool> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibThreadPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_max_threads(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/get_max_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_num_threads(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/get_num_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async move_to_front(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/move_to_front`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_max_threads(max_threads: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/set_max_threads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_threads', String(max_threads));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unprocessed(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/unprocessed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_max_idle_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/get_max_idle_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_max_unused_threads(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/get_max_unused_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_num_unused_threads(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/get_num_unused_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async set_max_idle_time(interval: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/set_max_idle_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async set_max_unused_threads(max_threads: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/set_max_unused_threads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_threads', String(max_threads));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async stop_unused_threads(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/stop_unused_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibTimeVal {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtimevalRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtimevalRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTimeVal> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeVal();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(microseconds: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('microseconds', String(microseconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async to_iso8601(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/to_iso8601`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async from_iso8601(iso_date: string, time_: GLibTimeVal): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/from_iso8601`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iso_date', String(iso_date));
    // Object with explode=false: serialize as comma-separated
    if (time_ && typeof time_ === 'object' && 'ptr' in time_) {
      url.searchParams.append('time_', 'ptr,' + time_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibTimeZone {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtimezoneRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtimezoneRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(identifier?: string): Promise<GLibTimeZone> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (identifier !== undefined) url.searchParams.append('identifier', String(identifier));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_identifier(identifier?: string): Promise<GLibTimeZone> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new_identifier`, apiConfig.baseUrl);
    // Primitive parameter
    if (identifier !== undefined) url.searchParams.append('identifier', String(identifier));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_local(): Promise<GLibTimeZone> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new_local`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_offset(seconds: number): Promise<GLibTimeZone> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_utc(): Promise<GLibTimeZone> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new_utc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async adjust_time(type_: GLibTimeType, time_: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/adjust_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('time_', String(time_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async find_interval(type_: GLibTimeType, time_: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/find_interval`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('time_', String(time_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_abbreviation(interval: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/get_abbreviation`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_identifier(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/get_identifier`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_offset(interval: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/get_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_dst(interval: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/is_dst`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibTimeZone> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTimeZone(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibTimer {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtimerRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtimerRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTimer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimer();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async continue(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/continue`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async elapsed(microseconds: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/elapsed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('microseconds', String(microseconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_active(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reset(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/reset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async start(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async stop(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibTrashStack {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtrashstackRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtrashstackRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTrashStack> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTrashStack();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async height(stack_p: GLibTrashStack): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/height`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async peek(stack_p: GLibTrashStack): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/peek`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async pop(stack_p: GLibTrashStack): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/pop`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async push(stack_p: GLibTrashStack): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibTree {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtreeRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtreeRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_full(key_compare_func: GLibCompareDataFunc, key_destroy_func: GLibDestroyNotify): Promise<GLibTree> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/new_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.key_compare_func !== undefined) {
      callbackDispatcher.set(data.key_compare_func.toString(), key_compare_func);
    }
    if (data.key_destroy_func !== undefined) {
      callbackDispatcher.set(data.key_destroy_func.toString(), key_destroy_func);
    }
    const instance = new GLibTree();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async foreach(func: GLibTraverseFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async foreach_node(func: GLibTraverseNodeFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/foreach_node`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async height(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/height`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async insert(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async insert_node(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/insert_node`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async lookup(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/lookup`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async lookup_extended(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/lookup_extended`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lookup_node(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/lookup_node`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async lower_bound(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/lower_bound`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async nnodes(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/nnodes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async node_first(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/node_first`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async node_last(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/node_last`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ref(): Promise<GLibTree> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTree(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_all(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/remove_all`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace_node(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/replace_node`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async search(search_func: GLibCompareFunc): Promise<{ search_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/search`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.search_func !== undefined) {
      callbackDispatcher.set(data.search_func.toString(), search_func);
    }
    return data;
  }
  async search_node(search_func: GLibCompareFunc): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/search_node`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.search_func !== undefined) {
      callbackDispatcher.set(data.search_func.toString(), search_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async steal(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/steal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async traverse(traverse_type: GLibTraverseType, traverse_func: GLibTraverseFunc): Promise<{ traverse_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/traverse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('traverse_type', String(traverse_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.traverse_func !== undefined) {
      callbackDispatcher.set(data.traverse_func.toString(), traverse_func);
    }
    return data;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async upper_bound(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/upper_bound`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibTreeNode {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtreenodeRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtreenodeRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTreeNode();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async key(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/key`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async next(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async previous(): Promise<GLibTreeNode> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/previous`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTreeNode(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async value(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/value`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibTuples {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtuplesRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtuplesRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTuples> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTuples();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async index(index_: number, field: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/ptr,${this.ptr}/index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    // Primitive parameter
    url.searchParams.append('field', String(field));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GLibUnixPipe {
  ptr!: Pointer;


}
export class GLibUri {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gliburiRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gliburiRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibUri();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_auth_params(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_auth_params`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_flags(): Promise<GLibUriFlags> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_fragment(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_fragment`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_host(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_host`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_password(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_password`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_path(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_port(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_port`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_query`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_scheme(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_scheme`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_user(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_user`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_userinfo(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_userinfo`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_relative(uri_ref: string, flags: GLibUriFlags): Promise<GLibUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/parse_relative`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_string_partial(flags: GLibUriHideFlags): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/to_string_partial`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async build(flags: GLibUriFlags, scheme: string, port: number, path: string, userinfo?: string, host?: string, query?: string, fragment?: string): Promise<GLibUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/build`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async build_with_user(flags: GLibUriFlags, scheme: string, port: number, path: string, user?: string, password?: string, auth_params?: string, host?: string, query?: string, fragment?: string): Promise<GLibUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/build_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (user !== undefined) url.searchParams.append('user', String(user));
    // Primitive parameter
    if (password !== undefined) url.searchParams.append('password', String(password));
    // Primitive parameter
    if (auth_params !== undefined) url.searchParams.append('auth_params', String(auth_params));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async escape_bytes(unescaped: Pointer, length: number, reserved_chars_allowed?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/escape_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    if (reserved_chars_allowed !== undefined) url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async escape_string(unescaped: string, allow_utf8: boolean, reserved_chars_allowed?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/escape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    if (reserved_chars_allowed !== undefined) url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    // Primitive parameter
    url.searchParams.append('allow_utf8', String(allow_utf8));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async is_valid(uri_string: string, flags: GLibUriFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async join(flags: GLibUriFlags, port: number, path: string, scheme?: string, userinfo?: string, host?: string, query?: string, fragment?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/join`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async join_with_user(flags: GLibUriFlags, port: number, path: string, scheme?: string, user?: string, password?: string, auth_params?: string, host?: string, query?: string, fragment?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/join_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (user !== undefined) url.searchParams.append('user', String(user));
    // Primitive parameter
    if (password !== undefined) url.searchParams.append('password', String(password));
    // Primitive parameter
    if (auth_params !== undefined) url.searchParams.append('auth_params', String(auth_params));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async list_extract_uris(uri_list: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/list_extract_uris`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_list', String(uri_list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async parse(uri_string: string, flags: GLibUriFlags): Promise<GLibUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async parse_params(params: string, length: number, separators: string, flags: GLibUriParamsFlags): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/parse_params`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('params', String(params));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('separators', String(separators));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async parse_scheme(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/parse_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async peek_scheme(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/peek_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async resolve_relative(uri_ref: string, flags: GLibUriFlags, base_uri_string?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/resolve_relative`, apiConfig.baseUrl);
    // Primitive parameter
    if (base_uri_string !== undefined) url.searchParams.append('base_uri_string', String(base_uri_string));
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async split(uri_ref: string, flags: GLibUriFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/split`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async split_network(uri_string: string, flags: GLibUriFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/split_network`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async split_with_user(uri_ref: string, flags: GLibUriFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/split_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async unescape_bytes(escaped_string: string, length: number, illegal_characters?: string): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/unescape_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async unescape_segment(escaped_string?: string, escaped_string_end?: string, illegal_characters?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/unescape_segment`, apiConfig.baseUrl);
    // Primitive parameter
    if (escaped_string !== undefined) url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    if (escaped_string_end !== undefined) url.searchParams.append('escaped_string_end', String(escaped_string_end));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async unescape_string(escaped_string: string, illegal_characters?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/unescape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibUriParamsIter {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gliburiparamsiterRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gliburiparamsiterRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibUriParamsIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibUriParamsIter();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async init(params: string, length: number, separators: string, flags: GLibUriParamsFlags): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('params', String(params));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('separators', String(separators));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async next(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibVariant {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibvariantRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibvariantRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_array(n_children: number, child_type?: GLibVariantType, children?: Pointer): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_type !== undefined && typeof child_type === 'object' && 'ptr' in child_type) {
      url.searchParams.append('child_type', 'ptr,' + child_type.ptr);
    }
    // Primitive parameter
    if (children !== undefined) url.searchParams.append('children', String(children));
    // Primitive parameter
    url.searchParams.append('n_children', String(n_children));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_boolean(value_: boolean): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_byte(value_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_byte`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_bytestring(string: Pointer): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_bytestring`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_bytestring_array(strv: Pointer, length: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_bytestring_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_dict_entry(key: GLibVariant, value_: GLibVariant): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_dict_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (key && typeof key === 'object' && 'ptr' in key) {
      url.searchParams.append('key', 'ptr,' + key.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_double(value_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_fixed_array(element_type: GLibVariantType, n_elements: number, element_size: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_fixed_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element_type && typeof element_type === 'object' && 'ptr' in element_type) {
      url.searchParams.append('element_type', 'ptr,' + element_type.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_elements', String(n_elements));
    // Primitive parameter
    url.searchParams.append('element_size', String(element_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_bytes(type_: GLibVariantType, bytes: GLibBytes, trusted: boolean): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_from_bytes`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (bytes && typeof bytes === 'object' && 'ptr' in bytes) {
      url.searchParams.append('bytes', 'ptr,' + bytes.ptr);
    }
    // Primitive parameter
    url.searchParams.append('trusted', String(trusted));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_data(type_: GLibVariantType, data_: Pointer, size: number, trusted: boolean, notify: GLibDestroyNotify): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_from_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('trusted', String(trusted));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.notify !== undefined) {
      callbackDispatcher.set(data.notify.toString(), notify);
    }
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_handle(value_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_handle`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_int16(value_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_int16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_int32(value_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_int32`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_int64(value_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_maybe(child_type?: GLibVariantType, child?: GLibVariant): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_maybe`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_type !== undefined && typeof child_type === 'object' && 'ptr' in child_type) {
      url.searchParams.append('child_type', 'ptr,' + child_type.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (child !== undefined && typeof child === 'object' && 'ptr' in child) {
      url.searchParams.append('child', 'ptr,' + child.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_object_path(object_path: string): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_object_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('object_path', String(object_path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_objv(strv: Pointer, length: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_objv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_signature(signature: string): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_signature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signature', String(signature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_string(string: string): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_strv(strv: Pointer, length: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_strv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_tuple(children: Pointer, n_children: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_tuple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('children', String(children));
    // Primitive parameter
    url.searchParams.append('n_children', String(n_children));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_uint16(value_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_uint16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_uint32(value_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_uint32`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_uint64(value_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_variant(value_: GLibVariant): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_variant`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async byteswap(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/byteswap`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async check_format_string(format_string: string, copy_only: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/check_format_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format_string', String(format_string));
    // Primitive parameter
    url.searchParams.append('copy_only', String(copy_only));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async classify(): Promise<GLibVariantClass> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/classify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async compare(two: GLibVariant): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (two && typeof two === 'object' && 'ptr' in two) {
      url.searchParams.append('two', 'ptr,' + two.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_bytestring(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_bytestring`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_bytestring_array(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_bytestring_array`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_objv(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_objv`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_strv(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_strv`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async equal(two: GLibVariant): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (two && typeof two === 'object' && 'ptr' in two) {
      url.searchParams.append('two', 'ptr,' + two.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boolean(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_byte(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_byte`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bytestring(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_bytestring`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bytestring_array(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_bytestring_array`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_child_value(index_: number): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_child_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_data(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_data_as_bytes(): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_data_as_bytes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_double(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_handle(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_handle`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int16(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_int16`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int32(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_int32`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_maybe(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_maybe`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_normal_form(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_normal_form`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_objv(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_objv`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_strv(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_strv`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_type(): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_type_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_type_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint16(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_uint16`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint32(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_uint32`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_variant(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_variant`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_container(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/is_container`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_floating(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/is_floating`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_normal_form(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/is_normal_form`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_of_type(type_: GLibVariantType): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/is_of_type`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lookup_value(key: string, expected_type?: GLibVariantType): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/lookup_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Object with explode=false: serialize as comma-separated
    if (expected_type !== undefined && typeof expected_type === 'object' && 'ptr' in expected_type) {
      url.searchParams.append('expected_type', 'ptr,' + expected_type.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async n_children(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/n_children`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async print(type_annotate: boolean): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/print`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_annotate', String(type_annotate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ref_sink(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/ref_sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async store(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/store`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async take_ref(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/take_ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async is_object_path(string: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/is_object_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async is_signature(string: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/is_signature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async parse(text: string, type_?: GLibVariantType, limit?: string, endptr?: string): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/parse`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ !== undefined && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    // Primitive parameter
    if (endptr !== undefined) url.searchParams.append('endptr', String(endptr));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async parse_error_print_context(error_: Pointer, source_str: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/parse_error_print_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('source_str', String(source_str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async parse_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/parse_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async parser_get_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/parser_get_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibVariantBuilder {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibvariantbuilderRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibvariantbuilderRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(type_: GLibVariantType): Promise<GLibVariantBuilder> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantBuilder();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_value(value_: GLibVariant): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/add_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async close(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/close`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async end(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/end`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async open(type_: GLibVariantType): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/open`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GLibVariantBuilder> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantBuilder(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibVariantDict {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibvariantdictRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibvariantdictRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(from_asv?: GLibVariant): Promise<GLibVariantDict> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (from_asv !== undefined && typeof from_asv === 'object' && 'ptr' in from_asv) {
      url.searchParams.append('from_asv', 'ptr,' + from_asv.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantDict();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clear(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async contains(key: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async end(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/end`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert_value(key: string, value_: GLibVariant): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/insert_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async lookup_value(key: string, expected_type?: GLibVariantType): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/lookup_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Object with explode=false: serialize as comma-separated
    if (expected_type !== undefined && typeof expected_type === 'object' && 'ptr' in expected_type) {
      url.searchParams.append('expected_type', 'ptr,' + expected_type.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ref(): Promise<GLibVariantDict> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantDict(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove(key: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GLibVariantType {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibvarianttypeRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibvarianttypeRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(type_string: string): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_array(element: GLibVariantType): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_dict_entry(key: GLibVariantType, value_: GLibVariantType): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new_dict_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (key && typeof key === 'object' && 'ptr' in key) {
      url.searchParams.append('key', 'ptr,' + key.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_maybe(element: GLibVariantType): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new_maybe`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_tuple(items: Pointer, length: number): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new_tuple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('items', String(items));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async dup_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/dup_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async element(): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/element`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async equal(type2: GLibVariantType): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type2 && typeof type2 === 'object' && 'ptr' in type2) {
      url.searchParams.append('type2', 'ptr,' + type2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async first(): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/first`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_string_length(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/get_string_length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_array(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_array`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_basic(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_basic`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_container(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_container`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_definite(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_definite`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_dict_entry(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_dict_entry`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_maybe(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_maybe`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subtype_of(supertype: GLibVariantType): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_subtype_of`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (supertype && typeof supertype === 'object' && 'ptr' in supertype) {
      url.searchParams.append('supertype', 'ptr,' + supertype.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_tuple(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_tuple`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_variant(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_variant`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async key(): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/key`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async n_items(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/n_items`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async next(): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async value(): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/value`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async checked_(type_string: string): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/checked_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async string_get_depth_(type_string: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/string_get_depth_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async string_is_valid(type_string: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/string_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async string_scan(string: string, limit?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/string_scan`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GModuleModule {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gmodulemoduleRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gmodulemoduleRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GModuleModule> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GModuleModule();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async close(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/close`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async make_resident(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/make_resident`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async symbol(symbol_name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('symbol_name', String(symbol_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async build_path(module_name: string, directory?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/build_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (directory !== undefined) url.searchParams.append('directory', String(directory));
    // Primitive parameter
    url.searchParams.append('module_name', String(module_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async error(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/error`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async supported(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/supported`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectTypeInstance {
  ptr!: Pointer;


  async get_private(private_type: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInstance/ptr,${this.ptr}/get_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_type', String(private_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GObjectObject extends GObjectTypeInstance {
  constructor(ptr?: string, transfer: boolean = false) {
    super(ptr, transfer);
    if (ptr) {
      this.ptr = ptr;
      objectRegistry.register(this, ptr);
      // If transfer is true, we need to ref the object
      if (transfer) {
        this.ref().catch(() => {});
      }
    }
  }

  async castTo<T extends GObjectObject>(t: T): Promise<T> {
    const type = await t.get_type();
    const is_type = await GObject.type_check_instance_is_a(this, type);
    // Don't set transfer=true here as it would cause ref() to be called in constructor
    // The object is already referenced properly
    const instance = new t(this.ptr, false);
    return instance;
  }
  
  // Manual cleanup method
  unref(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    return fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + this.ptr + '/unref')
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async newv(object_type: string, n_parameters: number, parameters: Pointer): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/newv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('object_type', String(object_type));
    // Primitive parameter
    url.searchParams.append('n_parameters', String(n_parameters));
    // Primitive parameter
    url.searchParams.append('parameters', String(parameters));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectObject();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async compat_control(what: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/compat_control`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('what', String(what));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async interface_find_property(g_iface: GObjectTypeInterface, property_name: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/interface_find_property`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async interface_install_property(g_iface: GObjectTypeInterface, pspec: GObjectParamSpec): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/interface_install_property`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async interface_list_properties(g_iface: GObjectTypeInterface): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/interface_list_properties`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async bind_property(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlagsValue): Promise<GObjectBinding> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/bind_property`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectBinding(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async bind_property_full(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlagsValue, transform_to: GObjectClosure, transform_from: GObjectClosure): Promise<GObjectBinding> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/bind_property_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Object with explode=false: serialize as comma-separated
    if (transform_to && typeof transform_to === 'object' && 'ptr' in transform_to) {
      url.searchParams.append('transform_to', 'ptr,' + transform_to.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (transform_from && typeof transform_from === 'object' && 'ptr' in transform_from) {
      url.searchParams.append('transform_from', 'ptr,' + transform_from.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectBinding(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async force_floating(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/force_floating`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async freeze_notify(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/freeze_notify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_data(key: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/get_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_property(property_name: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/get_property`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_qdata(quark: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async getv(n_properties: number, names: Pointer, values: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/getv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_properties', String(n_properties));
    // Primitive parameter
    url.searchParams.append('names', String(names));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_floating(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/is_floating`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async notify(property_name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/notify`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async notify_by_pspec(pspec: GObjectParamSpec): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/notify_by_pspec`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    // ref() should not create a new instance - it just increments the reference count
    // and returns the same object (this) to avoid infinite recursion
    return this;
  }
  async ref_sink(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/ref_sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    // ref_sink() should not create a new instance - it just sinks the floating reference
    // and returns the same object (this) to avoid infinite recursion
    return this;
  }
  async run_dispose(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/run_dispose`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_data(key: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/set_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_property(property_name: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/set_property`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_data(key: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/steal_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_qdata(quark: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async thaw_notify(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/thaw_notify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async watch_closure(closure: GObjectClosure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/watch_closure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectBinding extends GObjectObject {

  async dup_source(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/dup_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectObject(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async dup_target(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/dup_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectObject(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_flags(): Promise<GObjectBindingFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_source(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectObject(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_source_property(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_source_property`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_target(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectObject(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_target_property(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_target_property`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unbind(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/unbind`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectBindingGroup extends GObjectObject {
  static async new(): Promise<GObjectBindingGroup> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectBindingGroup();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async bind(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/ptr,${this.ptr}/bind`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async bind_full(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlagsValue, transform_to?: GObjectClosure, transform_from?: GObjectClosure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/ptr,${this.ptr}/bind_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Object with explode=false: serialize as comma-separated
    if (transform_to !== undefined && typeof transform_to === 'object' && 'ptr' in transform_to) {
      url.searchParams.append('transform_to', 'ptr,' + transform_to.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (transform_from !== undefined && typeof transform_from === 'object' && 'ptr' in transform_from) {
      url.searchParams.append('transform_from', 'ptr,' + transform_from.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async dup_source(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/ptr,${this.ptr}/dup_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectObject(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async set_source(source?: GObjectObject): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/ptr,${this.ptr}/set_source`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (source !== undefined && typeof source === 'object' && 'ptr' in source) {
      url.searchParams.append('source', 'ptr,' + source.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectCClosure {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjectcclosureRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjectcclosureRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GObjectCClosure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectCClosure();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async marshal_BOOLEAN__BOXED_BOXED(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_BOOLEAN__BOXED_BOXED`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_BOOLEAN__FLAGS(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_BOOLEAN__FLAGS`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_STRING__OBJECT_POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_STRING__OBJECT_POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__BOOLEAN(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__BOOLEAN`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__BOXED(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__BOXED`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__CHAR(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__CHAR`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__DOUBLE(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__DOUBLE`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__ENUM(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__ENUM`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__FLAGS(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__FLAGS`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__FLOAT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__FLOAT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__INT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__INT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__LONG(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__LONG`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__OBJECT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__OBJECT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__PARAM(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__PARAM`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__STRING(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__STRING`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__UCHAR(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__UCHAR`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__UINT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__UINT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__UINT_POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__UINT_POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__ULONG(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__ULONG`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__VARIANT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__VARIANT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_VOID__VOID(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__VOID`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async marshal_generic(closure: GObjectClosure, return_gvalue: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_generic`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_gvalue && typeof return_gvalue === 'object' && 'ptr' in return_gvalue) {
      url.searchParams.append('return_gvalue', 'ptr,' + return_gvalue.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GObjectClosure {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjectclosureRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjectclosureRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_object(sizeof_closure: number, object: GObjectObject): Promise<GObjectClosure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/new_object`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('sizeof_closure', String(sizeof_closure));
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectClosure();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_simple(sizeof_closure: number): Promise<GObjectClosure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/new_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('sizeof_closure', String(sizeof_closure));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectClosure();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async invalidate(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/invalidate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async invoke(return_value: GObjectValue, n_param_values: number, param_values: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/invoke`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Primitive parameter
    url.searchParams.append('param_values', String(param_values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GObjectClosure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectClosure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async sink(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectClosureNotifyData {
  ptr!: Pointer;


}
export class GObjectEnumClass {
  ptr!: Pointer;


}
export class GObjectEnumValue {
  ptr!: Pointer;


}
export class GObjectFlagsClass {
  ptr!: Pointer;


}
export class GObjectFlagsValue {
  ptr!: Pointer;


}
export class GObjectInitiallyUnowned extends GObjectObject {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/InitiallyUnowned/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectInterfaceInfo {
  ptr!: Pointer;


}
export class GObjectObjectConstructParam {
  ptr!: Pointer;


}
export class GObjectParamSpec {
  ptr!: Pointer;


  static async is_valid_name(name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/is_valid_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_blurb(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_blurb`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_default_value(): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_default_value`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_name_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_nick(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_nick`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_qdata(quark: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_redirect_target(): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_redirect_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_qdata(quark: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/set_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sink(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_qdata(quark: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecBoolean extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecBoolean/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecBoxed extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecBoxed/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecChar extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecChar/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecDouble extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecDouble/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecEnum extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecEnum/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecFlags extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecFlags/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecFloat extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecFloat/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecGType extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecGType/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecInt extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecInt/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecInt64 extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecInt64/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecLong extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecLong/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecObject extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecObject/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecOverride extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecOverride/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecParam extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecParam/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecPointer extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPointer/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecPool {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjectparamspecpoolRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjectparamspecpoolRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GObjectParamSpecPool> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectParamSpecPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async insert(pspec: GObjectParamSpec, owner_type: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Primitive parameter
    url.searchParams.append('owner_type', String(owner_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async list(owner_type: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('owner_type', String(owner_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_owned(owner_type: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/list_owned`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('owner_type', String(owner_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lookup(param_name: string, owner_type: string, walk_ancestors: boolean): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('param_name', String(param_name));
    // Primitive parameter
    url.searchParams.append('owner_type', String(owner_type));
    // Primitive parameter
    url.searchParams.append('walk_ancestors', String(walk_ancestors));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove(pspec: GObjectParamSpec): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GObjectParamSpecString extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecString/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecTypeInfo {
  ptr!: Pointer;


}
export class GObjectParamSpecUChar extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecUChar/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecUInt extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecUInt/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecUInt64 extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecUInt64/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecULong extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecULong/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecUnichar extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecUnichar/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecValueArray extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecValueArray/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParamSpecVariant extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecVariant/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectParameter {
  ptr!: Pointer;


}
export class GObjectSignalGroup extends GObjectObject {
  static async new(target_type: string): Promise<GObjectSignalGroup> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('target_type', String(target_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectSignalGroup();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async block(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/block`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async connect_closure(detailed_signal: string, closure: GObjectClosure, after: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/connect_closure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    url.searchParams.append('after', String(after));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async connect_data(detailed_signal: string, flags: GObjectConnectFlags, c_handler: GObjectCallback): Promise<{ c_handler?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/connect_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.c_handler !== undefined) {
      callbackDispatcher.set(data.c_handler.toString(), c_handler);
    }
    return data;
  }
  async connect_swapped(detailed_signal: string, c_handler: GObjectCallback): Promise<{ c_handler?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/connect_swapped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.c_handler !== undefined) {
      callbackDispatcher.set(data.c_handler.toString(), c_handler);
    }
    return data;
  }
  async dup_target(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/dup_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectObject(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async set_target(target?: GObjectObject): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/set_target`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (target !== undefined && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unblock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/unblock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectSignalInvocationHint {
  ptr!: Pointer;


}
export class GObjectSignalQuery {
  ptr!: Pointer;


}
export class GObjectTypeClass {
  ptr!: Pointer;


  async add_private(private_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ptr,${this.ptr}/add_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_size', String(private_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_private(private_type: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ptr,${this.ptr}/get_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_type', String(private_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async peek_parent(): Promise<GObjectTypeClass> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ptr,${this.ptr}/peek_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async adjust_private_offset(private_size_or_offset: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/adjust_private_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_size_or_offset', String(private_size_or_offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async peek(type_: string): Promise<GObjectTypeClass> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async peek_static(type_: string): Promise<GObjectTypeClass> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/peek_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async ref(type_: string): Promise<GObjectTypeClass> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GObjectTypeFundamentalInfo {
  ptr!: Pointer;


}
export class GObjectTypeInfo {
  ptr!: Pointer;


}
export class GObjectTypeInterface {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjecttypeinterfaceRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjecttypeinterfaceRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GObjectTypeInterface> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectTypeInterface();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async peek_parent(): Promise<GObjectTypeInterface> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/ptr,${this.ptr}/peek_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeInterface(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async add_prerequisite(interface_type: string, prerequisite_type: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/add_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Primitive parameter
    url.searchParams.append('prerequisite_type', String(prerequisite_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_plugin(instance_type: string, interface_type: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/get_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async instantiatable_prerequisite(interface_type: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/instantiatable_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async peek(instance_class: GObjectTypeClass, iface_type: string): Promise<GObjectTypeInterface> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/peek`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance_class && typeof instance_class === 'object' && 'ptr' in instance_class) {
      url.searchParams.append('instance_class', 'ptr,' + instance_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('iface_type', String(iface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeInterface(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async prerequisites(interface_type: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/prerequisites`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectTypeModule extends GObjectObject {

  async add_interface(instance_type: string, interface_type: string, interface_info: GObjectInterfaceInfo): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/add_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Object with explode=false: serialize as comma-separated
    if (interface_info && typeof interface_info === 'object' && 'ptr' in interface_info) {
      url.searchParams.append('interface_info', 'ptr,' + interface_info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async register_enum(name: string, const_static_values: GObjectEnumValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/register_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (const_static_values && typeof const_static_values === 'object' && 'ptr' in const_static_values) {
      url.searchParams.append('const_static_values', 'ptr,' + const_static_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async register_flags(name: string, const_static_values: GObjectFlagsValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/register_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (const_static_values && typeof const_static_values === 'object' && 'ptr' in const_static_values) {
      url.searchParams.append('const_static_values', 'ptr,' + const_static_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async register_type(parent_type: string, type_name: string, type_info: GObjectTypeInfo, flags: GObjectTypeFlags): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/register_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('parent_type', String(parent_type));
    // Primitive parameter
    url.searchParams.append('type_name', String(type_name));
    // Object with explode=false: serialize as comma-separated
    if (type_info && typeof type_info === 'object' && 'ptr' in type_info) {
      url.searchParams.append('type_info', 'ptr,' + type_info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_name(name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unuse(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/unuse`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async use(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/use`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectTypePluginClass {
  ptr!: Pointer;


}
export class GObjectTypeQuery {
  ptr!: Pointer;


}
export class GObjectTypeValueTable {
  ptr!: Pointer;


}
export class GObjectValue {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjectvalueRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjectvalueRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectValue();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(dest_value: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest_value && typeof dest_value === 'object' && 'ptr' in dest_value) {
      url.searchParams.append('dest_value', 'ptr,' + dest_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async dup_object(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/dup_object`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectObject(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async dup_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/dup_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_variant(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/dup_variant`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async fits_pointer(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/fits_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boolean(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boxed(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_boxed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_char(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_char`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_enum(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_enum`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_flags(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_float(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_float`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_gtype(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_gtype`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_int`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_long(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_long`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_object(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_object`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GObjectObject(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_param(): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_param`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_pointer(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_schar(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_schar`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uchar(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_uchar`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_uint`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_ulong(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_ulong`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_variant(): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_variant`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async init(g_type: string): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_type', String(g_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async init_from_instance(instance: GObjectTypeInstance): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/init_from_instance`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async peek_pointer(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/peek_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async reset(): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/reset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_boolean(v_boolean: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_boolean', String(v_boolean));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_boxed(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_boxed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_boxed_take_ownership(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_boxed_take_ownership`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_char(v_char: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_char', String(v_char));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_double(v_double: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_double', String(v_double));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_enum(v_enum: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_enum', String(v_enum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_flags(v_flags: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_flags', String(v_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_float(v_float: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_float`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_float', String(v_float));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_gtype(v_gtype: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_gtype`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_gtype', String(v_gtype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_instance(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_instance`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_int(v_int: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_int', String(v_int));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_int64(v_int64: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_int64', String(v_int64));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_interned_string(v_string?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_interned_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_long(v_long: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_long`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_long', String(v_long));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_object(v_object?: GObjectObject): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_object`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (v_object !== undefined && typeof v_object === 'object' && 'ptr' in v_object) {
      url.searchParams.append('v_object', 'ptr,' + v_object.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_param(param?: GObjectParamSpec): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_param`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (param !== undefined && typeof param === 'object' && 'ptr' in param) {
      url.searchParams.append('param', 'ptr,' + param.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_pointer(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_schar(v_char: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_schar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_char', String(v_char));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_static_boxed(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_static_boxed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_static_string(v_string?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_static_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_string(v_string?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_string_take_ownership(v_string?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_string_take_ownership`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uchar(v_uchar: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_uchar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_uchar', String(v_uchar));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uint(v_uint: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_uint', String(v_uint));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uint64(v_uint64: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_uint64', String(v_uint64));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_ulong(v_ulong: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_ulong`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_ulong', String(v_ulong));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_variant(variant?: GLibVariant): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_variant`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (variant !== undefined && typeof variant === 'object' && 'ptr' in variant) {
      url.searchParams.append('variant', 'ptr,' + variant.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/steal_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async take_boxed(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/take_boxed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async take_string(v_string?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/take_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async take_variant(variant?: GLibVariant): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/take_variant`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (variant !== undefined && typeof variant === 'object' && 'ptr' in variant) {
      url.searchParams.append('variant', 'ptr,' + variant.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async transform(dest_value: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/transform`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest_value && typeof dest_value === 'object' && 'ptr' in dest_value) {
      url.searchParams.append('dest_value', 'ptr,' + dest_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unset(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/unset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async type_compatible(src_type: string, dest_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/type_compatible`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async type_transformable(src_type: string, dest_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/type_transformable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectValueArray {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjectvaluearrayRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjectvaluearrayRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(n_prealloced: number): Promise<GObjectValueArray> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_prealloced', String(n_prealloced));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectValueArray();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append(value_?: GObjectValue): Promise<GObjectValueArray> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ !== undefined && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy(): Promise<GObjectValueArray> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_nth(index_: number): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/get_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert(index_: number, value_?: GObjectValue): Promise<GObjectValueArray> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    // Object with explode=false: serialize as comma-separated
    if (value_ !== undefined && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend(value_?: GObjectValue): Promise<GObjectValueArray> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/prepend`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ !== undefined && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove(index_: number): Promise<GObjectValueArray> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async sort(compare_func: GLibCompareDataFunc): Promise<GObjectValueArray> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/sort`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.compare_func !== undefined) {
      callbackDispatcher.set(data.compare_func.toString(), compare_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GObjectWeakRef {
  ptr!: Pointer;


}
export class GstAllocationParams {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstallocationparamsRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstallocationparamsRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstAllocationParams> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstAllocationParams();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GstAllocationParams> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstAllocationParams(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async init(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstObject extends GObjectInitiallyUnowned {

  static async check_uniqueness(list: Pointer, name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/check_uniqueness`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async default_deep_notify(object: GObjectObject, orig: GstObject, pspec: GObjectParamSpec, excluded_props?: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/default_deep_notify`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (orig && typeof orig === 'object' && 'ptr' in orig) {
      url.searchParams.append('orig', 'ptr,' + orig.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Primitive parameter
    if (excluded_props !== undefined) url.searchParams.append('excluded_props', String(excluded_props));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async replace(oldobj?: GstObject, newobj?: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + oldobj.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/replace`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (oldobj !== undefined && typeof oldobj === 'object' && 'ptr' in oldobj) {
      url.searchParams.append('oldobj', 'ptr,' + oldobj.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newobj !== undefined && typeof newobj === 'object' && 'ptr' in newobj) {
      url.searchParams.append('newobj', 'ptr,' + newobj.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + oldobj.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + oldobj.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async add_control_binding(binding: GstControlBinding): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/add_control_binding`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (binding && typeof binding === 'object' && 'ptr' in binding) {
      url.searchParams.append('binding', 'ptr,' + binding.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async default_error(error_: Pointer, debug?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/default_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_control_binding(property_name: string): Promise<GstControlBinding> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_control_binding`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstControlBinding(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_control_rate(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_control_rate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_g_value_array(property_name: string, timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_g_value_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_parent(): Promise<GstObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstObject(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_path_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_path_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(property_name: string, timestamp: number): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_active_control_bindings(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/has_active_control_bindings`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_ancestor(ancestor: GstObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/has_ancestor`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ancestor && typeof ancestor === 'object' && 'ptr' in ancestor) {
      url.searchParams.append('ancestor', 'ptr,' + ancestor.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_as_ancestor(ancestor: GstObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/has_as_ancestor`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ancestor && typeof ancestor === 'object' && 'ptr' in ancestor) {
      url.searchParams.append('ancestor', 'ptr,' + ancestor.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_as_parent(parent: GstObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/has_as_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref_2(): Promise<GstObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstObject(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async remove_control_binding(binding: GstControlBinding): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/remove_control_binding`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (binding && typeof binding === 'object' && 'ptr' in binding) {
      url.searchParams.append('binding', 'ptr,' + binding.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_control_binding_disabled(property_name: string, disabled: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_control_binding_disabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('disabled', String(disabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_control_bindings_disabled(disabled: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_control_bindings_disabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('disabled', String(disabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_control_rate(control_rate: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_control_rate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('control_rate', String(control_rate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_name(name?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_parent(parent: GstObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async suggest_next_sync(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/suggest_next_sync`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async sync_values(timestamp: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/sync_values`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unparent(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/unparent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstAllocator extends GstObject {

  static async find(name?: string): Promise<GstAllocator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/find`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstAllocator(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  static async register(name: string, allocator: GstAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async alloc(size: number, params?: GstAllocationParams): Promise<GstMemory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/ptr,${this.ptr}/alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async free(memory: GstMemory): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (memory && typeof memory === 'object' && 'ptr' in memory) {
      url.searchParams.append('memory', 'ptr,' + memory.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_default(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/ptr,${this.ptr}/set_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstAllocatorPrivate {
  ptr!: Pointer;


}
export class GstAtomicQueue {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstatomicqueueRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstatomicqueueRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(initial_size: number): Promise<GstAtomicQueue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('initial_size', String(initial_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstAtomicQueue();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async length(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/peek`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async pop(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstElement extends GstObject {

  static async make_from_uri(type_: GstURITypeValue, uri: string, elementname?: string): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/make_from_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    if (elementname !== undefined) url.searchParams.append('elementname', String(elementname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  static async register(name: string, rank: number, type_: string, plugin?: GstPlugin): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async state_change_return_get_name(state_ret: GstStateChangeReturnValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/state_change_return_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state_ret', String(state_ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async state_get_name(state: GstStateValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/state_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async type_set_skip_documentation(type_: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/type_set_skip_documentation`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async abort_state(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/abort_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_pad(pad: GstPad): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/add_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_property_deep_notify_watch(include_value: boolean, property_name?: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/add_property_deep_notify_watch`, apiConfig.baseUrl);
    // Primitive parameter
    if (property_name !== undefined) url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('include_value', String(include_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_property_notify_watch(include_value: boolean, property_name?: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/add_property_notify_watch`, apiConfig.baseUrl);
    // Primitive parameter
    if (property_name !== undefined) url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('include_value', String(include_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async call_async(func: GstElementCallAsyncFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/call_async`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async change_state(transition: GstStateChangeValue): Promise<GstStateChangeReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/change_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('transition', String(transition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async continue_state(ret: GstStateChangeReturnValue): Promise<GstStateChangeReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/continue_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_all_pads(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/create_all_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async decorate_stream_id(stream_id: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/decorate_stream_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stream_id', String(stream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async foreach_pad(func: GstElementForeachPadFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/foreach_pad`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async foreach_sink_pad(func: GstElementForeachPadFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/foreach_sink_pad`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async foreach_src_pad(func: GstElementForeachPadFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/foreach_src_pad`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get_base_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_base_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstBus(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_clock(): Promise<GstClock> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstClock(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_compatible_pad(pad: GstPad, caps?: GstCaps): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_compatible_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_compatible_pad_template(compattempl: GstPadTemplate): Promise<GstPadTemplate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_compatible_pad_template`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (compattempl && typeof compattempl === 'object' && 'ptr' in compattempl) {
      url.searchParams.append('compattempl', 'ptr,' + compattempl.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPadTemplate(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_context(context_type: string): Promise<GstContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_context_unlocked(context_type: string): Promise<GstContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_context_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_contexts(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_contexts`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_current_clock_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_current_clock_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_current_running_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_current_running_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_factory(): Promise<GstElementFactory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_factory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElementFactory(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pad_template(name: string): Promise<GstPadTemplate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_pad_template`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPadTemplate(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_pad_template_list(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_pad_template_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_request_pad(name: string): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_request_pad`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_start_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_start_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_state(state: GstStateValue, pending: GstStateValue, timeout: number): Promise<GstStateChangeReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    // Primitive parameter
    url.searchParams.append('pending', String(pending));
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_static_pad(name: string): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_static_pad`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async is_locked_state(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/is_locked_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_pads(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/iterate_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_sink_pads(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/iterate_sink_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_src_pads(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/iterate_src_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async link(dest: GstElement): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_filtered(dest: GstElement, filter?: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link_filtered`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_pads(dest: GstElement, srcpadname?: string, destpadname?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link_pads`, apiConfig.baseUrl);
    // Primitive parameter
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_pads_filtered(dest: GstElement, srcpadname?: string, destpadname?: string, filter?: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link_pads_filtered`, apiConfig.baseUrl);
    // Primitive parameter
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_pads_full(dest: GstElement, flags: GstPadLinkCheckValue, srcpadname?: string, destpadname?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link_pads_full`, apiConfig.baseUrl);
    // Primitive parameter
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lost_state(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/lost_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async message_full(type_: GstMessageTypeValue, domain: number, code: number, file: string, function_: string, line: number, text?: string, debug?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/message_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    if (text !== undefined) url.searchParams.append('text', String(text));
    // Primitive parameter
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async message_full_with_details(type_: GstMessageTypeValue, domain: number, code: number, file: string, function_: string, line: number, structure: GstStructure, text?: string, debug?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/message_full_with_details`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    if (text !== undefined) url.searchParams.append('text', String(text));
    // Primitive parameter
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async no_more_pads(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/no_more_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async post_message(message: GstMessage): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/post_message`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async provide_clock(): Promise<GstClock> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/provide_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstClock(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async query(query: GstQuery): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/query`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/query_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_val', String(src_val));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_duration(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/query_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_position(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/query_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async release_request_pad(pad: GstPad): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/release_request_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_pad(pad: GstPad): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/remove_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_property_notify_watch(watch_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/remove_property_notify_watch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('watch_id', String(watch_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async request_pad(templ: GstPadTemplate, name?: string, caps?: GstCaps): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/request_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async request_pad_simple(name: string): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/request_pad_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async seek(rate: number, format: GstFormatValue, flags: GstSeekFlagsValue, start_type: GstSeekTypeValue, start: number, stop_type: GstSeekTypeValue, stop: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async seek_simple(format: GstFormatValue, seek_flags: GstSeekFlagsValue, seek_pos: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/seek_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('seek_flags', String(seek_flags));
    // Primitive parameter
    url.searchParams.append('seek_pos', String(seek_pos));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async send_event(event: GstEvent): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/send_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_base_time(time: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_base_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_bus(bus?: GstBus): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_bus`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bus !== undefined && typeof bus === 'object' && 'ptr' in bus) {
      url.searchParams.append('bus', 'ptr,' + bus.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_clock(clock?: GstClock): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock !== undefined && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_context(context: GstContext): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_locked_state(locked_state: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_locked_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('locked_state', String(locked_state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_start_time(time: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_start_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_state(state: GstStateValue): Promise<GstStateChangeReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async sync_state_with_parent(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/sync_state_with_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unlink(dest: GstElement): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/unlink`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unlink_pads(srcpadname: string, dest: GstElement, destpadname: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/unlink_pads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    url.searchParams.append('destpadname', String(destpadname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstBin extends GstElement {
  static async new(name?: string): Promise<GstBin> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBin();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(element: GstElement): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async find_unlinked_pad(direction: GstPadDirectionValue): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/find_unlinked_pad`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_by_interface(iface: string): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/get_by_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iface', String(iface));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_by_name(name: string): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/get_by_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_by_name_recurse_up(name: string): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/get_by_name_recurse_up`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_suppressed_flags(): Promise<GstElementFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/get_suppressed_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_all_by_element_factory_name(factory_name: string): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_all_by_element_factory_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factory_name', String(factory_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_all_by_interface(iface: string): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_all_by_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iface', String(iface));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_elements(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_elements`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_recurse(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_recurse`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_sinks(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_sinks`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_sorted(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_sorted`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_sources(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_sources`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async recalculate_latency(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/recalculate_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove(element: GstElement): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_suppressed_flags(flags: GstElementFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/set_suppressed_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sync_children_states(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/sync_children_states`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstBinPrivate {
  ptr!: Pointer;


}
export class GstBitmask {
  ptr!: Pointer;


  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bitmask/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstBuffer {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstbufferRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstbufferRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_allocate(size: number, allocator?: GstAllocator, params?: GstAllocationParams): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_allocate`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_memdup(data_: Pointer, size: number): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_memdup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_wrapped(data_: Pointer, size: number): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_wrapped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_wrapped_bytes(bytes: GLibBytes): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_wrapped_bytes`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes && typeof bytes === 'object' && 'ptr' in bytes) {
      url.searchParams.append('bytes', 'ptr,' + bytes.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_wrapped_full(flags: GstMemoryFlagsValue, data_: Pointer, maxsize: number, offset: number, size: number, notify: GLibDestroyNotify): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_wrapped_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.notify !== undefined) {
      callbackDispatcher.set(data.notify.toString(), notify);
    }
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_custom_meta(name: string): Promise<GstCustomMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_custom_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCustomMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_meta(info: GstMetaInfo): Promise<GstMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_parent_buffer_meta(ref: GstBuffer): Promise<GstParentBufferMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_parent_buffer_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ref && typeof ref === 'object' && 'ptr' in ref) {
      url.searchParams.append('ref', 'ptr,' + ref.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstParentBufferMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_protection_meta(info: GstStructure): Promise<GstProtectionMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_protection_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstProtectionMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_reference_timestamp_meta(reference: GstCaps, timestamp: number, duration: number): Promise<GstReferenceTimestampMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_reference_timestamp_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (reference && typeof reference === 'object' && 'ptr' in reference) {
      url.searchParams.append('reference', 'ptr,' + reference.ptr);
    }
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstReferenceTimestampMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async append(buf2: GstBuffer): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buf2 && typeof buf2 === 'object' && 'ptr' in buf2) {
      url.searchParams.append('buf2', 'ptr,' + buf2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async append_memory(mem: GstMemory): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/append_memory`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async append_region(buf2: GstBuffer, offset: number, size: number): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/append_region`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buf2 && typeof buf2 === 'object' && 'ptr' in buf2) {
      url.searchParams.append('buf2', 'ptr,' + buf2.ptr);
    }
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy_deep(): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/copy_deep`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy_into(src: GstBuffer, flags: GstBufferCopyFlagsValue, offset: number, size: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/copy_into`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy_region(flags: GstBufferCopyFlagsValue, offset: number, size: number): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/copy_region`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async extract(offset: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/extract`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async extract_dup(offset: number, size: number): Promise<{ dest?: Pointer; dest_size?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/extract_dup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async fill(offset: number, src: Pointer, size: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fill`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async find_memory(offset: number, size: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/find_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async foreach_meta(func: GstBufferForeachMetaFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/foreach_meta`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get_all_memory(): Promise<GstMemory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_all_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_custom_meta(name: string): Promise<GstCustomMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_custom_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCustomMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_flags(): Promise<GstBufferFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_memory(idx: number): Promise<GstMemory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_memory_range(idx: number, length: number): Promise<GstMemory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_memory_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_meta(api: string): Promise<GstMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_n_meta(api_type: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_n_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api_type', String(api_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_reference_timestamp_meta(reference?: GstCaps): Promise<GstReferenceTimestampMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_reference_timestamp_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (reference !== undefined && typeof reference === 'object' && 'ptr' in reference) {
      url.searchParams.append('reference', 'ptr,' + reference.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstReferenceTimestampMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sizes(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_sizes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sizes_range(idx: number, length: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_sizes_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_flags(flags: GstBufferFlagsValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/has_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async insert_memory(idx: number, mem: GstMemory): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/insert_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_all_memory_writable(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/is_all_memory_writable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_memory_range_writable(idx: number, length: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/is_memory_range_writable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async map(info: GstMapInfo, flags: GstMapFlagsValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/map`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async map_range(idx: number, length: number, info: GstMapInfo, flags: GstMapFlagsValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/map_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async memcmp(offset: number, mem: Pointer, size: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/memcmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async memset(offset: number, val: number, size: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/memset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async n_memory(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/n_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek_memory(idx: number): Promise<GstMemory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/peek_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend_memory(mem: GstMemory): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/prepend_memory`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_all_memory(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/remove_all_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_memory(idx: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/remove_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_memory_range(idx: number, length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/remove_memory_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_meta(meta: GstMeta): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/remove_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (meta && typeof meta === 'object' && 'ptr' in meta) {
      url.searchParams.append('meta', 'ptr,' + meta.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async replace_all_memory(mem: GstMemory): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/replace_all_memory`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace_memory(idx: number, mem: GstMemory): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/replace_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace_memory_range(idx: number, length: number, mem: GstMemory): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/replace_memory_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async resize(offset: number, size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/resize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async resize_range(idx: number, length: number, offset: number, size: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/resize_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flags(flags: GstBufferFlagsValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/set_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_size(size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/set_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unmap(info: GstMapInfo): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/unmap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unset_flags(flags: GstBufferFlagsValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/unset_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_max_memory(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/get_max_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstBufferList {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstbufferlistRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstbufferlistRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstBufferList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBufferList();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_sized(size: number): Promise<GstBufferList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/new_sized`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBufferList();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async calculate_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/calculate_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy_deep(): Promise<GstBufferList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/copy_deep`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBufferList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async foreach(func: GstBufferListFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get(idx: number): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_writable(idx: number): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/get_writable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert(idx: number, buffer: GstBuffer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async length(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove(idx: number, length: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstBufferPool extends GstObject {
  static async new(): Promise<GstBufferPool> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBufferPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async config_add_option(config: GstStructure, option: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_add_option`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Primitive parameter
    url.searchParams.append('option', String(option));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async config_get_allocator(config: GstStructure, params: GstAllocationParams, allocator?: GstAllocator): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_get_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async config_get_option(config: GstStructure, index: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_get_option`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async config_get_params(config: GstStructure, caps?: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_get_params`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async config_has_option(config: GstStructure, option: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_has_option`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Primitive parameter
    url.searchParams.append('option', String(option));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async config_n_options(config: GstStructure): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_n_options`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async config_set_allocator(config: GstStructure, allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_set_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async config_set_params(config: GstStructure, size: number, min_buffers: number, max_buffers: number, caps?: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_set_params`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async config_validate_params(config: GstStructure, size: number, min_buffers: number, max_buffers: number, caps?: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_validate_params`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async acquire_buffer(buffer?: GstBuffer, params?: GstBufferPoolAcquireParams): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/acquire_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer !== undefined && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_config(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/get_config`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_options(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/get_options`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_option(option: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/has_option`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('option', String(option));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_active(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async release_buffer(buffer: GstBuffer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/release_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_active(active: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/set_active`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_config(config: GstStructure): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/set_config`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flushing(flushing: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/set_flushing`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flushing', String(flushing));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstBufferPoolAcquireParams {
  ptr!: Pointer;


}
export class GstBufferPoolPrivate {
  ptr!: Pointer;


}
export class GstBus extends GstObject {
  static async new(): Promise<GstBus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBus();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_signal_watch(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/add_signal_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_signal_watch_full(priority: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/add_signal_watch_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_watch(priority: number, func: GstBusFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/add_watch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async async_signal_func(message: GstMessage): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/async_signal_func`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_watch(): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/create_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async disable_sync_message_emission(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/disable_sync_message_emission`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async enable_sync_message_emission(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/enable_sync_message_emission`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_pollfd(fd: GLibPollFD): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/get_pollfd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async have_pending(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/have_pending`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek(): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/peek`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async poll(events: GstMessageTypeValue, timeout: number): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/poll`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('events', String(events));
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async pop(): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async pop_filtered(types: GstMessageTypeValue): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/pop_filtered`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('types', String(types));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async post(message: GstMessage): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/post`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_signal_watch(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/remove_signal_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_watch(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/remove_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flushing(flushing: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/set_flushing`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flushing', String(flushing));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_sync_handler(func: GstBusSyncHandler): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/set_sync_handler`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async sync_signal_handler(message: GstMessage): Promise<GstBusSyncReplyValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/sync_signal_handler`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async timed_pop(timeout: number): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/timed_pop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async timed_pop_filtered(timeout: number, types: GstMessageTypeValue): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/timed_pop_filtered`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    // Primitive parameter
    url.searchParams.append('types', String(types));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstBusPrivate {
  ptr!: Pointer;


}
export class GstByteArrayInterface {
  ptr!: Pointer;


}
export class GstCaps {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstcapsRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstcapsRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_any(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/new_any`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCaps();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_empty(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/new_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCaps();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_empty_simple(media_type: string): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/new_empty_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('media_type', String(media_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCaps();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append(caps2: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async append_structure(structure: GstStructure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/append_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async append_structure_full(structure: GstStructure, features?: GstCapsFeatures): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/append_structure_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async can_intersect(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/can_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy_nth(nth: number): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/copy_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nth', String(nth));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async filter_and_map_in_place(func: GstCapsFilterMapFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/filter_and_map_in_place`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async fixate(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/fixate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async foreach(func: GstCapsForeachFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get_features(index: number): Promise<GstCapsFeatures> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/get_features`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_structure(index: number): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async intersect(caps2: GstCaps): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async intersect_full(caps2: GstCaps, mode: GstCapsIntersectModeValue): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/intersect_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_always_compatible(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_always_compatible`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_any(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_any`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_empty(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_equal(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_equal_fixed(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_equal_fixed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_fixed(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_fixed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_strictly_equal(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_strictly_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subset(superset: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_subset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (superset && typeof superset === 'object' && 'ptr' in superset) {
      url.searchParams.append('superset', 'ptr,' + superset.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subset_structure(structure: GstStructure): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_subset_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subset_structure_full(structure: GstStructure, features?: GstCapsFeatures): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_subset_structure_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async map_in_place(func: GstCapsMapFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/map_in_place`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async merge(caps2: GstCaps): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/merge`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async merge_structure(structure: GstStructure): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/merge_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async merge_structure_full(structure: GstStructure, features?: GstCapsFeatures): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/merge_structure_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async normalize(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/normalize`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove_structure(idx: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/remove_structure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async serialize(flags: GstSerializeFlagsValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/serialize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_features(index: number, features?: GstCapsFeatures): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/set_features`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_features_simple(features?: GstCapsFeatures): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/set_features_simple`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_value(field: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async simplify(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/simplify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async steal_structure(index: number): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/steal_structure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async subtract(subtrahend: GstCaps): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async truncate(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/truncate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async from_string(string: string): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstCapsFeatures {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstcapsfeaturesRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstcapsfeaturesRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_any(): Promise<GstCapsFeatures> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/new_any`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCapsFeatures();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_empty(): Promise<GstCapsFeatures> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/new_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCapsFeatures();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_single(feature: string): Promise<GstCapsFeatures> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/new_single`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCapsFeatures();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(feature: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_id(feature: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/add_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async contains(feature: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async contains_id(feature: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/contains_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GstCapsFeatures> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_nth(i: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/get_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('i', String(i));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_nth_id(i: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/get_nth_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('i', String(i));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_any(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/is_any`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_equal(features2: GstCapsFeatures): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (features2 && typeof features2 === 'object' && 'ptr' in features2) {
      url.searchParams.append('features2', 'ptr,' + features2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove(feature: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_id(feature: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/remove_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_parent_refcount(refcount: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/set_parent_refcount`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('refcount', String(refcount));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async from_string(features: string): Promise<GstCapsFeatures> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('features', String(features));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstClock extends GstObject {

  static async id_compare_func(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_compare_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async id_get_clock(): Promise<GstClock> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_get_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstClock(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  static async id_get_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_get_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async id_ref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async id_unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async id_unschedule(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_unschedule`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async id_uses_clock(clock: GstClock): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_uses_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async id_wait(): Promise<GstClockReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_wait`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async id_wait_async(func: GstClockCallback): Promise<GstClockReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_wait_async`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async add_observation(slave: number, master: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/add_observation`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('slave', String(slave));
    // Primitive parameter
    url.searchParams.append('master', String(master));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_observation_unapplied(slave: number, master: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/add_observation_unapplied`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('slave', String(slave));
    // Primitive parameter
    url.searchParams.append('master', String(master));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async adjust_unlocked(internal: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/adjust_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('internal', String(internal));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async adjust_with_calibration(internal_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/adjust_with_calibration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('internal_target', String(internal_target));
    // Primitive parameter
    url.searchParams.append('cinternal', String(cinternal));
    // Primitive parameter
    url.searchParams.append('cexternal', String(cexternal));
    // Primitive parameter
    url.searchParams.append('cnum', String(cnum));
    // Primitive parameter
    url.searchParams.append('cdenom', String(cdenom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_calibration(): Promise<{ internal?: number; external?: number; rate_num?: number; rate_denom?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_calibration`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async get_internal_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_internal_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_master(): Promise<GstClock> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_master`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstClock(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_resolution(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_resolution`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_timeout(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_timeout`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_synced(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/is_synced`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async new_periodic_id(start_time: number, interval: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/new_periodic_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start_time', String(start_time));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async new_single_shot_id(time: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/new_single_shot_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async periodic_id_reinit(start_time: number, interval: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/periodic_id_reinit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start_time', String(start_time));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_calibration(internal: number, external: number, rate_num: number, rate_denom: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_calibration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('internal', String(internal));
    // Primitive parameter
    url.searchParams.append('external', String(external));
    // Primitive parameter
    url.searchParams.append('rate_num', String(rate_num));
    // Primitive parameter
    url.searchParams.append('rate_denom', String(rate_denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_master(master?: GstClock): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_master`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (master !== undefined && typeof master === 'object' && 'ptr' in master) {
      url.searchParams.append('master', 'ptr,' + master.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_resolution(resolution: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_resolution`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('resolution', String(resolution));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_synced(synced: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_synced`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('synced', String(synced));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_timeout(timeout: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_timeout`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async single_shot_id_reinit(time: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/single_shot_id_reinit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unadjust_unlocked(external: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/unadjust_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('external', String(external));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unadjust_with_calibration(external_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/unadjust_with_calibration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('external_target', String(external_target));
    // Primitive parameter
    url.searchParams.append('cinternal', String(cinternal));
    // Primitive parameter
    url.searchParams.append('cexternal', String(cexternal));
    // Primitive parameter
    url.searchParams.append('cnum', String(cnum));
    // Primitive parameter
    url.searchParams.append('cdenom', String(cdenom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async wait_for_sync(timeout: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/wait_for_sync`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstClockEntry {
  ptr!: Pointer;


}
export class GstClockPrivate {
  ptr!: Pointer;


}
export class GstContext {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstcontextRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstcontextRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(context_type: string, persistent: boolean): Promise<GstContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    // Primitive parameter
    url.searchParams.append('persistent', String(persistent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstContext();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_context_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/get_context_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_structure(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_context_type(context_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/has_context_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_persistent(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/is_persistent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async writable_structure(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstControlBinding extends GstObject {

  async get_g_value_array_2(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/get_g_value_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value_2(timestamp: number): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_disabled(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/is_disabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_disabled(disabled: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/set_disabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('disabled', String(disabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sync_values_2(object: GstObject, timestamp: number, last_sync: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/sync_values`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('last_sync', String(last_sync));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstControlBindingPrivate {
  ptr!: Pointer;


}
export class GstControlSource extends GstObject {

  async control_source_get_value(timestamp: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlSource/ptr,${this.ptr}/control_source_get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async control_source_get_value_array(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlSource/ptr,${this.ptr}/control_source_get_value_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlSource/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstCustomMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstcustommetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstcustommetaRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstCustomMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCustomMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_structure(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_name(name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstDateTime {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstdatetimeRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstdatetimeRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(tzoffset: number, year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tzoffset', String(tzoffset));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_g_date_time(dt?: GLibDateTime): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_g_date_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dt !== undefined && typeof dt === 'object' && 'ptr' in dt) {
      url.searchParams.append('dt', 'ptr,' + dt.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_iso8601_string(string: string): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_iso8601_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_epoch_local_time(secs: number): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_unix_epoch_local_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('secs', String(secs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_epoch_local_time_usecs(usecs: number): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_unix_epoch_local_time_usecs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_epoch_utc(secs: number): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_unix_epoch_utc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('secs', String(secs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_epoch_utc_usecs(usecs: number): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_unix_epoch_utc_usecs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_local_time(year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_local_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now_local_time(): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_now_local_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now_utc(): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_now_utc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_y(year: number): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_y`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_ym(year: number, month: number): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_ym`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_ymd(year: number, month: number, day: number): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_ymd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_day(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_day`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_hour(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_hour`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_microsecond(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_microsecond`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_minute(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_minute`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_month(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_second(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_second`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_time_zone_offset(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_time_zone_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_year(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_day(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_day`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_month(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_second(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_second`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_time(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_year(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GstDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_g_date_time(): Promise<GLibDateTime> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/to_g_date_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_iso8601_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/to_iso8601_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstDebugCategory {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstdebugcategoryRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstdebugcategoryRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstDebugCategory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDebugCategory();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_color(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/get_color`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_description(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_threshold(): Promise<GstDebugLevelValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/get_threshold`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reset_threshold(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/reset_threshold`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_threshold(level: GstDebugLevelValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/set_threshold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GstDebugMessage {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstdebugmessageRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstdebugmessageRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugMessage/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstDebugMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugMessage/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDebugMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugMessage/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_id(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugMessage/ptr,${this.ptr}/get_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstDevice extends GstObject {

  async create_element(name?: string): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/create_element`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_device_class(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/get_device_class`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_display_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/get_display_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_properties(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/get_properties`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_classes(classes: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/has_classes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classesv(classes: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/has_classesv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reconfigure_element(element: GstElement): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/reconfigure_element`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstDeviceMonitor extends GstObject {
  static async new(): Promise<GstDeviceMonitor> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDeviceMonitor();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_filter(classes?: string, caps?: GstCaps): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/add_filter`, apiConfig.baseUrl);
    // Primitive parameter
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstBus(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_devices(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/get_devices`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_providers(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/get_providers`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_show_all_devices(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/get_show_all_devices`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_filter(filter_id: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/remove_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filter_id', String(filter_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_show_all_devices(show_all: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/set_show_all_devices`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('show_all', String(show_all));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async start(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async stop(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstDeviceMonitorPrivate {
  ptr!: Pointer;


}
export class GstDevicePrivate {
  ptr!: Pointer;


}
export class GstDeviceProvider extends GstObject {

  static async register(name: string, rank: number, type_: string, plugin?: GstPlugin): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_monitor(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/can_monitor`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async device_add(device: GstDevice): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/device_add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async device_changed(device: GstDevice, changed_device: GstDevice): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/device_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      url.searchParams.append('changed_device', 'ptr,' + changed_device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async device_remove(device: GstDevice): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/device_remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstBus(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_devices(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_devices`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_factory(): Promise<GstDeviceProviderFactory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_factory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstDeviceProviderFactory(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_hidden_providers(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_hidden_providers`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async hide_provider(name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/hide_provider`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_started(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/is_started`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async start(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async stop(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unhide_provider(name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/unhide_provider`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstPluginFeature extends GstObject {

  static async list_copy(list: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/list_copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async list_debug(list: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/list_debug`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async list_free(list: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/list_free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async rank_compare_func(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/rank_compare_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async check_version(min_major: number, min_minor: number, min_micro: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/check_version`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('min_major', String(min_major));
    // Primitive parameter
    url.searchParams.append('min_minor', String(min_minor));
    // Primitive parameter
    url.searchParams.append('min_micro', String(min_micro));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_plugin(): Promise<GstPlugin> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/get_plugin`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPlugin(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_plugin_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/get_plugin_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_rank(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/get_rank`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load(): Promise<GstPluginFeature> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/load`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPluginFeature(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async set_rank(rank: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/set_rank`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstDeviceProviderFactory extends GstPluginFeature {

  static async find(name: string): Promise<GstDeviceProviderFactory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstDeviceProviderFactory(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  static async get_by_name(factoryname: string): Promise<GstDeviceProvider> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/get_by_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstDeviceProvider(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  static async list_get_device_providers(minrank: GstRankValue): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/list_get_device_providers`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('minrank', String(minrank));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get(): Promise<GstDeviceProvider> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstDeviceProvider(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_device_provider_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/get_device_provider_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata_keys(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/get_metadata_keys`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classes(classes?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/has_classes`, apiConfig.baseUrl);
    // Primitive parameter
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classesv(classes?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/has_classesv`, apiConfig.baseUrl);
    // Primitive parameter
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstDeviceProviderPrivate {
  ptr!: Pointer;


}
export class GstDoubleRange {
  ptr!: Pointer;


  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DoubleRange/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstDynamicTypeFactory extends GstPluginFeature {

  static async load_2(factoryname: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DynamicTypeFactory/load`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DynamicTypeFactory/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstElementFactory extends GstPluginFeature {

  static async find(name: string): Promise<GstElementFactory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElementFactory(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  static async list_filter(list: Pointer, caps: GstCaps, direction: GstPadDirectionValue, subsetonly: boolean): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/list_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    // Primitive parameter
    url.searchParams.append('subsetonly', String(subsetonly));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async list_get_elements(type_: number, minrank: GstRankValue): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/list_get_elements`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('minrank', String(minrank));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async make(factoryname: string, name?: string): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/make`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  static async make_with_properties(factoryname: string, n: number, names?: Pointer, values?: Pointer): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/make_with_properties`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    if (values !== undefined) url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async can_sink_all_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/can_sink_all_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_sink_any_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/can_sink_any_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_src_all_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/can_src_all_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_src_any_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/can_src_any_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create(name?: string): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/create`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async create_with_properties(n: number, names?: Pointer, values?: Pointer): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/create_with_properties`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n', String(n));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    if (values !== undefined) url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_element_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_element_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata_keys(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_metadata_keys`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_num_pad_templates(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_num_pad_templates`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_skip_documentation(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_skip_documentation`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_static_pad_templates(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_static_pad_templates`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uri_protocols(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_uri_protocols`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uri_type(): Promise<GstURITypeValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_uri_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_interface(interfacename: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/has_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interfacename', String(interfacename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_is_type(type_: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/list_is_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstEvent {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsteventRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsteventRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_buffer_size(format: GstFormatValue, minsize: number, maxsize: number, async_: boolean): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_buffer_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('minsize', String(minsize));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('async', String(async_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_caps(caps: GstCaps): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_custom(type_: GstEventTypeValue, structure: GstStructure): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_eos(): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_eos`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_flush_start(): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_flush_start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_flush_stop(reset_time: boolean): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_flush_stop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('reset_time', String(reset_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_gap(timestamp: number, duration: number): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_gap`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_instant_rate_change(rate_multiplier: number, new_flags: GstSegmentFlagsValue): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_instant_rate_change`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate_multiplier', String(rate_multiplier));
    // Primitive parameter
    url.searchParams.append('new_flags', String(new_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_instant_rate_sync_time(rate_multiplier: number, running_time: number, upstream_running_time: number): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_instant_rate_sync_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate_multiplier', String(rate_multiplier));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    // Primitive parameter
    url.searchParams.append('upstream_running_time', String(upstream_running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_latency(latency: number): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_latency`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('latency', String(latency));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_navigation(structure: GstStructure): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_navigation`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_protection(system_id: string, data_: GstBuffer, origin: string): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_protection`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('system_id', String(system_id));
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('origin', String(origin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_qos(type_: GstQOSTypeValue, proportion: number, diff: number, timestamp: number): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_qos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('proportion', String(proportion));
    // Primitive parameter
    url.searchParams.append('diff', String(diff));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_reconfigure(): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_seek(rate: number, format: GstFormatValue, flags: GstSeekFlagsValue, start_type: GstSeekTypeValue, start: number, stop_type: GstSeekTypeValue, stop: number): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment(segment: GstSegment): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment_done(format: GstFormatValue, position: number): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_segment_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_select_streams(streams: Pointer): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_select_streams`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('streams', String(streams));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_sink_message(name: string, msg: GstMessage): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_sink_message`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (msg && typeof msg === 'object' && 'ptr' in msg) {
      url.searchParams.append('msg', 'ptr,' + msg.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_step(format: GstFormatValue, amount: number, rate: number, flush: boolean, intermediate: boolean): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_step`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('amount', String(amount));
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    // Primitive parameter
    url.searchParams.append('intermediate', String(intermediate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_collection(collection: GstStreamCollection): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_group_done(group_id: number): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_stream_group_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_id', String(group_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_start(stream_id: string): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_stream_start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stream_id', String(stream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_tag(taglist: GstTagList): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (taglist && typeof taglist === 'object' && 'ptr' in taglist) {
      url.searchParams.append('taglist', 'ptr,' + taglist.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_toc(toc: GstToc, updated: boolean): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    // Primitive parameter
    url.searchParams.append('updated', String(updated));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_toc_select(uid: string): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_toc_select`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uid', String(uid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy_segment(segment: GstSegment): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/copy_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_running_time_offset(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/get_running_time_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_seqnum(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/get_seqnum`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_structure(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_name(name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_name_id(name: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/has_name_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_buffer_size(format: GstFormatValue): Promise<{ minsize?: number; maxsize?: number; async_?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_buffer_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_caps(caps: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_flush_stop(): Promise<{ reset_time?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_flush_stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_gap(): Promise<{ timestamp?: number; duration?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_gap`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_gap_flags(flags: GstGapFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_gap_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_group_id(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_group_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_instant_rate_change(new_flags: GstSegmentFlagsValue): Promise<{ rate_multiplier?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_instant_rate_change`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('new_flags', String(new_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_instant_rate_sync_time(): Promise<{ rate_multiplier?: number; running_time?: number; upstream_running_time?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_instant_rate_sync_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_latency(): Promise<{ latency?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_protection(data_: GstBuffer): Promise<{ system_id?: string; origin?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_protection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_qos(type_: GstQOSTypeValue): Promise<{ proportion?: number; diff?: number; timestamp?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_qos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_seek(format: GstFormatValue, flags: GstSeekFlagsValue, start_type: GstSeekTypeValue, stop_type: GstSeekTypeValue): Promise<{ rate?: number; start?: number; stop?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_seek_trickmode_interval(): Promise<{ interval?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_seek_trickmode_interval`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_segment(segment: GstSegment): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_segment_done(format: GstFormatValue): Promise<{ position?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_segment_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_select_streams(): Promise<{ streams?: Pointer }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_select_streams`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_sink_message(msg: GstMessage): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_sink_message`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (msg && typeof msg === 'object' && 'ptr' in msg) {
      url.searchParams.append('msg', 'ptr,' + msg.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_step(format: GstFormatValue): Promise<{ amount?: number; rate?: number; flush?: boolean; intermediate?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_step`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_stream(stream: GstStream): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (stream && typeof stream === 'object' && 'ptr' in stream) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (stream && typeof stream === 'object' && 'ptr' in stream) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_stream_collection(collection: GstStreamCollection): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (collection && typeof collection === 'object' && 'ptr' in collection) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_stream_flags(flags: GstStreamFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_stream_group_done(): Promise<{ group_id?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream_group_done`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_stream_start(): Promise<{ stream_id?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream_start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_tag(taglist: GstTagList): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (taglist && typeof taglist === 'object' && 'ptr' in taglist) {
      url.searchParams.append('taglist', 'ptr,' + taglist.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_toc(toc: GstToc): Promise<{ updated?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_toc_select(): Promise<{ uid?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_toc_select`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async set_gap_flags(flags: GstGapFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_gap_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_group_id(group_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_group_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_id', String(group_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_running_time_offset(offset: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_running_time_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_seek_trickmode_interval(interval: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_seek_trickmode_interval`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_seqnum(seqnum: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_seqnum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seqnum', String(seqnum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream(stream: GstStream): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_stream`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_flags(flags: GstStreamFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_stream_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async writable_structure(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstFlagSet {
  ptr!: Pointer;


  static async register(flags_type: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/FlagSet/register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/FlagSet/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstFormatDefinition {
  ptr!: Pointer;


}
export class GstFraction {
  ptr!: Pointer;


  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Fraction/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstFractionRange {
  ptr!: Pointer;


  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/FractionRange/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstPad extends GstObject {
  static async new(direction: GstPadDirectionValue, name?: string): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_static_template(templ: GstStaticPadTemplate, name: string): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/new_from_static_template`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_template(templ: GstPadTemplate, name?: string): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/new_from_template`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPad();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async link_get_name(ret: GstPadLinkReturnValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/link_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async activate_mode(mode: GstPadModeValue, active: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/activate_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_probe(mask: GstPadProbeTypeValue, callback: GstPadProbeCallback): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/add_probe`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.callback !== undefined) {
      callbackDispatcher.set(data.callback.toString(), callback);
    }
    return data.return;
  }
  async can_link(sinkpad: GstPad): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/can_link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async chain(buffer: GstBuffer): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/chain`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async chain_list(list: GstBufferList): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/chain_list`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async check_reconfigure(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/check_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_stream_id(parent: GstElement, stream_id?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/create_stream_id`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    if (stream_id !== undefined) url.searchParams.append('stream_id', String(stream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async event_default(event: GstEvent, parent?: GstObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/event_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async forward(forward: GstPadForwardFunction): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/forward`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.forward !== undefined) {
      callbackDispatcher.set(data.forward.toString(), forward);
    }
    return data.return;
  }
  async get_allowed_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_allowed_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_current_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_current_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_direction(): Promise<GstPadDirectionValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_direction`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_element_private(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_element_private`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_last_flow_return(): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_last_flow_return`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_offset(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pad_template(): Promise<GstPadTemplate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_pad_template`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPadTemplate(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_pad_template_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_pad_template_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_parent_element(): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_parent_element`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_peer(): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_peer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_range(offset: number, size: number, buffer: GstBuffer): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_single_internal_link(): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_single_internal_link`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_sticky_event(event_type: GstEventTypeValue, idx: number): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_sticky_event`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('event_type', String(event_type));
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstEvent(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_stream(): Promise<GstStream> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_stream`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstStream(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_stream_id(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_stream_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_task_state(): Promise<GstTaskStateValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_task_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_current_caps(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/has_current_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_active(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_blocked(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/is_blocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_blocking(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/is_blocking`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_linked(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/is_linked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_internal_links(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/iterate_internal_links`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_internal_links_default(parent?: GstObject): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/iterate_internal_links_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async link(sinkpad: GstPad): Promise<GstPadLinkReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_full(sinkpad: GstPad, flags: GstPadLinkCheckValue): Promise<GstPadLinkReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/link_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_maybe_ghosting(sink: GstPad): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/link_maybe_ghosting`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sink && typeof sink === 'object' && 'ptr' in sink) {
      url.searchParams.append('sink', 'ptr,' + sink.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_maybe_ghosting_full(sink: GstPad, flags: GstPadLinkCheckValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/link_maybe_ghosting_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sink && typeof sink === 'object' && 'ptr' in sink) {
      url.searchParams.append('sink', 'ptr,' + sink.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async mark_reconfigure(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/mark_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async needs_reconfigure(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/needs_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pause_task(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/pause_task`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query(query: GstQuery): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_accept_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_caps(filter?: GstCaps): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async peer_query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_val', String(src_val));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_duration(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_position(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async proxy_query_accept_caps(query: GstQuery): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/proxy_query_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async proxy_query_caps(query: GstQuery): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/proxy_query_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pull_range(offset: number, size: number, buffer: GstBuffer): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/pull_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push(buffer: GstBuffer): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push_event(event: GstEvent): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/push_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push_list(list: GstBufferList): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/push_list`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query(query: GstQuery): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_accept_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_caps(filter?: GstCaps): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_val', String(src_val));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_default(query: GstQuery, parent?: GstObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_duration(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_position(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_probe(id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/remove_probe`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async send_event(event: GstEvent): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/send_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_activate_function_full(activate: GstPadActivateFunction): Promise<{ activate?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_activate_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.activate !== undefined) {
      callbackDispatcher.set(data.activate.toString(), activate);
    }
    return data;
  }
  async set_activatemode_function_full(activatemode: GstPadActivateModeFunction): Promise<{ activatemode?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_activatemode_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.activatemode !== undefined) {
      callbackDispatcher.set(data.activatemode.toString(), activatemode);
    }
    return data;
  }
  async set_active(active: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_active`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_chain_function_full(chain: GstPadChainFunction): Promise<{ chain?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_chain_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.chain !== undefined) {
      callbackDispatcher.set(data.chain.toString(), chain);
    }
    return data;
  }
  async set_chain_list_function_full(chainlist: GstPadChainListFunction): Promise<{ chainlist?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_chain_list_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.chainlist !== undefined) {
      callbackDispatcher.set(data.chainlist.toString(), chainlist);
    }
    return data;
  }
  async set_element_private(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_element_private`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_event_full_function_full(event: GstPadEventFullFunction): Promise<{ event?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_event_full_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.event !== undefined) {
      callbackDispatcher.set(data.event.toString(), event);
    }
    return data;
  }
  async set_event_function_full(event: GstPadEventFunction): Promise<{ event?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_event_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.event !== undefined) {
      callbackDispatcher.set(data.event.toString(), event);
    }
    return data;
  }
  async set_getrange_function_full(get: GstPadGetRangeFunction): Promise<{ get?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_getrange_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.get !== undefined) {
      callbackDispatcher.set(data.get.toString(), get);
    }
    return data;
  }
  async set_iterate_internal_links_function_full(iterintlink: GstPadIterIntLinkFunction): Promise<{ iterintlink?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_iterate_internal_links_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.iterintlink !== undefined) {
      callbackDispatcher.set(data.iterintlink.toString(), iterintlink);
    }
    return data;
  }
  async set_link_function_full(link: GstPadLinkFunction): Promise<{ link?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_link_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.link !== undefined) {
      callbackDispatcher.set(data.link.toString(), link);
    }
    return data;
  }
  async set_offset(offset: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_query_function_full(query: GstPadQueryFunction): Promise<{ query?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_query_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.query !== undefined) {
      callbackDispatcher.set(data.query.toString(), query);
    }
    return data;
  }
  async set_unlink_function_full(unlink: GstPadUnlinkFunction): Promise<{ unlink?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_unlink_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.unlink !== undefined) {
      callbackDispatcher.set(data.unlink.toString(), unlink);
    }
    return data;
  }
  async start_task(func: GstTaskFunction): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/start_task`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async sticky_events_foreach(foreach_func: GstPadStickyEventsForeachFunction): Promise<{ foreach_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/sticky_events_foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.foreach_func !== undefined) {
      callbackDispatcher.set(data.foreach_func.toString(), foreach_func);
    }
    return data;
  }
  async stop_task(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/stop_task`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async store_sticky_event(event: GstEvent): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/store_sticky_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unlink(sinkpad: GstPad): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/unlink`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async use_fixed_caps(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/use_fixed_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstProxyPad extends GstPad {

  static async chain_default(pad: GstPad, buffer: GstBuffer, parent?: GstObject): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/chain_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async chain_list_default(pad: GstPad, list: GstBufferList, parent?: GstObject): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/chain_list_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async getrange_default(pad: GstPad, parent: GstObject, offset: number, size: number, buffer: GstBuffer): Promise<GstFlowReturnValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/getrange_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async iterate_internal_links_default_2(pad: GstPad, parent?: GstObject): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/iterate_internal_links_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_internal(): Promise<GstProxyPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/ptr,${this.ptr}/get_internal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstProxyPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstGhostPad extends GstProxyPad {
  static async new_2(target: GstPad, name?: string): Promise<GstGhostPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_template_2(target: GstPad, templ: GstPadTemplate, name?: string): Promise<GstGhostPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/new_from_template`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_no_target(dir: GstPadDirectionValue, name?: string): Promise<GstGhostPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/new_no_target`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('dir', String(dir));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_no_target_from_template(templ: GstPadTemplate, name?: string): Promise<GstGhostPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/new_no_target_from_template`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async activate_mode_default(pad: GstPad, mode: GstPadModeValue, active: boolean, parent?: GstObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/activate_mode_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async internal_activate_mode_default(pad: GstPad, mode: GstPadModeValue, active: boolean, parent?: GstObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/internal_activate_mode_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async construct(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/ptr,${this.ptr}/construct`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_target(): Promise<GstPad> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/ptr,${this.ptr}/get_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPad(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async set_target(newtarget?: GstPad): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/ptr,${this.ptr}/set_target`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (newtarget !== undefined && typeof newtarget === 'object' && 'ptr' in newtarget) {
      url.searchParams.append('newtarget', 'ptr,' + newtarget.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstGhostPadPrivate {
  ptr!: Pointer;


}
export class GstInt64Range {
  ptr!: Pointer;


  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Int64Range/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstIntRange {
  ptr!: Pointer;


  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/IntRange/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstIterator {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstiteratorRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstiteratorRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_single(type_: string, object: GObjectValue): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/new_single`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstIterator();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async filter(user_data: GObjectValue, func: GLibCompareFunc): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/filter`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (user_data && typeof user_data === 'object' && 'ptr' in user_data) {
      url.searchParams.append('user_data', 'ptr,' + user_data.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async find_custom(elem: GObjectValue, func: GLibCompareFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/find_custom`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (elem && typeof elem === 'object' && 'ptr' in elem) {
      url.searchParams.append('elem', 'ptr,' + elem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async fold(ret: GObjectValue, func: GstIteratorFoldFunction): Promise<GstIteratorResultValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fold`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ret && typeof ret === 'object' && 'ptr' in ret) {
      url.searchParams.append('ret', 'ptr,' + ret.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async foreach(func: GstIteratorForeachFunction): Promise<GstIteratorResultValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async next(elem: GObjectValue): Promise<GstIteratorResultValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (elem && typeof elem === 'object' && 'ptr' in elem) {
      url.searchParams.append('elem', 'ptr,' + elem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push(other: GstIterator): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (other && typeof other === 'object' && 'ptr' in other) {
      url.searchParams.append('other', 'ptr,' + other.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async resync(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/resync`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstMapInfo {
  ptr!: Pointer;


}
export class GstMemory {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstmemoryRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstmemoryRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_wrapped(flags: GstMemoryFlagsValue, data_: Pointer, maxsize: number, offset: number, size: number, notify: GLibDestroyNotify): Promise<GstMemory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/new_wrapped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.notify !== undefined) {
      callbackDispatcher.set(data.notify.toString(), notify);
    }
    const instance = new GstMemory();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(offset: number, size: number): Promise<GstMemory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_sizes(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/get_sizes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_span(mem2: GstMemory): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/is_span`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem2 && typeof mem2 === 'object' && 'ptr' in mem2) {
      url.searchParams.append('mem2', 'ptr,' + mem2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_type(mem_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/is_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_type', String(mem_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async make_mapped(info: GstMapInfo, flags: GstMapFlagsValue): Promise<GstMemory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/make_mapped`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async map(info: GstMapInfo, flags: GstMapFlagsValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/map`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async resize(offset: number, size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/resize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async share(offset: number, size: number): Promise<GstMemory> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/share`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unmap(info: GstMapInfo): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/unmap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstMessage {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstmessageRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstmessageRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_application(structure: GstStructure, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_application`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_async_done(running_time: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_async_done`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_async_start(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_async_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_buffering(percent: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_buffering`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('percent', String(percent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_clock_lost(clock: GstClock, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_clock_lost`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_clock_provide(clock: GstClock, ready: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_clock_provide`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    // Primitive parameter
    url.searchParams.append('ready', String(ready));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_custom(type_: GstMessageTypeValue, src?: GstObject, structure?: GstStructure): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_device_added(device: GstDevice, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_device_added`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_device_changed(device: GstDevice, changed_device: GstDevice, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_device_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      url.searchParams.append('changed_device', 'ptr,' + changed_device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_device_removed(device: GstDevice, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_device_removed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_duration_changed(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_duration_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_element(structure: GstStructure, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_element`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_eos(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_eos`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_error(error_: Pointer, debug: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_error`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_error_with_details(error_: Pointer, debug: string, src?: GstObject, details?: GstStructure): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_error_with_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    // Object with explode=false: serialize as comma-separated
    if (details !== undefined && typeof details === 'object' && 'ptr' in details) {
      url.searchParams.append('details', 'ptr,' + details.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_have_context(context: GstContext, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_have_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (context && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_info(error_: Pointer, debug: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_info`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_info_with_details(error_: Pointer, debug: string, src?: GstObject, details?: GstStructure): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_info_with_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    // Object with explode=false: serialize as comma-separated
    if (details !== undefined && typeof details === 'object' && 'ptr' in details) {
      url.searchParams.append('details', 'ptr,' + details.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_instant_rate_request(rate_multiplier: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_instant_rate_request`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('rate_multiplier', String(rate_multiplier));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_latency(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_latency`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_need_context(context_type: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_need_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_new_clock(clock: GstClock, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_new_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_progress(type_: GstProgressTypeValue, code: string, text: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_progress`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    url.searchParams.append('text', String(text));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_property_notify(src: GstObject, property_name: string, val?: GObjectValue): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_property_notify`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Object with explode=false: serialize as comma-separated
    if (val !== undefined && typeof val === 'object' && 'ptr' in val) {
      url.searchParams.append('val', 'ptr,' + val.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_qos(live: boolean, running_time: number, stream_time: number, timestamp: number, duration: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_qos`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('live', String(live));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    // Primitive parameter
    url.searchParams.append('stream_time', String(stream_time));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_redirect(location: string, src?: GstObject, tag_list?: GstTagList, entry_struct?: GstStructure): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_redirect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Object with explode=false: serialize as comma-separated
    if (tag_list !== undefined && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (entry_struct !== undefined && typeof entry_struct === 'object' && 'ptr' in entry_struct) {
      url.searchParams.append('entry_struct', 'ptr,' + entry_struct.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_request_state(state: GstStateValue, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_request_state`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_reset_time(running_time: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_reset_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment_done(format: GstFormatValue, position: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_segment_done`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment_start(format: GstFormatValue, position: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_segment_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_state_changed(oldstate: GstStateValue, newstate: GstStateValue, pending: GstStateValue, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_state_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('oldstate', String(oldstate));
    // Primitive parameter
    url.searchParams.append('newstate', String(newstate));
    // Primitive parameter
    url.searchParams.append('pending', String(pending));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_state_dirty(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_state_dirty`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_step_done(format: GstFormatValue, amount: number, rate: number, flush: boolean, intermediate: boolean, duration: number, eos: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_step_done`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('amount', String(amount));
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    // Primitive parameter
    url.searchParams.append('intermediate', String(intermediate));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    // Primitive parameter
    url.searchParams.append('eos', String(eos));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_step_start(active: boolean, format: GstFormatValue, amount: number, rate: number, flush: boolean, intermediate: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_step_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('amount', String(amount));
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    // Primitive parameter
    url.searchParams.append('intermediate', String(intermediate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_collection(collection: GstStreamCollection, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_start(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_stream_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_status(type_: GstStreamStatusTypeValue, owner: GstElement, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_stream_status`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_streams_selected(collection: GstStreamCollection, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_streams_selected`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_structure_change(type_: GstStructureChangeTypeValue, owner: GstElement, busy: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_structure_change`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    // Primitive parameter
    url.searchParams.append('busy', String(busy));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_tag(tag_list: GstTagList, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (tag_list && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_toc(toc: GstToc, updated: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    // Primitive parameter
    url.searchParams.append('updated', String(updated));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_warning(error_: Pointer, debug: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_warning`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_warning_with_details(error_: Pointer, debug: string, src?: GstObject, details?: GstStructure): Promise<GstMessage> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_warning_with_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    // Object with explode=false: serialize as comma-separated
    if (details !== undefined && typeof details === 'object' && 'ptr' in details) {
      url.searchParams.append('details', 'ptr,' + details.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_redirect_entry(location: string, tag_list?: GstTagList, entry_struct?: GstStructure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/add_redirect_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Object with explode=false: serialize as comma-separated
    if (tag_list !== undefined && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (entry_struct !== undefined && typeof entry_struct === 'object' && 'ptr' in entry_struct) {
      url.searchParams.append('entry_struct', 'ptr,' + entry_struct.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_num_redirect_entries(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/get_num_redirect_entries`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_seqnum(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/get_seqnum`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_status_object(): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/get_stream_status_object`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_structure(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_name(name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_async_done(): Promise<{ running_time?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_async_done`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering(): Promise<{ percent?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_buffering`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering_stats(mode: GstBufferingModeValue): Promise<{ avg_in?: number; avg_out?: number; buffering_left?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_clock_lost(clock: GstClock): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_clock_lost`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_clock_provide(clock: GstClock): Promise<{ ready?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_clock_provide`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_context_type(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_context_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_device_added(device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (device && typeof device === 'object' && 'ptr' in device) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_device_added`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (device && typeof device === 'object' && 'ptr' in device) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_device_changed(device: GstDevice, changed_device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (device && typeof device === 'object' && 'ptr' in device) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/ref').catch(() => {});
    }
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + changed_device.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_device_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      url.searchParams.append('changed_device', 'ptr,' + changed_device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + changed_device.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (device && typeof device === 'object' && 'ptr' in device) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
      }
      if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + changed_device.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_device_removed(device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (device && typeof device === 'object' && 'ptr' in device) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_device_removed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (device && typeof device === 'object' && 'ptr' in device) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_error(): Promise<{ gerror?: Pointer; debug?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_error`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_error_details(structure?: GstStructure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_error_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_group_id(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_group_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_have_context(context: GstContext): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_have_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_info(): Promise<{ gerror?: Pointer; debug?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_info_details(structure?: GstStructure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_info_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_instant_rate_request(): Promise<{ rate_multiplier?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_instant_rate_request`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_new_clock(clock: GstClock): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_new_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_progress(type_: GstProgressTypeValue): Promise<{ code?: string; text?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_progress`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_property_notify(object: GstObject, property_value?: GObjectValue): Promise<{ property_name?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_property_notify`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (property_value !== undefined && typeof property_value === 'object' && 'ptr' in property_value) {
      url.searchParams.append('property_value', 'ptr,' + property_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_qos(): Promise<{ live?: boolean; running_time?: number; stream_time?: number; timestamp?: number; duration?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_qos`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_qos_stats(format: GstFormatValue): Promise<{ processed?: number; dropped?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_qos_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_qos_values(): Promise<{ jitter?: number; proportion?: number; quality?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_qos_values`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_redirect_entry(entry_index: number, tag_list?: GstTagList, entry_struct?: GstStructure): Promise<{ location?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_redirect_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('entry_index', String(entry_index));
    // Object with explode=false: serialize as comma-separated
    if (tag_list !== undefined && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (entry_struct !== undefined && typeof entry_struct === 'object' && 'ptr' in entry_struct) {
      url.searchParams.append('entry_struct', 'ptr,' + entry_struct.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_request_state(state: GstStateValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_request_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_reset_time(): Promise<{ running_time?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_reset_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_segment_done(format: GstFormatValue): Promise<{ position?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_segment_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_segment_start(format: GstFormatValue): Promise<{ position?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_segment_start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_state_changed(oldstate: GstStateValue, newstate: GstStateValue, pending: GstStateValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_state_changed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('oldstate', String(oldstate));
    // Primitive parameter
    url.searchParams.append('newstate', String(newstate));
    // Primitive parameter
    url.searchParams.append('pending', String(pending));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_step_done(format: GstFormatValue): Promise<{ amount?: number; rate?: number; flush?: boolean; intermediate?: boolean; duration?: number; eos?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_step_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_step_start(format: GstFormatValue): Promise<{ active?: boolean; amount?: number; rate?: number; flush?: boolean; intermediate?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_step_start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_stream_collection(collection: GstStreamCollection): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (collection && typeof collection === 'object' && 'ptr' in collection) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_stream_status(type_: GstStreamStatusTypeValue, owner: GstElement): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_stream_status`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_streams_selected(collection: GstStreamCollection): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_streams_selected`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (collection && typeof collection === 'object' && 'ptr' in collection) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_structure_change(type_: GstStructureChangeTypeValue, owner: GstElement): Promise<{ busy?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_structure_change`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_tag(tag_list: GstTagList): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tag_list && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_toc(toc: GstToc): Promise<{ updated?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_warning(): Promise<{ gerror?: Pointer; debug?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_warning`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_warning_details(structure?: GstStructure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_warning_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffering_stats(mode: GstBufferingModeValue, avg_in: number, avg_out: number, buffering_left: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('avg_in', String(avg_in));
    // Primitive parameter
    url.searchParams.append('avg_out', String(avg_out));
    // Primitive parameter
    url.searchParams.append('buffering_left', String(buffering_left));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_group_id(group_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_group_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_id', String(group_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_qos_stats(format: GstFormatValue, processed: number, dropped: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_qos_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('processed', String(processed));
    // Primitive parameter
    url.searchParams.append('dropped', String(dropped));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_qos_values(jitter: number, proportion: number, quality: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_qos_values`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('jitter', String(jitter));
    // Primitive parameter
    url.searchParams.append('proportion', String(proportion));
    // Primitive parameter
    url.searchParams.append('quality', String(quality));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_seqnum(seqnum: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_seqnum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seqnum', String(seqnum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_status_object(object: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_stream_status_object`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async streams_selected_add(stream: GstStream): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/streams_selected_add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async streams_selected_get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/streams_selected_get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async streams_selected_get_stream(idx: number): Promise<GstStream> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/streams_selected_get_stream`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstStream(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async writable_structure(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstmetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstmetaRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async compare_seqnum(meta2: GstMeta): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/compare_seqnum`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (meta2 && typeof meta2 === 'object' && 'ptr' in meta2) {
      url.searchParams.append('meta2', 'ptr,' + meta2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_seqnum(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/get_seqnum`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async serialize(data_: GstByteArrayInterface): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/serialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async serialize_simple(data_: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/serialize_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async api_type_get_tags(api: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/api_type_get_tags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async api_type_has_tag(api: string, tag: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/api_type_has_tag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async api_type_register(api: string, tags: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/api_type_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async deserialize(buffer: GstBuffer, data_: number, size: number): Promise<GstMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/deserialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_info(impl: string): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/get_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('impl', String(impl));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async register_custom(name: string, tags: Pointer, transform_func: GstCustomMetaTransformFunction): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/register_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.transform_func !== undefined) {
      callbackDispatcher.set(data.transform_func.toString(), transform_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async register_custom_simple(name: string): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/register_custom_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GstMetaInfo {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstmetainfoRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstmetainfoRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMetaInfo();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async is_custom(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/is_custom`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async register(): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/register`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GstMetaTransformCopy {
  ptr!: Pointer;


}
export class GstMiniObject {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstminiobjectRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstminiobjectRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstMiniObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMiniObject();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_parent(parent: GstMiniObject): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/add_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_qdata(quark: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_writable(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/is_writable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lock(flags: GstLockFlagsValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/lock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_parent(parent: GstMiniObject): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/remove_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_qdata(quark: number, destroy: GLibDestroyNotify): Promise<{ destroy?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/set_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.destroy !== undefined) {
      callbackDispatcher.set(data.destroy.toString(), destroy);
    }
    return data;
  }
  async steal_qdata(quark: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unlock(flags: GstLockFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/unlock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async replace(olddata?: GstMiniObject, newdata?: GstMiniObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/replace`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata !== undefined && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata !== undefined && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async take(olddata: GstMiniObject, newdata: GstMiniObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstPadPrivate {
  ptr!: Pointer;


}
export class GstPadProbeInfo {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstpadprobeinfoRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstpadprobeinfoRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstPadProbeInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadProbeInfo();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_buffer(): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/get_buffer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_buffer_list(): Promise<GstBufferList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/get_buffer_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBufferList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_event(): Promise<GstEvent> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/get_event`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstEvent(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_query(): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/get_query`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstQuery(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GstPadTemplate extends GstObject {
  static async new(name_template: string, direction: GstPadDirectionValue, presence: GstPadPresenceValue, caps: GstCaps): Promise<GstPadTemplate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name_template', String(name_template));
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    // Primitive parameter
    url.searchParams.append('presence', String(presence));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_static_pad_template_with_gtype(pad_template: GstStaticPadTemplate, pad_type: string): Promise<GstPadTemplate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/new_from_static_pad_template_with_gtype`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad_template && typeof pad_template === 'object' && 'ptr' in pad_template) {
      url.searchParams.append('pad_template', 'ptr,' + pad_template.ptr);
    }
    // Primitive parameter
    url.searchParams.append('pad_type', String(pad_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_with_gtype(name_template: string, direction: GstPadDirectionValue, presence: GstPadPresenceValue, caps: GstCaps, pad_type: string): Promise<GstPadTemplate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/new_with_gtype`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name_template', String(name_template));
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    // Primitive parameter
    url.searchParams.append('presence', String(presence));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('pad_type', String(pad_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_documentation_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/ptr,${this.ptr}/get_documentation_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async pad_created(pad: GstPad): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/ptr,${this.ptr}/pad_created`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_documentation_caps(caps: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/ptr,${this.ptr}/set_documentation_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstParamArray extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParamArray/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstParamFraction extends GObjectParamSpec {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParamFraction/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstParamSpecArray {
  ptr!: Pointer;


}
export class GstParamSpecFraction {
  ptr!: Pointer;


}
export class GstParentBufferMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstparentbuffermetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstparentbuffermetaRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstParentBufferMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstParentBufferMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async get_info(): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GstParseContext {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstparsecontextRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstparsecontextRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstParseContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstParseContext();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GstParseContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstParseContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_missing_elements(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/ptr,${this.ptr}/get_missing_elements`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstPipeline extends GstBin {
  static async new_2(name?: string): Promise<GstPipeline> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPipeline();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async auto_clock(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/auto_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_auto_flush_bus(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_auto_flush_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstBus(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_configured_latency(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_configured_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_delay(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_delay`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_latency(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pipeline_clock(): Promise<GstClock> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_pipeline_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstClock(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async is_live(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/is_live`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_auto_flush_bus(auto_flush: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/set_auto_flush_bus`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('auto_flush', String(auto_flush));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_delay(delay: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/set_delay`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('delay', String(delay));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_latency(latency: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/set_latency`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('latency', String(latency));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async use_clock(clock?: GstClock): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/use_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock !== undefined && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstPipelinePrivate {
  ptr!: Pointer;


}
export class GstPlugin extends GstObject {

  static async list_free(list: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/list_free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async load_by_name(name: string): Promise<GstPlugin> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/load_by_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPlugin(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  static async load_file(filename: Pointer): Promise<GstPlugin> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/load_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPlugin(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  static async register_static(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package_: string, origin: string, init_func: GstPluginInitFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('major_version', String(major_version));
    // Primitive parameter
    url.searchParams.append('minor_version', String(minor_version));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    // Primitive parameter
    url.searchParams.append('version', String(version));
    // Primitive parameter
    url.searchParams.append('license', String(license));
    // Primitive parameter
    url.searchParams.append('source', String(source));
    // Primitive parameter
    url.searchParams.append('package', String(package_));
    // Primitive parameter
    url.searchParams.append('origin', String(origin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.init_func !== undefined) {
      callbackDispatcher.set(data.init_func.toString(), init_func);
    }
    return data.return;
  }
  static async register_static_full(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package_: string, origin: string, init_full_func: GstPluginInitFullFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/register_static_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('major_version', String(major_version));
    // Primitive parameter
    url.searchParams.append('minor_version', String(minor_version));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    // Primitive parameter
    url.searchParams.append('version', String(version));
    // Primitive parameter
    url.searchParams.append('license', String(license));
    // Primitive parameter
    url.searchParams.append('source', String(source));
    // Primitive parameter
    url.searchParams.append('package', String(package_));
    // Primitive parameter
    url.searchParams.append('origin', String(origin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.init_full_func !== undefined) {
      callbackDispatcher.set(data.init_full_func.toString(), init_full_func);
    }
    return data.return;
  }
  async add_dependency(flags: GstPluginDependencyFlagsValue, env_vars?: Pointer, paths?: Pointer, names?: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_dependency`, apiConfig.baseUrl);
    // Primitive parameter
    if (env_vars !== undefined) url.searchParams.append('env_vars', String(env_vars));
    // Primitive parameter
    if (paths !== undefined) url.searchParams.append('paths', String(paths));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_dependency_simple(flags: GstPluginDependencyFlagsValue, env_vars?: string, paths?: string, names?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_dependency_simple`, apiConfig.baseUrl);
    // Primitive parameter
    if (env_vars !== undefined) url.searchParams.append('env_vars', String(env_vars));
    // Primitive parameter
    if (paths !== undefined) url.searchParams.append('paths', String(paths));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_status_error(message: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_status_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_status_info(message: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_status_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_status_warning(message: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_status_warning`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_cache_data(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_cache_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_description(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_filename(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_filename`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_license(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_license`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_origin(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_origin`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_package(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_package`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_release_date_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_release_date_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_source(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_status_errors(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_status_errors`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_status_infos(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_status_infos`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_status_warnings(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_status_warnings`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_version(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_version`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_loaded(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/is_loaded`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load(): Promise<GstPlugin> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/load`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPlugin(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async set_cache_data(cache_data: GstStructure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/set_cache_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (cache_data && typeof cache_data === 'object' && 'ptr' in cache_data) {
      url.searchParams.append('cache_data', 'ptr,' + cache_data.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstPluginDesc {
  ptr!: Pointer;


}
export class GstPoll {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstpollRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstpollRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstPoll> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPoll();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_fd(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/add_fd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_can_read(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_can_read`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_can_write(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_can_write`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_ctl_pri(fd: GstPollFD, active: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_ctl_pri`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_ctl_read(fd: GstPollFD, active: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_ctl_read`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_ctl_write(fd: GstPollFD, active: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_ctl_write`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_has_closed(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_has_closed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_has_error(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_has_error`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_has_pri(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_has_pri`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_ignored(fd: GstPollFD): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_ignored`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_read_gpollfd(fd: GLibPollFD): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/get_read_gpollfd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async read_control(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/read_control`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_fd(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/remove_fd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async restart(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/restart`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_controllable(controllable: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/set_controllable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('controllable', String(controllable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flushing(flushing: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/set_flushing`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flushing', String(flushing));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait(timeout: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async write_control(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/write_control`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstPollFD {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstpollfdRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstpollfdRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PollFD/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstPollFD> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PollFD/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPollFD();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async init(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PollFD/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}
export class GstPromise {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstpromiseRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstpromiseRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstPromise> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPromise();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_with_change_func(func: GstPromiseChangeFunc): Promise<GstPromise> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/new_with_change_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    const instance = new GstPromise();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async expire(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/expire`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_reply(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/get_reply`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async interrupt(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/interrupt`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async reply(s?: GstStructure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/reply`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (s !== undefined && typeof s === 'object' && 'ptr' in s) {
      url.searchParams.append('s', 'ptr,' + s.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait(): Promise<GstPromiseResultValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstProtectionMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstprotectionmetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstprotectionmetaRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProtectionMeta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstProtectionMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProtectionMeta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstProtectionMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async get_info(): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProtectionMeta/get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GstProxyPadPrivate {
  ptr!: Pointer;


}
export class GstQuery {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstqueryRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstqueryRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_accept_caps(caps: GstCaps): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_allocation(need_pool: boolean, caps?: GstCaps): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_allocation`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('need_pool', String(need_pool));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_bitrate(): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_bitrate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_buffering(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_buffering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_caps(filter: GstCaps): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_context(context_type: string): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_convert(src_format: GstFormatValue, value_: number, dest_format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_custom(type_: GstQueryTypeValue, structure?: GstStructure): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_drain(): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_drain`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_duration(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_formats(): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_formats`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_latency(): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_position(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_scheduling(): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_scheduling`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_seeking(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_seeking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_segment`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_selectable(): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_selectable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_uri(): Promise<GstQuery> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_uri`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_allocation_meta(api: string, params?: GstStructure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_allocation_param(allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_allocation_param`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_allocation_pool(size: number, min_buffers: number, max_buffers: number, pool?: GstBufferPool): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_allocation_pool`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pool !== undefined && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_buffering_range(start: number, stop: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_scheduling_mode(mode: GstPadModeValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_scheduling_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async find_allocation_meta(api: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/find_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_allocation_metas(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_allocation_metas`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_allocation_params(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_allocation_params`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_allocation_pools(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_allocation_pools`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_buffering_ranges(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_buffering_ranges`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_scheduling_modes(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_scheduling_modes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_structure(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_scheduling_mode(mode: GstPadModeValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/has_scheduling_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_scheduling_mode_with_flags(mode: GstPadModeValue, flags: GstSchedulingFlagsValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/has_scheduling_mode_with_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_accept_caps(caps: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_accept_caps_result(): Promise<{ result_?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_accept_caps_result`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_allocation(caps?: GstCaps): Promise<{ need_pool?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_allocation`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_bitrate(): Promise<{ nominal_bitrate?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_bitrate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering_percent(): Promise<{ busy?: boolean; percent?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_buffering_percent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering_range(format: GstFormatValue): Promise<{ start?: number; stop?: number; estimated_total?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering_stats(mode: GstBufferingModeValue): Promise<{ avg_in?: number; avg_out?: number; buffering_left?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_caps(filter: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_caps_result(caps?: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_caps_result`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_context(context?: GstContext): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_context_type(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_context_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_convert(src_format: GstFormatValue, dest_format: GstFormatValue): Promise<{ src_value?: number; dest_value?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_duration(format: GstFormatValue): Promise<{ duration?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_latency(): Promise<{ live?: boolean; min_latency?: number; max_latency?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_n_formats(): Promise<{ n_formats?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_n_formats`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_nth_allocation_meta(index: number, params: GstStructure): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (params && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_nth_allocation_param(index: number, params: GstAllocationParams, allocator?: GstAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_allocation_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_nth_allocation_pool(index: number, pool?: GstBufferPool): Promise<{ size?: number; min_buffers?: number; max_buffers?: number }> {
    // Increment ref for parameters with full transfer ownership
    if (pool && typeof pool === 'object' && 'ptr' in pool) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + pool.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_allocation_pool`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (pool !== undefined && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (pool && typeof pool === 'object' && 'ptr' in pool) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + pool.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (pool && typeof pool === 'object' && 'ptr' in pool) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + pool.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_nth_buffering_range(index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_nth_format(nth: number, format: GstFormatValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_format`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nth', String(nth));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_nth_scheduling_mode(index: number): Promise<GstPadModeValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_scheduling_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_position(format: GstFormatValue): Promise<{ cur?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_scheduling(flags: GstSchedulingFlagsValue): Promise<{ minsize?: number; maxsize?: number; align?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_scheduling`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_seeking(format: GstFormatValue): Promise<{ seekable?: boolean; segment_start?: number; segment_end?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_seeking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_segment(format: GstFormatValue): Promise<{ rate?: number; start_value?: number; stop_value?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_segment`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_selectable(): Promise<{ selectable?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_selectable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_uri(): Promise<{ uri?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_uri`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_uri_redirection(): Promise<{ uri?: string }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_uri_redirection`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_uri_redirection_permanent(): Promise<{ permanent?: boolean }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_uri_redirection_permanent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async remove_nth_allocation_meta(index: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/remove_nth_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_nth_allocation_param(index: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/remove_nth_allocation_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_nth_allocation_pool(index: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/remove_nth_allocation_pool`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_accept_caps_result(result_: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_accept_caps_result`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('result', String(result_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_bitrate(nominal_bitrate: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_bitrate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nominal_bitrate', String(nominal_bitrate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffering_percent(busy: boolean, percent: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_buffering_percent`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('busy', String(busy));
    // Primitive parameter
    url.searchParams.append('percent', String(percent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffering_range(format: GstFormatValue, start: number, stop: number, estimated_total: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    // Primitive parameter
    url.searchParams.append('estimated_total', String(estimated_total));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffering_stats(mode: GstBufferingModeValue, avg_in: number, avg_out: number, buffering_left: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('avg_in', String(avg_in));
    // Primitive parameter
    url.searchParams.append('avg_out', String(avg_out));
    // Primitive parameter
    url.searchParams.append('buffering_left', String(buffering_left));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_caps_result(caps?: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_caps_result`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_context(context?: GstContext): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_convert(src_format: GstFormatValue, src_value: number, dest_format: GstFormatValue, dest_value: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_value', String(src_value));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    // Primitive parameter
    url.searchParams.append('dest_value', String(dest_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_duration(format: GstFormatValue, duration: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_formatsv(n_formats: number, formats: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_formatsv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_formats', String(n_formats));
    // Primitive parameter
    url.searchParams.append('formats', String(formats));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_latency(live: boolean, min_latency: number, max_latency: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_latency`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('live', String(live));
    // Primitive parameter
    url.searchParams.append('min_latency', String(min_latency));
    // Primitive parameter
    url.searchParams.append('max_latency', String(max_latency));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_nth_allocation_param(index: number, allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_nth_allocation_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_nth_allocation_pool(index: number, size: number, min_buffers: number, max_buffers: number, pool?: GstBufferPool): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_nth_allocation_pool`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (pool !== undefined && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_position(format: GstFormatValue, cur: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('cur', String(cur));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_scheduling(flags: GstSchedulingFlagsValue, minsize: number, maxsize: number, align: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_scheduling`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('minsize', String(minsize));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('align', String(align));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_seeking(format: GstFormatValue, seekable: boolean, segment_start: number, segment_end: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_seeking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('seekable', String(seekable));
    // Primitive parameter
    url.searchParams.append('segment_start', String(segment_start));
    // Primitive parameter
    url.searchParams.append('segment_end', String(segment_end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_segment(rate: number, format: GstFormatValue, start_value: number, stop_value: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_segment`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('start_value', String(start_value));
    // Primitive parameter
    url.searchParams.append('stop_value', String(stop_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_selectable(selectable: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_selectable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('selectable', String(selectable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uri(uri?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_uri`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uri_redirection(uri?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_uri_redirection`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uri_redirection_permanent(permanent: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_uri_redirection_permanent`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('permanent', String(permanent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async writable_structure(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstReferenceTimestampMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstreferencetimestampmetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstreferencetimestampmetaRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstReferenceTimestampMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstReferenceTimestampMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async get_info(): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GstRegistry extends GstObject {

  static async fork_is_enabled(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/fork_is_enabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async fork_set_enabled(enabled: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/fork_set_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('enabled', String(enabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get(): Promise<GstRegistry> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstRegistry(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async add_feature(feature: GstPluginFeature): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/add_feature`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (feature && typeof feature === 'object' && 'ptr' in feature) {
      url.searchParams.append('feature', 'ptr,' + feature.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_plugin(plugin: GstPlugin): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/add_plugin`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async check_feature_version(feature_name: string, min_major: number, min_minor: number, min_micro: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/check_feature_version`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature_name', String(feature_name));
    // Primitive parameter
    url.searchParams.append('min_major', String(min_major));
    // Primitive parameter
    url.searchParams.append('min_minor', String(min_minor));
    // Primitive parameter
    url.searchParams.append('min_micro', String(min_micro));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async feature_filter(first: boolean, filter: GstPluginFeatureFilter): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/feature_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('first', String(first));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.filter !== undefined) {
      callbackDispatcher.set(data.filter.toString(), filter);
    }
    return data.return;
  }
  async find_feature(name: string, type_: string): Promise<GstPluginFeature> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/find_feature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPluginFeature(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async find_plugin(name: string): Promise<GstPlugin> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/find_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPlugin(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_feature_list(type_: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/get_feature_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_feature_list_by_plugin(name: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/get_feature_list_by_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_feature_list_cookie(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/get_feature_list_cookie`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_plugin_list(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/get_plugin_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lookup(filename: string): Promise<GstPlugin> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPlugin(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async lookup_feature(name: string): Promise<GstPluginFeature> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/lookup_feature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPluginFeature(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async plugin_filter(first: boolean, filter: GstPluginFilter): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/plugin_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('first', String(first));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.filter !== undefined) {
      callbackDispatcher.set(data.filter.toString(), filter);
    }
    return data.return;
  }
  async remove_feature(feature: GstPluginFeature): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/remove_feature`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (feature && typeof feature === 'object' && 'ptr' in feature) {
      url.searchParams.append('feature', 'ptr,' + feature.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_plugin(plugin: GstPlugin): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/remove_plugin`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async scan_path(path: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/scan_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstRegistryPrivate {
  ptr!: Pointer;


}
export class GstSample {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstsampleRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstsampleRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(buffer?: GstBuffer, caps?: GstCaps, segment?: GstSegment, info?: GstStructure): Promise<GstSample> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer !== undefined && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (segment !== undefined && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (info !== undefined && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstSample();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_buffer(): Promise<GstBuffer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_buffer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_buffer_list(): Promise<GstBufferList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_buffer_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBufferList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_info(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_segment(): Promise<GstSegment> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_segment`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstSegment(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_buffer(buffer: GstBuffer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffer_list(buffer_list: GstBufferList): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_buffer_list`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer_list && typeof buffer_list === 'object' && 'ptr' in buffer_list) {
      url.searchParams.append('buffer_list', 'ptr,' + buffer_list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_caps(caps: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_info(info: GstStructure): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_info`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_segment(segment: GstSegment): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstSegment {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstsegmentRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstsegmentRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstSegment> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstSegment();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clip(format: GstFormatValue, start: number, stop: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/clip`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GstSegment> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstSegment(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy_into(dest: GstSegment): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/copy_into`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async do_seek(rate: number, format: GstFormatValue, flags: GstSeekFlagsValue, start_type: GstSeekTypeValue, start: number, stop_type: GstSeekTypeValue, stop: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/do_seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async init(format: GstFormatValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_equal(s1: GstSegment): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (s1 && typeof s1 === 'object' && 'ptr' in s1) {
      url.searchParams.append('s1', 'ptr,' + s1.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async offset_running_time(format: GstFormatValue, offset: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/offset_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async position_from_running_time(format: GstFormatValue, running_time: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/position_from_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async position_from_running_time_full(format: GstFormatValue, running_time: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/position_from_running_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async position_from_stream_time(format: GstFormatValue, stream_time: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/position_from_stream_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('stream_time', String(stream_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async position_from_stream_time_full(format: GstFormatValue, stream_time: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/position_from_stream_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('stream_time', String(stream_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_running_time(format: GstFormatValue, running_time: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/set_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_position(format: GstFormatValue, running_time: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_running_time(format: GstFormatValue, position: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_running_time_full(format: GstFormatValue, position: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_running_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_stream_time(format: GstFormatValue, position: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_stream_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_stream_time_full(format: GstFormatValue, position: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_stream_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstTaskPool extends GstObject {
  static async new(): Promise<GstTaskPool> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTaskPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async cleanup(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/cleanup`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async dispose_handle(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/dispose_handle`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async join(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async prepare(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/prepare`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push(func: GstTaskPoolFunction): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstSharedTaskPool extends GstTaskPool {
  static async new_2(): Promise<GstSharedTaskPool> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SharedTaskPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstSharedTaskPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_max_threads(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SharedTaskPool/ptr,${this.ptr}/get_max_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_max_threads(max_threads: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SharedTaskPool/ptr,${this.ptr}/set_max_threads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_threads', String(max_threads));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SharedTaskPool/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstSharedTaskPoolPrivate {
  ptr!: Pointer;


}
export class GstStaticCaps {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gststaticcapsRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gststaticcapsRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstStaticCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStaticCaps();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async cleanup(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/cleanup`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GstStaticPadTemplate {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gststaticpadtemplateRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gststaticpadtemplateRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstStaticPadTemplate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStaticPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get(): Promise<GstPadTemplate> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstPadTemplate(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}
export class GstStream extends GstObject {
  static async new(type_: GstStreamTypeValue, flags: GstStreamFlagsValue, stream_id?: string, caps?: GstCaps): Promise<GstStream> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (stream_id !== undefined) url.searchParams.append('stream_id', String(stream_id));
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStream();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_stream_flags(): Promise<GstStreamFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_stream_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_id(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_stream_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_type(): Promise<GstStreamTypeValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_stream_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tags(): Promise<GstTagList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_tags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_caps(caps?: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/set_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_flags(flags: GstStreamFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/set_stream_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_type(stream_type: GstStreamTypeValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/set_stream_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stream_type', String(stream_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_tags(tags?: GstTagList): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/set_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstStreamCollection extends GstObject {
  static async new(upstream_id?: string): Promise<GstStreamCollection> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (upstream_id !== undefined) url.searchParams.append('upstream_id', String(upstream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStreamCollection();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_stream(stream: GstStream): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/ptr,${this.ptr}/add_stream`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (stream && typeof stream === 'object' && 'ptr' in stream) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (stream && typeof stream === 'object' && 'ptr' in stream) {
        await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream(index: number): Promise<GstStream> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/ptr,${this.ptr}/get_stream`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstStream(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  async get_upstream_id(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/ptr,${this.ptr}/get_upstream_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstStreamCollectionPrivate {
  ptr!: Pointer;


}
export class GstStreamPrivate {
  ptr!: Pointer;


}
export class GstStructure {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gststructureRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gststructureRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async from_string(string: string): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStructure();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_empty(name: string): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/new_empty`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStructure();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_string(string: string): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/new_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStructure();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_id_empty(quark: number): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/new_id_empty`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStructure();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async can_intersect(struct2: GstStructure): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/can_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (struct2 && typeof struct2 === 'object' && 'ptr' in struct2) {
      url.searchParams.append('struct2', 'ptr,' + struct2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async filter_and_map_in_place(func: GstStructureFilterMapFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/filter_and_map_in_place`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async fixate(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async fixate_field(field_name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_boolean(field_name: string, target: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_nearest_double(field_name: string, target: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_nearest_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_nearest_fraction(field_name: string, target_numerator: number, target_denominator: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_nearest_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target_numerator', String(target_numerator));
    // Primitive parameter
    url.searchParams.append('target_denominator', String(target_denominator));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_nearest_int(field_name: string, target: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_nearest_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_string(field_name: string, target: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async foreach(func: GstStructureForeachFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get_array(fieldname: string, array: GObjectValueArray): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boolean(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_clock_time(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_clock_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date(fieldname: string, value_: GLibDate): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_date`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date_time(fieldname: string, value_: GstDateTime): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_enum(fieldname: string, enumtype: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Primitive parameter
    url.searchParams.append('enumtype', String(enumtype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_field_type(fieldname: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_field_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_flags(fieldname: string, flags_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_flagset(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_flagset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_fraction(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_list(fieldname: string, array: GObjectValueArray): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name_id(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_name_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string(fieldname: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(fieldname: string): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_field(fieldname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/has_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_field_typed(fieldname: string, type_: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/has_field_typed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_name(name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_get_value(field: number): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async id_has_field(field: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_has_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_has_field_typed(field: number, type_: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_has_field_typed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_set_value(field: number, value_: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async id_take_value(field: number, value_: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_take_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async intersect(struct2: GstStructure): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (struct2 && typeof struct2 === 'object' && 'ptr' in struct2) {
      url.searchParams.append('struct2', 'ptr,' + struct2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_equal(structure2: GstStructure): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure2 && typeof structure2 === 'object' && 'ptr' in structure2) {
      url.searchParams.append('structure2', 'ptr,' + structure2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subset(superset: GstStructure): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/is_subset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (superset && typeof superset === 'object' && 'ptr' in superset) {
      url.searchParams.append('superset', 'ptr,' + superset.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async map_in_place(func: GstStructureMapFunc): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/map_in_place`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async n_fields(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/n_fields`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async nth_field_name(index: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/nth_field_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_all_fields(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/remove_all_fields`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_field(fieldname: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/remove_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async serialize(flags: GstSerializeFlagsValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/serialize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async serialize_full(flags: GstSerializeFlagsValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/serialize_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_array(fieldname: string, array: GObjectValueArray): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_list(fieldname: string, array: GObjectValueArray): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_name(name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_parent_refcount(refcount: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_parent_refcount`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('refcount', String(refcount));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_value(fieldname: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async take_value(fieldname: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/take_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async to_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async take(oldstr_ptr?: GstStructure, newstr?: GstStructure): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (oldstr_ptr !== undefined && typeof oldstr_ptr === 'object' && 'ptr' in oldstr_ptr) {
      url.searchParams.append('oldstr_ptr', 'ptr,' + oldstr_ptr.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newstr !== undefined && typeof newstr === 'object' && 'ptr' in newstr) {
      url.searchParams.append('newstr', 'ptr,' + newstr.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstSystemClock extends GstClock {

  static async obtain(): Promise<GstClock> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SystemClock/obtain`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstClock(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  static async set_default(new_clock?: GstClock): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SystemClock/set_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (new_clock !== undefined && typeof new_clock === 'object' && 'ptr' in new_clock) {
      url.searchParams.append('new_clock', 'ptr,' + new_clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SystemClock/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstSystemClockPrivate {
  ptr!: Pointer;


}
export class GstTagList {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsttaglistRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsttaglistRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_empty(): Promise<GstTagList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/new_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTagList();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_string(str: string): Promise<GstTagList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/new_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTagList();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_value(mode: GstTagMergeModeValue, tag: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/add_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async copy(): Promise<GstTagList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async foreach(func: GstTagForeachFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async get_boolean(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boolean_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_boolean_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date(tag: string, value_: GLibDate): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_date`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date_index(tag: string, index: number, value_: GLibDate): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_date_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date_time(tag: string, value_: GstDateTime): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date_time_index(tag: string, index: number, value_: GstDateTime): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_date_time_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_double_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_float(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_float`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_float_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_float_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_int64_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_int_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pointer(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pointer_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_pointer_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sample(tag: string, sample: GstSample): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_sample`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (sample && typeof sample === 'object' && 'ptr' in sample) {
      url.searchParams.append('sample', 'ptr,' + sample.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sample_index(tag: string, index: number, sample: GstSample): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_sample_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (sample && typeof sample === 'object' && 'ptr' in sample) {
      url.searchParams.append('sample', 'ptr,' + sample.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_scope(): Promise<GstTagScopeValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_scope`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_string_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tag_size(tag: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_tag_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_uint64_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_uint_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value_index(tag: string, index: number): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_value_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert(from: GstTagList, mode: GstTagMergeModeValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (from && typeof from === 'object' && 'ptr' in from) {
      url.searchParams.append('from', 'ptr,' + from.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_empty(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_equal(list2: GstTagList): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list2 && typeof list2 === 'object' && 'ptr' in list2) {
      url.searchParams.append('list2', 'ptr,' + list2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async merge(mode: GstTagMergeModeValue, list2?: GstTagList): Promise<GstTagList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/merge`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list2 !== undefined && typeof list2 === 'object' && 'ptr' in list2) {
      url.searchParams.append('list2', 'ptr,' + list2.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async n_tags(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/n_tags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async nth_tag_name(index: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/nth_tag_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek_string_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/peek_string_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_tag(tag: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/remove_tag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_scope(scope: GstTagScopeValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/set_scope`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope', String(scope));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async to_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async copy_value(dest: GObjectValue, list: GstTagList, tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/copy_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstTask extends GstObject {
  static async new(func: GstTaskFunction): Promise<GstTask> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    const instance = new GstTask();
    Object.assign(instance, data.return || data);
    return instance;
  }

  static async cleanup_all(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/cleanup_all`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_pool(): Promise<GstTaskPool> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/get_pool`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstTaskPool(data.return.ptr, false);
      return instance;
    }
    return data.return;
  }
  async get_state(): Promise<GstTaskStateValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/get_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async join(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pause(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/pause`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async resume(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/resume`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_enter_callback(enter_func: GstTaskThreadFunc): Promise<{ enter_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_enter_callback`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.enter_func !== undefined) {
      callbackDispatcher.set(data.enter_func.toString(), enter_func);
    }
    return data;
  }
  async set_leave_callback(leave_func: GstTaskThreadFunc): Promise<{ leave_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_leave_callback`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.leave_func !== undefined) {
      callbackDispatcher.set(data.leave_func.toString(), leave_func);
    }
    return data;
  }
  async set_lock(mutex: GLibRecMutex): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_lock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mutex && typeof mutex === 'object' && 'ptr' in mutex) {
      url.searchParams.append('mutex', 'ptr,' + mutex.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_pool(pool: GstTaskPool): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_pool`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pool && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_state(state: GstTaskStateValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async start(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async stop(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstTaskPrivate {
  ptr!: Pointer;


}
export class GstTimedValue {
  ptr!: Pointer;


}
export class GstToc {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsttocRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsttocRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(scope: GstTocScopeValue): Promise<GstToc> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope', String(scope));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstToc();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append_entry(entry: GstTocEntry): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/append_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (entry && typeof entry === 'object' && 'ptr' in entry) {
      url.searchParams.append('entry', 'ptr,' + entry.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async dump(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/dump`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async find_entry(uid: string): Promise<GstTocEntry> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/find_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uid', String(uid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTocEntry(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_entries(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/get_entries`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_scope(): Promise<GstTocScopeValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/get_scope`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tags(): Promise<GstTagList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/get_tags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async merge_tags(mode: GstTagMergeModeValue, tags?: GstTagList): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/merge_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_tags(tags?: GstTagList): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/set_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstTocEntry {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsttocentryRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsttocentryRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(type_: GstTocEntryTypeValue, uid: string): Promise<GstTocEntry> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('uid', String(uid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTocEntry();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append_sub_entry(subentry: GstTocEntry): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/append_sub_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (subentry && typeof subentry === 'object' && 'ptr' in subentry) {
      url.searchParams.append('subentry', 'ptr,' + subentry.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_entry_type(): Promise<GstTocEntryTypeValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_entry_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_loop(loop_type: GstTocLoopTypeValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_loop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('loop_type', String(loop_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_parent(): Promise<GstTocEntry> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTocEntry(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_start_stop_times(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_start_stop_times`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sub_entries(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_sub_entries`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tags(): Promise<GstTagList> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_tags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_toc(): Promise<GstToc> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_toc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstToc(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_uid(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_uid`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_alternative(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/is_alternative`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_sequence(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/is_sequence`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async merge_tags(mode: GstTagMergeModeValue, tags?: GstTagList): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/merge_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_loop(loop_type: GstTocLoopTypeValue, repeat_count: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/set_loop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('loop_type', String(loop_type));
    // Primitive parameter
    url.searchParams.append('repeat_count', String(repeat_count));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_start_stop_times(start: number, stop: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/set_start_stop_times`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_tags(tags?: GstTagList): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/set_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstTracer extends GstObject {

  static async register(name: string, type_: string, plugin?: GstPlugin): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Tracer/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Tracer/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstTracerFactory extends GstPluginFeature {

  static async get_list(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerFactory/get_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tracer_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerFactory/ptr,${this.ptr}/get_tracer_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerFactory/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstTracerPrivate {
  ptr!: Pointer;


}
export class GstTracerRecord extends GstObject {

  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerRecord/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstTypeFind {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsttypefindRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsttypefindRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstTypeFind> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTypeFind();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_length(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/get_length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek(offset: number, size: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async suggest(probability: number, caps: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/suggest`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('probability', String(probability));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async suggest_empty_simple(probability: number, media_type: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/suggest_empty_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('probability', String(probability));
    // Primitive parameter
    url.searchParams.append('media_type', String(media_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async register(name: string, rank: number, func: GstTypeFindFunction, plugin?: GstPlugin, extensions?: string, possible_caps?: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    if (extensions !== undefined) url.searchParams.append('extensions', String(extensions));
    // Object with explode=false: serialize as comma-separated
    if (possible_caps !== undefined && typeof possible_caps === 'object' && 'ptr' in possible_caps) {
      url.searchParams.append('possible_caps', 'ptr,' + possible_caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
}
export class GstTypeFindFactory extends GstPluginFeature {

  static async get_list(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/get_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async call_function(find: GstTypeFind): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/ptr,${this.ptr}/call_function`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (find && typeof find === 'object' && 'ptr' in find) {
      url.searchParams.append('find', 'ptr,' + find.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_extensions(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/ptr,${this.ptr}/get_extensions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_function(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/ptr,${this.ptr}/has_function`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstUri {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsturiRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsturiRegistry.unregister(this);
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(port: number, scheme?: string, userinfo?: string, host?: string, path?: string, query?: string, fragment?: string): Promise<GstUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstUri();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append_path(relative_path?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/append_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (relative_path !== undefined) url.searchParams.append('relative_path', String(relative_path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async append_path_segment(path_segment?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/append_path_segment`, apiConfig.baseUrl);
    // Primitive parameter
    if (path_segment !== undefined) url.searchParams.append('path_segment', String(path_segment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async equal(second: GstUri): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (second && typeof second === 'object' && 'ptr' in second) {
      url.searchParams.append('second', 'ptr,' + second.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async from_string_with_base(uri: string): Promise<GstUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/from_string_with_base`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_fragment(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_fragment`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_host(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_host`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_media_fragment_table(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_media_fragment_table`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_path(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_path_segments(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_path_segments`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_path_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_path_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_port(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_port`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_keys(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_keys`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_string_ordered(keys?: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_string_ordered`, apiConfig.baseUrl);
    // Primitive parameter
    if (keys !== undefined) url.searchParams.append('keys', String(keys));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_table(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_table`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_value(query_key: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_scheme(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_scheme`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_userinfo(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_userinfo`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_normalized(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/is_normalized`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_writable(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/is_writable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async join(ref_uri?: GstUri): Promise<GstUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ref_uri !== undefined && typeof ref_uri === 'object' && 'ptr' in ref_uri) {
      url.searchParams.append('ref_uri', 'ptr,' + ref_uri.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async make_writable(): Promise<GstUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/make_writable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async new_with_base(port: number, scheme?: string, userinfo?: string, host?: string, path?: string, query?: string, fragment?: string): Promise<GstUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/new_with_base`, apiConfig.baseUrl);
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async normalize(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/normalize`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_has_key(query_key: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/query_has_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_query_key(query_key: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/remove_query_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_fragment(fragment?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_fragment`, apiConfig.baseUrl);
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_host(host: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_host`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('host', String(host));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_path(path?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_path_segments(path_segments?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_path_segments`, apiConfig.baseUrl);
    // Primitive parameter
    if (path_segments !== undefined) url.searchParams.append('path_segments', String(path_segments));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_path_string(path: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_path_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_port(port: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_port`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('port', String(port));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_query_string(query?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_query_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_query_table(query_table?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_query_table`, apiConfig.baseUrl);
    // Primitive parameter
    if (query_table !== undefined) url.searchParams.append('query_table', String(query_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_query_value(query_key: string, query_value?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_query_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    // Primitive parameter
    if (query_value !== undefined) url.searchParams.append('query_value', String(query_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_scheme(scheme: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_userinfo(userinfo: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_userinfo`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('userinfo', String(userinfo));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_string_with_keys(keys?: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/to_string_with_keys`, apiConfig.baseUrl);
    // Primitive parameter
    if (keys !== undefined) url.searchParams.append('keys', String(keys));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async construct(protocol: string, location: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/construct`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    // Primitive parameter
    url.searchParams.append('location', String(location));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async from_string(uri: string): Promise<GstUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async from_string_escaped(uri: string): Promise<GstUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/from_string_escaped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async get_location(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/get_location`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_protocol(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/get_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async has_protocol(uri: string, protocol: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/has_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async is_valid(uri: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async join_strings(base_uri: string, ref_uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/join_strings`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('base_uri', String(base_uri));
    // Primitive parameter
    url.searchParams.append('ref_uri', String(ref_uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async protocol_is_supported(type_: GstURITypeValue, protocol: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/protocol_is_supported`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async protocol_is_valid(protocol: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/protocol_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstValueArray {
  ptr!: Pointer;


  static async append_and_take_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/append_and_take_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async append_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/append_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_size(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/get_size`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_value(value_: GObjectValue, index: number): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/get_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async init(value_: GObjectValue, prealloc: number): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/init`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('prealloc', String(prealloc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async prepend_value(value_: GObjectValue, prepend_value: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/prepend_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (prepend_value && typeof prepend_value === 'object' && 'ptr' in prepend_value) {
      url.searchParams.append('prepend_value', 'ptr,' + prepend_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstValueList {
  ptr!: Pointer;


  static async append_and_take_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/append_and_take_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async append_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/append_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async concat(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/concat`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_size(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/get_size`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  static async get_value(value_: GObjectValue, index: number): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/get_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async init(value_: GObjectValue, prealloc: number): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/init`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('prealloc', String(prealloc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  static async merge(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/merge`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async prepend_value(value_: GObjectValue, prepend_value: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/prepend_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (prepend_value && typeof prepend_value === 'object' && 'ptr' in prepend_value) {
      url.searchParams.append('prepend_value', 'ptr,' + prepend_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  static async get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export class GstValueTable {
  ptr!: Pointer;


}

export namespace GObject {
  export async function boxed_copy(boxed_type: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/boxed_copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('boxed_type', String(boxed_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function boxed_free(boxed_type: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/boxed_free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('boxed_type', String(boxed_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function boxed_type_register_static(name: string, boxed_copy: GObjectBoxedCopyFunc, boxed_free: GObjectBoxedFreeFunc): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/boxed_type_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.boxed_copy !== undefined) {
      callbackDispatcher.set(data.boxed_copy.toString(), boxed_copy);
    }
    if (data.boxed_free !== undefined) {
      callbackDispatcher.set(data.boxed_free.toString(), boxed_free);
    }
    return data.return;
  }
  export async function cclosure_marshal_BOOLEAN__BOXED_BOXED(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_BOOLEAN__BOXED_BOXED`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_BOOLEAN__FLAGS(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_BOOLEAN__FLAGS`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_STRING__OBJECT_POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_STRING__OBJECT_POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__BOOLEAN(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__BOOLEAN`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__BOXED(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__BOXED`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__CHAR(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__CHAR`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__DOUBLE(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__DOUBLE`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__ENUM(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__ENUM`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__FLAGS(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__FLAGS`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__FLOAT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__FLOAT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__INT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__INT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__LONG(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__LONG`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__OBJECT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__OBJECT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__PARAM(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__PARAM`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__STRING(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__STRING`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__UCHAR(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__UCHAR`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__UINT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__UINT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__UINT_POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__UINT_POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__ULONG(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__ULONG`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__VARIANT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__VARIANT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_VOID__VOID(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__VOID`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function cclosure_marshal_generic(closure: GObjectClosure, return_gvalue: GObjectValue, n_param_values: number, param_values: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_generic`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_gvalue && typeof return_gvalue === 'object' && 'ptr' in return_gvalue) {
      url.searchParams.append('return_gvalue', 'ptr,' + return_gvalue.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function clear_signal_handler(handler_id_ptr: number, instance: GObjectObject): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/clear_signal_handler`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('handler_id_ptr', String(handler_id_ptr));
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function enum_complete_type_info(g_enum_type: string, info: GObjectTypeInfo, const_values: GObjectEnumValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_complete_type_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_enum_type', String(g_enum_type));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (const_values && typeof const_values === 'object' && 'ptr' in const_values) {
      url.searchParams.append('const_values', 'ptr,' + const_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function enum_get_value(enum_class: GObjectEnumClass, value_: number): Promise<GObjectEnumValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_get_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (enum_class && typeof enum_class === 'object' && 'ptr' in enum_class) {
      url.searchParams.append('enum_class', 'ptr,' + enum_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function enum_get_value_by_name(enum_class: GObjectEnumClass, name: string): Promise<GObjectEnumValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_get_value_by_name`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (enum_class && typeof enum_class === 'object' && 'ptr' in enum_class) {
      url.searchParams.append('enum_class', 'ptr,' + enum_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function enum_get_value_by_nick(enum_class: GObjectEnumClass, nick: string): Promise<GObjectEnumValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_get_value_by_nick`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (enum_class && typeof enum_class === 'object' && 'ptr' in enum_class) {
      url.searchParams.append('enum_class', 'ptr,' + enum_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function enum_register_static(name: string, const_static_values: GObjectEnumValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (const_static_values && typeof const_static_values === 'object' && 'ptr' in const_static_values) {
      url.searchParams.append('const_static_values', 'ptr,' + const_static_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function enum_to_string(g_enum_type: string, value_: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_to_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_enum_type', String(g_enum_type));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flags_complete_type_info(g_flags_type: string, info: GObjectTypeInfo, const_values: GObjectFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_complete_type_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_flags_type', String(g_flags_type));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (const_values && typeof const_values === 'object' && 'ptr' in const_values) {
      url.searchParams.append('const_values', 'ptr,' + const_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function flags_get_first_value(flags_class: GObjectFlagsClass, value_: number): Promise<GObjectFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_get_first_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (flags_class && typeof flags_class === 'object' && 'ptr' in flags_class) {
      url.searchParams.append('flags_class', 'ptr,' + flags_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flags_get_value_by_name(flags_class: GObjectFlagsClass, name: string): Promise<GObjectFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_get_value_by_name`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (flags_class && typeof flags_class === 'object' && 'ptr' in flags_class) {
      url.searchParams.append('flags_class', 'ptr,' + flags_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flags_get_value_by_nick(flags_class: GObjectFlagsClass, nick: string): Promise<GObjectFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_get_value_by_nick`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (flags_class && typeof flags_class === 'object' && 'ptr' in flags_class) {
      url.searchParams.append('flags_class', 'ptr,' + flags_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flags_register_static(name: string, const_static_values: GObjectFlagsValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (const_static_values && typeof const_static_values === 'object' && 'ptr' in const_static_values) {
      url.searchParams.append('const_static_values', 'ptr,' + const_static_values.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flags_to_string(flags_type: string, value_: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_to_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function gtype_get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/gtype_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_spec_boolean(name: string, default_value: boolean, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_boxed(name: string, boxed_type: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_boxed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('boxed_type', String(boxed_type));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_char(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_double(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_enum(name: string, enum_type: string, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('enum_type', String(enum_type));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_flags(name: string, flags_type: string, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_float(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_float`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_gtype(name: string, is_a_type: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_gtype`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('is_a_type', String(is_a_type));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_int(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_int64(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_long(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_long`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_object(name: string, object_type: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_object`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('object_type', String(object_type));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_param(name: string, param_type: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('param_type', String(param_type));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_pointer(name: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_string(name: string, flags: GObjectParamFlags, nick?: string, blurb?: string, default_value?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    if (default_value !== undefined) url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_uchar(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_uchar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_uint(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_uint64(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_ulong(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_ulong`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_unichar(name: string, default_value: Pointer, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_variant(name: string, type_: GLibVariantType, flags: GObjectParamFlags, nick?: string, blurb?: string, default_value?: GLibVariant): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_variant`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (default_value !== undefined && typeof default_value === 'object' && 'ptr' in default_value) {
      url.searchParams.append('default_value', 'ptr,' + default_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_type_register_static(name: string, pspec_info: GObjectParamSpecTypeInfo): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_type_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (pspec_info && typeof pspec_info === 'object' && 'ptr' in pspec_info) {
      url.searchParams.append('pspec_info', 'ptr,' + pspec_info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_value_convert(pspec: GObjectParamSpec, src_value: GObjectValue, dest_value: GObjectValue, strict_validation: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_convert`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src_value && typeof src_value === 'object' && 'ptr' in src_value) {
      url.searchParams.append('src_value', 'ptr,' + src_value.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (dest_value && typeof dest_value === 'object' && 'ptr' in dest_value) {
      url.searchParams.append('dest_value', 'ptr,' + dest_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('strict_validation', String(strict_validation));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_value_defaults(pspec: GObjectParamSpec, value_: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_defaults`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_value_is_valid(pspec: GObjectParamSpec, value_: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_is_valid`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_value_set_default(pspec: GObjectParamSpec, value_: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_set_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function param_value_validate(pspec: GObjectParamSpec, value_: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_validate`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_values_cmp(pspec: GObjectParamSpec, value1: GObjectValue, value2: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_values_cmp`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function pointer_type_register_static(name: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/pointer_type_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_accumulator_first_wins(ihint: GObjectSignalInvocationHint, return_accu: GObjectValue, handler_return: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_accumulator_first_wins`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ihint && typeof ihint === 'object' && 'ptr' in ihint) {
      url.searchParams.append('ihint', 'ptr,' + ihint.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_accu && typeof return_accu === 'object' && 'ptr' in return_accu) {
      url.searchParams.append('return_accu', 'ptr,' + return_accu.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (handler_return && typeof handler_return === 'object' && 'ptr' in handler_return) {
      url.searchParams.append('handler_return', 'ptr,' + handler_return.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_accumulator_true_handled(ihint: GObjectSignalInvocationHint, return_accu: GObjectValue, handler_return: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_accumulator_true_handled`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ihint && typeof ihint === 'object' && 'ptr' in ihint) {
      url.searchParams.append('ihint', 'ptr,' + ihint.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_accu && typeof return_accu === 'object' && 'ptr' in return_accu) {
      url.searchParams.append('return_accu', 'ptr,' + return_accu.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (handler_return && typeof handler_return === 'object' && 'ptr' in handler_return) {
      url.searchParams.append('handler_return', 'ptr,' + handler_return.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_add_emission_hook(signal_id: number, detail: number, hook_func: GObjectSignalEmissionHook): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_add_emission_hook`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.hook_func !== undefined) {
      callbackDispatcher.set(data.hook_func.toString(), hook_func);
    }
    return data.return;
  }
  export async function signal_chain_from_overridden(instance_and_params: Pointer, return_value: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_chain_from_overridden`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_and_params', String(instance_and_params));
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_connect_closure(instance: GObjectObject, detailed_signal: string, closure: GObjectClosure, after: boolean): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_connect_closure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    url.searchParams.append('after', String(after));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_connect_closure_by_id(instance: GObjectObject, signal_id: number, detail: number, closure: GObjectClosure, after: boolean): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_connect_closure_by_id`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    url.searchParams.append('after', String(after));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_emitv(instance_and_params: Pointer, signal_id: number, detail: number, return_value: GObjectValue): Promise<{ return_value?: GObjectValue }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_emitv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_and_params', String(instance_and_params));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function signal_get_invocation_hint(instance: GObjectObject): Promise<GObjectSignalInvocationHint> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_get_invocation_hint`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_handler_block(instance: GObjectObject, handler_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_block`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_handler_disconnect(instance: GObjectObject, handler_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_disconnect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_handler_find(instance: GObjectObject, mask: GObjectSignalMatchType, signal_id: number, detail: number, closure?: GObjectClosure): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_find`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure !== undefined && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_handler_is_connected(instance: GObjectObject, handler_id: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_is_connected`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_handler_unblock(instance: GObjectObject, handler_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_unblock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_handlers_block_matched(instance: GObjectObject, mask: GObjectSignalMatchType, signal_id: number, detail: number, closure?: GObjectClosure): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handlers_block_matched`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure !== undefined && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_handlers_destroy(instance: GObjectObject): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handlers_destroy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_handlers_disconnect_matched(instance: GObjectObject, mask: GObjectSignalMatchType, signal_id: number, detail: number, closure?: GObjectClosure): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handlers_disconnect_matched`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure !== undefined && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_handlers_unblock_matched(instance: GObjectObject, mask: GObjectSignalMatchType, signal_id: number, detail: number, closure?: GObjectClosure): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handlers_unblock_matched`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure !== undefined && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_has_handler_pending(instance: GObjectObject, signal_id: number, detail: number, may_be_blocked: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_has_handler_pending`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Primitive parameter
    url.searchParams.append('may_be_blocked', String(may_be_blocked));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_is_valid_name(name: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_is_valid_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_list_ids(itype: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_list_ids`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_lookup(name: string, itype: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_name(signal_id: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_newv(signal_name: string, itype: string, signal_flags: GObjectSignalFlags, return_type: string, n_params: number, accumulator: GObjectSignalAccumulator, c_marshaller: GObjectClosureMarshal, class_closure?: GObjectClosure, param_types?: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_newv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_name', String(signal_name));
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    // Primitive parameter
    url.searchParams.append('signal_flags', String(signal_flags));
    // Object with explode=false: serialize as comma-separated
    if (class_closure !== undefined && typeof class_closure === 'object' && 'ptr' in class_closure) {
      url.searchParams.append('class_closure', 'ptr,' + class_closure.ptr);
    }
    // Primitive parameter
    url.searchParams.append('return_type', String(return_type));
    // Primitive parameter
    url.searchParams.append('n_params', String(n_params));
    // Primitive parameter
    if (param_types !== undefined) url.searchParams.append('param_types', String(param_types));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.accumulator !== undefined) {
      callbackDispatcher.set(data.accumulator.toString(), accumulator);
    }
    if (data.c_marshaller !== undefined) {
      callbackDispatcher.set(data.c_marshaller.toString(), c_marshaller);
    }
    return data.return;
  }
  export async function signal_override_class_closure(signal_id: number, instance_type: string, class_closure: GObjectClosure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_override_class_closure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Object with explode=false: serialize as comma-separated
    if (class_closure && typeof class_closure === 'object' && 'ptr' in class_closure) {
      url.searchParams.append('class_closure', 'ptr,' + class_closure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_override_class_handler(signal_name: string, instance_type: string, class_handler: GObjectCallback): Promise<{ class_handler?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_override_class_handler`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_name', String(signal_name));
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.class_handler !== undefined) {
      callbackDispatcher.set(data.class_handler.toString(), class_handler);
    }
    return data;
  }
  export async function signal_parse_name(detailed_signal: string, itype: string, force_detail_quark: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_parse_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    // Primitive parameter
    url.searchParams.append('force_detail_quark', String(force_detail_quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function signal_query(signal_id: number, query: GObjectSignalQuery): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_query`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_remove_emission_hook(signal_id: number, hook_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_remove_emission_hook`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('hook_id', String(hook_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_set_va_marshaller(signal_id: number, instance_type: string, va_marshaller: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_set_va_marshaller`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('va_marshaller', String(va_marshaller));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_stop_emission(instance: GObjectObject, signal_id: number, detail: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_stop_emission`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_stop_emission_by_name(instance: GObjectObject, detailed_signal: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_stop_emission_by_name`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function signal_type_cclosure_new(itype: string, struct_offset: number): Promise<GObjectClosure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_type_cclosure_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    // Primitive parameter
    url.searchParams.append('struct_offset', String(struct_offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectClosure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function source_set_closure(source: GLibSource, closure: GObjectClosure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/source_set_closure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (source && typeof source === 'object' && 'ptr' in source) {
      url.searchParams.append('source', 'ptr,' + source.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function source_set_dummy_callback(source: GLibSource): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/source_set_dummy_callback`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (source && typeof source === 'object' && 'ptr' in source) {
      url.searchParams.append('source', 'ptr,' + source.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function strdup_value_contents(value_: GObjectValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/strdup_value_contents`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_add_class_private(class_type: string, private_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_add_class_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('class_type', String(class_type));
    // Primitive parameter
    url.searchParams.append('private_size', String(private_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_add_instance_private(class_type: string, private_size: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_add_instance_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('class_type', String(class_type));
    // Primitive parameter
    url.searchParams.append('private_size', String(private_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_add_interface_dynamic(instance_type: string, interface_type: string, plugin: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_add_interface_dynamic`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Primitive parameter
    url.searchParams.append('plugin', String(plugin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_add_interface_static(instance_type: string, interface_type: string, info: GObjectInterfaceInfo): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_add_interface_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_check_class_is_a(g_class: GObjectTypeClass, is_a_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_class_is_a`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_class && typeof g_class === 'object' && 'ptr' in g_class) {
      url.searchParams.append('g_class', 'ptr,' + g_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('is_a_type', String(is_a_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_check_instance(instance: GObjectTypeInstance): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_instance`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_check_instance_is_a(instance: GObjectTypeInstance, iface_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_instance_is_a`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('iface_type', String(iface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_check_instance_is_fundamentally_a(instance: GObjectTypeInstance, fundamental_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_instance_is_fundamentally_a`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('fundamental_type', String(fundamental_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_check_is_value_type(type_: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_is_value_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_check_value(value_: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_check_value_holds(value_: GObjectValue, type_: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_value_holds`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_children(type_: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_children`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_class_adjust_private_offset(private_size_or_offset: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_class_adjust_private_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_size_or_offset', String(private_size_or_offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_class_peek(type_: string): Promise<GObjectTypeClass> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_class_peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function type_class_peek_static(type_: string): Promise<GObjectTypeClass> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_class_peek_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function type_class_ref(type_: string): Promise<GObjectTypeClass> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_class_ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function type_default_interface_peek(g_type: string): Promise<GObjectTypeInterface> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_default_interface_peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_type', String(g_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeInterface(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function type_default_interface_ref(g_type: string): Promise<GObjectTypeInterface> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_default_interface_ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_type', String(g_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeInterface(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function type_default_interface_unref(g_iface: GObjectTypeInterface): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_default_interface_unref`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_depth(type_: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_depth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_ensure(type_: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_ensure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_free_instance(instance: GObjectTypeInstance): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_free_instance`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_from_name(name: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_from_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_fundamental(type_id: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_fundamental`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_id', String(type_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_fundamental_next(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_fundamental_next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_get_instance_count(type_: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_get_instance_count`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_get_plugin(type_: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_get_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_get_qdata(type_: string, quark: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_get_type_registration_serial(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_get_type_registration_serial`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_init(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_init_with_debug_flags(debug_flags: GObjectTypeDebugFlags): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_init_with_debug_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('debug_flags', String(debug_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_interface_add_prerequisite(interface_type: string, prerequisite_type: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_add_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Primitive parameter
    url.searchParams.append('prerequisite_type', String(prerequisite_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_interface_get_plugin(instance_type: string, interface_type: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_get_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_interface_instantiatable_prerequisite(interface_type: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_instantiatable_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_interface_peek(instance_class: GObjectTypeClass, iface_type: string): Promise<GObjectTypeInterface> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_peek`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance_class && typeof instance_class === 'object' && 'ptr' in instance_class) {
      url.searchParams.append('instance_class', 'ptr,' + instance_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('iface_type', String(iface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeInterface(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function type_interface_prerequisites(interface_type: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_prerequisites`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_interfaces(type_: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interfaces`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_is_a(type_: string, is_a_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_is_a`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('is_a_type', String(is_a_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_name(type_: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_name_from_class(g_class: GObjectTypeClass): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_name_from_class`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_class && typeof g_class === 'object' && 'ptr' in g_class) {
      url.searchParams.append('g_class', 'ptr,' + g_class.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_name_from_instance(instance: GObjectTypeInstance): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_name_from_instance`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_next_base(leaf_type: string, root_type: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_next_base`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('leaf_type', String(leaf_type));
    // Primitive parameter
    url.searchParams.append('root_type', String(root_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_parent(type_: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_parent`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_qname(type_: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_qname`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_query(type_: string, query: GObjectTypeQuery): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_query`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_register_dynamic(parent_type: string, type_name: string, plugin: Pointer, flags: GObjectTypeFlags): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_register_dynamic`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('parent_type', String(parent_type));
    // Primitive parameter
    url.searchParams.append('type_name', String(type_name));
    // Primitive parameter
    url.searchParams.append('plugin', String(plugin));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_register_fundamental(type_id: string, type_name: string, info: GObjectTypeInfo, finfo: GObjectTypeFundamentalInfo, flags: GObjectTypeFlags): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_register_fundamental`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_id', String(type_id));
    // Primitive parameter
    url.searchParams.append('type_name', String(type_name));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (finfo && typeof finfo === 'object' && 'ptr' in finfo) {
      url.searchParams.append('finfo', 'ptr,' + finfo.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_register_static(parent_type: string, type_name: string, info: GObjectTypeInfo, flags: GObjectTypeFlags): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('parent_type', String(parent_type));
    // Primitive parameter
    url.searchParams.append('type_name', String(type_name));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_set_qdata(type_: string, quark: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_set_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function type_test_flags(type_: string, flags: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_test_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_type_compatible(src_type: string, dest_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/value_type_compatible`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_type_transformable(src_type: string, dest_type: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/value_type_transformable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_get_gtype(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/variant_get_gtype`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function module_build_path(module_name: string, directory?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/module_build_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (directory !== undefined) url.searchParams.append('directory', String(directory));
    // Primitive parameter
    url.searchParams.append('module_name', String(module_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function module_error(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/module_error`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function module_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/module_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function module_supported(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/module_supported`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function access(filename: Pointer, mode: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/access`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function aligned_alloc(n_blocks: number, n_block_bytes: number, alignment: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/aligned_alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    // Primitive parameter
    url.searchParams.append('alignment', String(alignment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function aligned_alloc0(n_blocks: number, n_block_bytes: number, alignment: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/aligned_alloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    // Primitive parameter
    url.searchParams.append('alignment', String(alignment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function aligned_free(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/aligned_free`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function aligned_free_sized(alignment: number, size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/aligned_free_sized`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('alignment', String(alignment));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function ascii_digit_value(c: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_digit_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_dtostr(buffer: string, buf_len: number, d: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_dtostr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buffer', String(buffer));
    // Primitive parameter
    url.searchParams.append('buf_len', String(buf_len));
    // Primitive parameter
    url.searchParams.append('d', String(d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_formatd(buffer: string, buf_len: number, format: string, d: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_formatd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buffer', String(buffer));
    // Primitive parameter
    url.searchParams.append('buf_len', String(buf_len));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('d', String(d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_strcasecmp(s1: string, s2: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strcasecmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_strdown(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strdown`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_string_to_signed(str: string, base: number, min: number, max: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_string_to_signed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('base', String(base));
    // Primitive parameter
    url.searchParams.append('min', String(min));
    // Primitive parameter
    url.searchParams.append('max', String(max));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_string_to_unsigned(str: string, base: number, min: number, max: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_string_to_unsigned`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('base', String(base));
    // Primitive parameter
    url.searchParams.append('min', String(min));
    // Primitive parameter
    url.searchParams.append('max', String(max));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_strncasecmp(s1: string, s2: string, n: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strncasecmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_strtod(nptr: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strtod`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nptr', String(nptr));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_strtoll(nptr: string, base: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strtoll`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nptr', String(nptr));
    // Primitive parameter
    url.searchParams.append('base', String(base));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_strtoull(nptr: string, base: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strtoull`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nptr', String(nptr));
    // Primitive parameter
    url.searchParams.append('base', String(base));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_strup(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_tolower(c: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_tolower`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_toupper(c: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_toupper`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ascii_xdigit_value(c: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_xdigit_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function assert_warning(log_domain: string, file: string, line: number, pretty_function: string, expression: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assert_warning`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('pretty_function', String(pretty_function));
    // Primitive parameter
    url.searchParams.append('expression', String(expression));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function assertion_message(domain: string, file: string, line: number, func: string, message: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function assertion_message_cmpint(domain: string, file: string, line: number, func: string, expr: string, arg1: number, cmp: string, arg2: number, numtype: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message_cmpint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('expr', String(expr));
    // Primitive parameter
    url.searchParams.append('arg1', String(arg1));
    // Primitive parameter
    url.searchParams.append('cmp', String(cmp));
    // Primitive parameter
    url.searchParams.append('arg2', String(arg2));
    // Primitive parameter
    url.searchParams.append('numtype', String(numtype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function assertion_message_cmpstr(domain: string, file: string, line: number, func: string, expr: string, arg1: string, cmp: string, arg2: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message_cmpstr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('expr', String(expr));
    // Primitive parameter
    url.searchParams.append('arg1', String(arg1));
    // Primitive parameter
    url.searchParams.append('cmp', String(cmp));
    // Primitive parameter
    url.searchParams.append('arg2', String(arg2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function assertion_message_cmpstrv(domain: string, file: string, line: number, func: string, expr: string, arg1: string, arg2: string, first_wrong_idx: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message_cmpstrv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('expr', String(expr));
    // Primitive parameter
    url.searchParams.append('arg1', String(arg1));
    // Primitive parameter
    url.searchParams.append('arg2', String(arg2));
    // Primitive parameter
    url.searchParams.append('first_wrong_idx', String(first_wrong_idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function assertion_message_error(domain: string, file: string, line: number, func: string, expr: string, error_: Pointer, error_domain: number, error_code: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('expr', String(expr));
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('error_domain', String(error_domain));
    // Primitive parameter
    url.searchParams.append('error_code', String(error_code));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atexit(func: GLibVoidFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atexit`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function atomic_int_add(atomic: number, val: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_int_and(atomic: number, val: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_and`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_int_compare_and_exchange(atomic: number, oldval: number, newval: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_compare_and_exchange`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('oldval', String(oldval));
    // Primitive parameter
    url.searchParams.append('newval', String(newval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_int_compare_and_exchange_full(atomic: number, oldval: number, newval: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_compare_and_exchange_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('oldval', String(oldval));
    // Primitive parameter
    url.searchParams.append('newval', String(newval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_int_dec_and_test(atomic: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_dec_and_test`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_int_exchange(atomic: number, newval: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_exchange`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('newval', String(newval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_int_exchange_and_add(atomic: number, val: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_exchange_and_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_int_get(atomic: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_get`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_int_inc(atomic: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_inc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_int_or(atomic: number, val: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_or`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_int_set(atomic: number, newval: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_set`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('newval', String(newval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_int_xor(atomic: number, val: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_xor`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_pointer_add(val: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_pointer_and(val: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_and`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_pointer_compare_and_exchange(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_compare_and_exchange`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_pointer_compare_and_exchange_full(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_compare_and_exchange_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_pointer_exchange(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_exchange`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_pointer_get(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_pointer_or(val: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_or`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_pointer_set(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_set`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_pointer_xor(val: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_xor`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_rc_box_acquire(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_acquire`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_rc_box_alloc(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_rc_box_alloc0(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_alloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_rc_box_dup(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_dup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_rc_box_get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_rc_box_release(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_release`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_rc_box_release_full(clear_func: GLibDestroyNotify): Promise<{ clear_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_release_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.clear_func !== undefined) {
      callbackDispatcher.set(data.clear_func.toString(), clear_func);
    }
    return data;
  }
  export async function atomic_ref_count_compare(arc: number, val: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_ref_count_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arc', String(arc));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_ref_count_dec(arc: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_ref_count_dec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arc', String(arc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function atomic_ref_count_inc(arc: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_ref_count_inc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arc', String(arc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function atomic_ref_count_init(arc: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_ref_count_init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arc', String(arc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function base64_decode(text: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_decode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function base64_decode_inplace(text: Pointer, out_len: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_decode_inplace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    url.searchParams.append('out_len', String(out_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function base64_encode(len: number, data_?: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_encode`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function base64_encode_close(break_lines: boolean, state: number, save: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_encode_close`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('break_lines', String(break_lines));
    // Primitive parameter
    url.searchParams.append('state', String(state));
    // Primitive parameter
    url.searchParams.append('save', String(save));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function base64_encode_step(in_: Pointer, len: number, break_lines: boolean, state: number, save: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_encode_step`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('in', String(in_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('break_lines', String(break_lines));
    // Primitive parameter
    url.searchParams.append('state', String(state));
    // Primitive parameter
    url.searchParams.append('save', String(save));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function basename(file_name: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/basename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function bit_lock(address: number, lock_bit: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_lock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function bit_nth_lsf(mask: number, nth_bit: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_nth_lsf`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('nth_bit', String(nth_bit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function bit_nth_msf(mask: number, nth_bit: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_nth_msf`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('nth_bit', String(nth_bit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function bit_storage(number: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_storage`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('number', String(number));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function bit_trylock(address: number, lock_bit: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_trylock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function bit_unlock(address: number, lock_bit: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_unlock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function blow_chunks(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/blow_chunks`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function bookmark_file_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bookmark_file_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function build_filenamev(args: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/build_filenamev`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('args', String(args));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function build_pathv(separator: string, args: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/build_pathv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('separator', String(separator));
    // Primitive parameter
    url.searchParams.append('args', String(args));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_append(array: Pointer, data_: number, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_append`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_free(array: Pointer, free_segment: boolean): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('free_segment', String(free_segment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_free_to_bytes(array: Pointer): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_free_to_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function byte_array_new(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_new_take(data_: Pointer, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_new_take`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_prepend(array: Pointer, data_: number, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_prepend`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_ref(array: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_remove_index(array: Pointer, index_: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_remove_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_remove_index_fast(array: Pointer, index_: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_remove_index_fast`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_remove_range(array: Pointer, index_: number, length: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_remove_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_set_size(array: Pointer, length: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_set_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_sized_new(reserved_size: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_sized_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('reserved_size', String(reserved_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_sort(array: Pointer, compare_func: GLibCompareFunc): Promise<{ compare_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_sort`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.compare_func !== undefined) {
      callbackDispatcher.set(data.compare_func.toString(), compare_func);
    }
    return data;
  }
  export async function byte_array_sort_with_data(array: Pointer, compare_func: GLibCompareDataFunc): Promise<{ compare_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_sort_with_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.compare_func !== undefined) {
      callbackDispatcher.set(data.compare_func.toString(), compare_func);
    }
    return data;
  }
  export async function byte_array_steal(array: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function byte_array_unref(array: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function canonicalize_filename(filename: Pointer, relative_to?: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/canonicalize_filename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    if (relative_to !== undefined) url.searchParams.append('relative_to', String(relative_to));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function chdir(path: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/chdir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function check_version(required_major: number, required_minor: number, required_micro: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/check_version`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('required_major', String(required_major));
    // Primitive parameter
    url.searchParams.append('required_minor', String(required_minor));
    // Primitive parameter
    url.searchParams.append('required_micro', String(required_micro));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function checksum_type_get_length(checksum_type: GLibChecksumType): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/checksum_type_get_length`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function child_watch_add(priority: number, pid: number, function_: GLibChildWatchFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/child_watch_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('pid', String(pid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.function !== undefined) {
      callbackDispatcher.set(data.function.toString(), function_);
    }
    return data.return;
  }
  export async function child_watch_source_new(pid: number): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/child_watch_source_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pid', String(pid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function chmod(filename: Pointer, mode: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/chmod`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function clear_error(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/clear_error`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function close(fd: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/close`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function closefrom(lowfd: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/closefrom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lowfd', String(lowfd));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function compute_checksum_for_bytes(checksum_type: GLibChecksumType, data_: GLibBytes): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_checksum_for_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function compute_checksum_for_data(checksum_type: GLibChecksumType, data_: Pointer, length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_checksum_for_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function compute_checksum_for_string(checksum_type: GLibChecksumType, str: string, length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_checksum_for_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function compute_hmac_for_bytes(digest_type: GLibChecksumType, key: GLibBytes, data_: GLibBytes): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_hmac_for_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('digest_type', String(digest_type));
    // Object with explode=false: serialize as comma-separated
    if (key && typeof key === 'object' && 'ptr' in key) {
      url.searchParams.append('key', 'ptr,' + key.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function compute_hmac_for_data(digest_type: GLibChecksumType, key: Pointer, key_len: number, data_: Pointer, length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_hmac_for_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('digest_type', String(digest_type));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('key_len', String(key_len));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function compute_hmac_for_string(digest_type: GLibChecksumType, key: Pointer, key_len: number, str: string, length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_hmac_for_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('digest_type', String(digest_type));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('key_len', String(key_len));
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function convert(str: Pointer, len: number, to_codeset: string, from_codeset: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('to_codeset', String(to_codeset));
    // Primitive parameter
    url.searchParams.append('from_codeset', String(from_codeset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function convert_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/convert_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function convert_with_fallback(str: Pointer, len: number, to_codeset: string, from_codeset: string, fallback: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/convert_with_fallback`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('to_codeset', String(to_codeset));
    // Primitive parameter
    url.searchParams.append('from_codeset', String(from_codeset));
    // Primitive parameter
    url.searchParams.append('fallback', String(fallback));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function creat(filename: Pointer, mode: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/creat`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function datalist_foreach(datalist: GLibData, func: GLibDataForeachFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_foreach`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function datalist_get_data(datalist: GLibData, key: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_get_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function datalist_get_flags(datalist: GLibData): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_get_flags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function datalist_id_get_data(datalist: GLibData, key_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_id_get_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('key_id', String(key_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function datalist_id_remove_multiple(datalist: GLibData, keys: Pointer, n_keys: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_id_remove_multiple`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('keys', String(keys));
    // Primitive parameter
    url.searchParams.append('n_keys', String(n_keys));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function datalist_set_flags(datalist: GLibData, flags: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_set_flags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function datalist_unset_flags(datalist: GLibData, flags: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_unset_flags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function dataset_destroy(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dataset_destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function dataset_foreach(func: GLibDataForeachFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dataset_foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function dataset_id_get_data(key_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dataset_id_get_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key_id', String(key_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function date_get_days_in_month(month: GLibDateMonth, year: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_get_days_in_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_get_monday_weeks_in_year(year: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_get_monday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_get_sunday_weeks_in_year(year: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_get_sunday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_is_leap_year(year: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_is_leap_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_strftime(s: string, slen: number, format: string, date: GLibDate): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_strftime`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s', String(s));
    // Primitive parameter
    url.searchParams.append('slen', String(slen));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Object with explode=false: serialize as comma-separated
    if (date && typeof date === 'object' && 'ptr' in date) {
      url.searchParams.append('date', 'ptr,' + date.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_valid_day(day: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_day`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_valid_dmy(day: number, month: GLibDateMonth, year: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_valid_julian(julian_date: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_date', String(julian_date));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_valid_month(month: GLibDateMonth): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_valid_weekday(weekday: GLibDateWeekday): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_weekday`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('weekday', String(weekday));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function date_valid_year(year: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function dcgettext(msgid: string, category: number, domain?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dcgettext`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    // Primitive parameter
    url.searchParams.append('category', String(category));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function dgettext(msgid: string, domain?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dgettext`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function dir_make_tmp(tmpl?: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dir_make_tmp`, apiConfig.baseUrl);
    // Primitive parameter
    if (tmpl !== undefined) url.searchParams.append('tmpl', String(tmpl));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function direct_equal(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/direct_equal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function direct_hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/direct_hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function dngettext(msgid: string, msgid_plural: string, n: number, domain?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dngettext`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    // Primitive parameter
    url.searchParams.append('msgid_plural', String(msgid_plural));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function double_equal(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/double_equal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function double_hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/double_hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function dpgettext(msgctxtid: string, msgidoffset: number, domain?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dpgettext`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('msgctxtid', String(msgctxtid));
    // Primitive parameter
    url.searchParams.append('msgidoffset', String(msgidoffset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function dpgettext2(context: string, msgid: string, domain?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dpgettext2`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('context', String(context));
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function environ_getenv(variable: Pointer, envp?: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/environ_getenv`, apiConfig.baseUrl);
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function environ_setenv(variable: Pointer, value_: Pointer, overwrite: boolean, envp?: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/environ_setenv`, apiConfig.baseUrl);
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    // Primitive parameter
    url.searchParams.append('overwrite', String(overwrite));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function environ_unsetenv(variable: Pointer, envp?: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/environ_unsetenv`, apiConfig.baseUrl);
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function error_domain_register(error_type_name: string, error_type_private_size: number, error_type_init: GLibErrorInitFunc, error_type_copy: GLibErrorCopyFunc, error_type_clear: GLibErrorClearFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/error_domain_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error_type_name', String(error_type_name));
    // Primitive parameter
    url.searchParams.append('error_type_private_size', String(error_type_private_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.error_type_init !== undefined) {
      callbackDispatcher.set(data.error_type_init.toString(), error_type_init);
    }
    if (data.error_type_copy !== undefined) {
      callbackDispatcher.set(data.error_type_copy.toString(), error_type_copy);
    }
    if (data.error_type_clear !== undefined) {
      callbackDispatcher.set(data.error_type_clear.toString(), error_type_clear);
    }
    return data.return;
  }
  export async function error_domain_register_static(error_type_name: string, error_type_private_size: number, error_type_init: GLibErrorInitFunc, error_type_copy: GLibErrorCopyFunc, error_type_clear: GLibErrorClearFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/error_domain_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error_type_name', String(error_type_name));
    // Primitive parameter
    url.searchParams.append('error_type_private_size', String(error_type_private_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.error_type_init !== undefined) {
      callbackDispatcher.set(data.error_type_init.toString(), error_type_init);
    }
    if (data.error_type_copy !== undefined) {
      callbackDispatcher.set(data.error_type_copy.toString(), error_type_copy);
    }
    if (data.error_type_clear !== undefined) {
      callbackDispatcher.set(data.error_type_clear.toString(), error_type_clear);
    }
    return data.return;
  }
  export async function fdwalk_set_cloexec(lowfd: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/fdwalk_set_cloexec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lowfd', String(lowfd));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function file_error_from_errno(err_no: number): Promise<GLibFileError> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_error_from_errno`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('err_no', String(err_no));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function file_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function file_get_contents(filename: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_get_contents`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function file_open_tmp(tmpl?: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_open_tmp`, apiConfig.baseUrl);
    // Primitive parameter
    if (tmpl !== undefined) url.searchParams.append('tmpl', String(tmpl));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function file_read_link(filename: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_read_link`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function file_set_contents(filename: Pointer, contents: Pointer, length: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_set_contents`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('contents', String(contents));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function file_set_contents_full(filename: Pointer, contents: Pointer, length: number, flags: GLibFileSetContentsFlags, mode: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_set_contents_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('contents', String(contents));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function file_test(filename: Pointer, test: GLibFileTest): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_test`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('test', String(test));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function filename_display_basename(filename: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_display_basename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function filename_display_name(filename: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_display_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function filename_from_uri(uri: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_from_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function filename_from_utf8(utf8string: string, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_from_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('utf8string', String(utf8string));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function filename_to_uri(filename: Pointer, hostname?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_to_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    if (hostname !== undefined) url.searchParams.append('hostname', String(hostname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function filename_to_utf8(opsysstring: Pointer, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('opsysstring', String(opsysstring));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function find_program_in_path(program: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/find_program_in_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('program', String(program));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function fopen(filename: Pointer, mode: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/fopen`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function format_size(size: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/format_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_size_for_display(size: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/format_size_for_display`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_size_full(size: number, flags: GLibFormatSizeFlags): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/format_size_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function free(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/free`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function free_sized(size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/free_sized`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function freopen(filename: Pointer, mode: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/freopen`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function fsync(fd: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/fsync`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_application_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_application_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_charset(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_charset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_codeset(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_codeset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_console_charset(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_console_charset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_current_dir(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_current_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_current_time(result_: GLibTimeVal): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_current_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (result_ && typeof result_ === 'object' && 'ptr' in result_) {
      url.searchParams.append('result', 'ptr,' + result_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function get_environ(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_environ`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_filename_charsets(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_filename_charsets`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_home_dir(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_home_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_host_name(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_host_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_language_names(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_language_names`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_language_names_with_category(category_name: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_language_names_with_category`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('category_name', String(category_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_locale_variants(locale: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_locale_variants`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('locale', String(locale));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_monotonic_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_monotonic_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_num_processors(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_num_processors`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_os_info(key_name: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_os_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key_name', String(key_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_prgname(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_prgname`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_real_name(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_real_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_real_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_real_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_system_config_dirs(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_system_config_dirs`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_system_data_dirs(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_system_data_dirs`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_tmp_dir(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_tmp_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_user_cache_dir(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_cache_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_user_config_dir(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_config_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_user_data_dir(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_data_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_user_name(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_user_runtime_dir(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_runtime_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_user_special_dir(directory: GLibUserDirectory): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_special_dir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('directory', String(directory));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_user_state_dir(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_state_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function getenv(variable: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/getenv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_add(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_contains(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_destroy(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_destroy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hash_table_find(hash_table: Pointer, predicate: GLibHRFunc): Promise<{ predicate?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.predicate !== undefined) {
      callbackDispatcher.set(data.predicate.toString(), predicate);
    }
    return data;
  }
  export async function hash_table_foreach(hash_table: Pointer, func: GLibHFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_foreach`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function hash_table_foreach_remove(hash_table: Pointer, func: GLibHRFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_foreach_remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  export async function hash_table_foreach_steal(hash_table: Pointer, func: GLibHRFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_foreach_steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  export async function hash_table_insert(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_lookup(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hash_table_lookup_extended(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_lookup_extended`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_new_similar(other_hash_table: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_new_similar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('other_hash_table', String(other_hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_ref(hash_table: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_remove(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_remove_all(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_remove_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hash_table_replace(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_replace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_size(hash_table: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_steal(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_steal_all(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_steal_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hash_table_steal_extended(hash_table: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_steal_extended`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hash_table_unref(hash_table: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hook_destroy(hook_list: GLibHookList, hook_id: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_destroy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('hook_id', String(hook_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hook_destroy_link(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_destroy_link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hook_free(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_free`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hook_insert_before(hook_list: GLibHookList, hook: GLibHook, sibling?: GLibHook): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_insert_before`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (sibling !== undefined && typeof sibling === 'object' && 'ptr' in sibling) {
      url.searchParams.append('sibling', 'ptr,' + sibling.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hook_insert_sorted(hook_list: GLibHookList, hook: GLibHook, func: GLibHookCompareFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_insert_sorted`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function hook_prepend(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_prepend`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hook_unref(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_unref`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function hostname_is_ascii_encoded(hostname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_is_ascii_encoded`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hostname_is_ip_address(hostname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_is_ip_address`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hostname_is_non_ascii(hostname: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_is_non_ascii`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hostname_to_ascii(hostname: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_to_ascii`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function hostname_to_unicode(hostname: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_to_unicode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function idle_add(priority: number, function_: GLibSourceFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/idle_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.function !== undefined) {
      callbackDispatcher.set(data.function.toString(), function_);
    }
    return data.return;
  }
  export async function idle_remove_by_data(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/idle_remove_by_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function idle_source_new(): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/idle_source_new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function int64_equal(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/int64_equal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function int64_hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/int64_hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function int_equal(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/int_equal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function int_hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/int_hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function intern_static_string(string?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/intern_static_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function intern_string(string?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/intern_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function io_add_watch(channel: GLibIOChannel, priority: number, condition: GLibIOConditionValue, func: GLibIOFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/io_add_watch`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (channel && typeof channel === 'object' && 'ptr' in channel) {
      url.searchParams.append('channel', 'ptr,' + channel.ptr);
    }
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('condition', String(condition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  export async function io_channel_error_from_errno(en: number): Promise<GLibIOChannelError> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/io_channel_error_from_errno`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('en', String(en));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function io_channel_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/io_channel_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function io_create_watch(channel: GLibIOChannel, condition: GLibIOConditionValue): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/io_create_watch`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (channel && typeof channel === 'object' && 'ptr' in channel) {
      url.searchParams.append('channel', 'ptr,' + channel.ptr);
    }
    // Primitive parameter
    url.searchParams.append('condition', String(condition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function key_file_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/key_file_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function list_pop_allocator(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/list_pop_allocator`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function list_push_allocator(allocator: GLibAllocator): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/list_push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function listenv(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/listenv`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function locale_from_utf8(utf8string: string, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/locale_from_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('utf8string', String(utf8string));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function locale_to_utf8(opsysstring: Pointer, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/locale_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('opsysstring', String(opsysstring));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_default_handler(log_level: GLibLogLevelFlags, log_domain?: string, message?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_default_handler`, apiConfig.baseUrl);
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    if (message !== undefined) url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function log_get_debug_enabled(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_get_debug_enabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_remove_handler(log_domain: string, handler_id: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_remove_handler`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function log_set_always_fatal(fatal_mask: GLibLogLevelFlags): Promise<GLibLogLevelFlags> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_always_fatal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fatal_mask', String(fatal_mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_set_debug_enabled(enabled: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_debug_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('enabled', String(enabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function log_set_fatal_mask(log_domain: string, fatal_mask: GLibLogLevelFlags): Promise<GLibLogLevelFlags> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_fatal_mask`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('fatal_mask', String(fatal_mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_set_handler(log_levels: GLibLogLevelFlags, log_func: GLibLogFunc, log_domain?: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_handler`, apiConfig.baseUrl);
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('log_levels', String(log_levels));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.log_func !== undefined) {
      callbackDispatcher.set(data.log_func.toString(), log_func);
    }
    return data.return;
  }
  export async function log_set_writer_func(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_writer_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function log_structured_array(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_structured_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function log_variant(log_level: GLibLogLevelFlags, fields: GLibVariant, log_domain?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_variant`, apiConfig.baseUrl);
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Object with explode=false: serialize as comma-separated
    if (fields && typeof fields === 'object' && 'ptr' in fields) {
      url.searchParams.append('fields', 'ptr,' + fields.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function log_writer_default(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number): Promise<GLibLogWriterOutput> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_default`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_writer_default_set_debug_domains(domains?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_default_set_debug_domains`, apiConfig.baseUrl);
    // Primitive parameter
    if (domains !== undefined) url.searchParams.append('domains', String(domains));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function log_writer_default_set_use_stderr(use_stderr: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_default_set_use_stderr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('use_stderr', String(use_stderr));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function log_writer_default_would_drop(log_level: GLibLogLevelFlags, log_domain?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_default_would_drop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_writer_format_fields(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number, use_color: boolean): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_format_fields`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    // Primitive parameter
    url.searchParams.append('use_color', String(use_color));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_writer_is_journald(output_fd: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_is_journald`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('output_fd', String(output_fd));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_writer_journald(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number): Promise<GLibLogWriterOutput> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_journald`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_writer_standard_streams(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number): Promise<GLibLogWriterOutput> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_standard_streams`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_writer_supports_color(output_fd: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_supports_color`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('output_fd', String(output_fd));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function log_writer_syslog(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number): Promise<GLibLogWriterOutput> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_syslog`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function lstat(filename: Pointer, buf: GLibStatBuf): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/lstat`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Object with explode=false: serialize as comma-separated
    if (buf && typeof buf === 'object' && 'ptr' in buf) {
      url.searchParams.append('buf', 'ptr,' + buf.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function main_context_default(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_context_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function main_context_get_thread_default(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_context_get_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function main_context_ref_thread_default(): Promise<GLibMainContext> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_context_ref_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function main_current_source(): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_current_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function main_depth(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_depth`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function malloc(n_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/malloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function malloc0(n_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/malloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function malloc0_n(n_blocks: number, n_block_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/malloc0_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function malloc_n(n_blocks: number, n_block_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/malloc_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function markup_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/markup_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function markup_escape_text(text: string, length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/markup_escape_text`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function mem_chunk_info(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mem_chunk_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function mem_is_system_malloc(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mem_is_system_malloc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function mem_profile(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mem_profile`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function mem_set_vtable(vtable: GLibMemVTable): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mem_set_vtable`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (vtable && typeof vtable === 'object' && 'ptr' in vtable) {
      url.searchParams.append('vtable', 'ptr,' + vtable.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function memdup(byte_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/memdup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('byte_size', String(byte_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function memdup2(byte_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/memdup2`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('byte_size', String(byte_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function mkdir(filename: Pointer, mode: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mkdir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function mkdir_with_parents(pathname: Pointer, mode: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mkdir_with_parents`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pathname', String(pathname));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function node_pop_allocator(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/node_pop_allocator`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function node_push_allocator(allocator: GLibAllocator): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/node_push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function nullify_pointer(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/nullify_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function number_parser_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/number_parser_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function on_error_query(prg_name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/on_error_query`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('prg_name', String(prg_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function on_error_stack_trace(prg_name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/on_error_stack_trace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('prg_name', String(prg_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function once_init_enter(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_enter`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function once_init_enter_impl(location: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_enter_impl`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function once_init_enter_pointer(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_enter_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function once_init_leave(result_: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_leave`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('result', String(result_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function once_init_leave_pointer(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_leave_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function open(filename: Pointer, flags: number, mode: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/open`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function option_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/option_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_debug_string(keys: Pointer, nkeys: number, string?: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/parse_debug_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('keys', String(keys));
    // Primitive parameter
    url.searchParams.append('nkeys', String(nkeys));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function path_buf_equal(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_buf_equal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function path_get_basename(file_name: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_get_basename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function path_get_dirname(file_name: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_get_dirname`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function path_is_absolute(file_name: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_is_absolute`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function path_skip_root(file_name: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_skip_root`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function pattern_match_simple(pattern: string, string: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pattern_match_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function pointer_bit_lock(lock_bit: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_lock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function pointer_bit_lock_and_get(lock_bit: number): Promise<{ out_ptr?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_lock_and_get`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function pointer_bit_lock_mask_ptr(lock_bit: number, set: boolean, preserve_mask: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_lock_mask_ptr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    // Primitive parameter
    url.searchParams.append('set', String(set));
    // Primitive parameter
    url.searchParams.append('preserve_mask', String(preserve_mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function pointer_bit_trylock(lock_bit: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_trylock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function pointer_bit_unlock(lock_bit: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_unlock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function pointer_bit_unlock_and_set(lock_bit: number, preserve_mask: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_unlock_and_set`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    // Primitive parameter
    url.searchParams.append('preserve_mask', String(preserve_mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function poll(fds: GLibPollFD, nfds: number, timeout: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fds && typeof fds === 'object' && 'ptr' in fds) {
      url.searchParams.append('fds', 'ptr,' + fds.ptr);
    }
    // Primitive parameter
    url.searchParams.append('nfds', String(nfds));
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function prefix_error_literal(prefix: string, err?: Pointer): Promise<{ err?: Pointer }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/prefix_error_literal`, apiConfig.baseUrl);
    // Primitive parameter
    if (err !== undefined) url.searchParams.append('err', String(err));
    // Primitive parameter
    url.searchParams.append('prefix', String(prefix));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function propagate_error(src: Pointer): Promise<{ dest?: Pointer }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/propagate_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function qsort_with_data(total_elems: number, size: number, compare_func: GLibCompareDataFunc): Promise<{ compare_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/qsort_with_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('total_elems', String(total_elems));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.compare_func !== undefined) {
      callbackDispatcher.set(data.compare_func.toString(), compare_func);
    }
    return data;
  }
  export async function quark_from_static_string(string?: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/quark_from_static_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function quark_from_string(string?: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/quark_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function quark_to_string(quark: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/quark_to_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function quark_try_string(string?: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/quark_try_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function random_double(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_double`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function random_double_range(begin: number, end: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_double_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function random_int(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_int`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function random_int_range(begin: number, end: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_int_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function random_set_seed(seed: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_set_seed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function rc_box_acquire(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_acquire`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function rc_box_alloc(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function rc_box_alloc0(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_alloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function rc_box_dup(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_dup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function rc_box_get_size(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function rc_box_release(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_release`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function rc_box_release_full(clear_func: GLibDestroyNotify): Promise<{ clear_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_release_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.clear_func !== undefined) {
      callbackDispatcher.set(data.clear_func.toString(), clear_func);
    }
    return data;
  }
  export async function realloc(n_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/realloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function realloc_n(n_blocks: number, n_block_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/realloc_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function ref_count_compare(rc: number, val: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_count_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rc', String(rc));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ref_count_dec(rc: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_count_dec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rc', String(rc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ref_count_inc(rc: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_count_inc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rc', String(rc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function ref_count_init(rc: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_count_init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rc', String(rc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function ref_string_acquire(str: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_acquire`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ref_string_length(str: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_length`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ref_string_new(str: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ref_string_new_intern(str: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_new_intern`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ref_string_new_len(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_new_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ref_string_release(str: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_release`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function regex_check_replacement(replacement: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_check_replacement`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('replacement', String(replacement));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function regex_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function regex_escape_nul(string: string, length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_escape_nul`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function regex_escape_string(string: string, length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_escape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function regex_match_simple(pattern: string, string: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_match_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function regex_split_simple(pattern: string, string: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_split_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function reload_user_special_dirs_cache(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/reload_user_special_dirs_cache`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function remove(filename: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function rename(oldfilename: Pointer, newfilename: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('oldfilename', String(oldfilename));
    // Primitive parameter
    url.searchParams.append('newfilename', String(newfilename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function rmdir(filename: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rmdir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function sequence_foreach_range(begin: GLibSequenceIter, end: GLibSequenceIter, func: GLibFunc): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_foreach_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function sequence_get(iter: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_get`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function sequence_insert_before(iter: GLibSequenceIter): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_insert_before`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function sequence_move(src: GLibSequenceIter, dest: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_move`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function sequence_move_range(dest: GLibSequenceIter, begin: GLibSequenceIter, end: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_move_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function sequence_range_get_midpoint(begin: GLibSequenceIter, end: GLibSequenceIter): Promise<GLibSequenceIter> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_range_get_midpoint`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSequenceIter(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function sequence_remove(iter: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function sequence_remove_range(begin: GLibSequenceIter, end: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_remove_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function sequence_set(iter: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_set`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function sequence_sort_changed(iter: GLibSequenceIter, cmp_func: GLibCompareDataFunc): Promise<{ cmp_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_sort_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.cmp_func !== undefined) {
      callbackDispatcher.set(data.cmp_func.toString(), cmp_func);
    }
    return data;
  }
  export async function sequence_sort_changed_iter(iter: GLibSequenceIter, iter_cmp: GLibSequenceIterCompareFunc): Promise<{ iter_cmp?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_sort_changed_iter`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.iter_cmp !== undefined) {
      callbackDispatcher.set(data.iter_cmp.toString(), iter_cmp);
    }
    return data;
  }
  export async function sequence_swap(a: GLibSequenceIter, b: GLibSequenceIter): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_swap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (a && typeof a === 'object' && 'ptr' in a) {
      url.searchParams.append('a', 'ptr,' + a.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (b && typeof b === 'object' && 'ptr' in b) {
      url.searchParams.append('b', 'ptr,' + b.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function set_application_name(application_name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/set_application_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('application_name', String(application_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function set_error_literal(domain: number, code: number, message: string): Promise<{ err?: Pointer }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/set_error_literal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function set_prgname(prgname: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/set_prgname`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('prgname', String(prgname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function setenv(variable: Pointer, value_: Pointer, overwrite: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/setenv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    // Primitive parameter
    url.searchParams.append('overwrite', String(overwrite));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function shell_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/shell_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function shell_parse_argv(command_line: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/shell_parse_argv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('command_line', String(command_line));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function shell_quote(unquoted_string: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/shell_quote`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unquoted_string', String(unquoted_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function shell_unquote(quoted_string: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/shell_unquote`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quoted_string', String(quoted_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function slice_alloc(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function slice_alloc0(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_alloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function slice_copy(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function slice_free1(block_size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_free1`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function slice_free_chain_with_offset(block_size: number, next_offset: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_free_chain_with_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    // Primitive parameter
    url.searchParams.append('next_offset', String(next_offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function slice_get_config(ckey: GLibSliceConfig): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_get_config`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ckey', String(ckey));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function slice_get_config_state(ckey: GLibSliceConfig, address: number, n_values: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_get_config_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ckey', String(ckey));
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function slice_set_config(ckey: GLibSliceConfig, value_: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_set_config`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ckey', String(ckey));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function slist_pop_allocator(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slist_pop_allocator`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function slist_push_allocator(allocator: GLibAllocator): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slist_push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function source_remove(tag: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/source_remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function source_remove_by_funcs_user_data(funcs: GLibSourceFuncs): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/source_remove_by_funcs_user_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function source_remove_by_user_data(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/source_remove_by_user_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function source_set_name_by_id(tag: number, name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/source_set_name_by_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function spaced_primes_closest(num: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spaced_primes_closest`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('num', String(num));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function spawn_async(argv: Pointer, flags: GLibSpawnFlags, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_async`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.child_setup !== undefined) {
      callbackDispatcher.set(data.child_setup.toString(), child_setup);
    }
    return data.return;
  }
  export async function spawn_async_with_fds(argv: Pointer, flags: GLibSpawnFlags, stdin_fd: number, stdout_fd: number, stderr_fd: number, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_async_with_fds`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('stdin_fd', String(stdin_fd));
    // Primitive parameter
    url.searchParams.append('stdout_fd', String(stdout_fd));
    // Primitive parameter
    url.searchParams.append('stderr_fd', String(stderr_fd));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.child_setup !== undefined) {
      callbackDispatcher.set(data.child_setup.toString(), child_setup);
    }
    return data.return;
  }
  export async function spawn_async_with_pipes(argv: Pointer, flags: GLibSpawnFlags, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_async_with_pipes`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.child_setup !== undefined) {
      callbackDispatcher.set(data.child_setup.toString(), child_setup);
    }
    return data.return;
  }
  export async function spawn_async_with_pipes_and_fds(argv: Pointer, flags: GLibSpawnFlags, stdin_fd: number, stdout_fd: number, stderr_fd: number, n_fds: number, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer, source_fds?: Pointer, target_fds?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_async_with_pipes_and_fds`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('stdin_fd', String(stdin_fd));
    // Primitive parameter
    url.searchParams.append('stdout_fd', String(stdout_fd));
    // Primitive parameter
    url.searchParams.append('stderr_fd', String(stderr_fd));
    // Primitive parameter
    if (source_fds !== undefined) url.searchParams.append('source_fds', String(source_fds));
    // Primitive parameter
    if (target_fds !== undefined) url.searchParams.append('target_fds', String(target_fds));
    // Primitive parameter
    url.searchParams.append('n_fds', String(n_fds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.child_setup !== undefined) {
      callbackDispatcher.set(data.child_setup.toString(), child_setup);
    }
    return data.return;
  }
  export async function spawn_check_exit_status(wait_status: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_check_exit_status`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('wait_status', String(wait_status));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function spawn_check_wait_status(wait_status: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_check_wait_status`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('wait_status', String(wait_status));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function spawn_close_pid(pid: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_close_pid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pid', String(pid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function spawn_command_line_async(command_line: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_command_line_async`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('command_line', String(command_line));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function spawn_command_line_sync(command_line: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_command_line_sync`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('command_line', String(command_line));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function spawn_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function spawn_exit_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_exit_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function spawn_sync(argv: Pointer, flags: GLibSpawnFlags, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_sync`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.child_setup !== undefined) {
      callbackDispatcher.set(data.child_setup.toString(), child_setup);
    }
    return data.return;
  }
  export async function stat(filename: Pointer, buf: GLibStatBuf): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/stat`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Object with explode=false: serialize as comma-separated
    if (buf && typeof buf === 'object' && 'ptr' in buf) {
      url.searchParams.append('buf', 'ptr,' + buf.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function stpcpy(dest: string, src: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/stpcpy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dest', String(dest));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function str_equal(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_equal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function str_has_prefix(str: string, prefix: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_has_prefix`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('prefix', String(prefix));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function str_has_suffix(str: string, suffix: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_has_suffix`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('suffix', String(suffix));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function str_hash(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function str_is_ascii(str: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_is_ascii`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function str_match_string(search_term: string, potential_hit: string, accept_alternates: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_match_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('search_term', String(search_term));
    // Primitive parameter
    url.searchParams.append('potential_hit', String(potential_hit));
    // Primitive parameter
    url.searchParams.append('accept_alternates', String(accept_alternates));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function str_to_ascii(str: string, from_locale?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_to_ascii`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    if (from_locale !== undefined) url.searchParams.append('from_locale', String(from_locale));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function str_tokenize_and_fold(string: string, translit_locale?: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_tokenize_and_fold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (translit_locale !== undefined) url.searchParams.append('translit_locale', String(translit_locale));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strcanon(string: string, valid_chars: string, substitutor: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strcanon`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('valid_chars', String(valid_chars));
    // Primitive parameter
    url.searchParams.append('substitutor', String(substitutor));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strcasecmp(s1: string, s2: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strcasecmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strchomp(string: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strchomp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strchug(string: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strchug`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strcmp0(str1?: string, str2?: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strcmp0`, apiConfig.baseUrl);
    // Primitive parameter
    if (str1 !== undefined) url.searchParams.append('str1', String(str1));
    // Primitive parameter
    if (str2 !== undefined) url.searchParams.append('str2', String(str2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strcompress(source: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strcompress`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source', String(source));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strdelimit(string: string, new_delimiter: number, delimiters?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strdelimit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (delimiters !== undefined) url.searchParams.append('delimiters', String(delimiters));
    // Primitive parameter
    url.searchParams.append('new_delimiter', String(new_delimiter));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strdown(string: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strdown`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strdup(str?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strdup`, apiConfig.baseUrl);
    // Primitive parameter
    if (str !== undefined) url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strdupv(str_array?: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strdupv`, apiConfig.baseUrl);
    // Primitive parameter
    if (str_array !== undefined) url.searchParams.append('str_array', String(str_array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strerror(errnum: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strerror`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('errnum', String(errnum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strescape(source: string, exceptions?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strescape`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source', String(source));
    // Primitive parameter
    if (exceptions !== undefined) url.searchParams.append('exceptions', String(exceptions));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strfreev(str_array?: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strfreev`, apiConfig.baseUrl);
    // Primitive parameter
    if (str_array !== undefined) url.searchParams.append('str_array', String(str_array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function strip_context(msgid: string, msgval: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strip_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    // Primitive parameter
    url.searchParams.append('msgval', String(msgval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strjoinv(str_array: Pointer, separator?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strjoinv`, apiConfig.baseUrl);
    // Primitive parameter
    if (separator !== undefined) url.searchParams.append('separator', String(separator));
    // Primitive parameter
    url.searchParams.append('str_array', String(str_array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strlcat(dest: string, src: string, dest_size: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strlcat`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dest', String(dest));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Primitive parameter
    url.searchParams.append('dest_size', String(dest_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strlcpy(dest: string, src: string, dest_size: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strlcpy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dest', String(dest));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Primitive parameter
    url.searchParams.append('dest_size', String(dest_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strncasecmp(s1: string, s2: string, n: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strncasecmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strndup(n: number, str?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strndup`, apiConfig.baseUrl);
    // Primitive parameter
    if (str !== undefined) url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strnfill(length: number, fill_char: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strnfill`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('fill_char', String(fill_char));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strreverse(string: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strreverse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strrstr(haystack: string, needle: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strrstr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('haystack', String(haystack));
    // Primitive parameter
    url.searchParams.append('needle', String(needle));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strrstr_len(haystack: string, haystack_len: number, needle: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strrstr_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('haystack', String(haystack));
    // Primitive parameter
    url.searchParams.append('haystack_len', String(haystack_len));
    // Primitive parameter
    url.searchParams.append('needle', String(needle));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strsignal(signum: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strsignal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signum', String(signum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strsplit(string: string, delimiter: string, max_tokens: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strsplit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('delimiter', String(delimiter));
    // Primitive parameter
    url.searchParams.append('max_tokens', String(max_tokens));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strsplit_set(string: string, delimiters: string, max_tokens: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strsplit_set`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('delimiters', String(delimiters));
    // Primitive parameter
    url.searchParams.append('max_tokens', String(max_tokens));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strstr_len(haystack: string, haystack_len: number, needle: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strstr_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('haystack', String(haystack));
    // Primitive parameter
    url.searchParams.append('haystack_len', String(haystack_len));
    // Primitive parameter
    url.searchParams.append('needle', String(needle));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strtod(nptr: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strtod`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nptr', String(nptr));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strup(string: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strv_contains(strv: Pointer, str: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strv_contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strv_equal(strv1: Pointer, strv2: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strv_equal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv1', String(strv1));
    // Primitive parameter
    url.searchParams.append('strv2', String(strv2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strv_get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strv_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function strv_length(str_array: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strv_length`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str_array', String(str_array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_add_data_func(testpath: string, test_func: GLibTestDataFunc): Promise<{ test_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_add_data_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('testpath', String(testpath));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.test_func !== undefined) {
      callbackDispatcher.set(data.test_func.toString(), test_func);
    }
    return data;
  }
  export async function test_add_data_func_full(testpath: string, test_func: GLibTestDataFunc): Promise<{ test_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_add_data_func_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('testpath', String(testpath));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.test_func !== undefined) {
      callbackDispatcher.set(data.test_func.toString(), test_func);
    }
    return data;
  }
  export async function test_add_func(testpath: string, test_func: GLibTestFunc): Promise<{ test_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_add_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('testpath', String(testpath));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.test_func !== undefined) {
      callbackDispatcher.set(data.test_func.toString(), test_func);
    }
    return data;
  }
  export async function test_assert_expected_messages_internal(domain: string, file: string, line: number, func: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_assert_expected_messages_internal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_bug(bug_uri_snippet: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_bug`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('bug_uri_snippet', String(bug_uri_snippet));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_bug_base(uri_pattern: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_bug_base`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_pattern', String(uri_pattern));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_disable_crash_reporting(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_disable_crash_reporting`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_expect_message(log_level: GLibLogLevelFlags, pattern: string, log_domain?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_expect_message`, apiConfig.baseUrl);
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_fail(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_fail`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_failed(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_failed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_get_dir(file_type: GLibTestFileType): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_get_dir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_type', String(file_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_get_path(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_get_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_incomplete(msg?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_incomplete`, apiConfig.baseUrl);
    // Primitive parameter
    if (msg !== undefined) url.searchParams.append('msg', String(msg));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_log_type_name(log_type: GLibTestLogType): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_log_type_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_type', String(log_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_queue_destroy(destroy_func: GLibDestroyNotify): Promise<{ destroy_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_queue_destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.destroy_func !== undefined) {
      callbackDispatcher.set(data.destroy_func.toString(), destroy_func);
    }
    return data;
  }
  export async function test_queue_free(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_queue_free`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_rand_double(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_rand_double`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_rand_double_range(range_start: number, range_end: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_rand_double_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('range_start', String(range_start));
    // Primitive parameter
    url.searchParams.append('range_end', String(range_end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_rand_int(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_rand_int`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_rand_int_range(begin: number, end: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_rand_int_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_run(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_run`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_run_suite(suite: GLibTestSuite): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_run_suite`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (suite && typeof suite === 'object' && 'ptr' in suite) {
      url.searchParams.append('suite', 'ptr,' + suite.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_set_nonfatal_assertions(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_set_nonfatal_assertions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_skip(msg?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_skip`, apiConfig.baseUrl);
    // Primitive parameter
    if (msg !== undefined) url.searchParams.append('msg', String(msg));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_subprocess(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_subprocess`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_summary(summary: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_summary`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('summary', String(summary));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_timer_elapsed(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_timer_elapsed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_timer_last(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_timer_last`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_timer_start(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_timer_start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_trap_assertions(domain: string, file: string, line: number, func: string, assertion_flags: number, pattern: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_assertions`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('assertion_flags', String(assertion_flags));
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_trap_fork(usec_timeout: number, test_trap_flags: GLibTestTrapFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_fork`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usec_timeout', String(usec_timeout));
    // Primitive parameter
    url.searchParams.append('test_trap_flags', String(test_trap_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_trap_has_passed(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_has_passed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_trap_reached_timeout(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_reached_timeout`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function test_trap_subprocess(usec_timeout: number, test_flags: GLibTestSubprocessFlags, test_path?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_subprocess`, apiConfig.baseUrl);
    // Primitive parameter
    if (test_path !== undefined) url.searchParams.append('test_path', String(test_path));
    // Primitive parameter
    url.searchParams.append('usec_timeout', String(usec_timeout));
    // Primitive parameter
    url.searchParams.append('test_flags', String(test_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function test_trap_subprocess_with_envp(usec_timeout: number, test_flags: GLibTestSubprocessFlags, test_path?: string, envp?: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_subprocess_with_envp`, apiConfig.baseUrl);
    // Primitive parameter
    if (test_path !== undefined) url.searchParams.append('test_path', String(test_path));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('usec_timeout', String(usec_timeout));
    // Primitive parameter
    url.searchParams.append('test_flags', String(test_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function thread_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function thread_exit(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_exit`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function thread_pool_get_max_idle_time(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_get_max_idle_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function thread_pool_get_max_unused_threads(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_get_max_unused_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function thread_pool_get_num_unused_threads(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_get_num_unused_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function thread_pool_set_max_idle_time(interval: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_set_max_idle_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function thread_pool_set_max_unused_threads(max_threads: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_set_max_unused_threads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_threads', String(max_threads));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function thread_pool_stop_unused_threads(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_stop_unused_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function thread_self(): Promise<GLibThread> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_self`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibThread(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function thread_yield(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_yield`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function time_val_from_iso8601(iso_date: string, time_: GLibTimeVal): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/time_val_from_iso8601`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iso_date', String(iso_date));
    // Object with explode=false: serialize as comma-separated
    if (time_ && typeof time_ === 'object' && 'ptr' in time_) {
      url.searchParams.append('time_', 'ptr,' + time_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function timeout_add(priority: number, interval: number, function_: GLibSourceFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/timeout_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.function !== undefined) {
      callbackDispatcher.set(data.function.toString(), function_);
    }
    return data.return;
  }
  export async function timeout_add_seconds(priority: number, interval: number, function_: GLibSourceFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/timeout_add_seconds`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.function !== undefined) {
      callbackDispatcher.set(data.function.toString(), function_);
    }
    return data.return;
  }
  export async function timeout_source_new(interval: number): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/timeout_source_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function timeout_source_new_seconds(interval: number): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/timeout_source_new_seconds`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function trash_stack_height(stack_p: GLibTrashStack): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/trash_stack_height`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function trash_stack_peek(stack_p: GLibTrashStack): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/trash_stack_peek`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function trash_stack_pop(stack_p: GLibTrashStack): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/trash_stack_pop`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function trash_stack_push(stack_p: GLibTrashStack): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/trash_stack_push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function try_malloc(n_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_malloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function try_malloc0(n_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_malloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function try_malloc0_n(n_blocks: number, n_block_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_malloc0_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function try_malloc_n(n_blocks: number, n_block_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_malloc_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function try_realloc(n_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_realloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function try_realloc_n(n_blocks: number, n_block_bytes: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_realloc_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function ucs4_to_utf16(str: Pointer, len: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ucs4_to_utf16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function ucs4_to_utf8(str: Pointer, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ucs4_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_break_type(c: Pointer): Promise<GLibUnicodeBreakTypeValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_break_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_combining_class(uc: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_combining_class`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uc', String(uc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_compose(a: Pointer, b: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_compose`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_decompose(ch: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_decompose`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_digit_value(c: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_digit_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_fully_decompose(ch: Pointer, compat: boolean, result_len: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_fully_decompose`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    // Primitive parameter
    url.searchParams.append('compat', String(compat));
    // Primitive parameter
    url.searchParams.append('result_len', String(result_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_get_mirror_char(ch: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_get_mirror_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_get_script(ch: Pointer): Promise<GLibUnicodeScriptValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_get_script`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_isalnum(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isalnum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_isalpha(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isalpha`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_iscntrl(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_iscntrl`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_isdefined(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isdefined`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_isdigit(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isdigit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_isgraph(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isgraph`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_islower(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_islower`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_ismark(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_ismark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_isprint(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isprint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_ispunct(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_ispunct`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_isspace(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isspace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_istitle(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_istitle`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_isupper(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isupper`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_iswide(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_iswide`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_iswide_cjk(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_iswide_cjk`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_isxdigit(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isxdigit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_iszerowidth(c: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_iszerowidth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_to_utf8(c: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_tolower(c: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_tolower`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_totitle(c: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_totitle`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_toupper(c: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_toupper`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_type(c: Pointer): Promise<GLibUnicodeTypeValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_validate(ch: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_validate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unichar_xdigit_value(c: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_xdigit_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unicode_canonical_decomposition(ch: Pointer, result_len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unicode_canonical_decomposition`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    // Primitive parameter
    url.searchParams.append('result_len', String(result_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unicode_canonical_ordering(string: Pointer, len: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unicode_canonical_ordering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function unicode_script_from_iso15924(iso15924: number): Promise<GLibUnicodeScriptValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unicode_script_from_iso15924`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iso15924', String(iso15924));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unicode_script_to_iso15924(script: GLibUnicodeScriptValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unicode_script_to_iso15924`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('script', String(script));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unix_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unix_fd_add_full(priority: number, fd: number, condition: GLibIOConditionValue, function_: GLibUnixFDSourceFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_fd_add_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('condition', String(condition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.function !== undefined) {
      callbackDispatcher.set(data.function.toString(), function_);
    }
    return data.return;
  }
  export async function unix_fd_source_new(fd: number, condition: GLibIOConditionValue): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_fd_source_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('condition', String(condition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function unix_get_passwd_entry(user_name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_get_passwd_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('user_name', String(user_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function unix_open_pipe(fds: Pointer, flags: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_open_pipe`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fds', String(fds));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unix_set_fd_nonblocking(fd: number, nonblock: boolean): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_set_fd_nonblocking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('nonblock', String(nonblock));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unix_signal_add(priority: number, signum: number, handler: GLibSourceFunc): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_signal_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('signum', String(signum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.handler !== undefined) {
      callbackDispatcher.set(data.handler.toString(), handler);
    }
    return data.return;
  }
  export async function unix_signal_source_new(signum: number): Promise<GLibSource> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_signal_source_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signum', String(signum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function unlink(filename: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unlink`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function unsetenv(variable: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unsetenv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function uri_build(flags: GLibUriFlags, scheme: string, port: number, path: string, userinfo?: string, host?: string, query?: string, fragment?: string): Promise<GLibUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_build`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function uri_build_with_user(flags: GLibUriFlags, scheme: string, port: number, path: string, user?: string, password?: string, auth_params?: string, host?: string, query?: string, fragment?: string): Promise<GLibUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_build_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (user !== undefined) url.searchParams.append('user', String(user));
    // Primitive parameter
    if (password !== undefined) url.searchParams.append('password', String(password));
    // Primitive parameter
    if (auth_params !== undefined) url.searchParams.append('auth_params', String(auth_params));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function uri_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_escape_bytes(unescaped: Pointer, length: number, reserved_chars_allowed?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_escape_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    if (reserved_chars_allowed !== undefined) url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_escape_string(unescaped: string, allow_utf8: boolean, reserved_chars_allowed?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_escape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    if (reserved_chars_allowed !== undefined) url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    // Primitive parameter
    url.searchParams.append('allow_utf8', String(allow_utf8));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_is_valid(uri_string: string, flags: GLibUriFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_join(flags: GLibUriFlags, port: number, path: string, scheme?: string, userinfo?: string, host?: string, query?: string, fragment?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_join`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_join_with_user(flags: GLibUriFlags, port: number, path: string, scheme?: string, user?: string, password?: string, auth_params?: string, host?: string, query?: string, fragment?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_join_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (user !== undefined) url.searchParams.append('user', String(user));
    // Primitive parameter
    if (password !== undefined) url.searchParams.append('password', String(password));
    // Primitive parameter
    if (auth_params !== undefined) url.searchParams.append('auth_params', String(auth_params));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_list_extract_uris(uri_list: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_list_extract_uris`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_list', String(uri_list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_parse(uri_string: string, flags: GLibUriFlags): Promise<GLibUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function uri_parse_params(params: string, length: number, separators: string, flags: GLibUriParamsFlags): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_parse_params`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('params', String(params));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('separators', String(separators));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_parse_scheme(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_parse_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_peek_scheme(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_peek_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_resolve_relative(uri_ref: string, flags: GLibUriFlags, base_uri_string?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_resolve_relative`, apiConfig.baseUrl);
    // Primitive parameter
    if (base_uri_string !== undefined) url.searchParams.append('base_uri_string', String(base_uri_string));
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_split(uri_ref: string, flags: GLibUriFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_split`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_split_network(uri_string: string, flags: GLibUriFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_split_network`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_split_with_user(uri_ref: string, flags: GLibUriFlags): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_split_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_unescape_bytes(escaped_string: string, length: number, illegal_characters?: string): Promise<GLibBytes> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_unescape_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function uri_unescape_segment(escaped_string?: string, escaped_string_end?: string, illegal_characters?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_unescape_segment`, apiConfig.baseUrl);
    // Primitive parameter
    if (escaped_string !== undefined) url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    if (escaped_string_end !== undefined) url.searchParams.append('escaped_string_end', String(escaped_string_end));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_unescape_string(escaped_string: string, illegal_characters?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_unescape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function usleep(microseconds: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/usleep`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('microseconds', String(microseconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function utf16_to_ucs4(str: Pointer, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf16_to_ucs4`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf16_to_utf8(str: Pointer, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf16_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_casefold(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_casefold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_collate(str1: string, str2: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_collate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str1', String(str1));
    // Primitive parameter
    url.searchParams.append('str2', String(str2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_collate_key(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_collate_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_collate_key_for_filename(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_collate_key_for_filename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_find_next_char(p: string, end?: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_find_next_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    if (end !== undefined) url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_find_prev_char(str: string, p: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_find_prev_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('p', String(p));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_get_char(p: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_get_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_get_char_validated(p: string, max_len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_get_char_validated`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    url.searchParams.append('max_len', String(max_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_make_valid(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_make_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_normalize(str: string, len: number, mode: GLibNormalizeModeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_normalize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_offset_to_pointer(str: string, offset: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_offset_to_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_pointer_to_offset(str: string, pos: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_pointer_to_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_prev_char(p: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_prev_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_strchr(p: string, len: number, c: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strchr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_strdown(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strdown`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_strlen(p: string, max: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strlen`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    url.searchParams.append('max', String(max));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_strncpy(dest: string, src: string, n: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strncpy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dest', String(dest));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_strrchr(p: string, len: number, c: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strrchr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('c', String(c));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_strreverse(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strreverse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_strup(str: string, len: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_substring(str: string, start_pos: number, end_pos: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_substring`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('start_pos', String(start_pos));
    // Primitive parameter
    url.searchParams.append('end_pos', String(end_pos));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_to_ucs4(str: string, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_to_ucs4`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_to_ucs4_fast(str: string, len: number): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_to_ucs4_fast`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_to_utf16(str: string, len: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_to_utf16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_truncate_middle(string: string, truncate_length: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_truncate_middle`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('truncate_length', String(truncate_length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_validate(str: Pointer, max_len: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_validate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('max_len', String(max_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utf8_validate_len(str: Pointer, max_len: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_validate_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('max_len', String(max_len));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function utime(filename: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utime`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uuid_string_is_valid(str: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uuid_string_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uuid_string_random(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uuid_string_random`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_get_gtype(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_get_gtype`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_is_object_path(string: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_is_object_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_is_signature(string: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_is_signature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_parse(text: string, type_?: GLibVariantType, limit?: string, endptr?: string): Promise<GLibVariant> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_parse`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ !== undefined && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    // Primitive parameter
    if (endptr !== undefined) url.searchParams.append('endptr', String(endptr));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function variant_parse_error_print_context(error_: Pointer, source_str: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_parse_error_print_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('source_str', String(source_str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_parse_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_parse_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_parser_get_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_parser_get_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_type_checked_(type_string: string): Promise<GLibVariantType> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_type_checked_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function variant_type_string_get_depth_(type_string: string): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_type_string_get_depth_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_type_string_is_valid(type_string: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_type_string_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function variant_type_string_scan(string: string, limit?: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_type_string_scan`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function buffer_get_max_memory(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/buffer_get_max_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function caps_features_from_string(features: string): Promise<GstCapsFeatures> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/caps_features_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('features', String(features));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function caps_from_string(string: string): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/caps_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function core_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/core_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_add_log_function(func: GstLogFunction): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_add_log_function`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function debug_add_ring_buffer_logger(max_size_per_thread: number, thread_timeout: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_add_ring_buffer_logger`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_size_per_thread', String(max_size_per_thread));
    // Primitive parameter
    url.searchParams.append('thread_timeout', String(thread_timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_bin_to_dot_data(bin: GstBin, details: GstDebugGraphDetailsValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_bin_to_dot_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bin && typeof bin === 'object' && 'ptr' in bin) {
      url.searchParams.append('bin', 'ptr,' + bin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('details', String(details));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_bin_to_dot_file(bin: GstBin, details: GstDebugGraphDetailsValue, file_name: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_bin_to_dot_file`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bin && typeof bin === 'object' && 'ptr' in bin) {
      url.searchParams.append('bin', 'ptr,' + bin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('details', String(details));
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_bin_to_dot_file_with_ts(bin: GstBin, details: GstDebugGraphDetailsValue, file_name: Pointer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_bin_to_dot_file_with_ts`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bin && typeof bin === 'object' && 'ptr' in bin) {
      url.searchParams.append('bin', 'ptr,' + bin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('details', String(details));
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_construct_term_color(colorinfo: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_construct_term_color`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('colorinfo', String(colorinfo));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_construct_win_color(colorinfo: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_construct_win_color`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('colorinfo', String(colorinfo));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_all_categories(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_get_all_categories`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_color_mode(): Promise<GstDebugColorModeValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_get_color_mode`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_default_threshold(): Promise<GstDebugLevelValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_get_default_threshold`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_stack_trace(flags: GstStackTraceFlagsValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_get_stack_trace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_is_active(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_is_colored(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_is_colored`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_level_get_name(level: GstDebugLevelValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_level_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_log_default(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message: GstDebugMessage, object?: GObjectObject): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_log_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (object !== undefined && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_log_get_line(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message: GstDebugMessage, object?: GObjectObject): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_log_get_line`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (object !== undefined && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_log_id_literal(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message_string: string, id?: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_log_id_literal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    if (id !== undefined) url.searchParams.append('id', String(id));
    // Primitive parameter
    url.searchParams.append('message_string', String(message_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_log_literal(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message_string: string, object?: GObjectObject): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_log_literal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (object !== undefined && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('message_string', String(message_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_print_stack_trace(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_print_stack_trace`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_remove_log_function(func: GstLogFunction): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_remove_log_function`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  export async function debug_remove_log_function_by_data(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_remove_log_function_by_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_remove_ring_buffer_logger(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_remove_ring_buffer_logger`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_ring_buffer_logger_get_logs(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_ring_buffer_logger_get_logs`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_set_active(active: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_active`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_color_mode(mode: GstDebugColorModeValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_color_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_color_mode_from_string(mode: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_color_mode_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_colored(colored: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_colored`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('colored', String(colored));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_default_threshold(level: GstDebugLevelValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_default_threshold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_threshold_for_name(name: string, level: GstDebugLevelValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_threshold_for_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_threshold_from_string(list: string, reset: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_threshold_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('reset', String(reset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_unset_threshold_for_name(name: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_unset_threshold_for_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function deinit(): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/deinit`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function dynamic_type_register(plugin: GstPlugin, type_: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/dynamic_type_register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function error_get_message(domain: number, code: number): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/error_get_message`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_get_flags(type_: GstEventTypeValue): Promise<GstEventTypeFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/event_type_get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_get_name(type_: GstEventTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/event_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_to_quark(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/event_type_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_to_sticky_ordering(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/event_type_to_sticky_ordering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function filename_to_uri(filename: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/filename_to_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flow_get_name(ret: GstFlowReturnValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/flow_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flow_to_quark(ret: GstFlowReturnValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/flow_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_get_by_nick(nick: string): Promise<GstFormatValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_get_by_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_get_details(format: GstFormatValue): Promise<GstFormatDefinition> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_get_details`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_get_name(format: GstFormatValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_iterate_definitions(): Promise<GstIterator> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_iterate_definitions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function format_register(nick: string, description: string): Promise<GstFormatValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_to_quark(format: GstFormatValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function formats_contains(formats: Pointer, format: GstFormatValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/formats_contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('formats', String(formats));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_main_executable_path(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/get_main_executable_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function init(argc?: number, argv?: Pointer): Promise<{ argc?: number; argv?: Pointer }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/init`, apiConfig.baseUrl);
    // Primitive parameter
    if (argc !== undefined) url.searchParams.append('argc', String(argc));
    // Primitive parameter
    if (argv !== undefined) url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function init_check(argc?: number, argv?: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/init_check`, apiConfig.baseUrl);
    // Primitive parameter
    if (argc !== undefined) url.searchParams.append('argc', String(argc));
    // Primitive parameter
    if (argv !== undefined) url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function is_caps_features(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/is_caps_features`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function is_initialized(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/is_initialized`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function library_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/library_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function message_type_get_name(type_: GstMessageTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/message_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function message_type_to_quark(type_: GstMessageTypeValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/message_type_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_api_type_get_tags(api: string): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_api_type_get_tags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_api_type_has_tag(api: string, tag: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_api_type_has_tag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_api_type_register(api: string, tags: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_api_type_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_deserialize(buffer: GstBuffer, data_: number, size: number): Promise<GstMeta> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_deserialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function meta_get_info(impl: string): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_get_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('impl', String(impl));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function meta_register_custom(name: string, tags: Pointer, transform_func: GstCustomMetaTransformFunction): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_register_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.transform_func !== undefined) {
      callbackDispatcher.set(data.transform_func.toString(), transform_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function meta_register_custom_simple(name: string): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_register_custom_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function mini_object_replace(olddata?: GstMiniObject, newdata?: GstMiniObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/mini_object_replace`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata !== undefined && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata !== undefined && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function mini_object_take(olddata: GstMiniObject, newdata: GstMiniObject): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/mini_object_take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function pad_mode_get_name(mode: GstPadModeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/pad_mode_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_spec_array(name: string, nick: string, blurb: string, element_spec: GObjectParamSpec, flags: GObjectParamFlags): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/param_spec_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('blurb', String(blurb));
    // Object with explode=false: serialize as comma-separated
    if (element_spec && typeof element_spec === 'object' && 'ptr' in element_spec) {
      url.searchParams.append('element_spec', 'ptr,' + element_spec.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_fraction(name: string, nick: string, blurb: string, min_num: number, min_denom: number, max_num: number, max_denom: number, default_num: number, default_denom: number, flags: GObjectParamFlags): Promise<GObjectParamSpec> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/param_spec_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('min_num', String(min_num));
    // Primitive parameter
    url.searchParams.append('min_denom', String(min_denom));
    // Primitive parameter
    url.searchParams.append('max_num', String(max_num));
    // Primitive parameter
    url.searchParams.append('max_denom', String(max_denom));
    // Primitive parameter
    url.searchParams.append('default_num', String(default_num));
    // Primitive parameter
    url.searchParams.append('default_denom', String(default_denom));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function parent_buffer_meta_api_get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parent_buffer_meta_api_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parent_buffer_meta_get_info(): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parent_buffer_meta_get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function parse_bin_from_description(bin_description: string, ghost_unlinked_pads: boolean): Promise<GstBin> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_bin_from_description`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('bin_description', String(bin_description));
    // Primitive parameter
    url.searchParams.append('ghost_unlinked_pads', String(ghost_unlinked_pads));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstBin(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  export async function parse_bin_from_description_full(bin_description: string, ghost_unlinked_pads: boolean, flags: GstParseFlagsValue, context?: GstParseContext): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_bin_from_description_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('bin_description', String(bin_description));
    // Primitive parameter
    url.searchParams.append('ghost_unlinked_pads', String(ghost_unlinked_pads));
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  export async function parse_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_launch(pipeline_description: string): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_launch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pipeline_description', String(pipeline_description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  export async function parse_launch_full(pipeline_description: string, flags: GstParseFlagsValue, context?: GstParseContext): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_launch_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pipeline_description', String(pipeline_description));
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  export async function parse_launchv(argv: Pointer): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_launchv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  export async function parse_launchv_full(argv: Pointer, flags: GstParseFlagsValue, context?: GstParseContext): Promise<GstElement> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_launchv_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      // For GObject types, pass transfer parameter based on x-gi-transfer
      // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
      const instance = new GstElement(data.return.ptr, true);
      return instance;
    }
    return data.return;
  }
  export async function plugin_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/plugin_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function preset_get_app_dir(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/preset_get_app_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function preset_set_app_dir(app_dir: Pointer): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/preset_set_app_dir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('app_dir', String(app_dir));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_filter_systems_by_available_decryptors(system_identifiers: Pointer): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/protection_filter_systems_by_available_decryptors`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('system_identifiers', String(system_identifiers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_meta_api_get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/protection_meta_api_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_meta_get_info(): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/protection_meta_get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function protection_select_system(system_identifiers: Pointer): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/protection_select_system`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('system_identifiers', String(system_identifiers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function query_type_get_flags(type_: GstQueryTypeValue): Promise<GstQueryTypeFlagsValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/query_type_get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function query_type_get_name(type_: GstQueryTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/query_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function query_type_to_quark(type_: GstQueryTypeValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/query_type_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function reference_timestamp_meta_api_get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/reference_timestamp_meta_api_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function reference_timestamp_meta_get_info(): Promise<GstMetaInfo> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/reference_timestamp_meta_get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function resource_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/resource_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function segtrap_is_enabled(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/segtrap_is_enabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function segtrap_set_enabled(enabled: boolean): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/segtrap_set_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('enabled', String(enabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function state_change_get_name(transition: GstStateChangeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/state_change_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('transition', String(transition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function static_caps_get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/static_caps_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function static_pad_template_get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/static_pad_template_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function stream_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/stream_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function stream_type_get_name(stype: GstStreamTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/stream_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stype', String(stype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function structure_take(oldstr_ptr?: GstStructure, newstr?: GstStructure): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/structure_take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (oldstr_ptr !== undefined && typeof oldstr_ptr === 'object' && 'ptr' in oldstr_ptr) {
      url.searchParams.append('oldstr_ptr', 'ptr,' + oldstr_ptr.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newstr !== undefined && typeof newstr === 'object' && 'ptr' in newstr) {
      url.searchParams.append('newstr', 'ptr,' + newstr.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_exists(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_exists`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_description(tag: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_get_description`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_flag(tag: string): Promise<GstTagFlagValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_get_flag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_nick(tag: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_get_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_type(tag: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_get_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_is_fixed(tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_is_fixed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_list_copy_value(dest: GObjectValue, list: GstTagList, tag: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_list_copy_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_merge_strings_with_comma(dest: GObjectValue, src: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_merge_strings_with_comma`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function tag_merge_use_first(dest: GObjectValue, src: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_merge_use_first`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function toc_entry_type_get_nick(type_: GstTocEntryTypeValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/toc_entry_type_get_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tracing_get_active_tracers(): Promise<Pointer> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tracing_get_active_tracers`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tracing_register_hook(tracer: GstTracer, detail: string, func: GObjectCallback): Promise<{ func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tracing_register_hook`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tracer && typeof tracer === 'object' && 'ptr' in tracer) {
      url.searchParams.append('tracer', 'ptr,' + tracer.ptr);
    }
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function type_find_get_type(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/type_find_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_find_register(name: string, rank: number, func: GstTypeFindFunction, plugin?: GstPlugin, extensions?: string, possible_caps?: GstCaps): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/type_find_register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    if (extensions !== undefined) url.searchParams.append('extensions', String(extensions));
    // Object with explode=false: serialize as comma-separated
    if (possible_caps !== undefined && typeof possible_caps === 'object' && 'ptr' in possible_caps) {
      url.searchParams.append('possible_caps', 'ptr,' + possible_caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  export async function type_is_plugin_api(type_: string, flags: GstPluginAPIFlagsValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/type_is_plugin_api`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_mark_as_plugin_api(type_: string, flags: GstPluginAPIFlagsValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/type_mark_as_plugin_api`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function update_registry(): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/update_registry`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_construct(protocol: string, location: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_construct`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    // Primitive parameter
    url.searchParams.append('location', String(location));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_error_quark(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_from_string(uri: string): Promise<GstUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function uri_from_string_escaped(uri: string): Promise<GstUri> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_from_string_escaped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function uri_get_location(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_get_location`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_get_protocol(uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_get_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_has_protocol(uri: string, protocol: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_has_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_is_valid(uri: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_join_strings(base_uri: string, ref_uri: string): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_join_strings`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('base_uri', String(base_uri));
    // Primitive parameter
    url.searchParams.append('ref_uri', String(ref_uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_protocol_is_supported(type_: GstURITypeValue, protocol: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_protocol_is_supported`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_protocol_is_valid(protocol: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_protocol_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_array_binary_search(num_elements: number, element_size: number, mode: GstSearchModeValue, search_func: GLibCompareDataFunc): Promise<{ search_func?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_array_binary_search`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('num_elements', String(num_elements));
    // Primitive parameter
    url.searchParams.append('element_size', String(element_size));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.search_func !== undefined) {
      callbackDispatcher.set(data.search_func.toString(), search_func);
    }
    return data;
  }
  export async function util_ceil_log2(v: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_ceil_log2`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v', String(v));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_double_to_fraction(src: number): Promise<{ dest_n?: number; dest_d?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_double_to_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function util_dump_buffer(buf: GstBuffer): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_dump_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buf && typeof buf === 'object' && 'ptr' in buf) {
      url.searchParams.append('buf', 'ptr,' + buf.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_dump_mem(mem: Pointer, size: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_dump_mem`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_filename_compare(a: Pointer, b: Pointer): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_filename_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_add(a_n: number, a_d: number, b_n: number, b_d: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_fraction_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a_n', String(a_n));
    // Primitive parameter
    url.searchParams.append('a_d', String(a_d));
    // Primitive parameter
    url.searchParams.append('b_n', String(b_n));
    // Primitive parameter
    url.searchParams.append('b_d', String(b_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_compare(a_n: number, a_d: number, b_n: number, b_d: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_fraction_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a_n', String(a_n));
    // Primitive parameter
    url.searchParams.append('a_d', String(a_d));
    // Primitive parameter
    url.searchParams.append('b_n', String(b_n));
    // Primitive parameter
    url.searchParams.append('b_d', String(b_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_multiply(a_n: number, a_d: number, b_n: number, b_d: number): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_fraction_multiply`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a_n', String(a_n));
    // Primitive parameter
    url.searchParams.append('a_d', String(a_d));
    // Primitive parameter
    url.searchParams.append('b_n', String(b_n));
    // Primitive parameter
    url.searchParams.append('b_d', String(b_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_to_double(src_n: number, src_d: number): Promise<{ dest?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_fraction_to_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_n', String(src_n));
    // Primitive parameter
    url.searchParams.append('src_d', String(src_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function util_gdouble_to_guint64(value_: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_gdouble_to_guint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_get_object_array(object: GObjectObject, name: string, array: GObjectValueArray): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_get_object_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_get_timestamp(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_get_timestamp`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_greatest_common_divisor(a: number, b: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_greatest_common_divisor`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_greatest_common_divisor_int64(a: number, b: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_greatest_common_divisor_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_group_id_next(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_group_id_next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_guint64_to_gdouble(value_: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_guint64_to_gdouble`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_seqnum_compare(s1: number, s2: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_seqnum_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_seqnum_next(): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_seqnum_next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_set_object_arg(object: GObjectObject, name: string, value_: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_set_object_arg`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_set_object_array(object: GObjectObject, name: string, array: GObjectValueArray): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_set_object_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_set_value_from_string(value_: GObjectValue, value_str: string): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_set_value_from_string`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('value_str', String(value_str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_simplify_fraction(numerator: number, denominator: number, n_terms: number, threshold: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_simplify_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('numerator', String(numerator));
    // Primitive parameter
    url.searchParams.append('denominator', String(denominator));
    // Primitive parameter
    url.searchParams.append('n_terms', String(n_terms));
    // Primitive parameter
    url.searchParams.append('threshold', String(threshold));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_uint64_scale(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_ceil(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_ceil`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_int(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_int_ceil(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_int_ceil`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_int_round(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_int_round`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_round(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_round`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_compare(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_can_compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_intersect(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_can_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_subtract(minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_can_subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (minuend && typeof minuend === 'object' && 'ptr' in minuend) {
      url.searchParams.append('minuend', 'ptr,' + minuend.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_union(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_can_union`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_compare(value1: GObjectValue, value2: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_deserialize(dest: GObjectValue, src: string): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_deserialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_deserialize_with_pspec(dest: GObjectValue, src: string, pspec?: GObjectParamSpec): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_deserialize_with_pspec`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Object with explode=false: serialize as comma-separated
    if (pspec !== undefined && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_fixate(dest: GObjectValue, src: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_fixate`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_fraction_multiply(product: GObjectValue, factor1: GObjectValue, factor2: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_fraction_multiply`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (product && typeof product === 'object' && 'ptr' in product) {
      url.searchParams.append('product', 'ptr,' + product.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (factor1 && typeof factor1 === 'object' && 'ptr' in factor1) {
      url.searchParams.append('factor1', 'ptr,' + factor1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (factor2 && typeof factor2 === 'object' && 'ptr' in factor2) {
      url.searchParams.append('factor2', 'ptr,' + factor2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_fraction_subtract(dest: GObjectValue, minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_fraction_subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (minuend && typeof minuend === 'object' && 'ptr' in minuend) {
      url.searchParams.append('minuend', 'ptr,' + minuend.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_bitmask(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_bitmask`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_caps(value_: GObjectValue): Promise<GstCaps> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_get_caps_features(value_: GObjectValue): Promise<GstCapsFeatures> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_caps_features`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_get_double_range_max(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_double_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_double_range_min(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_double_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_flagset_flags(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_flagset_flags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_flagset_mask(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_flagset_mask`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_denominator(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_fraction_denominator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_numerator(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_fraction_numerator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_range_max(value_: GObjectValue): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_fraction_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_get_fraction_range_min(value_: GObjectValue): Promise<GObjectValue> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_fraction_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_get_int64_range_max(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int64_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int64_range_min(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int64_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int64_range_step(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int64_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int_range_max(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int_range_min(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int_range_step(value_: GObjectValue): Promise<number> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_structure(value_: GObjectValue): Promise<GstStructure> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_init_and_copy(dest: GObjectValue, src: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_init_and_copy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_intersect(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_is_fixed(value_: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_is_fixed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_is_subset(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_is_subset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_register(table: GstValueTable): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (table && typeof table === 'object' && 'ptr' in table) {
      url.searchParams.append('table', 'ptr,' + table.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_serialize(value_: GObjectValue): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_serialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_set_bitmask(value_: GObjectValue, bitmask: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_bitmask`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('bitmask', String(bitmask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_caps(value_: GObjectValue, caps: GstCaps): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_caps_features(value_: GObjectValue, features: GstCapsFeatures): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_caps_features`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_double_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_double_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_flagset(value_: GObjectValue, flags: number, mask: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_flagset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_fraction(value_: GObjectValue, numerator: number, denominator: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_fraction`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('numerator', String(numerator));
    // Primitive parameter
    url.searchParams.append('denominator', String(denominator));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_fraction_range(value_: GObjectValue, start: GObjectValue, end: GObjectValue): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_fraction_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (start && typeof start === 'object' && 'ptr' in start) {
      url.searchParams.append('start', 'ptr,' + start.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_fraction_range_full(value_: GObjectValue, numerator_start: number, denominator_start: number, numerator_end: number, denominator_end: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_fraction_range_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('numerator_start', String(numerator_start));
    // Primitive parameter
    url.searchParams.append('denominator_start', String(denominator_start));
    // Primitive parameter
    url.searchParams.append('numerator_end', String(numerator_end));
    // Primitive parameter
    url.searchParams.append('denominator_end', String(denominator_end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int64_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_int64_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int64_range_step(value_: GObjectValue, start: number, end: number, step: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_int64_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    // Primitive parameter
    url.searchParams.append('step', String(step));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_int_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int_range_step(value_: GObjectValue, start: number, end: number, step: number): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_int_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    // Primitive parameter
    url.searchParams.append('step', String(step));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_structure(value_: GObjectValue, structure: GstStructure): Promise<void> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_subtract(dest: GObjectValue, minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (minuend && typeof minuend === 'object' && 'ptr' in minuend) {
      url.searchParams.append('minuend', 'ptr,' + minuend.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_union(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_union`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function version(): Promise<{ major?: number; minor?: number; micro?: number; nano?: number }> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/version`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function version_string(): Promise<string> {
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/version_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

