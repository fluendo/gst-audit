/**
 * Gst REST API
 * Version: 1.0
 * Auto-generated by girest-client-generator
 */

// Configuration for API server location
let apiConfig = {
  host: 'localhost',
  port: 9000,
  basePath: '',
  get baseUrl(): string {
    return `http://${this.host}:${this.port}`;
  },
  get normalizedBasePath(): string {
    return this.basePath && !this.basePath.startsWith('/') ? `/${this.basePath}` : this.basePath;
  },
  get fullBaseUrl(): string {
    return `http://${this.host}:${this.port}${this.normalizedBasePath}`;
  },
};

/**
 * Update the API server configuration
 * @param config New configuration with host, port, and/or basePath
 */
export function setApiConfig(config: { host?: string; port?: number; basePath?: string }): void {
  if (config.host !== undefined) {
    apiConfig.host = config.host;
  }
  if (config.port !== undefined) {
    apiConfig.port = config.port;
  }
  if (config.basePath !== undefined) {
    apiConfig.basePath = config.basePath;
  }

  // Reinitialize callback EventSource with new URL
  if (typeof EventSource !== 'undefined' && (config.host !== undefined || config.port !== undefined || config.basePath !== undefined)) {
    initializeCallbackSource();
  }
}

/**
 * Get the current API server configuration
 */
export function getApiConfig(): { host: string; port: number; basePath: string; baseUrl: string } {
  return {
    host: apiConfig.host,
    port: apiConfig.port,
    basePath: apiConfig.basePath,
    baseUrl: apiConfig.baseUrl
  };
}

// FinalizationRegistry for automatic cleanup of GObject instances
const objectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Object/ptr,' + ptr + '/unref')
    .catch(err => console.error('Failed to unref object:', ptr, err));
});

// Callback dispatcher for handling callbacks from the server
interface CallbackEntry {
  converter: (data: any) => any[];
  userFunction: Function;
}
const callbackDispatcher = new Map<string, CallbackEntry>();

let callbackSource: EventSource | null = null;
let isReinitializing = false;

function initializeCallbackSource(): void {
  // Prevent concurrent reinitialization
  if (isReinitializing) {
    return;
  }
  isReinitializing = true;
  
  // Close existing EventSource if it exists
  if (callbackSource) {
    callbackSource.close();
    callbackSource = null;
  }
  
  // Initialize callback dispatcher with EventSource
  if (typeof EventSource !== 'undefined') {
    callbackSource = new EventSource(apiConfig.fullBaseUrl + '/GIRest/callbacks');
    callbackSource.onmessage = (ev) => {
      try {
        const json = JSON.parse(ev.data);
        const callbackEntry = callbackDispatcher.get(json.id.toString());
        if (callbackEntry) {
          const convertedArgs = callbackEntry.converter(json.data);
          callbackEntry.userFunction(...convertedArgs);
        }
      } catch (error) {
        console.error('Error processing callback:', error);
      }
    };
    callbackSource.onerror = (error) => {
      console.error('Callback EventSource error:', error);
    };
    callbackSource.onopen = () => {
      isReinitializing = false;
    };
  } else {
    isReinitializing = false;
  }
}

// Define the core interfaces for objects and structs memory management
interface ObjectLikeInstance {
  ref(): Promise<void>;
  unref(): Promise<void>;
}

interface StructLikeInstance {
  free(): Promise<void>;
  copy(): Promise<void>;
}

// Combined interface for objects that might need various cleanup
interface ManagedResource extends Partial<ObjectLikeInstance>, Partial<StructLikeInstance> {}

type transferType = 'none' | 'container' | 'full';

  export type Pointer = string;
  export interface Event {
  data: string;
}

  
// Finalization registry for GObjectTypeInstance
const gobjecttypeinstanceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/TypeInstance/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectTypeInstance:', ptr, err));
});

export class GObjectTypeInstance {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjecttypeinstanceRegistry.register(this, ptr);
  }


    





 
  async get_private(private_type: string): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInstance/ptr,${this.ptr}/get_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_type', String(private_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_g_class(): Promise<GObjectTypeClass | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInstance/ptr,${this.ptr}/fields/g_class`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeClass(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  // Finalization registry for GObjectObject
const gobjectobjectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Object/ptr,' + ptr + '/unref')
    .catch(err => console.error('Failed to free GObjectObject:', ptr, err));
});

// Type interface for GObject constructors with static get_type method
interface GObjectConstructor<T extends GObjectObject> {
  new (ptr: string, transferType: transferType): T;
	get_type(): Promise<string>;
}

export class GObjectObject extends GObjectTypeInstance {


  constructor(ptr: string, transferType: transferType) {
	super(ptr, 'none');
    this.ptr = ptr;
    gobjectobjectRegistry.register(this, ptr);
    if (transferType === 'none') {
      this.ref().catch(() => {});
    }
  }

    





 
  static async newv(object_type: string, n_parameters: number, parameters: Pointer): Promise<GObjectObject> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/newv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('object_type', String(object_type));
    // Primitive parameter
    url.searchParams.append('n_parameters', String(n_parameters));
    // Primitive parameter
    url.searchParams.append('parameters', String(parameters));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectObject(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


	castTo<T extends GObjectObject>(TargetClass: GObjectConstructor<T>): T {
    return new TargetClass(this.ptr, 'none');
  }

	async isOf<T extends GObjectObject>(TargetClass: GObjectConstructor<T>): Promise<boolean> {
    const type = await TargetClass.get_type();
    const is_type = await GObject.type_check_instance_is_a(this, type);
    return is_type;
  }

      





 
  static async compat_control(what: number, data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/compat_control`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('what', String(what));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async interface_find_property(g_iface: GObjectTypeInterface, property_name: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/interface_find_property`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async interface_install_property(g_iface: GObjectTypeInterface, pspec: GObjectParamSpec): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/interface_install_property`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async interface_list_properties(g_iface: GObjectTypeInterface): Promise<{n_properties_p: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/interface_list_properties`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: n_properties_p
      result.n_properties_p = (() => {
        return data.n_properties_p;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async bind_property(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlagsValue): Promise<GObjectBinding> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/bind_property`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectBinding(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async bind_property_full(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlagsValue, transform_to: GObjectClosure, transform_from: GObjectClosure): Promise<GObjectBinding> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/bind_property_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Object with explode=false: serialize as comma-separated
    if (transform_to && typeof transform_to === 'object' && 'ptr' in transform_to) {
      url.searchParams.append('transform_to', 'ptr,' + transform_to.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (transform_from && typeof transform_from === 'object' && 'ptr' in transform_from) {
      url.searchParams.append('transform_from', 'ptr,' + transform_from.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectBinding(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async force_floating(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/force_floating`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async freeze_notify(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/freeze_notify`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_data(key: string): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/get_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_property(property_name: string, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/get_property`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_qdata(quark: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async getv(n_properties: number, names: Pointer, values: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/getv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_properties', String(n_properties));
    // Primitive parameter
    url.searchParams.append('names', String(names));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_floating(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/is_floating`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async notify(property_name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/notify`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async notify_by_pspec(pspec: GObjectParamSpec): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/notify_by_pspec`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async ref(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    // ref() should not create a new instance - it just increments the reference count
    // and returns the same object (this) to avoid infinite recursion
    return this;
		}

      





 
  async ref_sink(): Promise<GObjectObject> {
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/ref_sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    // ref_sink() should not create a new instance - it just sinks the floating reference
    // and returns the same object (this) to avoid infinite recursion
    return this;
  }

      





 
  async run_dispose(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/run_dispose`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_data(key: string, data_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/set_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_property(property_name: string, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/set_property`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async steal_data(key: string): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/steal_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async steal_qdata(quark: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async thaw_notify(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/thaw_notify`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async watch_closure(closure: GObjectClosure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/ptr,${this.ptr}/watch_closure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Object/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


}
  
export class GObjectBinding extends GObjectObject {




      





 
  async dup_source(): Promise<GObjectObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/dup_source`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectObject(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async dup_target(): Promise<GObjectObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/dup_target`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectObject(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_flags(): Promise<GObjectBindingFlagsValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_source(): Promise<GObjectObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_source`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectObject(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_source_property(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_source_property`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_target(): Promise<GObjectObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_target`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectObject(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_target_property(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/get_target_property`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unbind(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/ptr,${this.ptr}/unbind`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Binding/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectTypeInterface
const gobjecttypeinterfaceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/TypeInterface/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectTypeInterface:', ptr, err));
});

export class GObjectTypeInterface {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjecttypeinterfaceRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GObjectTypeInterface> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeInterface(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async peek_parent(): Promise<GObjectTypeInterface> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/ptr,${this.ptr}/peek_parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeInterface(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async add_prerequisite(interface_type: string, prerequisite_type: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/add_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Primitive parameter
    url.searchParams.append('prerequisite_type', String(prerequisite_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_plugin(instance_type: string, interface_type: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/get_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async instantiatable_prerequisite(interface_type: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/instantiatable_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async peek(instance_class: GObjectTypeClass, iface_type: string): Promise<GObjectTypeInterface> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/peek`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance_class && typeof instance_class === 'object' && 'ptr' in instance_class) {
      url.searchParams.append('instance_class', 'ptr,' + instance_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('iface_type', String(iface_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeInterface(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async prerequisites(interface_type: string): Promise<{n_prerequisites: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/prerequisites`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: n_prerequisites
      result.n_prerequisites = (() => {
        return data.n_prerequisites;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_g_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/ptr,${this.ptr}/fields/g_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_g_instance_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeInterface/ptr,${this.ptr}/fields/g_instance_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectTypeClass
const gobjecttypeclassRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/TypeClass/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectTypeClass:', ptr, err));
});

export class GObjectTypeClass {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjecttypeclassRegistry.register(this, ptr);
  }


    





 
  async add_private(private_size: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ptr,${this.ptr}/add_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_size', String(private_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_private(private_type: string): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ptr,${this.ptr}/get_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_type', String(private_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek_parent(): Promise<GObjectTypeClass> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ptr,${this.ptr}/peek_parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeClass(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async adjust_private_offset(private_size_or_offset: number, g_class?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/adjust_private_offset`, apiConfig.baseUrl);
    // Primitive parameter
    if (g_class !== undefined) url.searchParams.append('g_class', String(g_class));
    // Primitive parameter
    url.searchParams.append('private_size_or_offset', String(private_size_or_offset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async peek(type_: string): Promise<GObjectTypeClass> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeClass(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async peek_static(type_: string): Promise<GObjectTypeClass> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/peek_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeClass(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async ref(type_: string): Promise<GObjectTypeClass> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeClass(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_g_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeClass/ptr,${this.ptr}/fields/g_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  // Finalization registry for GObjectParamSpec
const gobjectparamspecRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/ParamSpec/ptr,' + ptr + '/unref')
    .catch(err => console.error('Failed to free GObjectParamSpec:', ptr, err));
});

export class GObjectParamSpec extends GObjectTypeInstance {


  constructor(ptr: string, transferType: transferType) {
	super(ptr, 'none');
    this.ptr = ptr;
    gobjectparamspecRegistry.register(this, ptr);
    if (transferType === 'none') {
      this.ref().catch(() => {});
    }
  }



      





 
  static async is_valid_name(name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/is_valid_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_blurb(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_blurb`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_default_value(): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_default_value`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_name(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_name_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_name_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_nick(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_nick`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_qdata(quark: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_redirect_target(): Promise<GObjectParamSpec | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/get_redirect_target`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_qdata(quark: number, data_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/set_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async sink(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/sink`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async steal_qdata(quark: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/ptr,${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpec/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectValue
const gobjectvalueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Value/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectValue:', ptr, err));
});

export class GObjectValue {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectvalueRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(dest_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest_value && typeof dest_value === 'object' && 'ptr' in dest_value) {
      url.searchParams.append('dest_value', 'ptr,' + dest_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dup_object(): Promise<GObjectObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/dup_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectObject(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dup_string(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/dup_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dup_variant(): Promise<GLibVariant | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/dup_variant`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fits_pointer(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/fits_pointer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_boolean(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_boxed(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_boxed`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_char(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_char`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_double(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_enum(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_enum`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_float(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_float`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_gtype(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_gtype`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_int`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int64(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_long(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_long`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_object(): Promise<GObjectObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectObject(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_param(): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_param`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_pointer(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_pointer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_schar(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_schar`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uchar(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_uchar`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_uint`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint64(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_ulong(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_ulong`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_variant(): Promise<GLibVariant | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/get_variant`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(g_type: string): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_type', String(g_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init_from_instance(instance: GObjectTypeInstance): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/init_from_instance`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek_pointer(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/peek_pointer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reset(): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/reset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_boolean(v_boolean: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_boolean', String(v_boolean));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_boxed(v_boxed?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_boxed`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_boxed !== undefined) url.searchParams.append('v_boxed', String(v_boxed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_boxed_take_ownership(v_boxed?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_boxed_take_ownership`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_boxed !== undefined) url.searchParams.append('v_boxed', String(v_boxed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_char(v_char: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_char', String(v_char));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_double(v_double: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_double', String(v_double));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_enum(v_enum: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_enum', String(v_enum));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_flags(v_flags: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_flags', String(v_flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_float(v_float: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_float`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_float', String(v_float));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_gtype(v_gtype: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_gtype`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_gtype', String(v_gtype));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_instance(instance?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_instance`, apiConfig.baseUrl);
    // Primitive parameter
    if (instance !== undefined) url.searchParams.append('instance', String(instance));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_int(v_int: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_int', String(v_int));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_int64(v_int64: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_int64', String(v_int64));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_interned_string(v_string?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_interned_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_long(v_long: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_long`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_long', String(v_long));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_object(v_object?: GObjectObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_object`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (v_object !== undefined && typeof v_object === 'object' && 'ptr' in v_object) {
      url.searchParams.append('v_object', 'ptr,' + v_object.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_param(param?: GObjectParamSpec): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_param`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (param !== undefined && typeof param === 'object' && 'ptr' in param) {
      url.searchParams.append('param', 'ptr,' + param.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_pointer(v_pointer?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_pointer !== undefined) url.searchParams.append('v_pointer', String(v_pointer));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_schar(v_char: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_schar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_char', String(v_char));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_static_boxed(v_boxed?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_static_boxed`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_boxed !== undefined) url.searchParams.append('v_boxed', String(v_boxed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_static_string(v_string?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_static_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_string(v_string?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_string_take_ownership(v_string?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_string_take_ownership`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_uchar(v_uchar: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_uchar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_uchar', String(v_uchar));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_uint(v_uint: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_uint', String(v_uint));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_uint64(v_uint64: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_uint64', String(v_uint64));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_ulong(v_ulong: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_ulong`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_ulong', String(v_ulong));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_variant(variant?: GLibVariant): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/set_variant`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (variant !== undefined && typeof variant === 'object' && 'ptr' in variant) {
      url.searchParams.append('variant', 'ptr,' + variant.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async steal_string(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/steal_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async take_boxed(v_boxed?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/take_boxed`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_boxed !== undefined) url.searchParams.append('v_boxed', String(v_boxed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async take_string(v_string?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/take_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async take_variant(variant?: GLibVariant): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/take_variant`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (variant !== undefined && typeof variant === 'object' && 'ptr' in variant) {
      url.searchParams.append('variant', 'ptr,' + variant.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async transform(dest_value: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/transform`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest_value && typeof dest_value === 'object' && 'ptr' in dest_value) {
      url.searchParams.append('dest_value', 'ptr,' + dest_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unset(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/unset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async type_compatible(src_type: string, dest_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/type_compatible`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async type_transformable(src_type: string, dest_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/type_transformable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_g_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/fields/g_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_data(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Value/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibDestroyNotify = (data_: Pointer) => void;

export function convertGLibDestroyNotifyArgs(data: any): Parameters<GLibDestroyNotify> {
  return [
    data.data  ];
}
  
// Finalization registry for GLibVariant
const glibvariantRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Variant/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibVariant:', ptr, err));
});

export class GLibVariant {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibvariantRegistry.register(this, ptr);
  }
    





 
  static async new_array(n_children: number, child_type?: GLibVariantType, children?: Pointer): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_type !== undefined && typeof child_type === 'object' && 'ptr' in child_type) {
      url.searchParams.append('child_type', 'ptr,' + child_type.ptr);
    }
    // Primitive parameter
    if (children !== undefined) url.searchParams.append('children', String(children));
    // Primitive parameter
    url.searchParams.append('n_children', String(n_children));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_boolean(value_: boolean): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_byte(value_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_byte`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_bytestring(string: Pointer): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_bytestring`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_bytestring_array(strv: Pointer, length: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_bytestring_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_dict_entry(key: GLibVariant, value_: GLibVariant): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_dict_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (key && typeof key === 'object' && 'ptr' in key) {
      url.searchParams.append('key', 'ptr,' + key.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_double(value_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_fixed_array(element_type: GLibVariantType, n_elements: number, element_size: number, elements?: Pointer): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_fixed_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element_type && typeof element_type === 'object' && 'ptr' in element_type) {
      url.searchParams.append('element_type', 'ptr,' + element_type.ptr);
    }
    // Primitive parameter
    if (elements !== undefined) url.searchParams.append('elements', String(elements));
    // Primitive parameter
    url.searchParams.append('n_elements', String(n_elements));
    // Primitive parameter
    url.searchParams.append('element_size', String(element_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_bytes(type_: GLibVariantType, bytes: GLibBytes, trusted: boolean): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_from_bytes`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (bytes && typeof bytes === 'object' && 'ptr' in bytes) {
      url.searchParams.append('bytes', 'ptr,' + bytes.ptr);
    }
    // Primitive parameter
    url.searchParams.append('trusted', String(trusted));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_data(type_: GLibVariantType, data_: Pointer, size: number, trusted: boolean, notify: GLibDestroyNotify, user_data?: Pointer): Promise<{notify: number, return: GLibVariant}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_from_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('trusted', String(trusted));
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.notify !== undefined) {
        callbackDispatcher.set(data.notify.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: notify
        });
      }
        const result: any = {};
      // Handle return parameter: notify
      result.notify = (() => {
        return data.notify;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibVariant(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_handle(value_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_handle`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_int16(value_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_int16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_int32(value_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_int32`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_int64(value_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_maybe(child_type?: GLibVariantType, child?: GLibVariant): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_maybe`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_type !== undefined && typeof child_type === 'object' && 'ptr' in child_type) {
      url.searchParams.append('child_type', 'ptr,' + child_type.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (child !== undefined && typeof child === 'object' && 'ptr' in child) {
      url.searchParams.append('child', 'ptr,' + child.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_object_path(object_path: string): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_object_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('object_path', String(object_path));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_objv(strv: Pointer, length: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_objv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_signature(signature: string): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_signature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signature', String(signature));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_string(string: string): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_strv(strv: Pointer, length: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_strv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_tuple(children: Pointer, n_children: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_tuple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('children', String(children));
    // Primitive parameter
    url.searchParams.append('n_children', String(n_children));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_uint16(value_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_uint16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_uint32(value_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_uint32`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_uint64(value_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_variant(value_: GLibVariant): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/new_variant`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async byteswap(): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/byteswap`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async check_format_string(format_string: string, copy_only: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/check_format_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format_string', String(format_string));
    // Primitive parameter
    url.searchParams.append('copy_only', String(copy_only));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async classify(): Promise<GLibVariantClass> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/classify`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async compare(two: GLibVariant): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (two && typeof two === 'object' && 'ptr' in two) {
      url.searchParams.append('two', 'ptr,' + two.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dup_bytestring(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_bytestring`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dup_bytestring_array(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_bytestring_array`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dup_objv(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_objv`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dup_string(): Promise<{length: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dup_strv(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/dup_strv`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async equal(two: GLibVariant): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (two && typeof two === 'object' && 'ptr' in two) {
      url.searchParams.append('two', 'ptr,' + two.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_boolean(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_byte(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_byte`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_bytestring(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_bytestring`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_bytestring_array(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_bytestring_array`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_child_value(index_: number): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_child_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data_as_bytes(): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_data_as_bytes`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_double(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_handle(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_handle`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int16(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_int16`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int32(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_int32`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int64(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_maybe(): Promise<GLibVariant | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_maybe`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_normal_form(): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_normal_form`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_objv(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_objv`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string(): Promise<{length: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_strv(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_strv`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type(): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_type_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint16(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_uint16`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint32(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_uint32`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint64(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_variant(): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/get_variant`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async hash(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_container(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/is_container`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_floating(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/is_floating`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_normal_form(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/is_normal_form`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_of_type(type_: GLibVariantType): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/is_of_type`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lookup_value(key: string, expected_type?: GLibVariantType): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/lookup_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Object with explode=false: serialize as comma-separated
    if (expected_type !== undefined && typeof expected_type === 'object' && 'ptr' in expected_type) {
      url.searchParams.append('expected_type', 'ptr,' + expected_type.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async n_children(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/n_children`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async print(type_annotate: boolean): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/print`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_annotate', String(type_annotate));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref_sink(): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/ref_sink`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async store(data_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/store`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async take_ref(): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/take_ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async is_object_path(string: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/is_object_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async is_signature(string: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/is_signature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async parse(text: string, type_?: GLibVariantType, limit?: string, endptr?: string): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/parse`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ !== undefined && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    // Primitive parameter
    if (endptr !== undefined) url.searchParams.append('endptr', String(endptr));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async parse_error_print_context(error_: Pointer, source_str: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/parse_error_print_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('source_str', String(source_str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async parse_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/parse_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async parser_get_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/parser_get_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Variant/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibVariantType
const glibvarianttypeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/VariantType/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibVariantType:', ptr, err));
});

export class GLibVariantType {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibvarianttypeRegistry.register(this, ptr);
  }
    





 
  static async new(type_string: string): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_array(element: GLibVariantType): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_dict_entry(key: GLibVariantType, value_: GLibVariantType): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new_dict_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (key && typeof key === 'object' && 'ptr' in key) {
      url.searchParams.append('key', 'ptr,' + key.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_maybe(element: GLibVariantType): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new_maybe`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_tuple(items: Pointer, length: number): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/new_tuple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('items', String(items));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dup_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/dup_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async element(): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/element`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async equal(type2: GLibVariantType): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type2 && typeof type2 === 'object' && 'ptr' in type2) {
      url.searchParams.append('type2', 'ptr,' + type2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async first(): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/first`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string_length(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/get_string_length`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async hash(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_array(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_array`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_basic(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_basic`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_container(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_container`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_definite(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_definite`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_dict_entry(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_dict_entry`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_maybe(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_maybe`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_subtype_of(supertype: GLibVariantType): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_subtype_of`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (supertype && typeof supertype === 'object' && 'ptr' in supertype) {
      url.searchParams.append('supertype', 'ptr,' + supertype.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_tuple(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_tuple`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_variant(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/is_variant`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async key(): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/key`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async n_items(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/n_items`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async next(): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async value_(): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/ptr,${this.ptr}/value`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async checked_(type_string: string): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/checked_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async string_get_depth_(type_string: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/string_get_depth_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async string_is_valid(type_string: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/string_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async string_scan(string: string, limit?: string): Promise<{endptr: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/string_scan`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: endptr
      result.endptr = (() => {
        return data.endptr;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibBytes
const glibbytesRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Bytes/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibBytes:', ptr, err));
});

export class GLibBytes {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibbytesRegistry.register(this, ptr);
  }
    





 
  static async new(size: number, data_?: Pointer): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_take(size: number, data_?: Pointer): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/new_take`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async compare(bytes2: GLibBytes): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes2 && typeof bytes2 === 'object' && 'ptr' in bytes2) {
      url.searchParams.append('bytes2', 'ptr,' + bytes2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async equal(bytes2: GLibBytes): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes2 && typeof bytes2 === 'object' && 'ptr' in bytes2) {
      url.searchParams.append('bytes2', 'ptr,' + bytes2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<{size: number, return: Pointer | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/get_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: size
      result.size = (() => {
        return data.size;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_region(element_size: number, offset: number, n_elements: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/get_region`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('element_size', String(element_size));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('n_elements', String(n_elements));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async hash(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async new_from_bytes(offset: number, length: number): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/new_from_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref_to_array(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/unref_to_array`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref_to_data(): Promise<{size: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/ptr,${this.ptr}/unref_to_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: size
      result.size = (() => {
        return data.size;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Bytes/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibVariantClass = "boolean" | "byte" | "int16" | "uint16" | "int32" | "uint32" | "int64" | "uint64" | "handle" | "double" | "string" | "object_path" | "signature" | "variant" | "maybe" | "array" | "tuple" | "dict_entry";

  export namespace GObjectBindingFlags {
  export const DEFAULT: 'default' = 'default';
  export const BIDIRECTIONAL: 'bidirectional' = 'bidirectional';
  export const SYNC_CREATE: 'sync_create' = 'sync_create';
  export const INVERT_BOOLEAN: 'invert_boolean' = 'invert_boolean';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GObjectBindingFlagsValue = "default" | "bidirectional" | "sync_create" | "invert_boolean";

  
// Finalization registry for GObjectClosure
const gobjectclosureRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Closure/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectClosure:', ptr, err));
});

export class GObjectClosure {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectclosureRegistry.register(this, ptr);
  }
    





 
  static async new_object(sizeof_closure: number, object: GObjectObject): Promise<GObjectClosure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/new_object`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('sizeof_closure', String(sizeof_closure));
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectClosure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_simple(sizeof_closure: number, data_?: Pointer): Promise<GObjectClosure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/new_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('sizeof_closure', String(sizeof_closure));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectClosure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async invalidate(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/invalidate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async invoke(return_value: GObjectValue, n_param_values: number, param_values: Pointer, invocation_hint?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/invoke`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Primitive parameter
    url.searchParams.append('param_values', String(param_values));
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GObjectClosure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectClosure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async sink(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/sink`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_ref_count(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/ref_count`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_meta_marshal_nouse(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/meta_marshal_nouse`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_guards(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/n_guards`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_fnotifiers(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/n_fnotifiers`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_inotifiers(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/n_inotifiers`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_in_inotify(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/in_inotify`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_floating(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/floating`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_derivative_flag(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/derivative_flag`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_in_marshal(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/in_marshal`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_in_marshal(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/in_marshal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_is_invalid(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/is_invalid`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_is_invalid(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/is_invalid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_marshal(): Promise<GObjectmarshal | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/marshal`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_notifiers(): Promise<GObjectClosureNotifyData | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/ptr,${this.ptr}/fields/notifiers`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectClosureNotifyData(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/Closure/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GObjectmarshal = (closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint: Pointer, marshal_data: Pointer) => void;

export function convertGObjectmarshalArgs(data: any): Parameters<GObjectmarshal> {
  return [
    new GObjectClosure(data.closure, 'none'),
    new GObjectValue(data.return_value, 'none'),
    data.n_param_values,
    new GObjectValue(data.param_values, 'none'),
    data.invocation_hint,
    data.marshal_data  ];
}
  
// Finalization registry for GObjectClosureNotifyData
const gobjectclosurenotifydataRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/ClosureNotifyData/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectClosureNotifyData:', ptr, err));
});

export class GObjectClosureNotifyData {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectclosurenotifydataRegistry.register(this, ptr);
  }


}
  
export class GObjectBindingGroup extends GObjectObject {


    





 
  static async new(): Promise<GObjectBindingGroup> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectBindingGroup(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async bind(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/ptr,${this.ptr}/bind`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async bind_full(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlagsValue, transform_to?: GObjectClosure, transform_from?: GObjectClosure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/ptr,${this.ptr}/bind_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Object with explode=false: serialize as comma-separated
    if (transform_to !== undefined && typeof transform_to === 'object' && 'ptr' in transform_to) {
      url.searchParams.append('transform_to', 'ptr,' + transform_to.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (transform_from !== undefined && typeof transform_from === 'object' && 'ptr' in transform_from) {
      url.searchParams.append('transform_from', 'ptr,' + transform_from.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async dup_source(): Promise<GObjectObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/ptr,${this.ptr}/dup_source`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectObject(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_source(source?: GObjectObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/ptr,${this.ptr}/set_source`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (source !== undefined && typeof source === 'object' && 'ptr' in source) {
      url.searchParams.append('source', 'ptr,' + source.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/BindingGroup/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectCClosure
const gobjectcclosureRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/CClosure/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectCClosure:', ptr, err));
});

export class GObjectCClosure {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectcclosureRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GObjectCClosure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectCClosure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  static async marshal_BOOLEAN__BOXED_BOXED(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_BOOLEAN__BOXED_BOXED`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_BOOLEAN__FLAGS(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_BOOLEAN__FLAGS`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_STRING__OBJECT_POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_STRING__OBJECT_POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__BOOLEAN(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__BOOLEAN`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__BOXED(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__BOXED`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__CHAR(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__CHAR`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__DOUBLE(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__DOUBLE`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__ENUM(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__ENUM`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__FLAGS(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__FLAGS`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__FLOAT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__FLOAT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__INT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__INT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__LONG(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__LONG`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__OBJECT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__OBJECT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__PARAM(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__PARAM`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__STRING(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__STRING`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__UCHAR(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__UCHAR`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__UINT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__UINT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__UINT_POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__UINT_POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__ULONG(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__ULONG`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__VARIANT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__VARIANT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_VOID__VOID(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_VOID__VOID`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async marshal_generic(closure: GObjectClosure, return_gvalue: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/marshal_generic`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_gvalue && typeof return_gvalue === 'object' && 'ptr' in return_gvalue) {
      url.searchParams.append('return_gvalue', 'ptr,' + return_gvalue.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_closure(): Promise<GObjectClosure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/ptr,${this.ptr}/fields/closure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectClosure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_closure(value_: GObjectClosure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/ptr,${this.ptr}/fields/closure`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_callback(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/ptr,${this.ptr}/fields/callback`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_callback(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/CClosure/ptr,${this.ptr}/fields/callback`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GObjectConnectFlags = "default" | "after" | "swapped";

  
// Finalization registry for GObjectEnumClass
const gobjectenumclassRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/EnumClass/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectEnumClass:', ptr, err));
});

export class GObjectEnumClass {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectenumclassRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GObjectEnumValue
const gobjectenumvalueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/EnumValue/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectEnumValue:', ptr, err));
});

export class GObjectEnumValue {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectenumvalueRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GObjectFlagsClass
const gobjectflagsclassRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/FlagsClass/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectFlagsClass:', ptr, err));
});

export class GObjectFlagsClass {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectflagsclassRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GObjectFlagsValue
const gobjectflagsvalueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/FlagsValue/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectFlagsValue:', ptr, err));
});

export class GObjectFlagsValue {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectflagsvalueRegistry.register(this, ptr);
  }


}
  export namespace GObjectIOCondition {
  export const IN: 'in' = 'in';
  export const OUT: 'out' = 'out';
  export const PRI: 'pri' = 'pri';
  export const ERR: 'err' = 'err';
  export const HUP: 'hup' = 'hup';
  export const NVAL: 'nval' = 'nval';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/IOCondition/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GObjectIOConditionValue = "in" | "out" | "pri" | "err" | "hup" | "nval";

  
export class GObjectInitiallyUnowned extends GObjectObject {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/InitiallyUnowned/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectInterfaceInfo
const gobjectinterfaceinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/InterfaceInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectInterfaceInfo:', ptr, err));
});

export class GObjectInterfaceInfo {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectinterfaceinfoRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GObjectObjectConstructParam
const gobjectobjectconstructparamRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/ObjectConstructParam/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectObjectConstructParam:', ptr, err));
});

export class GObjectObjectConstructParam {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectobjectconstructparamRegistry.register(this, ptr);
  }


}
  export type GObjectParamFlags = "readable" | "writable" | "readwrite" | "construct" | "construct_only" | "lax_validation" | "static_name" | "private" | "static_nick" | "static_blurb" | "explicit_notify" | "deprecated";

  
export class GObjectParamSpecBoolean extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecBoolean/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecBoxed extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecBoxed/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecChar extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecChar/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecDouble extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecDouble/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecEnum extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecEnum/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecFlags extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecFloat extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecFloat/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecGType extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecGType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecInt extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecInt/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecInt64 extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecInt64/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecLong extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecLong/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecObject extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecObject/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecOverride extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecOverride/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecParam extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecParam/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecPointer extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPointer/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectParamSpecPool
const gobjectparamspecpoolRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/ParamSpecPool/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectParamSpecPool:', ptr, err));
});

export class GObjectParamSpecPool {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectparamspecpoolRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GObjectParamSpecPool> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectParamSpecPool(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async insert(pspec: GObjectParamSpec, owner_type: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Primitive parameter
    url.searchParams.append('owner_type', String(owner_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async list(owner_type: string): Promise<{n_pspecs_p: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('owner_type', String(owner_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: n_pspecs_p
      result.n_pspecs_p = (() => {
        return data.n_pspecs_p;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async list_owned(owner_type: string): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/list_owned`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('owner_type', String(owner_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'container', GObjectParamSpec, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lookup(param_name: string, owner_type: string, walk_ancestors: boolean): Promise<GObjectParamSpec | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('param_name', String(param_name));
    // Primitive parameter
    url.searchParams.append('owner_type', String(owner_type));
    // Primitive parameter
    url.searchParams.append('walk_ancestors', String(walk_ancestors));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(pspec: GObjectParamSpec): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecPool/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibList
const gliblistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/List/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibList:', ptr, err));
});

export class GLibList<T = any> implements AsyncIterable<T> {

	ptr!: string;
	head?: GLibList<T>;
  transferType!: transferType;
  TargetClass!: new (ptr: string, transferType: transferType) => T;

	constructor(ptr: string, transferType: transferType, TargetClass: new (ptr: string, transferType: transferType) => T, head?: GLibList<T>) {
    if (ptr) {
      this.ptr = ptr;
      this.transferType = transferType;
			this.TargetClass = TargetClass;
			this.head = head;
      if (transferType !== 'none' && head === undefined)
			  gliblistRegistry.register(this, ptr);
    }
  }
    





	static async new<T>(TargetClass: new (ptr: string, transferType: transferType) => T): Promise<GLibList<T>> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', TargetClass, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


  // Implement AsyncIterable interface
  [Symbol.asyncIterator](): AsyncIterator<T, any, any> {
    let currentNode: GLibList | null = this;
    
    return {
      next: async (): Promise<IteratorResult<T>> => {
        // Check if current node is null/undefined (reached end of list)
        if (!currentNode || !currentNode.ptr) {
          return { done: true, value: undefined };
        }
        
        try {
          // Get the data from the current node
          const data = await currentNode.get_data();
          
          // Move to the next node
          const nextNode = await currentNode.get_next();
          
          // Check if nextNode has a valid pointer, if not we've reached the end
          if (nextNode && typeof nextNode === 'object' && 'ptr' in nextNode && nextNode.ptr) {
            currentNode = nextNode;
          } else {
            currentNode = null;
          }
          
          // Create an instance of the target class if TargetClass is provided and data is a pointer
          if (this.TargetClass && data && typeof data === 'string') {
            const instance = new this.TargetClass(data, this.transferType === 'full' ? 'full' : 'none');
            return { done: false, value: instance };
          }
          
          // Otherwise return the raw data cast to type T
          return { done: false, value: data as T };
        } catch (error) {
          // If we get an error, we're probably at the end of the list
          return { done: true, value: undefined };
        }
      }
    };
  }

    





 
  static async pop_allocator(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/pop_allocator`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async push_allocator(allocator: GLibAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_data(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





  async get_next(): Promise<GLibList<T> | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', this.TargetClass, this.head);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





	async put_next(value_: GLibList<T>): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





  async get_prev(): Promise<GLibList<T> | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/ptr,${this.ptr}/fields/prev`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', this.TargetClass, this.head);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





	async put_prev(value_: GLibList<T>): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/List/ptr,${this.ptr}/fields/prev`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


}
  
// Finalization registry for GLibAllocator
const gliballocatorRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Allocator/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibAllocator:', ptr, err));
});

export class GLibAllocator {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gliballocatorRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibAllocator> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Allocator/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibAllocator(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Allocator/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


}
  
export class GObjectParamSpecString extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecString/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectParamSpecTypeInfo
const gobjectparamspectypeinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/ParamSpecTypeInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectParamSpecTypeInfo:', ptr, err));
});

export class GObjectParamSpecTypeInfo {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectparamspectypeinfoRegistry.register(this, ptr);
  }


}
  
export class GObjectParamSpecUChar extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecUChar/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecUInt extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecUInt/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecUInt64 extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecUInt64/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecULong extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecULong/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecUnichar extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecUnichar/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecValueArray extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecValueArray/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GObjectParamSpecVariant extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ParamSpecVariant/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectParameter
const gobjectparameterRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Parameter/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectParameter:', ptr, err));
});

export class GObjectParameter {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectparameterRegistry.register(this, ptr);
  }


}
  export type GObjectSignalFlags = "run_first" | "run_last" | "run_cleanup" | "no_recurse" | "detailed" | "action" | "no_hooks" | "must_collect" | "deprecated" | "accumulator_first_run";

  export type GObjectCallback = () => void;

export function convertGObjectCallbackArgs(data: any): Parameters<GObjectCallback> {
  return [
  ];
}
  
export class GObjectSignalGroup extends GObjectObject {


    





 
  static async new(target_type: string): Promise<GObjectSignalGroup> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('target_type', String(target_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectSignalGroup(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async block(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/block`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async connect_closure(detailed_signal: string, closure: GObjectClosure, after: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/connect_closure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    url.searchParams.append('after', String(after));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async connect_data(detailed_signal: string, flags: GObjectConnectFlags, c_handler: GObjectCallback): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/connect_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.c_handler !== undefined) {
        callbackDispatcher.set(data.c_handler.toString(), {
          converter: convertGObjectCallbackArgs,
          userFunction: c_handler
        });
      }
    return data.c_handler;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async connect_swapped(detailed_signal: string, c_handler: GObjectCallback): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/connect_swapped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.c_handler !== undefined) {
        callbackDispatcher.set(data.c_handler.toString(), {
          converter: convertGObjectCallbackArgs,
          userFunction: c_handler
        });
      }
    return data.c_handler;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async dup_target(): Promise<GObjectObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/dup_target`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectObject(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_target(target?: GObjectObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/set_target`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (target !== undefined && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unblock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/ptr,${this.ptr}/unblock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/SignalGroup/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectSignalInvocationHint
const gobjectsignalinvocationhintRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/SignalInvocationHint/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectSignalInvocationHint:', ptr, err));
});

export class GObjectSignalInvocationHint {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectsignalinvocationhintRegistry.register(this, ptr);
  }


}
  export type GObjectSignalMatchType = "id" | "detail" | "closure" | "func" | "data" | "unblocked";

  
// Finalization registry for GObjectSignalQuery
const gobjectsignalqueryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/SignalQuery/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectSignalQuery:', ptr, err));
});

export class GObjectSignalQuery {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectsignalqueryRegistry.register(this, ptr);
  }


}
  export type GObjectTypeDebugFlags = "none" | "objects" | "signals" | "instance_count" | "mask";

  export type GObjectTypeFlags = "none" | "abstract" | "value_abstract" | "final" | "deprecated";

  export type GObjectTypeFundamentalFlags = "classed" | "instantiatable" | "derivable" | "deep_derivable";

  
// Finalization registry for GObjectTypeFundamentalInfo
const gobjecttypefundamentalinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/TypeFundamentalInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectTypeFundamentalInfo:', ptr, err));
});

export class GObjectTypeFundamentalInfo {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjecttypefundamentalinfoRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GObjectTypeInfo
const gobjecttypeinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/TypeInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectTypeInfo:', ptr, err));
});

export class GObjectTypeInfo {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjecttypeinfoRegistry.register(this, ptr);
  }


}
  
export class GObjectTypeModule extends GObjectObject {




      





 
  async add_interface(instance_type: string, interface_type: string, interface_info: GObjectInterfaceInfo): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/add_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Object with explode=false: serialize as comma-separated
    if (interface_info && typeof interface_info === 'object' && 'ptr' in interface_info) {
      url.searchParams.append('interface_info', 'ptr,' + interface_info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async register_enum(name: string, const_static_values: GObjectEnumValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/register_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (const_static_values && typeof const_static_values === 'object' && 'ptr' in const_static_values) {
      url.searchParams.append('const_static_values', 'ptr,' + const_static_values.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async register_flags(name: string, const_static_values: GObjectFlagsValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/register_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (const_static_values && typeof const_static_values === 'object' && 'ptr' in const_static_values) {
      url.searchParams.append('const_static_values', 'ptr,' + const_static_values.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async register_type(parent_type: string, type_name: string, type_info: GObjectTypeInfo, flags: GObjectTypeFlags): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/register_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('parent_type', String(parent_type));
    // Primitive parameter
    url.searchParams.append('type_name', String(type_name));
    // Object with explode=false: serialize as comma-separated
    if (type_info && typeof type_info === 'object' && 'ptr' in type_info) {
      url.searchParams.append('type_info', 'ptr,' + type_info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_name(name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unuse(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/unuse`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async use(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/ptr,${this.ptr}/use`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/TypeModule/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectTypePluginClass
const gobjecttypepluginclassRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/TypePluginClass/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectTypePluginClass:', ptr, err));
});

export class GObjectTypePluginClass {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjecttypepluginclassRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GObjectTypeQuery
const gobjecttypequeryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/TypeQuery/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectTypeQuery:', ptr, err));
});

export class GObjectTypeQuery {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjecttypequeryRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GObjectTypeValueTable
const gobjecttypevaluetableRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/TypeValueTable/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectTypeValueTable:', ptr, err));
});

export class GObjectTypeValueTable {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjecttypevaluetableRegistry.register(this, ptr);
  }


}
  export type GLibCompareDataFunc = (a: Pointer, b: Pointer, user_data: Pointer) => number;

export function convertGLibCompareDataFuncArgs(data: any): Parameters<GLibCompareDataFunc> {
  return [
    data.a,
    data.b,
    data.user_data  ];
}
  
// Finalization registry for GObjectValueArray
const gobjectvaluearrayRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/ValueArray/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectValueArray:', ptr, err));
});

export class GObjectValueArray {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectvaluearrayRegistry.register(this, ptr);
  }
    





 
  static async new(n_prealloced: number): Promise<GObjectValueArray> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_prealloced', String(n_prealloced));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValueArray(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async append(value_?: GObjectValue): Promise<GObjectValueArray> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ !== undefined && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValueArray(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy(): Promise<GObjectValueArray> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValueArray(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_nth(index_: number): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/get_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert(index_: number, value_?: GObjectValue): Promise<GObjectValueArray> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    // Object with explode=false: serialize as comma-separated
    if (value_ !== undefined && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValueArray(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async prepend(value_?: GObjectValue): Promise<GObjectValueArray> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/prepend`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ !== undefined && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValueArray(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(index_: number): Promise<GObjectValueArray> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValueArray(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async sort(compare_func: GLibCompareDataFunc): Promise<{compare_func: number, return: GObjectValueArray}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/sort`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.compare_func !== undefined) {
        callbackDispatcher.set(data.compare_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: compare_func
        });
      }
        const result: any = {};
      // Handle return parameter: compare_func
      result.compare_func = (() => {
        return data.compare_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GObjectValueArray(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_values(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/fields/n_values`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_n_values(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/fields/n_values`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_values(): Promise<GObjectValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/fields/values`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_values(value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/fields/values`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_prealloced(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/ptr,${this.ptr}/fields/n_prealloced`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/ValueArray/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GObjectWeakRef
const gobjectweakrefRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/WeakRef/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GObjectWeakRef:', ptr, err));
});

export class GObjectWeakRef {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gobjectweakrefRegistry.register(this, ptr);
  }


}
  export type GObjectBoxedCopyFunc = (boxed: Pointer) => Pointer;

export function convertGObjectBoxedCopyFuncArgs(data: any): Parameters<GObjectBoxedCopyFunc> {
  return [
    data.boxed  ];
}
  export type GObjectBoxedFreeFunc = (boxed: Pointer) => void;

export function convertGObjectBoxedFreeFuncArgs(data: any): Parameters<GObjectBoxedFreeFunc> {
  return [
    data.boxed  ];
}
  export type GObjectSignalEmissionHook = (ihint: GObjectSignalInvocationHint, n_param_values: number, param_values: Pointer, data_: Pointer) => boolean;

export function convertGObjectSignalEmissionHookArgs(data: any): Parameters<GObjectSignalEmissionHook> {
  return [
    new GObjectSignalInvocationHint(data.ihint, 'none'),
    data.n_param_values,
    data.param_values,
    data.data  ];
}
  export type GObjectSignalAccumulator = (ihint: GObjectSignalInvocationHint, return_accu: GObjectValue, handler_return: GObjectValue, data_: Pointer) => boolean;

export function convertGObjectSignalAccumulatorArgs(data: any): Parameters<GObjectSignalAccumulator> {
  return [
    new GObjectSignalInvocationHint(data.ihint, 'none'),
    new GObjectValue(data.return_accu, 'none'),
    new GObjectValue(data.handler_return, 'none'),
    data.data  ];
}
  export type GObjectClosureMarshal = (closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: Pointer, invocation_hint: Pointer, marshal_data: Pointer) => void;

export function convertGObjectClosureMarshalArgs(data: any): Parameters<GObjectClosureMarshal> {
  return [
    new GObjectClosure(data.closure, 'none'),
    new GObjectValue(data.return_value, 'none'),
    data.n_param_values,
    data.param_values,
    data.invocation_hint,
    data.marshal_data  ];
}
  export type GLibSourceFunc = (user_data: Pointer) => boolean;

export function convertGLibSourceFuncArgs(data: any): Parameters<GLibSourceFunc> {
  return [
    data.user_data  ];
}
  
// Finalization registry for GLibSource
const glibsourceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Source/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSource:', ptr, err));
});

export class GLibSource {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibsourceRegistry.register(this, ptr);
  }
    





 
  static async new(source_funcs: GLibSourceFuncs, struct_size: number): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (source_funcs && typeof source_funcs === 'object' && 'ptr' in source_funcs) {
      url.searchParams.append('source_funcs', 'ptr,' + source_funcs.ptr);
    }
    // Primitive parameter
    url.searchParams.append('struct_size', String(struct_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_child_source(child_source: GLibSource): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/add_child_source`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_source && typeof child_source === 'object' && 'ptr' in child_source) {
      url.searchParams.append('child_source', 'ptr,' + child_source.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_poll(fd: GLibPollFD): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/add_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_unix_fd(fd: number, events: GLibIOConditionValue): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/add_unix_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('events', String(events));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async attach(context?: GLibMainContext): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/attach`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async destroy(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_can_recurse(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_can_recurse`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_context(): Promise<GLibMainContext | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_context`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_current_time(timeval: GLibTimeVal): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_current_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (timeval && typeof timeval === 'object' && 'ptr' in timeval) {
      url.searchParams.append('timeval', 'ptr,' + timeval.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_id(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_name(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_priority(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_priority`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_ready_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_ready_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/get_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_destroyed(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/is_destroyed`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async modify_unix_fd(tag: Pointer, new_events: GLibIOConditionValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/modify_unix_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('new_events', String(new_events));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async query_unix_fd(tag: Pointer): Promise<GLibIOConditionValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/query_unix_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_child_source(child_source: GLibSource): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/remove_child_source`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_source && typeof child_source === 'object' && 'ptr' in child_source) {
      url.searchParams.append('child_source', 'ptr,' + child_source.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_poll(fd: GLibPollFD): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/remove_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_unix_fd(tag: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/remove_unix_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_callback(func: GLibSourceFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_callback`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibSourceFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_callback_indirect(callback_funcs: GLibSourceCallbackFuncs, callback_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_callback_indirect`, apiConfig.baseUrl);
    // Primitive parameter
    if (callback_data !== undefined) url.searchParams.append('callback_data', String(callback_data));
    // Object with explode=false: serialize as comma-separated
    if (callback_funcs && typeof callback_funcs === 'object' && 'ptr' in callback_funcs) {
      url.searchParams.append('callback_funcs', 'ptr,' + callback_funcs.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_can_recurse(can_recurse: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_can_recurse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('can_recurse', String(can_recurse));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_funcs(funcs: GLibSourceFuncs): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_funcs`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_name(name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_priority(priority: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_priority`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_ready_time(ready_time: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_ready_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ready_time', String(ready_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_static_name(name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/set_static_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove(tag: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove_by_funcs_user_data(funcs: GLibSourceFuncs, user_data?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/remove_by_funcs_user_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove_by_user_data(user_data?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/remove_by_user_data`, apiConfig.baseUrl);
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async set_name_by_id(tag: number, name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/set_name_by_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_callback_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/callback_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_callback_funcs(): Promise<GLibSourceCallbackFuncs | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/callback_funcs`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSourceCallbackFuncs(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_source_funcs(): Promise<GLibSourceFuncs | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/source_funcs`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSourceFuncs(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_ref_count(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/ref_count`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_source_id(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/source_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_poll_fds(): Promise<GLibSList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/poll_fds`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_prev(): Promise<GLibSource | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/prev`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next(): Promise<GLibSource | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_priv(): Promise<GLibSourcePrivate | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/ptr,${this.ptr}/fields/priv`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSourcePrivate(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Source/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibSourceFuncs
const glibsourcefuncsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/SourceFuncs/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSourceFuncs:', ptr, err));
});

export class GLibSourceFuncs {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibsourcefuncsRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GLibPollFD
const glibpollfdRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/PollFD/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibPollFD:', ptr, err));
});

export class GLibPollFD {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibpollfdRegistry.register(this, ptr);
  }


}
  export namespace GLibIOCondition {
  export const IN: 'in' = 'in';
  export const OUT: 'out' = 'out';
  export const PRI: 'pri' = 'pri';
  export const ERR: 'err' = 'err';
  export const HUP: 'hup' = 'hup';
  export const NVAL: 'nval' = 'nval';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOCondition/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GLibIOConditionValue = "in" | "out" | "pri" | "err" | "hup" | "nval";

  
// Finalization registry for GLibMainContext
const glibmaincontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MainContext/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMainContext:', ptr, err));
});

export class GLibMainContext {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibmaincontextRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibMainContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_with_flags(flags: GLibMainContextFlags): Promise<GLibMainContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/new_with_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async acquire(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/acquire`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_poll(fd: GLibPollFD, priority: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/add_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async check(max_priority: number, fds: Pointer, n_fds: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/check`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_priority', String(max_priority));
    // Primitive parameter
    url.searchParams.append('fds', String(fds));
    // Primitive parameter
    url.searchParams.append('n_fds', String(n_fds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dispatch(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/dispatch`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async find_source_by_funcs_user_data(funcs: GLibSourceFuncs, user_data?: Pointer): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/find_source_by_funcs_user_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async find_source_by_id(source_id: number): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/find_source_by_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_id', String(source_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async find_source_by_user_data(user_data?: Pointer): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/find_source_by_user_data`, apiConfig.baseUrl);
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async invoke_full(priority: number, function_: GLibSourceFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/invoke_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.function !== undefined) {
        callbackDispatcher.set(data.function.toString(), {
          converter: convertGLibSourceFuncArgs,
          userFunction: function_
        });
      }
    return data.function;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_owner(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/is_owner`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async iteration(may_block: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/iteration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_block', String(may_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pending(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/pending`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pop_thread_default(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/pop_thread_default`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async prepare(): Promise<{priority: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/prepare`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: priority
      result.priority = (() => {
        return data.priority;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push_thread_default(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/push_thread_default`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async query(max_priority: number, n_fds: number): Promise<{timeout_: number, fds: Pointer, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/query`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_priority', String(max_priority));
    // Primitive parameter
    url.searchParams.append('n_fds', String(n_fds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: timeout_
      result.timeout_ = (() => {
        return data.timeout_;

      })();
      // Handle return parameter: fds
      result.fds = (() => {
        return data.fds;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibMainContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async release(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/release`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_poll(fd: GLibPollFD): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/remove_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async wait(cond: GLibCond, mutex: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (cond && typeof cond === 'object' && 'ptr' in cond) {
      url.searchParams.append('cond', 'ptr,' + cond.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mutex', String(mutex));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async wakeup(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ptr,${this.ptr}/wakeup`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async default_(): Promise<GLibMainContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/default`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_thread_default(): Promise<GLibMainContext | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/get_thread_default`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async ref_thread_default(): Promise<GLibMainContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/ref_thread_default`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainContext/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibMainContextFlags = "none" | "ownerless_polling";

  
// Finalization registry for GLibCond
const glibcondRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Cond/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibCond:', ptr, err));
});

export class GLibCond {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibcondRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibCond> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibCond(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async broadcast(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/broadcast`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async clear(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async signal(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/signal`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async wait(mutex: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mutex', String(mutex));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async wait_until(mutex: Pointer, end_time: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/wait_until`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mutex', String(mutex));
    // Primitive parameter
    url.searchParams.append('end_time', String(end_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_p(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/fields/p`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_i(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cond/ptr,${this.ptr}/fields/i`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibTimeVal
const glibtimevalRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TimeVal/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTimeVal:', ptr, err));
});

export class GLibTimeVal {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtimevalRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibTimeVal> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTimeVal(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add(microseconds: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('microseconds', String(microseconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_iso8601(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/to_iso8601`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async from_iso8601(iso_date: string, time_: GLibTimeVal): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/from_iso8601`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iso_date', String(iso_date));
    // Object with explode=false: serialize as comma-separated
    if (time_ && typeof time_ === 'object' && 'ptr' in time_) {
      url.searchParams.append('time_', 'ptr,' + time_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_tv_sec(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/fields/tv_sec`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_tv_sec(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/fields/tv_sec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_tv_usec(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/fields/tv_usec`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_tv_usec(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeVal/ptr,${this.ptr}/fields/tv_usec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibSourceCallbackFuncs
const glibsourcecallbackfuncsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/SourceCallbackFuncs/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSourceCallbackFuncs:', ptr, err));
});

export class GLibSourceCallbackFuncs {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibsourcecallbackfuncsRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GLibSList
const glibslistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/SList/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSList:', ptr, err));
});

export class GLibSList {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibslistRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibSList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  static async pop_allocator(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/pop_allocator`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async push_allocator(allocator: GLibAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_data(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next(): Promise<GLibSList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_next(value_: GLibSList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SList/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibSourcePrivate
const glibsourceprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/SourcePrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSourcePrivate:', ptr, err));
});

export class GLibSourcePrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibsourceprivateRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GModuleModule
const gmodulemoduleRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GModule/Module/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GModuleModule:', ptr, err));
});

export class GModuleModule {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gmodulemoduleRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GModuleModule> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GModuleModule(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async close(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/close`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async make_resident(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/make_resident`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async name(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async symbol(symbol_name: string): Promise<{symbol: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/ptr,${this.ptr}/symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('symbol_name', String(symbol_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: symbol
      result.symbol = (() => {
        return data.symbol;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async build_path(module_name: string, directory?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/build_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (directory !== undefined) url.searchParams.append('directory', String(directory));
    // Primitive parameter
    url.searchParams.append('module_name', String(module_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async error_(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/error`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async supported(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/Module/supported`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GModuleModuleError = "failed" | "check_failed";

  export type GModuleModuleFlags = "lazy" | "local" | "mask";

  
// Finalization registry for GLibArray
const glibarrayRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Array/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibArray:', ptr, err));
});

export class GLibArray {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibarrayRegistry.register(this, ptr);
  }


}
  export type GLibAsciiType = "alnum" | "alpha" | "cntrl" | "digit" | "graph" | "lower" | "print" | "punct" | "space" | "upper" | "xdigit";

  
// Finalization registry for GLibAsyncQueue
const glibasyncqueueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/AsyncQueue/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibAsyncQueue:', ptr, err));
});

export class GLibAsyncQueue {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibasyncqueueRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibAsyncQueue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibAsyncQueue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async length(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/length`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async length_unlocked(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/length_unlocked`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/lock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pop(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pop_unlocked(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/pop_unlocked`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push(data_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push_front(item: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_front`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('item', String(item));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push_front_unlocked(item: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_front_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('item', String(item));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push_sorted(data_: Pointer, func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_sorted`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push_sorted_unlocked(func: GLibCompareDataFunc, data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_sorted_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push_unlocked(data_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/push_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref_unlocked(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/ref_unlocked`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(item: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('item', String(item));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_unlocked(item?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/remove_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    if (item !== undefined) url.searchParams.append('item', String(item));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async sort(func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/sort`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async sort_unlocked(func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/sort_unlocked`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async timed_pop(end_time: GLibTimeVal): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/timed_pop`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (end_time && typeof end_time === 'object' && 'ptr' in end_time) {
      url.searchParams.append('end_time', 'ptr,' + end_time.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async timed_pop_unlocked(end_time: GLibTimeVal): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/timed_pop_unlocked`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (end_time && typeof end_time === 'object' && 'ptr' in end_time) {
      url.searchParams.append('end_time', 'ptr,' + end_time.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async timeout_pop(timeout: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/timeout_pop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async timeout_pop_unlocked(timeout: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/timeout_pop_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async try_pop(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/try_pop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async try_pop_unlocked(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/try_pop_unlocked`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unlock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/unlock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref_and_unlock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/AsyncQueue/ptr,${this.ptr}/unref_and_unlock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibBookmarkFile
const glibbookmarkfileRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/BookmarkFile/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibBookmarkFile:', ptr, err));
});

export class GLibBookmarkFile {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibbookmarkfileRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibBookmarkFile> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBookmarkFile(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_application(uri: string, name?: string, exec?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/add_application`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Primitive parameter
    if (exec !== undefined) url.searchParams.append('exec', String(exec));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_group(uri: string, group: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/add_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('group', String(group));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy(): Promise<GLibBookmarkFile> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBookmarkFile(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_added(uri: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_added`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_added_date_time(uri: string): Promise<GLibDateTime> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_added_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_app_info(uri: string, name: string): Promise<{exec: string, count: number, stamp: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_app_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: exec
      result.exec = (() => {
        return data.exec;

      })();
      // Handle return parameter: count
      result.count = (() => {
        return data.count;

      })();
      // Handle return parameter: stamp
      result.stamp = (() => {
        return data.stamp;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_application_info(uri: string, name: string, stamp: GLibDateTime): Promise<{exec: string, count: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_application_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (stamp && typeof stamp === 'object' && 'ptr' in stamp) {
      url.searchParams.append('stamp', 'ptr,' + stamp.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: exec
      result.exec = (() => {
        return data.exec;

      })();
      // Handle return parameter: count
      result.count = (() => {
        return data.count;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_applications(uri: string): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_applications`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_description(uri: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_groups(uri: string): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_groups`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_icon(uri: string): Promise<{href: string, mime_type: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_icon`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: href
      result.href = (() => {
        return data.href;

      })();
      // Handle return parameter: mime_type
      result.mime_type = (() => {
        return data.mime_type;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_is_private(uri: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_is_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_mime_type(uri: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_mime_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_modified(uri: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_modified`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_modified_date_time(uri: string): Promise<GLibDateTime> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_modified_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_title(uri?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_title`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uris(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_uris`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_visited(uri: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_visited`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_visited_date_time(uri: string): Promise<GLibDateTime> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/get_visited_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_application(uri: string, name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/has_application`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_group(uri: string, group: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/has_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('group', String(group));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_item(uri: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/has_item`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async load_from_data(data_: Pointer, length: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/load_from_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async load_from_data_dirs(file: Pointer): Promise<{full_path: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/load_from_data_dirs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file', String(file));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: full_path
      result.full_path = (() => {
        return data.full_path;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async load_from_file(filename: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/load_from_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async move_item(old_uri: string, new_uri?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/move_item`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('old_uri', String(old_uri));
    // Primitive parameter
    if (new_uri !== undefined) url.searchParams.append('new_uri', String(new_uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_application(uri: string, name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/remove_application`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_group(uri: string, group: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/remove_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('group', String(group));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_item(uri: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/remove_item`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_added(uri: string, added: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_added`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('added', String(added));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_added_date_time(uri: string, added: GLibDateTime): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_added_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Object with explode=false: serialize as comma-separated
    if (added && typeof added === 'object' && 'ptr' in added) {
      url.searchParams.append('added', 'ptr,' + added.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_app_info(uri: string, name: string, exec: string, count: number, stamp: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_app_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('exec', String(exec));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    // Primitive parameter
    url.searchParams.append('stamp', String(stamp));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_application_info(uri: string, name: string, exec: string, count: number, stamp?: GLibDateTime): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_application_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('exec', String(exec));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    // Object with explode=false: serialize as comma-separated
    if (stamp !== undefined && typeof stamp === 'object' && 'ptr' in stamp) {
      url.searchParams.append('stamp', 'ptr,' + stamp.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_description(description: string, uri?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_description`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_groups(uri: string, length: number, groups?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_groups`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    if (groups !== undefined) url.searchParams.append('groups', String(groups));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_icon(uri: string, mime_type: string, href?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_icon`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    if (href !== undefined) url.searchParams.append('href', String(href));
    // Primitive parameter
    url.searchParams.append('mime_type', String(mime_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_is_private(uri: string, is_private: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_is_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('is_private', String(is_private));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_mime_type(uri: string, mime_type: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_mime_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('mime_type', String(mime_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_modified(uri: string, modified: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_modified`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('modified', String(modified));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_modified_date_time(uri: string, modified: GLibDateTime): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_modified_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Object with explode=false: serialize as comma-separated
    if (modified && typeof modified === 'object' && 'ptr' in modified) {
      url.searchParams.append('modified', 'ptr,' + modified.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_title(title: string, uri?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_title`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('title', String(title));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_visited(uri: string, visited: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_visited`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('visited', String(visited));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_visited_date_time(uri: string, visited: GLibDateTime): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/set_visited_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Object with explode=false: serialize as comma-separated
    if (visited && typeof visited === 'object' && 'ptr' in visited) {
      url.searchParams.append('visited', 'ptr,' + visited.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_data(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/to_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_file(filename: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/ptr,${this.ptr}/to_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/BookmarkFile/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibDateTime
const glibdatetimeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/DateTime/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibDateTime:', ptr, err));
});

export class GLibDateTime {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibdatetimeRegistry.register(this, ptr);
  }
    





 
  static async new(tz: GLibTimeZone, year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tz && typeof tz === 'object' && 'ptr' in tz) {
      url.searchParams.append('tz', 'ptr,' + tz.ptr);
    }
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_iso8601(text: string, default_tz?: GLibTimeZone): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_iso8601`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Object with explode=false: serialize as comma-separated
    if (default_tz !== undefined && typeof default_tz === 'object' && 'ptr' in default_tz) {
      url.searchParams.append('default_tz', 'ptr,' + default_tz.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_timeval_local(tv: GLibTimeVal): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_timeval_local`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tv && typeof tv === 'object' && 'ptr' in tv) {
      url.searchParams.append('tv', 'ptr,' + tv.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_timeval_utc(tv: GLibTimeVal): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_timeval_utc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tv && typeof tv === 'object' && 'ptr' in tv) {
      url.searchParams.append('tv', 'ptr,' + tv.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_unix_local(t: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_unix_local`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('t', String(t));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_unix_local_usec(usecs: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_unix_local_usec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_unix_utc(t: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_unix_utc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('t', String(t));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_unix_utc_usec(usecs: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_from_unix_utc_usec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_local(year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_local`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_now(tz: GLibTimeZone): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_now`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tz && typeof tz === 'object' && 'ptr' in tz) {
      url.searchParams.append('tz', 'ptr,' + tz.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_now_local(): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_now_local`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_now_utc(): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_now_utc`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_utc(year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/new_utc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add(timespan: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timespan', String(timespan));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_days(days: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('days', String(days));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_full(years: number, months: number, days: number, hours: number, minutes: number, seconds: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('years', String(years));
    // Primitive parameter
    url.searchParams.append('months', String(months));
    // Primitive parameter
    url.searchParams.append('days', String(days));
    // Primitive parameter
    url.searchParams.append('hours', String(hours));
    // Primitive parameter
    url.searchParams.append('minutes', String(minutes));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_hours(hours: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_hours`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hours', String(hours));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_minutes(minutes: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_minutes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('minutes', String(minutes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_months(months: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_months`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('months', String(months));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_seconds(seconds: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_seconds`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_weeks(weeks: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_weeks`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('weeks', String(weeks));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_years(years: number): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/add_years`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('years', String(years));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async compare(dt2: GLibDateTime): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dt2 && typeof dt2 === 'object' && 'ptr' in dt2) {
      url.searchParams.append('dt2', 'ptr,' + dt2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async difference(begin: GLibDateTime): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/difference`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async equal(dt2: GLibDateTime): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dt2 && typeof dt2 === 'object' && 'ptr' in dt2) {
      url.searchParams.append('dt2', 'ptr,' + dt2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async format(format: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/format`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async format_iso8601(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/format_iso8601`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_day_of_month(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_day_of_month`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_day_of_week(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_day_of_week`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_day_of_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_day_of_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_hour(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_hour`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_microsecond(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_microsecond`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_minute(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_minute`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_month(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_month`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_second(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_second`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_seconds(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_seconds`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_timezone(): Promise<GLibTimeZone> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_timezone`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTimeZone(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_timezone_abbreviation(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_timezone_abbreviation`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_utc_offset(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_utc_offset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_week_numbering_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_week_numbering_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_week_of_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_week_of_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_ymd(): Promise<{year: number, month: number, day: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/get_ymd`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: year
      result.year = (() => {
        return data.year;

      })();
      // Handle return parameter: month
      result.month = (() => {
        return data.month;

      })();
      // Handle return parameter: day
      result.day = (() => {
        return data.day;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async hash(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_daylight_savings(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/is_daylight_savings`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibDateTime> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_local(): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_local`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_timeval(tv: GLibTimeVal): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_timeval`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tv && typeof tv === 'object' && 'ptr' in tv) {
      url.searchParams.append('tv', 'ptr,' + tv.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_timezone(tz: GLibTimeZone): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_timezone`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tz && typeof tz === 'object' && 'ptr' in tz) {
      url.searchParams.append('tz', 'ptr,' + tz.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_unix(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_unix`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_unix_usec(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_unix_usec`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_utc(): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/to_utc`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/DateTime/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibTimeZone
const glibtimezoneRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TimeZone/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTimeZone:', ptr, err));
});

export class GLibTimeZone {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtimezoneRegistry.register(this, ptr);
  }
    





 
  static async new(identifier?: string): Promise<GLibTimeZone> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (identifier !== undefined) url.searchParams.append('identifier', String(identifier));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTimeZone(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_identifier(identifier?: string): Promise<GLibTimeZone | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new_identifier`, apiConfig.baseUrl);
    // Primitive parameter
    if (identifier !== undefined) url.searchParams.append('identifier', String(identifier));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTimeZone(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_local(): Promise<GLibTimeZone> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new_local`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTimeZone(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_offset(seconds: number): Promise<GLibTimeZone> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTimeZone(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_utc(): Promise<GLibTimeZone> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/new_utc`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTimeZone(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async adjust_time(type_: GLibTimeType, time_: number): Promise<{time_: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/adjust_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('time_', String(time_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: time_
      result.time_ = (() => {
        return data.time_;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async find_interval(type_: GLibTimeType, time_: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/find_interval`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('time_', String(time_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_abbreviation(interval: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/get_abbreviation`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_identifier(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/get_identifier`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_offset(interval: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/get_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_dst(interval: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/is_dst`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibTimeZone> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTimeZone(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TimeZone/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibTimeType = "standard" | "daylight" | "universal";

  export type GLibBookmarkFileError = "invalid_uri" | "invalid_value" | "app_not_registered" | "uri_not_found" | "read" | "unknown_encoding" | "write" | "file_not_found";

  export type GLibCompareFunc = (a: Pointer, b: Pointer) => number;

export function convertGLibCompareFuncArgs(data: any): Parameters<GLibCompareFunc> {
  return [
    data.a,
    data.b  ];
}
  
// Finalization registry for GLibByteArray
const glibbytearrayRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/ByteArray/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibByteArray:', ptr, err));
});

export class GLibByteArray {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibbytearrayRegistry.register(this, ptr);
  }

      





 
  static async free(array: Pointer, free_segment: boolean): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('free_segment', String(free_segment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  static async append(array: Pointer, data_: number, len: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/append`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async free_to_bytes(array: Pointer): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/free_to_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_take(data_: Pointer, len: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/new_take`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async prepend(array: Pointer, data_: number, len: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/prepend`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async ref(array: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove_index(array: Pointer, index_: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/remove_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove_index_fast(array: Pointer, index_: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/remove_index_fast`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove_range(array: Pointer, index_: number, length: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/remove_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async set_size(array: Pointer, length: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/set_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async sized_new(reserved_size: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/sized_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('reserved_size', String(reserved_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async sort(array: Pointer, compare_func: GLibCompareFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/sort`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.compare_func !== undefined) {
        callbackDispatcher.set(data.compare_func.toString(), {
          converter: convertGLibCompareFuncArgs,
          userFunction: compare_func
        });
      }
    return data.compare_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async sort_with_data(array: Pointer, compare_func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/sort_with_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.compare_func !== undefined) {
        callbackDispatcher.set(data.compare_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: compare_func
        });
      }
    return data.compare_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async steal(array: Pointer): Promise<{len: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: len
      result.len = (() => {
        return data.len;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async unref(array: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_data(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_len(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/ptr,${this.ptr}/fields/len`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_len(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/ptr,${this.ptr}/fields/len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ByteArray/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibHFunc = (key: Pointer, value_: Pointer, user_data: Pointer) => void;

export function convertGLibHFuncArgs(data: any): Parameters<GLibHFunc> {
  return [
    data.key,
    data.value,
    data.user_data  ];
}
  
// Finalization registry for GLibCache
const glibcacheRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Cache/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibCache:', ptr, err));
});

export class GLibCache {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibcacheRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibCache> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibCache(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async destroy(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert(key?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async key_foreach(func: GLibHFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/key_foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(value_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async value_foreach(func: GLibHFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Cache/ptr,${this.ptr}/value_foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibChecksum
const glibchecksumRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Checksum/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibChecksum:', ptr, err));
});

export class GLibChecksum {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibchecksumRegistry.register(this, ptr);
  }
    





 
  static async new(checksum_type: GLibChecksumType): Promise<GLibChecksum | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibChecksum(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(): Promise<GLibChecksum> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibChecksum(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reset(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/reset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async update(data_: Pointer, length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/ptr,${this.ptr}/update`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async type_get_length(checksum_type: GLibChecksumType): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/type_get_length`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Checksum/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibChecksumType = "md5" | "sha1" | "sha256" | "sha512" | "sha384";

  
// Finalization registry for GLibCompletion
const glibcompletionRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Completion/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibCompletion:', ptr, err));
});

export class GLibCompletion {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibcompletionRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibCompletion> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibCompletion(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async clear_items(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/clear_items`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async complete_utf8(prefix: string, new_prefix: string): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/complete_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('prefix', String(prefix));
    // Primitive parameter
    url.searchParams.append('new_prefix', String(new_prefix));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', string, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_items(): Promise<GLibList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/items`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', Pointer, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_items(value_: GLibList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/items`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_func(): Promise<GLibCompletionFunc | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_func(value_: GLibCompletionFunc): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_prefix(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/prefix`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_prefix(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/prefix`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_cache(): Promise<GLibList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/cache`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', Pointer, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_cache(value_: GLibList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/cache`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_strncmp_func(): Promise<GLibCompletionStrncmpFunc | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/strncmp_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_strncmp_func(value_: GLibCompletionStrncmpFunc): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Completion/ptr,${this.ptr}/fields/strncmp_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibCompletionFunc = (item: Pointer) => string;

export function convertGLibCompletionFuncArgs(data: any): Parameters<GLibCompletionFunc> {
  return [
    data.item  ];
}
  export type GLibCompletionStrncmpFunc = (s1: string, s2: string, n: number) => number;

export function convertGLibCompletionStrncmpFuncArgs(data: any): Parameters<GLibCompletionStrncmpFunc> {
  return [
    data.s1,
    data.s2,
    data.n  ];
}
  export type GLibConvertError = "no_conversion" | "illegal_sequence" | "failed" | "partial_input" | "bad_uri" | "not_absolute_path" | "no_memory" | "embedded_nul";

  
// Finalization registry for GLibData
const glibdataRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Data/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibData:', ptr, err));
});

export class GLibData {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibdataRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GLibDate
const glibdateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Date/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibDate:', ptr, err));
});

export class GLibDate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibdateRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibDate> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDate(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_dmy(day: number, month: GLibDateMonth, year: number): Promise<GLibDate> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/new_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDate(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_julian(julian_day: number): Promise<GLibDate> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/new_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_day', String(julian_day));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDate(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_days(n_days: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/add_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_days', String(n_days));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_months(n_months: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/add_months`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_months', String(n_months));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_years(n_years: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/add_years`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_years', String(n_years));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async clamp(min_date: GLibDate, max_date: GLibDate): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/clamp`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (min_date && typeof min_date === 'object' && 'ptr' in min_date) {
      url.searchParams.append('min_date', 'ptr,' + min_date.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (max_date && typeof max_date === 'object' && 'ptr' in max_date) {
      url.searchParams.append('max_date', 'ptr,' + max_date.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async clear(n_dates: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_dates', String(n_dates));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async compare(rhs: GLibDate): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (rhs && typeof rhs === 'object' && 'ptr' in rhs) {
      url.searchParams.append('rhs', 'ptr,' + rhs.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy(): Promise<GLibDate> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDate(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async days_between(date2: GLibDate): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/days_between`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (date2 && typeof date2 === 'object' && 'ptr' in date2) {
      url.searchParams.append('date2', 'ptr,' + date2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_day(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_day`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_day_of_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_day_of_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_iso8601_week_of_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_iso8601_week_of_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_julian(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_julian`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_monday_week_of_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_monday_week_of_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_month(): Promise<GLibDateMonth> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_month`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_sunday_week_of_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_sunday_week_of_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_weekday(): Promise<GLibDateWeekday> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_weekday`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/get_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_first_of_month(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/is_first_of_month`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_last_of_month(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/is_last_of_month`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async order(date2: GLibDate): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/order`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (date2 && typeof date2 === 'object' && 'ptr' in date2) {
      url.searchParams.append('date2', 'ptr,' + date2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_day(day: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_day`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_dmy(day: number, month: GLibDateMonth, y: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('y', String(y));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_julian(julian_date: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_date', String(julian_date));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_month(month: GLibDateMonth): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_parse(str: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_time(time_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time_', String(time_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_time_t(timet: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_time_t`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timet', String(timet));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_time_val(timeval: GLibTimeVal): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_time_val`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (timeval && typeof timeval === 'object' && 'ptr' in timeval) {
      url.searchParams.append('timeval', 'ptr,' + timeval.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_year(year: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/set_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async subtract_days(n_days: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/subtract_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_days', String(n_days));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async subtract_months(n_months: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/subtract_months`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_months', String(n_months));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async subtract_years(n_years: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/subtract_years`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_years', String(n_years));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_struct_tm(tm: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/to_struct_tm`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tm', String(tm));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async valid(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/valid`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_days_in_month(month: GLibDateMonth, year: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/get_days_in_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_monday_weeks_in_year(year: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/get_monday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_sunday_weeks_in_year(year: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/get_sunday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async is_leap_year(year: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/is_leap_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async strftime(s: string, slen: number, format: string, date: GLibDate): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/strftime`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s', String(s));
    // Primitive parameter
    url.searchParams.append('slen', String(slen));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Object with explode=false: serialize as comma-separated
    if (date && typeof date === 'object' && 'ptr' in date) {
      url.searchParams.append('date', 'ptr,' + date.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async valid_day(day: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_day`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async valid_dmy(day: number, month: GLibDateMonth, year: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async valid_julian(julian_date: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_date', String(julian_date));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async valid_month(month: GLibDateMonth): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async valid_weekday(weekday: GLibDateWeekday): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_weekday`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('weekday', String(weekday));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async valid_year(year: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/valid_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_julian_days(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/fields/julian_days`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_julian_days(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/ptr,${this.ptr}/fields/julian_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Date/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibDateMonth = "bad_month" | "january" | "february" | "march" | "april" | "may" | "june" | "july" | "august" | "september" | "october" | "november" | "december";

  export type GLibDateWeekday = "bad_weekday" | "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";

  export type GLibDateDMY = "day" | "month" | "year";

  
// Finalization registry for GLibDebugKey
const glibdebugkeyRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/DebugKey/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibDebugKey:', ptr, err));
});

export class GLibDebugKey {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibdebugkeyRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GLibDir
const glibdirRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Dir/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibDir:', ptr, err));
});

export class GLibDir {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibdirRegistry.register(this, ptr);
  }
    





 
  static async open(path: string, flags: number): Promise<GLibDir> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/open`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDir(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async close(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/close`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async read_name(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/read_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibDir> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDir(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async rewind(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/rewind`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async make_tmp(tmpl?: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/make_tmp`, apiConfig.baseUrl);
    // Primitive parameter
    if (tmpl !== undefined) url.searchParams.append('tmpl', String(tmpl));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Dir/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibErrorInitFunc = (error_: Pointer) => void;

export function convertGLibErrorInitFuncArgs(data: any): Parameters<GLibErrorInitFunc> {
  return [
    data.error  ];
}
  export type GLibErrorCopyFunc = (src_error: Pointer, dest_error: Pointer) => void;

export function convertGLibErrorCopyFuncArgs(data: any): Parameters<GLibErrorCopyFunc> {
  return [
    data.src_error,
    data.dest_error  ];
}
  export type GLibErrorClearFunc = (error_: Pointer) => void;

export function convertGLibErrorClearFuncArgs(data: any): Parameters<GLibErrorClearFunc> {
  return [
    data.error  ];
}
  
// Finalization registry for GLibError
const gliberrorRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Error/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibError:', ptr, err));
});

export class GLibError {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gliberrorRegistry.register(this, ptr);
  }
    





 
  static async new_literal(domain: number, code: number, message: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/new_literal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    url.searchParams.append('message', String(message));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async matches(domain: number, code: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/matches`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async domain_register(error_type_name: string, error_type_private_size: number, error_type_init: GLibErrorInitFunc, error_type_copy: GLibErrorCopyFunc, error_type_clear: GLibErrorClearFunc): Promise<{error_type_init: number, error_type_copy: number, error_type_clear: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/domain_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error_type_name', String(error_type_name));
    // Primitive parameter
    url.searchParams.append('error_type_private_size', String(error_type_private_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.error_type_init !== undefined) {
        callbackDispatcher.set(data.error_type_init.toString(), {
          converter: convertGLibErrorInitFuncArgs,
          userFunction: error_type_init
        });
      }
      if (data.error_type_copy !== undefined) {
        callbackDispatcher.set(data.error_type_copy.toString(), {
          converter: convertGLibErrorCopyFuncArgs,
          userFunction: error_type_copy
        });
      }
      if (data.error_type_clear !== undefined) {
        callbackDispatcher.set(data.error_type_clear.toString(), {
          converter: convertGLibErrorClearFuncArgs,
          userFunction: error_type_clear
        });
      }
        const result: any = {};
      // Handle return parameter: error_type_init
      result.error_type_init = (() => {
        return data.error_type_init;

      })();
      // Handle return parameter: error_type_copy
      result.error_type_copy = (() => {
        return data.error_type_copy;

      })();
      // Handle return parameter: error_type_clear
      result.error_type_clear = (() => {
        return data.error_type_clear;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async domain_register_static(error_type_name: string, error_type_private_size: number, error_type_init: GLibErrorInitFunc, error_type_copy: GLibErrorCopyFunc, error_type_clear: GLibErrorClearFunc): Promise<{error_type_init: number, error_type_copy: number, error_type_clear: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/domain_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error_type_name', String(error_type_name));
    // Primitive parameter
    url.searchParams.append('error_type_private_size', String(error_type_private_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.error_type_init !== undefined) {
        callbackDispatcher.set(data.error_type_init.toString(), {
          converter: convertGLibErrorInitFuncArgs,
          userFunction: error_type_init
        });
      }
      if (data.error_type_copy !== undefined) {
        callbackDispatcher.set(data.error_type_copy.toString(), {
          converter: convertGLibErrorCopyFuncArgs,
          userFunction: error_type_copy
        });
      }
      if (data.error_type_clear !== undefined) {
        callbackDispatcher.set(data.error_type_clear.toString(), {
          converter: convertGLibErrorClearFuncArgs,
          userFunction: error_type_clear
        });
      }
        const result: any = {};
      // Handle return parameter: error_type_init
      result.error_type_init = (() => {
        return data.error_type_init;

      })();
      // Handle return parameter: error_type_copy
      result.error_type_copy = (() => {
        return data.error_type_copy;

      })();
      // Handle return parameter: error_type_clear
      result.error_type_clear = (() => {
        return data.error_type_clear;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_domain(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/fields/domain`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_domain(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/fields/domain`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_code(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/fields/code`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_code(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/fields/code`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_message(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/fields/message`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_message(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/ptr,${this.ptr}/fields/message`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Error/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibErrorType = "unknown" | "unexp_eof" | "unexp_eof_in_string" | "unexp_eof_in_comment" | "non_digit_in_const" | "digit_radix" | "float_radix" | "float_malformed";

  export type GLibFileError = "exist" | "isdir" | "acces" | "nametoolong" | "noent" | "notdir" | "nxio" | "nodev" | "rofs" | "txtbsy" | "fault" | "loop" | "nospc" | "nomem" | "mfile" | "nfile" | "badf" | "inval" | "pipe" | "again" | "intr" | "io" | "perm" | "nosys" | "failed";

  export type GLibFileSetContentsFlags = "none" | "consistent" | "durable" | "only_existing";

  export type GLibFileTest = "is_regular" | "is_symlink" | "is_dir" | "is_executable" | "exists";

  export type GLibFormatSizeFlags = "default" | "long_format" | "iec_units" | "bits" | "only_value" | "only_unit";

  export type GLibHRFunc = (key: Pointer, value_: Pointer, user_data: Pointer) => boolean;

export function convertGLibHRFuncArgs(data: any): Parameters<GLibHRFunc> {
  return [
    data.key,
    data.value,
    data.user_data  ];
}
  
// Finalization registry for GLibHashTable
const glibhashtableRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/HashTable/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibHashTable:', ptr, err));
});

export class GLibHashTable {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibhashtableRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibHashTable> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHashTable(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  static async add(hash_table: Pointer, key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async contains(hash_table: Pointer, key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async destroy(hash_table: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/destroy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async find(hash_table: Pointer, predicate: GLibHRFunc): Promise<{predicate: number, return: Pointer | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.predicate !== undefined) {
        callbackDispatcher.set(data.predicate.toString(), {
          converter: convertGLibHRFuncArgs,
          userFunction: predicate
        });
      }
        const result: any = {};
      // Handle return parameter: predicate
      result.predicate = (() => {
        return data.predicate;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async foreach(hash_table: Pointer, func: GLibHFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/foreach`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async foreach_remove(hash_table: Pointer, func: GLibHRFunc): Promise<{func: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/foreach_remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHRFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async foreach_steal(hash_table: Pointer, func: GLibHRFunc): Promise<{func: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/foreach_steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHRFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async insert(hash_table: Pointer, key?: Pointer, value_?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async lookup(hash_table: Pointer, key?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async lookup_extended(hash_table: Pointer, lookup_key?: Pointer): Promise<{orig_key: Pointer, value: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/lookup_extended`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (lookup_key !== undefined) url.searchParams.append('lookup_key', String(lookup_key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: orig_key
      result.orig_key = (() => {
        return data.orig_key;

      })();
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_similar(other_hash_table: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/new_similar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('other_hash_table', String(other_hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async ref(hash_table: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove(hash_table: Pointer, key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove_all(hash_table: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/remove_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async replace(hash_table: Pointer, key?: Pointer, value_?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/replace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async size(hash_table: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async steal(hash_table: Pointer, key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async steal_all(hash_table: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/steal_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async steal_extended(hash_table: Pointer, lookup_key?: Pointer): Promise<{stolen_key: Pointer, stolen_value: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/steal_extended`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (lookup_key !== undefined) url.searchParams.append('lookup_key', String(lookup_key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: stolen_key
      result.stolen_key = (() => {
        return data.stolen_key;

      })();
      // Handle return parameter: stolen_value
      result.stolen_value = (() => {
        return data.stolen_value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async unref(hash_table: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTable/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibHashTableIter
const glibhashtableiterRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/HashTableIter/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibHashTableIter:', ptr, err));
});

export class GLibHashTableIter {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibhashtableiterRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibHashTableIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHashTableIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_hash_table(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/get_hash_table`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(hash_table: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async next(): Promise<{key: Pointer, value: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: key
      result.key = (() => {
        return data.key;

      })();
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace(value_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async steal(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/steal`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy1(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/fields/dummy1`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy2(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/fields/dummy2`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy3(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/fields/dummy3`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy4(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/fields/dummy4`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy5(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/fields/dummy5`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy6(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HashTableIter/ptr,${this.ptr}/fields/dummy6`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibHmac
const glibhmacRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Hmac/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibHmac:', ptr, err));
});

export class GLibHmac {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibhmacRegistry.register(this, ptr);
  }
    





 
  static async new(digest_type: GLibChecksumType, key: Pointer, key_len: number): Promise<GLibHmac | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('digest_type', String(digest_type));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('key_len', String(key_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHmac(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(): Promise<GLibHmac> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHmac(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_digest(buffer: Pointer, digest_len: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/get_digest`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buffer', String(buffer));
    // Primitive parameter
    url.searchParams.append('digest_len', String(digest_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.digest_len;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibHmac> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHmac(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async update(data_: Pointer, length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/ptr,${this.ptr}/update`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hmac/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibHookCompareFunc = (new_hook: GLibHook, sibling: GLibHook) => number;

export function convertGLibHookCompareFuncArgs(data: any): Parameters<GLibHookCompareFunc> {
  return [
    new GLibHook(data.new_hook, 'none'),
    new GLibHook(data.sibling, 'none')  ];
}
  
// Finalization registry for GLibHook
const glibhookRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Hook/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibHook:', ptr, err));
});

export class GLibHook {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibhookRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibHook> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHook(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  static async free(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/free`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async compare_ids(sibling: GLibHook): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/compare_ids`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sibling && typeof sibling === 'object' && 'ptr' in sibling) {
      url.searchParams.append('sibling', 'ptr,' + sibling.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async destroy(hook_list: GLibHookList, hook_id: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/destroy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('hook_id', String(hook_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async destroy_link(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/destroy_link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async insert_before(hook_list: GLibHookList, hook: GLibHook, sibling?: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/insert_before`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (sibling !== undefined && typeof sibling === 'object' && 'ptr' in sibling) {
      url.searchParams.append('sibling', 'ptr,' + sibling.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async insert_sorted(hook_list: GLibHookList, hook: GLibHook, func: GLibHookCompareFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/insert_sorted`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHookCompareFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async prepend(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/prepend`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async unref(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/unref`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_data(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next(): Promise<GLibHook | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHook(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_next(value_: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_prev(): Promise<GLibHook | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/prev`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHook(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_prev(value_: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/prev`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_ref_count(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/ref_count`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_ref_count(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/ref_count`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_hook_id(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/hook_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_hook_id(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/hook_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_flags(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_func(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_func(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_destroy(): Promise<GLibDestroyNotify | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_destroy(value_: GLibDestroyNotify): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Hook/ptr,${this.ptr}/fields/destroy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibHookMarshaller = (hook: GLibHook, marshal_data: Pointer) => void;

export function convertGLibHookMarshallerArgs(data: any): Parameters<GLibHookMarshaller> {
  return [
    new GLibHook(data.hook, 'none'),
    data.marshal_data  ];
}
  export type GLibHookCheckMarshaller = (hook: GLibHook, marshal_data: Pointer) => boolean;

export function convertGLibHookCheckMarshallerArgs(data: any): Parameters<GLibHookCheckMarshaller> {
  return [
    new GLibHook(data.hook, 'none'),
    data.marshal_data  ];
}
  
// Finalization registry for GLibHookList
const glibhooklistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/HookList/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibHookList:', ptr, err));
});

export class GLibHookList {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibhooklistRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibHookList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHookList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async clear(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(hook_size: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hook_size', String(hook_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async invoke(may_recurse: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/invoke`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_recurse', String(may_recurse));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async invoke_check(may_recurse: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/invoke_check`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_recurse', String(may_recurse));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async marshal(may_recurse: boolean, marshaller: GLibHookMarshaller): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/marshal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_recurse', String(may_recurse));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.marshaller !== undefined) {
        callbackDispatcher.set(data.marshaller.toString(), {
          converter: convertGLibHookMarshallerArgs,
          userFunction: marshaller
        });
      }
    return data.marshaller;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async marshal_check(may_recurse: boolean, marshaller: GLibHookCheckMarshaller): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/marshal_check`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_recurse', String(may_recurse));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.marshaller !== undefined) {
        callbackDispatcher.set(data.marshaller.toString(), {
          converter: convertGLibHookCheckMarshallerArgs,
          userFunction: marshaller
        });
      }
    return data.marshaller;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_seq_id(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/seq_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_seq_id(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/seq_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_hook_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/hook_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_hook_size(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/hook_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_is_setup(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/is_setup`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_is_setup(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/is_setup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_hooks(): Promise<GLibHook | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/hooks`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibHook(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_hooks(value_: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/hooks`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy3(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/dummy3`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_dummy3(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/dummy3`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_finalize_hook(): Promise<GLibHookFinalizeFunc | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/finalize_hook`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_finalize_hook(value_: GLibHookFinalizeFunc): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/finalize_hook`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/dummy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_dummy(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/HookList/ptr,${this.ptr}/fields/dummy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibHookFinalizeFunc = (hook_list: GLibHookList, hook: GLibHook) => void;

export function convertGLibHookFinalizeFuncArgs(data: any): Parameters<GLibHookFinalizeFunc> {
  return [
    new GLibHookList(data.hook_list, 'none'),
    new GLibHook(data.hook, 'none')  ];
}
  export type GLibHookFlagMask = "active" | "in_call" | "mask";

  
// Finalization registry for GLibIOChannel
const glibiochannelRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/IOChannel/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibIOChannel:', ptr, err));
});

export class GLibIOChannel {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibiochannelRegistry.register(this, ptr);
  }
    





 
  static async new_file(filename: Pointer, mode: string): Promise<GLibIOChannel> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/new_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibIOChannel(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async unix_new(fd: number): Promise<GLibIOChannel> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/unix_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibIOChannel(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async close(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/close`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async flush(): Promise<GLibIOStatus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/flush`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_buffer_condition(): Promise<GLibIOConditionValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_buffer_condition`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_buffer_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_buffer_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_buffered(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_buffered`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_close_on_unref(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_close_on_unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_encoding(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_encoding`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<GLibIOFlags> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_line_term(): Promise<{length: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/get_line_term`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async read(buf: string, count: number, bytes_read: number): Promise<GLibIOError> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buf', String(buf));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    // Primitive parameter
    url.searchParams.append('bytes_read', String(bytes_read));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async read_chars(count: number): Promise<{buf: Pointer, bytes_read: number, return: GLibIOStatus}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_chars`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('count', String(count));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: buf
      result.buf = (() => {
        return data.buf;

      })();
      // Handle return parameter: bytes_read
      result.bytes_read = (() => {
        return data.bytes_read;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async read_line(): Promise<{str_return: string, length: number, terminator_pos: number, return: GLibIOStatus}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_line`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: str_return
      result.str_return = (() => {
        return data.str_return;

      })();
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: terminator_pos
      result.terminator_pos = (() => {
        return data.terminator_pos;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async read_line_string(buffer: GLibString, terminator_pos?: number): Promise<GLibIOStatus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_line_string`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Primitive parameter
    if (terminator_pos !== undefined) url.searchParams.append('terminator_pos', String(terminator_pos));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async read_to_end(): Promise<{str_return: Pointer, length: number, return: GLibIOStatus}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_to_end`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: str_return
      result.str_return = (() => {
        return data.str_return;

      })();
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async read_unichar(): Promise<{thechar: Pointer, return: GLibIOStatus}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/read_unichar`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: thechar
      result.thechar = (() => {
        return data.thechar;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibIOChannel> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibIOChannel(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async seek(offset: number, type_: GLibSeekType): Promise<GLibIOError> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async seek_position(offset: number, type_: GLibSeekType): Promise<GLibIOStatus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/seek_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_buffer_size(size: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_buffer_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_buffered(buffered: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_buffered`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buffered', String(buffered));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_close_on_unref(do_close: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_close_on_unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('do_close', String(do_close));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_encoding(encoding?: string): Promise<GLibIOStatus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_encoding`, apiConfig.baseUrl);
    // Primitive parameter
    if (encoding !== undefined) url.searchParams.append('encoding', String(encoding));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_flags(flags: GLibIOFlags): Promise<GLibIOStatus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_line_term(length: number, line_term?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/set_line_term`, apiConfig.baseUrl);
    // Primitive parameter
    if (line_term !== undefined) url.searchParams.append('line_term', String(line_term));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async shutdown(flush: boolean): Promise<GLibIOStatus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/shutdown`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unix_get_fd(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/unix_get_fd`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async write(buf: string, count: number, bytes_written: number): Promise<GLibIOError> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/write`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buf', String(buf));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    // Primitive parameter
    url.searchParams.append('bytes_written', String(bytes_written));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async write_chars(buf: Pointer, count: number): Promise<{bytes_written: number, return: GLibIOStatus}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/write_chars`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buf', String(buf));
    // Primitive parameter
    url.searchParams.append('count', String(count));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: bytes_written
      result.bytes_written = (() => {
        return data.bytes_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async write_unichar(thechar: Pointer): Promise<GLibIOStatus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/write_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('thechar', String(thechar));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async error_from_errno(en: number): Promise<GLibIOChannelError> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/error_from_errno`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('en', String(en));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_ref_count(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/ref_count`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_funcs(): Promise<GLibIOFuncs | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/funcs`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibIOFuncs(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_read_cd(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/read_cd`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_write_cd(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/write_cd`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_line_term_len(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/line_term_len`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_buf_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/buf_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_read_buf(): Promise<GLibString | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/read_buf`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_encoded_read_buf(): Promise<GLibString | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/encoded_read_buf`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_write_buf(): Promise<GLibString | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/write_buf`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_partial_write_buf(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/partial_write_buf`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_use_buffer(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/use_buffer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_do_encode(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/do_encode`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_is_readable(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/is_readable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_is_writeable(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/is_writeable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_is_seekable(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/is_seekable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_reserved1(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/reserved1`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_reserved2(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/ptr,${this.ptr}/fields/reserved2`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/IOChannel/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibIOStatus = "error" | "normal" | "eof" | "again";

  export type GLibIOFlags = "none" | "append" | "nonblock" | "is_readable" | "is_writable" | "is_writeable" | "is_seekable" | "mask" | "get_mask" | "set_mask";

  export type GLibIOError = "none" | "again" | "inval" | "unknown";

  
// Finalization registry for GLibString
const glibstringRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/String/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibString:', ptr, err));
});

export class GLibString {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibstringRegistry.register(this, ptr);
  }
    





 
  static async new(init?: string): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (init !== undefined) url.searchParams.append('init', String(init));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_len(init: string, len: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/new_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('init', String(init));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_take(init?: string): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/new_take`, apiConfig.baseUrl);
    // Primitive parameter
    if (init !== undefined) url.searchParams.append('init', String(init));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async sized_new(dfl_size: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/sized_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dfl_size', String(dfl_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(free_segment: boolean): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('free_segment', String(free_segment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async append(val: string): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append_c(c: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append_c`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append_len(val: string, len: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append_unichar(wc: Pointer): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('wc', String(wc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append_uri_escaped(unescaped: string, reserved_chars_allowed: string, allow_utf8: boolean): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/append_uri_escaped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    // Primitive parameter
    url.searchParams.append('allow_utf8', String(allow_utf8));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ascii_down(): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/ascii_down`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ascii_up(): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/ascii_up`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async assign(rval: string): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/assign`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rval', String(rval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async down(): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/down`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async equal(v2: GLibString): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (v2 && typeof v2 === 'object' && 'ptr' in v2) {
      url.searchParams.append('v2', 'ptr,' + v2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async erase(pos: number, len: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/erase`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async free_and_steal(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/free_and_steal`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async free_to_bytes(): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/free_to_bytes`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async hash(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert(pos: number, val: string): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_c(pos: number, c: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/insert_c`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_len(pos: number, val: string, len: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/insert_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_unichar(pos: number, wc: Pointer): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/insert_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('wc', String(wc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async overwrite(pos: number, val: string): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/overwrite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async overwrite_len(pos: number, val: string, len: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/overwrite_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async prepend(val: string): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/prepend`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async prepend_c(c: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/prepend_c`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async prepend_len(val: string, len: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/prepend_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async prepend_unichar(wc: Pointer): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/prepend_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('wc', String(wc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace(find: string, replace: string, limit: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('find', String(find));
    // Primitive parameter
    url.searchParams.append('replace', String(replace));
    // Primitive parameter
    url.searchParams.append('limit', String(limit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_size(len: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/set_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async truncate(len: number): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/truncate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async up(): Promise<GLibString> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/up`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_str(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/fields/str`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_str(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/fields/str`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_len(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/fields/len`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_len(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/fields/len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_allocated_len(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/fields/allocated_len`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_allocated_len(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/ptr,${this.ptr}/fields/allocated_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/String/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibSeekType = "cur" | "set" | "end";

  export type GLibIOChannelError = "fbig" | "inval" | "io" | "isdir" | "nospc" | "nxio" | "overflow" | "pipe" | "failed";

  
// Finalization registry for GLibIOFuncs
const glibiofuncsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/IOFuncs/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibIOFuncs:', ptr, err));
});

export class GLibIOFuncs {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibiofuncsRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GLibKeyFile
const glibkeyfileRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/KeyFile/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibKeyFile:', ptr, err));
});

export class GLibKeyFile {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibkeyfileRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibKeyFile> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibKeyFile(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_boolean(group_name: string, key: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_boolean_list(group_name: string, key: string): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_boolean_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_comment(group_name?: string, key?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_comment`, apiConfig.baseUrl);
    // Primitive parameter
    if (group_name !== undefined) url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_double(group_name: string, key: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_double_list(group_name: string, key: string): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_double_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_groups(): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_groups`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int64(group_name: string, key: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_integer(group_name: string, key: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_integer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_integer_list(group_name: string, key: string): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_integer_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_keys(group_name: string): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_keys`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_locale_for_key(group_name: string, key: string, locale?: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_locale_for_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    if (locale !== undefined) url.searchParams.append('locale', String(locale));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_locale_string(group_name: string, key: string, locale?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_locale_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    if (locale !== undefined) url.searchParams.append('locale', String(locale));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_locale_string_list(group_name: string, key: string, locale?: string): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_locale_string_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    if (locale !== undefined) url.searchParams.append('locale', String(locale));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_start_group(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_start_group`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string(group_name: string, key: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string_list(group_name: string, key: string): Promise<{length: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_string_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint64(group_name: string, key: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_value(group_name: string, key: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_group(group_name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/has_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async load_from_bytes(bytes: GLibBytes, flags: GLibKeyFileFlags): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_bytes`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes && typeof bytes === 'object' && 'ptr' in bytes) {
      url.searchParams.append('bytes', 'ptr,' + bytes.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async load_from_data(data_: string, length: number, flags: GLibKeyFileFlags): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async load_from_data_dirs(file: Pointer, flags: GLibKeyFileFlags): Promise<{full_path: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_data_dirs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: full_path
      result.full_path = (() => {
        return data.full_path;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async load_from_dirs(file: Pointer, search_dirs: Pointer, flags: GLibKeyFileFlags): Promise<{full_path: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_dirs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('search_dirs', String(search_dirs));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: full_path
      result.full_path = (() => {
        return data.full_path;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async load_from_file(file: Pointer, flags: GLibKeyFileFlags): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/load_from_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_comment(group_name?: string, key?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/remove_comment`, apiConfig.baseUrl);
    // Primitive parameter
    if (group_name !== undefined) url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_group(group_name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/remove_group`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_key(group_name: string, key: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/remove_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async save_to_file(filename: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/save_to_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_boolean(group_name: string, key: string, value_: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_boolean_list(group_name: string, key: string, list: Pointer, length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_boolean_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_comment(comment: string, group_name?: string, key?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_comment`, apiConfig.baseUrl);
    // Primitive parameter
    if (group_name !== undefined) url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('comment', String(comment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_double(group_name: string, key: string, value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_double_list(group_name: string, key: string, list: Pointer, length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_double_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_int64(group_name: string, key: string, value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_integer(group_name: string, key: string, value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_integer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_integer_list(group_name: string, key: string, list: Pointer, length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_integer_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_list_separator(separator: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_list_separator`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('separator', String(separator));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_locale_string(group_name: string, key: string, locale: string, string: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_locale_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('locale', String(locale));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_locale_string_list(group_name: string, key: string, locale: string, list: Pointer, length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_locale_string_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('locale', String(locale));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_string(group_name: string, key: string, string: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_string_list(group_name: string, key: string, list: Pointer, length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_string_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_uint64(group_name: string, key: string, value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_value(group_name: string, key: string, value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_name', String(group_name));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_data(): Promise<{length: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/to_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/KeyFile/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibKeyFileFlags = "none" | "keep_comments" | "keep_translations";

  export type GLibKeyFileError = "unknown_encoding" | "parse" | "not_found" | "key_not_found" | "group_not_found" | "invalid_value";

  
// Finalization registry for GLibLogField
const gliblogfieldRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/LogField/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibLogField:', ptr, err));
});

export class GLibLogField {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gliblogfieldRegistry.register(this, ptr);
  }


}
  export type GLibLogLevelFlags = "flag_recursion" | "flag_fatal" | "level_error" | "level_critical" | "level_warning" | "level_message" | "level_info" | "level_debug" | "level_mask";

  export type GLibLogWriterOutput = "handled" | "unhandled";

  
// Finalization registry for GLibMainLoop
const glibmainloopRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MainLoop/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMainLoop:', ptr, err));
});

export class GLibMainLoop {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibmainloopRegistry.register(this, ptr);
  }
    





 
  static async new(is_running: boolean, context?: GLibMainContext): Promise<GLibMainLoop> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('is_running', String(is_running));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainLoop(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_context(): Promise<GLibMainContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/get_context`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_running(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/is_running`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async quit(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/quit`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibMainLoop> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainLoop(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async run(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/run`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MainLoop/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibMappedFile
const glibmappedfileRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MappedFile/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMappedFile:', ptr, err));
});

export class GLibMappedFile {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibmappedfileRegistry.register(this, ptr);
  }
    





 
  static async new(filename: Pointer, writable: boolean): Promise<GLibMappedFile> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('writable', String(writable));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMappedFile(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_fd(fd: number, writable: boolean): Promise<GLibMappedFile> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/new_from_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('writable', String(writable));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMappedFile(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_bytes(): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/get_bytes`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_contents(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/get_contents`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_length(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/get_length`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibMappedFile> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMappedFile(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MappedFile/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibMarkupCollectType = "invalid" | "string" | "strdup" | "boolean" | "tristate" | "optional";

  export type GLibMarkupError = "bad_utf8" | "empty" | "parse" | "unknown_element" | "unknown_attribute" | "invalid_content" | "missing_attribute";

  
// Finalization registry for GLibMarkupParseContext
const glibmarkupparsecontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MarkupParseContext/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMarkupParseContext:', ptr, err));
});

export class GLibMarkupParseContext {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibmarkupparsecontextRegistry.register(this, ptr);
  }
    





 
  static async new(parser: GLibMarkupParser, flags: GLibMarkupParseFlags, user_data_dnotify: GLibDestroyNotify, user_data?: Pointer): Promise<{user_data_dnotify: number, return: GLibMarkupParseContext}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parser && typeof parser === 'object' && 'ptr' in parser) {
      url.searchParams.append('parser', 'ptr,' + parser.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.user_data_dnotify !== undefined) {
        callbackDispatcher.set(data.user_data_dnotify.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: user_data_dnotify
        });
      }
        const result: any = {};
      // Handle return parameter: user_data_dnotify
      result.user_data_dnotify = (() => {
        return data.user_data_dnotify;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibMarkupParseContext(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async end_parse(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/end_parse`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_element(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/get_element`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_element_stack(): Promise<GLibSList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/get_element_stack`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_position(): Promise<{line_number: number, char_number: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/get_position`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: line_number
      result.line_number = (() => {
        return data.line_number;

      })();
      // Handle return parameter: char_number
      result.char_number = (() => {
        return data.char_number;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_user_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/get_user_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse(text: string, text_len: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    url.searchParams.append('text_len', String(text_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pop(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push(parser: GLibMarkupParser, user_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parser && typeof parser === 'object' && 'ptr' in parser) {
      url.searchParams.append('parser', 'ptr,' + parser.ptr);
    }
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibMarkupParseContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMarkupParseContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MarkupParseContext/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibMarkupParser
const glibmarkupparserRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MarkupParser/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMarkupParser:', ptr, err));
});

export class GLibMarkupParser {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibmarkupparserRegistry.register(this, ptr);
  }


}
  export type GLibMarkupParseFlags = "default_flags" | "do_not_use_this_unsupported_flag" | "treat_cdata_as_text" | "prefix_error_position" | "ignore_qualified";

  
// Finalization registry for GLibMatchInfo
const glibmatchinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MatchInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMatchInfo:', ptr, err));
});

export class GLibMatchInfo {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibmatchinfoRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibMatchInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMatchInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async expand_references(string_to_expand: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/expand_references`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string_to_expand', String(string_to_expand));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fetch(match_num: number): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('match_num', String(match_num));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fetch_all(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch_all`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fetch_named(name: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch_named`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fetch_named_pos(name: string): Promise<{start_pos: number, end_pos: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch_named_pos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: start_pos
      result.start_pos = (() => {
        return data.start_pos;

      })();
      // Handle return parameter: end_pos
      result.end_pos = (() => {
        return data.end_pos;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fetch_pos(match_num: number): Promise<{start_pos: number, end_pos: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/fetch_pos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('match_num', String(match_num));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: start_pos
      result.start_pos = (() => {
        return data.start_pos;

      })();
      // Handle return parameter: end_pos
      result.end_pos = (() => {
        return data.end_pos;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_match_count(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/get_match_count`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_regex(): Promise<GLibRegex> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/get_regex`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRegex(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_partial_match(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/is_partial_match`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async matches(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/matches`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async next(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibMatchInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMatchInfo(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MatchInfo/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibRegexEvalCallback = (match_info: GLibMatchInfo, result_: GLibString, user_data: Pointer) => boolean;

export function convertGLibRegexEvalCallbackArgs(data: any): Parameters<GLibRegexEvalCallback> {
  return [
    new GLibMatchInfo(data.match_info, 'none'),
    new GLibString(data.result, 'none'),
    data.user_data  ];
}
  
// Finalization registry for GLibRegex
const glibregexRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Regex/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRegex:', ptr, err));
});

export class GLibRegex {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibregexRegistry.register(this, ptr);
  }
    





 
  static async new(pattern: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<GLibRegex | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRegex(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_capture_count(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_capture_count`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_compile_flags(): Promise<GLibRegexCompileFlags> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_compile_flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_has_cr_or_lf(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_has_cr_or_lf`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_match_flags(): Promise<GLibRegexMatchFlags> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_match_flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_max_backref(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_max_backref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_max_lookbehind(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_max_lookbehind`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_pattern(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_pattern`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string_number(name: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/get_string_number`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async match(string: string, match_options: GLibRegexMatchFlags, match_info: GLibMatchInfo): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/match`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Object with explode=false: serialize as comma-separated
    if (match_info && typeof match_info === 'object' && 'ptr' in match_info) {
      url.searchParams.append('match_info', 'ptr,' + match_info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async match_all(string: string, match_options: GLibRegexMatchFlags, match_info: GLibMatchInfo): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/match_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Object with explode=false: serialize as comma-separated
    if (match_info && typeof match_info === 'object' && 'ptr' in match_info) {
      url.searchParams.append('match_info', 'ptr,' + match_info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async match_all_full(string: Pointer, string_len: number, start_position: number, match_options: GLibRegexMatchFlags, match_info: GLibMatchInfo): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/match_all_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Object with explode=false: serialize as comma-separated
    if (match_info && typeof match_info === 'object' && 'ptr' in match_info) {
      url.searchParams.append('match_info', 'ptr,' + match_info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async match_full(string: Pointer, string_len: number, start_position: number, match_options: GLibRegexMatchFlags, match_info: GLibMatchInfo): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/match_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Object with explode=false: serialize as comma-separated
    if (match_info && typeof match_info === 'object' && 'ptr' in match_info) {
      url.searchParams.append('match_info', 'ptr,' + match_info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibRegex> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRegex(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace(string: Pointer, string_len: number, start_position: number, replacement: string, match_options: GLibRegexMatchFlags): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('replacement', String(replacement));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace_eval(string: Pointer, string_len: number, start_position: number, match_options: GLibRegexMatchFlags, eval_: GLibRegexEvalCallback): Promise<{eval: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/replace_eval`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.eval !== undefined) {
        callbackDispatcher.set(data.eval.toString(), {
          converter: convertGLibRegexEvalCallbackArgs,
          userFunction: eval_
        });
      }
        const result: any = {};
      // Handle return parameter: eval
      result.eval = (() => {
        return data.eval;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace_literal(string: Pointer, string_len: number, start_position: number, replacement: string, match_options: GLibRegexMatchFlags): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/replace_literal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('replacement', String(replacement));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async split(string: string, match_options: GLibRegexMatchFlags): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/split`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async split_full(string: Pointer, string_len: number, start_position: number, match_options: GLibRegexMatchFlags, max_tokens: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/split_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('string_len', String(string_len));
    // Primitive parameter
    url.searchParams.append('start_position', String(start_position));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    // Primitive parameter
    url.searchParams.append('max_tokens', String(max_tokens));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async check_replacement(replacement: string): Promise<{has_references: boolean, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/check_replacement`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('replacement', String(replacement));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: has_references
      result.has_references = (() => {
        return data.has_references;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async escape_nul(string: string, length: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/escape_nul`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async escape_string(string: string, length: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/escape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async match_simple(pattern: string, string: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/match_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async split_simple(pattern: string, string: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/split_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Regex/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibRegexCompileFlags = "default" | "caseless" | "multiline" | "dotall" | "extended" | "anchored" | "dollar_endonly" | "ungreedy" | "raw" | "no_auto_capture" | "optimize" | "firstline" | "dupnames" | "newline_cr" | "newline_lf" | "newline_crlf" | "newline_anycrlf" | "bsr_anycrlf" | "javascript_compat";

  export type GLibRegexMatchFlags = "default" | "anchored" | "notbol" | "noteol" | "notempty" | "partial" | "newline_cr" | "newline_lf" | "newline_crlf" | "newline_any" | "newline_anycrlf" | "bsr_anycrlf" | "bsr_any" | "partial_soft" | "partial_hard" | "notempty_atstart";

  
// Finalization registry for GLibMemChunk
const glibmemchunkRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MemChunk/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMemChunk:', ptr, err));
});

export class GLibMemChunk {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibmemchunkRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibMemChunk> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMemChunk(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(mem?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async alloc(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/alloc`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async alloc0(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/alloc0`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async clean(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/clean`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async destroy(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async print(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/print`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reset(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/ptr,${this.ptr}/reset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async info(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/MemChunk/info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibMemVTable
const glibmemvtableRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/MemVTable/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibMemVTable:', ptr, err));
});

export class GLibMemVTable {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibmemvtableRegistry.register(this, ptr);
  }


}
  export type GLibNodeForeachFunc = (node: GLibNode, data_: Pointer) => void;

export function convertGLibNodeForeachFuncArgs(data: any): Parameters<GLibNodeForeachFunc> {
  return [
    new GLibNode(data.node, 'none'),
    data.data  ];
}
  export type GLibNodeTraverseFunc = (node: GLibNode, data_: Pointer) => boolean;

export function convertGLibNodeTraverseFuncArgs(data: any): Parameters<GLibNodeTraverseFunc> {
  return [
    new GLibNode(data.node, 'none'),
    data.data  ];
}
  
// Finalization registry for GLibNode
const glibnodeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Node/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibNode:', ptr, err));
});

export class GLibNode {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibnodeRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibNode> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async child_index(data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/child_index`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async child_position(child: GLibNode): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/child_position`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child && typeof child === 'object' && 'ptr' in child) {
      url.searchParams.append('child', 'ptr,' + child.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async children_foreach(flags: GLibTraverseFlags, func: GLibNodeForeachFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/children_foreach`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibNodeForeachFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async depth(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/depth`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async destroy(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_ancestor(descendant: GLibNode): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/is_ancestor`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (descendant && typeof descendant === 'object' && 'ptr' in descendant) {
      url.searchParams.append('descendant', 'ptr,' + descendant.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async max_height(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/max_height`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async n_children(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/n_children`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async n_nodes(flags: GLibTraverseFlags): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/n_nodes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reverse_children(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/reverse_children`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async traverse(order: GLibTraverseType, flags: GLibTraverseFlags, max_depth: number, func: GLibNodeTraverseFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/traverse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('order', String(order));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('max_depth', String(max_depth));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibNodeTraverseFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unlink(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/unlink`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async pop_allocator(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/pop_allocator`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async push_allocator(allocator: GLibAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_data(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next(): Promise<GLibNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_next(value_: GLibNode): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_prev(): Promise<GLibNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/prev`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_prev(value_: GLibNode): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/prev`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_parent(): Promise<GLibNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_parent(value_: GLibNode): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_children(): Promise<GLibNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/children`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_children(value_: GLibNode): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Node/ptr,${this.ptr}/fields/children`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibTraverseFlags = "leaves" | "non_leaves" | "all" | "mask" | "leafs" | "non_leafs";

  export type GLibTraverseType = "in_order" | "pre_order" | "post_order" | "level_order";

  export namespace GLibNormalizeMode {
  export const DEFAULT: 'default' = 'default';
  export const NFD: 'nfd' = 'nfd';
  export const DEFAULT_COMPOSE: 'default_compose' = 'default_compose';
  export const NFC: 'nfc' = 'nfc';
  export const ALL: 'all' = 'all';
  export const NFKD: 'nfkd' = 'nfkd';
  export const ALL_COMPOSE: 'all_compose' = 'all_compose';
  export const NFKC: 'nfkc' = 'nfkc';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/NormalizeMode/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GLibNormalizeModeValue = "default" | "nfd" | "default_compose" | "nfc" | "all" | "nfkd" | "all_compose" | "nfkc";

  export type GLibNumberParserError = "invalid" | "out_of_bounds";

  
// Finalization registry for GLibOnce
const glibonceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Once/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibOnce:', ptr, err));
});

export class GLibOnce {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibonceRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibOnce> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibOnce(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  static async init_enter(location: Pointer): Promise<{location: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_enter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: location
      result.location = (() => {
        return data.location;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async init_enter_impl(location: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_enter_impl`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async init_enter_pointer(location: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_enter_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async init_leave(location: Pointer, result_: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_leave`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Primitive parameter
    url.searchParams.append('result', String(result_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.location;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async init_leave_pointer(location: Pointer, result_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/init_leave_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Primitive parameter
    if (result_ !== undefined) url.searchParams.append('result_', String(result_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_status(): Promise<GLibOnceStatus | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/ptr,${this.ptr}/fields/status`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_status(value_: GLibOnceStatus): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/ptr,${this.ptr}/fields/status`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_retval(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/ptr,${this.ptr}/fields/retval`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_retval(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Once/ptr,${this.ptr}/fields/retval`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibOnceStatus = "notcalled" | "progress" | "ready";

  export type GLibOptionArg = "none" | "string" | "int" | "callback" | "filename" | "string_array" | "filename_array" | "double" | "int64";

  export type GLibTranslateFunc = (str: string, data_: Pointer) => string;

export function convertGLibTranslateFuncArgs(data: any): Parameters<GLibTranslateFunc> {
  return [
    data.str,
    data.data  ];
}
  
// Finalization registry for GLibOptionContext
const gliboptioncontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/OptionContext/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibOptionContext:', ptr, err));
});

export class GLibOptionContext {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gliboptioncontextRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibOptionContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibOptionContext(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_group(group: GLibOptionGroup): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/add_group`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (group && typeof group === 'object' && 'ptr' in group) {
      url.searchParams.append('group', 'ptr,' + group.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_main_entries(entries: Pointer, translation_domain?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/add_main_entries`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('entries', String(entries));
    // Primitive parameter
    if (translation_domain !== undefined) url.searchParams.append('translation_domain', String(translation_domain));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_description(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_help(main_help: boolean, group?: GLibOptionGroup): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_help`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('main_help', String(main_help));
    // Object with explode=false: serialize as comma-separated
    if (group !== undefined && typeof group === 'object' && 'ptr' in group) {
      url.searchParams.append('group', 'ptr,' + group.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_help_enabled(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_help_enabled`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_ignore_unknown_options(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_ignore_unknown_options`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_main_group(): Promise<GLibOptionGroup> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_main_group`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibOptionGroup(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_strict_posix(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_strict_posix`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_summary(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/get_summary`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse(argc: number, argv: Pointer): Promise<{argc: number, argv: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('argc', String(argc));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: argc
      result.argc = (() => {
        return data.argc;

      })();
      // Handle return parameter: argv
      result.argv = (() => {
        return data.argv;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_strv(arguments_: Pointer): Promise<{arguments: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/parse_strv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arguments', String(arguments_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: arguments
      result.arguments = (() => {
        return data.arguments;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_description(description?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_description`, apiConfig.baseUrl);
    // Primitive parameter
    if (description !== undefined) url.searchParams.append('description', String(description));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_help_enabled(help_enabled: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_help_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('help_enabled', String(help_enabled));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_ignore_unknown_options(ignore_unknown: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_ignore_unknown_options`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ignore_unknown', String(ignore_unknown));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_main_group(group: GLibOptionGroup): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_main_group`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (group && typeof group === 'object' && 'ptr' in group) {
      url.searchParams.append('group', 'ptr,' + group.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_strict_posix(strict_posix: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_strict_posix`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strict_posix', String(strict_posix));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_summary(summary?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_summary`, apiConfig.baseUrl);
    // Primitive parameter
    if (summary !== undefined) url.searchParams.append('summary', String(summary));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_translate_func(func: GLibTranslateFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_translate_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibTranslateFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_translation_domain(domain: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionContext/ptr,${this.ptr}/set_translation_domain`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibOptionGroup
const gliboptiongroupRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/OptionGroup/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibOptionGroup:', ptr, err));
});

export class GLibOptionGroup {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gliboptiongroupRegistry.register(this, ptr);
  }
    





 
  static async new(name: string, description: string, help_description: string, destroy: GLibDestroyNotify, user_data?: Pointer): Promise<{destroy: number, return: GLibOptionGroup}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    // Primitive parameter
    url.searchParams.append('help_description', String(help_description));
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.destroy !== undefined) {
        callbackDispatcher.set(data.destroy.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: destroy
        });
      }
        const result: any = {};
      // Handle return parameter: destroy
      result.destroy = (() => {
        return data.destroy;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibOptionGroup(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_entries(entries: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/add_entries`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('entries', String(entries));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibOptionGroup> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibOptionGroup(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_translate_func(func: GLibTranslateFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/set_translate_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibTranslateFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_translation_domain(domain: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/set_translation_domain`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/OptionGroup/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibOptionEntry
const gliboptionentryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/OptionEntry/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibOptionEntry:', ptr, err));
});

export class GLibOptionEntry {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gliboptionentryRegistry.register(this, ptr);
  }


}
  export type GLibOptionError = "unknown_option" | "bad_value" | "failed";

  export type GLibOptionFlags = "none" | "hidden" | "in_main" | "reverse" | "no_arg" | "filename" | "optional_arg" | "noalias";

  
// Finalization registry for GLibPathBuf
const glibpathbufRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/PathBuf/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibPathBuf:', ptr, err));
});

export class GLibPathBuf {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibpathbufRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibPathBuf> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibPathBuf(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async clear(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async clear_to_path(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/clear_to_path`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async free_to_path(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/free_to_path`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(): Promise<GLibPathBuf> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibPathBuf(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init_from_path(path?: Pointer): Promise<GLibPathBuf> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/init_from_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibPathBuf(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pop(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push(path: Pointer): Promise<GLibPathBuf> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibPathBuf(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_extension(extension?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/set_extension`, apiConfig.baseUrl);
    // Primitive parameter
    if (extension !== undefined) url.searchParams.append('extension', String(extension));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_filename(file_name: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/set_filename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_path(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/to_path`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async equal(v1: Pointer, v2: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/equal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v1', String(v1));
    // Primitive parameter
    url.searchParams.append('v2', String(v2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PathBuf/ptr,${this.ptr}/fields/dummy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibPatternSpec
const glibpatternspecRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/PatternSpec/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibPatternSpec:', ptr, err));
});

export class GLibPatternSpec {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibpatternspecRegistry.register(this, ptr);
  }
    





 
  static async new(pattern: string): Promise<GLibPatternSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibPatternSpec(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(): Promise<GLibPatternSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibPatternSpec(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async equal(pspec2: GLibPatternSpec): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec2 && typeof pspec2 === 'object' && 'ptr' in pspec2) {
      url.searchParams.append('pspec2', 'ptr,' + pspec2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async match(string_length: number, string: string, string_reversed?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/match`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string_length', String(string_length));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (string_reversed !== undefined) url.searchParams.append('string_reversed', String(string_reversed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async match_string(string: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/ptr,${this.ptr}/match_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/PatternSpec/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibPrivate
const glibprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Private/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibPrivate:', ptr, err));
});

export class GLibPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibprivateRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibPrivate> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibPrivate(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace(value_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set(value_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/set`, apiConfig.baseUrl);
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_p(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/fields/p`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_notify(): Promise<GLibDestroyNotify | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/fields/notify`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_future(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Private/ptr,${this.ptr}/fields/future`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibPtrArray
const glibptrarrayRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/PtrArray/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibPtrArray:', ptr, err));
});

export class GLibPtrArray {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibptrarrayRegistry.register(this, ptr);
  }


}
  export type GLibFunc = (data_: Pointer, user_data: Pointer) => void;

export function convertGLibFuncArgs(data: any): Parameters<GLibFunc> {
  return [
    data.data,
    data.user_data  ];
}
  
// Finalization registry for GLibQueue
const glibqueueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Queue/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibQueue:', ptr, err));
});

export class GLibQueue {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibqueueRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibQueue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibQueue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async clear(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async clear_full(free_func: GLibDestroyNotify): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/clear_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.free_func !== undefined) {
        callbackDispatcher.set(data.free_func.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: free_func
        });
      }
    return data.free_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach(func: GLibFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async free_full(free_func: GLibDestroyNotify): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/free_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.free_func !== undefined) {
        callbackDispatcher.set(data.free_func.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: free_func
        });
      }
    return data.free_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_length(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/get_length`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async index(data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/index`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_sorted(func: GLibCompareDataFunc, data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/insert_sorted`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_empty(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek_head(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/peek_head`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek_nth(n: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/peek_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n', String(n));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek_tail(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/peek_tail`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pop_head(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/pop_head`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pop_nth(n: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/pop_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n', String(n));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pop_tail(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/pop_tail`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push_head(data_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/push_head`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push_nth(n: number, data_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/push_nth`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push_tail(data_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/push_tail`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(data_?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_all(data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/remove_all`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reverse(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/reverse`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async sort(compare_func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/sort`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.compare_func !== undefined) {
        callbackDispatcher.set(data.compare_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: compare_func
        });
      }
    return data.compare_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_head(): Promise<GLibList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/fields/head`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', Pointer, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_head(value_: GLibList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/fields/head`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_tail(): Promise<GLibList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/fields/tail`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', Pointer, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_tail(value_: GLibList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Queue/ptr,${this.ptr}/fields/tail`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibRWLock
const glibrwlockRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/RWLock/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRWLock:', ptr, err));
});

export class GLibRWLock {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibrwlockRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibRWLock> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRWLock(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async clear(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reader_lock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/reader_lock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reader_trylock(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/reader_trylock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reader_unlock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/reader_unlock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async writer_lock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/writer_lock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async writer_trylock(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/writer_trylock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async writer_unlock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/writer_unlock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_p(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/fields/p`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_i(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RWLock/ptr,${this.ptr}/fields/i`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibRand
const glibrandRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Rand/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRand:', ptr, err));
});

export class GLibRand {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibrandRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibRand> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRand(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_with_seed(seed: number): Promise<GLibRand> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/new_with_seed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRand(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_with_seed_array(seed: number, seed_length: number): Promise<GLibRand> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/new_with_seed_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    // Primitive parameter
    url.searchParams.append('seed_length', String(seed_length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRand(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(): Promise<GLibRand> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRand(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async double(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/double`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async double_range(begin: number, end: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/double_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async int(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/int`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async int_range(begin: number, end: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/int_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_seed(seed: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/set_seed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_seed_array(seed: number, seed_length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/ptr,${this.ptr}/set_seed_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    // Primitive parameter
    url.searchParams.append('seed_length', String(seed_length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Rand/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibRecMutex
const glibrecmutexRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/RecMutex/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRecMutex:', ptr, err));
});

export class GLibRecMutex {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibrecmutexRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibRecMutex> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRecMutex(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async clear(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/lock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async trylock(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/trylock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unlock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/unlock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_p(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/fields/p`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_i(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/RecMutex/ptr,${this.ptr}/fields/i`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibRegexError = "compile" | "optimize" | "replace" | "match" | "internal" | "stray_backslash" | "missing_control_char" | "unrecognized_escape" | "quantifiers_out_of_order" | "quantifier_too_big" | "unterminated_character_class" | "invalid_escape_in_character_class" | "range_out_of_order" | "nothing_to_repeat" | "unrecognized_character" | "posix_named_class_outside_class" | "unmatched_parenthesis" | "inexistent_subpattern_reference" | "unterminated_comment" | "expression_too_large" | "memory_error" | "variable_length_lookbehind" | "malformed_condition" | "too_many_conditional_branches" | "assertion_expected" | "unknown_posix_class_name" | "posix_collating_elements_not_supported" | "hex_code_too_large" | "invalid_condition" | "single_byte_match_in_lookbehind" | "infinite_loop" | "missing_subpattern_name_terminator" | "duplicate_subpattern_name" | "malformed_property" | "unknown_property" | "subpattern_name_too_long" | "too_many_subpatterns" | "invalid_octal_value" | "too_many_branches_in_define" | "define_repetion" | "inconsistent_newline_options" | "missing_back_reference" | "invalid_relative_reference" | "backtracking_control_verb_argument_forbidden" | "unknown_backtracking_control_verb" | "number_too_big" | "missing_subpattern_name" | "missing_digit" | "invalid_data_character" | "extra_subpattern_name" | "backtracking_control_verb_argument_required" | "invalid_control_char" | "missing_name" | "not_supported_in_class" | "too_many_forward_references" | "name_too_long" | "character_value_too_large";

  
// Finalization registry for GLibRelation
const glibrelationRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Relation/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibRelation:', ptr, err));
});

export class GLibRelation {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibrelationRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibRelation> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibRelation(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async count(field: number, key?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/count`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('field', String(field));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async delete_(field: number, key?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/delete`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('field', String(field));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async destroy(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async print(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Relation/ptr,${this.ptr}/print`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibScanner
const glibscannerRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Scanner/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibScanner:', ptr, err));
});

export class GLibScanner {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibscannerRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibScanner> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibScanner(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async cur_line(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/cur_line`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async cur_position(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/cur_position`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async cur_token(): Promise<GLibTokenType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/cur_token`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async destroy(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async eof(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/eof`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next_token(): Promise<GLibTokenType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/get_next_token`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async input_file(input_fd: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/input_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('input_fd', String(input_fd));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async input_text(text: string, text_len: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/input_text`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    url.searchParams.append('text_len', String(text_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lookup_symbol(symbol: string): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/lookup_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('symbol', String(symbol));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek_next_token(): Promise<GLibTokenType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/peek_next_token`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async scope_add_symbol(scope_id: number, symbol: string, value_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/scope_add_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    // Primitive parameter
    url.searchParams.append('symbol', String(symbol));
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async scope_foreach_symbol(scope_id: number, func: GLibHFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/scope_foreach_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async scope_lookup_symbol(scope_id: number, symbol: string): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/scope_lookup_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    // Primitive parameter
    url.searchParams.append('symbol', String(symbol));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async scope_remove_symbol(scope_id: number, symbol: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/scope_remove_symbol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    // Primitive parameter
    url.searchParams.append('symbol', String(symbol));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_scope(scope_id: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/set_scope`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope_id', String(scope_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async sync_file_offset(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/sync_file_offset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unexp_token(expected_token: GLibTokenType, identifier_spec: string, symbol_spec: string, symbol_name: string, message: string, is_error: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/unexp_token`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('expected_token', String(expected_token));
    // Primitive parameter
    url.searchParams.append('identifier_spec', String(identifier_spec));
    // Primitive parameter
    url.searchParams.append('symbol_spec', String(symbol_spec));
    // Primitive parameter
    url.searchParams.append('symbol_name', String(symbol_name));
    // Primitive parameter
    url.searchParams.append('message', String(message));
    // Primitive parameter
    url.searchParams.append('is_error', String(is_error));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_user_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/user_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_user_data(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/user_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_max_parse_errors(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/max_parse_errors`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_max_parse_errors(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/max_parse_errors`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_parse_errors(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/parse_errors`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_parse_errors(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/parse_errors`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_input_name(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/input_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_input_name(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/input_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_qdata(): Promise<GLibData | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/qdata`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibData(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_qdata(value_: GLibData): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/qdata`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_config(): Promise<GLibScannerConfig | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/config`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibScannerConfig(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_config(value_: GLibScannerConfig): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/config`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_token(): Promise<GLibTokenType | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/token`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_token(value_: GLibTokenType): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/token`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_value(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/value`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_value(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_line(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/line`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_line(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/line`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_position(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/position`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_position(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next_value(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/next_value`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_next_value(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/next_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next_line(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/next_line`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_next_line(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/next_line`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next_position(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/next_position`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_next_position(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/next_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_symbol_table(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/symbol_table`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_input_fd(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/input_fd`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_text(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/text`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_text_end(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/text_end`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_buffer(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/buffer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_scope_id(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/scope_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_msg_handler(): Promise<GLibScannerMsgFunc | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/msg_handler`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_msg_handler(value_: GLibScannerMsgFunc): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Scanner/ptr,${this.ptr}/fields/msg_handler`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibTokenType = "eof" | "left_paren" | "right_paren" | "left_curly" | "right_curly" | "left_brace" | "right_brace" | "equal_sign" | "comma" | "none" | "error" | "char" | "binary" | "octal" | "int" | "hex" | "float" | "string" | "symbol" | "identifier" | "identifier_null" | "comment_single" | "comment_multi";

  
// Finalization registry for GLibScannerConfig
const glibscannerconfigRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/ScannerConfig/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibScannerConfig:', ptr, err));
});

export class GLibScannerConfig {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibscannerconfigRegistry.register(this, ptr);
  }


}
  export type GLibScannerMsgFunc = (scanner: GLibScanner, message: string, error_: boolean) => void;

export function convertGLibScannerMsgFuncArgs(data: any): Parameters<GLibScannerMsgFunc> {
  return [
    new GLibScanner(data.scanner, 'none'),
    data.message,
    data.error  ];
}
  export type GLibSequenceIterCompareFunc = (a: GLibSequenceIter, b: GLibSequenceIter, data_: Pointer) => number;

export function convertGLibSequenceIterCompareFuncArgs(data: any): Parameters<GLibSequenceIterCompareFunc> {
  return [
    new GLibSequenceIter(data.a, 'none'),
    new GLibSequenceIter(data.b, 'none'),
    data.data  ];
}
  
// Finalization registry for GLibSequence
const glibsequenceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Sequence/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSequence:', ptr, err));
});

export class GLibSequence {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibsequenceRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibSequence> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequence(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async append(data_?: Pointer): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach(func: GLibFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_begin_iter(): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/get_begin_iter`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_end_iter(): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/get_end_iter`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_iter_at_pos(pos: number): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/get_iter_at_pos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_length(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/get_length`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_sorted(cmp_func: GLibCompareDataFunc, data_?: Pointer): Promise<{cmp_func: number, return: GLibSequenceIter}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/insert_sorted`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.cmp_func !== undefined) {
        callbackDispatcher.set(data.cmp_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: cmp_func
        });
      }
        const result: any = {};
      // Handle return parameter: cmp_func
      result.cmp_func = (() => {
        return data.cmp_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibSequenceIter(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_sorted_iter(iter_cmp: GLibSequenceIterCompareFunc, data_?: Pointer): Promise<{iter_cmp: number, return: GLibSequenceIter}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/insert_sorted_iter`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.iter_cmp !== undefined) {
        callbackDispatcher.set(data.iter_cmp.toString(), {
          converter: convertGLibSequenceIterCompareFuncArgs,
          userFunction: iter_cmp
        });
      }
        const result: any = {};
      // Handle return parameter: iter_cmp
      result.iter_cmp = (() => {
        return data.iter_cmp;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibSequenceIter(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_empty(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lookup(cmp_func: GLibCompareDataFunc, data_?: Pointer): Promise<{cmp_func: number, return: GLibSequenceIter | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/lookup`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.cmp_func !== undefined) {
        callbackDispatcher.set(data.cmp_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: cmp_func
        });
      }
        const result: any = {};
      // Handle return parameter: cmp_func
      result.cmp_func = (() => {
        return data.cmp_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibSequenceIter(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lookup_iter(iter_cmp: GLibSequenceIterCompareFunc, data_?: Pointer): Promise<{iter_cmp: number, return: GLibSequenceIter | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/lookup_iter`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.iter_cmp !== undefined) {
        callbackDispatcher.set(data.iter_cmp.toString(), {
          converter: convertGLibSequenceIterCompareFuncArgs,
          userFunction: iter_cmp
        });
      }
        const result: any = {};
      // Handle return parameter: iter_cmp
      result.iter_cmp = (() => {
        return data.iter_cmp;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibSequenceIter(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async prepend(data_?: Pointer): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/prepend`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async search(cmp_func: GLibCompareDataFunc, data_?: Pointer): Promise<{cmp_func: number, return: GLibSequenceIter}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/search`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.cmp_func !== undefined) {
        callbackDispatcher.set(data.cmp_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: cmp_func
        });
      }
        const result: any = {};
      // Handle return parameter: cmp_func
      result.cmp_func = (() => {
        return data.cmp_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibSequenceIter(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async search_iter(iter_cmp: GLibSequenceIterCompareFunc, data_?: Pointer): Promise<{iter_cmp: number, return: GLibSequenceIter}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/search_iter`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.iter_cmp !== undefined) {
        callbackDispatcher.set(data.iter_cmp.toString(), {
          converter: convertGLibSequenceIterCompareFuncArgs,
          userFunction: iter_cmp
        });
      }
        const result: any = {};
      // Handle return parameter: iter_cmp
      result.iter_cmp = (() => {
        return data.iter_cmp;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibSequenceIter(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async sort(cmp_func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/sort`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.cmp_func !== undefined) {
        callbackDispatcher.set(data.cmp_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: cmp_func
        });
      }
    return data.cmp_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async sort_iter(cmp_func: GLibSequenceIterCompareFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/ptr,${this.ptr}/sort_iter`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.cmp_func !== undefined) {
        callbackDispatcher.set(data.cmp_func.toString(), {
          converter: convertGLibSequenceIterCompareFuncArgs,
          userFunction: cmp_func
        });
      }
    return data.cmp_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async foreach_range(begin: GLibSequenceIter, end: GLibSequenceIter, func: GLibFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/foreach_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get(iter: GLibSequenceIter): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/get`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async insert_before(iter: GLibSequenceIter, data_?: Pointer): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/insert_before`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async move(src: GLibSequenceIter, dest: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/move`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async move_range(dest: GLibSequenceIter, begin: GLibSequenceIter, end: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/move_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async range_get_midpoint(begin: GLibSequenceIter, end: GLibSequenceIter): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/range_get_midpoint`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove(iter: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async remove_range(begin: GLibSequenceIter, end: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/remove_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async set(iter: GLibSequenceIter, data_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/set`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async sort_changed(iter: GLibSequenceIter, cmp_func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/sort_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.cmp_func !== undefined) {
        callbackDispatcher.set(data.cmp_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: cmp_func
        });
      }
    return data.cmp_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async sort_changed_iter(iter: GLibSequenceIter, iter_cmp: GLibSequenceIterCompareFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/sort_changed_iter`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.iter_cmp !== undefined) {
        callbackDispatcher.set(data.iter_cmp.toString(), {
          converter: convertGLibSequenceIterCompareFuncArgs,
          userFunction: iter_cmp
        });
      }
    return data.iter_cmp;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async swap(a: GLibSequenceIter, b: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Sequence/swap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (a && typeof a === 'object' && 'ptr' in a) {
      url.searchParams.append('a', 'ptr,' + a.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (b && typeof b === 'object' && 'ptr' in b) {
      url.searchParams.append('b', 'ptr,' + b.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibSequenceIter
const glibsequenceiterRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/SequenceIter/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibSequenceIter:', ptr, err));
});

export class GLibSequenceIter {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibsequenceiterRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async compare(b: GLibSequenceIter): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (b && typeof b === 'object' && 'ptr' in b) {
      url.searchParams.append('b', 'ptr,' + b.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_position(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/get_position`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_sequence(): Promise<GLibSequence> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/get_sequence`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequence(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_begin(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/is_begin`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_end(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/is_end`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async move(delta: number): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/move`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('delta', String(delta));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async next(): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async prev(): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/SequenceIter/ptr,${this.ptr}/prev`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibShellError = "bad_quoting" | "empty_string" | "failed";

  export type GLibSliceConfig = "always_malloc" | "bypass_magazines" | "working_set_msecs" | "color_increment" | "chunk_sizes" | "contention_counter";

  export type GLibSpawnError = "fork" | "read" | "chdir" | "acces" | "perm" | "too_big" | "2big" | "noexec" | "nametoolong" | "noent" | "nomem" | "notdir" | "loop" | "txtbusy" | "io" | "nfile" | "mfile" | "inval" | "isdir" | "libbad" | "failed";

  export type GLibSpawnFlags = "default" | "leave_descriptors_open" | "do_not_reap_child" | "search_path" | "stdout_to_dev_null" | "stderr_to_dev_null" | "child_inherits_stdin" | "file_and_argv_zero" | "search_path_from_envp" | "cloexec_pipes" | "child_inherits_stdout" | "child_inherits_stderr" | "stdin_from_dev_null";

  
// Finalization registry for GLibStatBuf
const glibstatbufRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/StatBuf/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibStatBuf:', ptr, err));
});

export class GLibStatBuf {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibstatbufRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GLibStringChunk
const glibstringchunkRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/StringChunk/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibStringChunk:', ptr, err));
});

export class GLibStringChunk {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibstringchunkRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibStringChunk> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibStringChunk(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async clear(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert(string: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_const(string: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/insert_const`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_len(string: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StringChunk/ptr,${this.ptr}/insert_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibStrvBuilder
const glibstrvbuilderRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/StrvBuilder/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibStrvBuilder:', ptr, err));
});

export class GLibStrvBuilder {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibstrvbuilderRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibStrvBuilder> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibStrvBuilder(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async addv(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/addv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async end(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/end`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibStrvBuilder> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibStrvBuilder(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async take(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/take`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/StrvBuilder/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibTestCase
const glibtestcaseRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TestCase/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTestCase:', ptr, err));
});

export class GLibTestCase {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtestcaseRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibTestCase> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestCase/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTestCase(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestCase/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


}
  
// Finalization registry for GLibTestConfig
const glibtestconfigRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TestConfig/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTestConfig:', ptr, err));
});

export class GLibTestConfig {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtestconfigRegistry.register(this, ptr);
  }


}
  export type GLibTestFileType = "dist" | "built";

  
// Finalization registry for GLibTestLogBuffer
const glibtestlogbufferRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TestLogBuffer/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTestLogBuffer:', ptr, err));
});

export class GLibTestLogBuffer {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtestlogbufferRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibTestLogBuffer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogBuffer/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTestLogBuffer(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogBuffer/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async push(n_bytes: number, bytes: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogBuffer/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    // Primitive parameter
    url.searchParams.append('bytes', String(bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<GLibString | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogBuffer/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibString(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_msgs(): Promise<GLibSList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogBuffer/ptr,${this.ptr}/fields/msgs`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibTestLogMsg
const glibtestlogmsgRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TestLogMsg/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTestLogMsg:', ptr, err));
});

export class GLibTestLogMsg {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtestlogmsgRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibTestLogMsg> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTestLogMsg(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_log_type(): Promise<GLibTestLogType | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/log_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_log_type(value_: GLibTestLogType): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/log_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_strings(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/n_strings`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_n_strings(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/n_strings`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_strings(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/strings`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_strings(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/strings`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_nums(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/n_nums`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_n_nums(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/n_nums`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_nums(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/nums`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_nums(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestLogMsg/ptr,${this.ptr}/fields/nums`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibTestLogType = "none" | "error" | "start_binary" | "list_case" | "skip_case" | "start_case" | "stop_case" | "min_result" | "max_result" | "message" | "start_suite" | "stop_suite";

  export type GLibTestResult = "success" | "skipped" | "failure" | "incomplete";

  export type GLibTestSubprocessFlags = "default" | "inherit_stdin" | "inherit_stdout" | "inherit_stderr";

  
// Finalization registry for GLibTestSuite
const glibtestsuiteRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TestSuite/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTestSuite:', ptr, err));
});

export class GLibTestSuite {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtestsuiteRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibTestSuite> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestSuite/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTestSuite(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestSuite/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add(test_case: GLibTestCase): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestSuite/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (test_case && typeof test_case === 'object' && 'ptr' in test_case) {
      url.searchParams.append('test_case', 'ptr,' + test_case.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_suite(nestedsuite: GLibTestSuite): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TestSuite/ptr,${this.ptr}/add_suite`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (nestedsuite && typeof nestedsuite === 'object' && 'ptr' in nestedsuite) {
      url.searchParams.append('nestedsuite', 'ptr,' + nestedsuite.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibTestTrapFlags = "default" | "silence_stdout" | "silence_stderr" | "inherit_stdin";

  export type GLibThreadFunc = (data_: Pointer) => Pointer;

export function convertGLibThreadFuncArgs(data: any): Parameters<GLibThreadFunc> {
  return [
    data.data  ];
}
  
// Finalization registry for GLibThread
const glibthreadRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Thread/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibThread:', ptr, err));
});

export class GLibThread {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibthreadRegistry.register(this, ptr);
  }
    





 
  static async new(func: GLibThreadFunc, name?: string): Promise<{func: number, return: GLibThread}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibThreadFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibThread(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async try_new(func: GLibThreadFunc, name?: string): Promise<{func: number, return: GLibThread}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/try_new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibThreadFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibThread(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async join(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibThread> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibThread(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async exit(retval?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/exit`, apiConfig.baseUrl);
    // Primitive parameter
    if (retval !== undefined) url.searchParams.append('retval', String(retval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async self(): Promise<GLibThread> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/self`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibThread(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async yield_(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/yield`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_func(): Promise<GLibThreadFunc | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/fields/func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_joinable(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/fields/joinable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_priority(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/ptr,${this.ptr}/fields/priority`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Thread/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibThreadError = "thread_error_again";

  
// Finalization registry for GLibThreadPool
const glibthreadpoolRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/ThreadPool/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibThreadPool:', ptr, err));
});

export class GLibThreadPool {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibthreadpoolRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibThreadPool> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibThreadPool(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(immediate: boolean, wait_: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('immediate', String(immediate));
    // Primitive parameter
    url.searchParams.append('wait_', String(wait_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_max_threads(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/get_max_threads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_num_threads(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/get_num_threads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async move_to_front(data_?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/move_to_front`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push(data_?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_max_threads(max_threads: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/set_max_threads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_threads', String(max_threads));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unprocessed(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/unprocessed`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_max_idle_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/get_max_idle_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_max_unused_threads(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/get_max_unused_threads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_num_unused_threads(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/get_num_unused_threads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async set_max_idle_time(interval: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/set_max_idle_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async set_max_unused_threads(max_threads: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/set_max_unused_threads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_threads', String(max_threads));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async stop_unused_threads(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/stop_unused_threads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_func(): Promise<GLibFunc | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/fields/func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_func(value_: GLibFunc): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/fields/func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_user_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/fields/user_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_user_data(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/fields/user_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_exclusive(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/fields/exclusive`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_exclusive(value_: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ThreadPool/ptr,${this.ptr}/fields/exclusive`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibTimer
const glibtimerRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Timer/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTimer:', ptr, err));
});

export class GLibTimer {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtimerRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibTimer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTimer(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async continue_(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/continue`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async destroy(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async elapsed(microseconds: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/elapsed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('microseconds', String(microseconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_active(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/is_active`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reset(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/reset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async start(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async stop(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Timer/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibTrashStack
const glibtrashstackRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TrashStack/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTrashStack:', ptr, err));
});

export class GLibTrashStack {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtrashstackRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibTrashStack> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTrashStack(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  static async height(stack_p: GLibTrashStack): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/height`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async peek(stack_p: GLibTrashStack): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/peek`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async pop(stack_p: GLibTrashStack): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/pop`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async push(stack_p: GLibTrashStack, data_p: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data_p', String(data_p));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next(): Promise<GLibTrashStack | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTrashStack(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_next(value_: GLibTrashStack): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TrashStack/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibTraverseFunc = (key: Pointer, value_: Pointer, data_: Pointer) => boolean;

export function convertGLibTraverseFuncArgs(data: any): Parameters<GLibTraverseFunc> {
  return [
    data.key,
    data.value,
    data.data  ];
}
  export type GLibTraverseNodeFunc = (node: GLibTreeNode, data_: Pointer) => boolean;

export function convertGLibTraverseNodeFuncArgs(data: any): Parameters<GLibTraverseNodeFunc> {
  return [
    new GLibTreeNode(data.node, 'none'),
    data.data  ];
}
  
// Finalization registry for GLibTree
const glibtreeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Tree/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTree:', ptr, err));
});

export class GLibTree {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtreeRegistry.register(this, ptr);
  }
    





 
  static async new_full(key_compare_func: GLibCompareDataFunc, key_destroy_func: GLibDestroyNotify): Promise<{key_compare_func: number, key_destroy_func: number, return: GLibTree}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/new_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.key_compare_func !== undefined) {
        callbackDispatcher.set(data.key_compare_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: key_compare_func
        });
      }
      if (data.key_destroy_func !== undefined) {
        callbackDispatcher.set(data.key_destroy_func.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: key_destroy_func
        });
      }
        const result: any = {};
      // Handle return parameter: key_compare_func
      result.key_compare_func = (() => {
        return data.key_compare_func;

      })();
      // Handle return parameter: key_destroy_func
      result.key_destroy_func = (() => {
        return data.key_destroy_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibTree(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async destroy(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach(func: GLibTraverseFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibTraverseFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach_node(func: GLibTraverseNodeFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/foreach_node`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibTraverseNodeFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async height(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/height`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert(key?: Pointer, value_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_node(key?: Pointer, value_?: Pointer): Promise<GLibTreeNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/insert_node`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lookup(key?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/lookup`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lookup_extended(lookup_key?: Pointer): Promise<{orig_key: Pointer, value: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/lookup_extended`, apiConfig.baseUrl);
    // Primitive parameter
    if (lookup_key !== undefined) url.searchParams.append('lookup_key', String(lookup_key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: orig_key
      result.orig_key = (() => {
        return data.orig_key;

      })();
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lookup_node(key?: Pointer): Promise<GLibTreeNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/lookup_node`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lower_bound(key?: Pointer): Promise<GLibTreeNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/lower_bound`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async nnodes(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/nnodes`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async node_first(): Promise<GLibTreeNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/node_first`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async node_last(): Promise<GLibTreeNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/node_last`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibTree> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTree(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_all(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/remove_all`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace(key?: Pointer, value_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/replace`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace_node(key?: Pointer, value_?: Pointer): Promise<GLibTreeNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/replace_node`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async search(search_func: GLibCompareFunc): Promise<{search_func: number, return: Pointer | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/search`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.search_func !== undefined) {
        callbackDispatcher.set(data.search_func.toString(), {
          converter: convertGLibCompareFuncArgs,
          userFunction: search_func
        });
      }
        const result: any = {};
      // Handle return parameter: search_func
      result.search_func = (() => {
        return data.search_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async search_node(search_func: GLibCompareFunc): Promise<{search_func: number, return: GLibTreeNode | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/search_node`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.search_func !== undefined) {
        callbackDispatcher.set(data.search_func.toString(), {
          converter: convertGLibCompareFuncArgs,
          userFunction: search_func
        });
      }
        const result: any = {};
      // Handle return parameter: search_func
      result.search_func = (() => {
        return data.search_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibTreeNode(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async steal(key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/steal`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async traverse(traverse_type: GLibTraverseType, traverse_func: GLibTraverseFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/traverse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('traverse_type', String(traverse_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.traverse_func !== undefined) {
        callbackDispatcher.set(data.traverse_func.toString(), {
          converter: convertGLibTraverseFuncArgs,
          userFunction: traverse_func
        });
      }
    return data.traverse_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async upper_bound(key?: Pointer): Promise<GLibTreeNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/ptr,${this.ptr}/upper_bound`, apiConfig.baseUrl);
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tree/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibTreeNode
const glibtreenodeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/TreeNode/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTreeNode:', ptr, err));
});

export class GLibTreeNode {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtreenodeRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibTreeNode> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async key(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/key`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async next(): Promise<GLibTreeNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async previous(): Promise<GLibTreeNode | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/previous`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTreeNode(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async value_(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/TreeNode/ptr,${this.ptr}/value`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibTuples
const glibtuplesRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Tuples/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibTuples:', ptr, err));
});

export class GLibTuples {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibtuplesRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibTuples> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibTuples(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async destroy(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async index(index_: number, field: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/ptr,${this.ptr}/index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    // Primitive parameter
    url.searchParams.append('field', String(field));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_len(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/ptr,${this.ptr}/fields/len`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_len(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Tuples/ptr,${this.ptr}/fields/len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GLibUnicodeBreakType {
  export const MANDATORY: 'mandatory' = 'mandatory';
  export const CARRIAGE_RETURN: 'carriage_return' = 'carriage_return';
  export const LINE_FEED: 'line_feed' = 'line_feed';
  export const COMBINING_MARK: 'combining_mark' = 'combining_mark';
  export const SURROGATE: 'surrogate' = 'surrogate';
  export const ZERO_WIDTH_SPACE: 'zero_width_space' = 'zero_width_space';
  export const INSEPARABLE: 'inseparable' = 'inseparable';
  export const NON_BREAKING_GLUE: 'non_breaking_glue' = 'non_breaking_glue';
  export const CONTINGENT: 'contingent' = 'contingent';
  export const SPACE: 'space' = 'space';
  export const AFTER: 'after' = 'after';
  export const BEFORE: 'before' = 'before';
  export const BEFORE_AND_AFTER: 'before_and_after' = 'before_and_after';
  export const HYPHEN: 'hyphen' = 'hyphen';
  export const NON_STARTER: 'non_starter' = 'non_starter';
  export const OPEN_PUNCTUATION: 'open_punctuation' = 'open_punctuation';
  export const CLOSE_PUNCTUATION: 'close_punctuation' = 'close_punctuation';
  export const QUOTATION: 'quotation' = 'quotation';
  export const EXCLAMATION: 'exclamation' = 'exclamation';
  export const IDEOGRAPHIC: 'ideographic' = 'ideographic';
  export const NUMERIC: 'numeric' = 'numeric';
  export const INFIX_SEPARATOR: 'infix_separator' = 'infix_separator';
  export const SYMBOL: 'symbol' = 'symbol';
  export const ALPHABETIC: 'alphabetic' = 'alphabetic';
  export const PREFIX: 'prefix' = 'prefix';
  export const POSTFIX: 'postfix' = 'postfix';
  export const COMPLEX_CONTEXT: 'complex_context' = 'complex_context';
  export const AMBIGUOUS: 'ambiguous' = 'ambiguous';
  export const UNKNOWN: 'unknown' = 'unknown';
  export const NEXT_LINE: 'next_line' = 'next_line';
  export const WORD_JOINER: 'word_joiner' = 'word_joiner';
  export const HANGUL_L_JAMO: 'hangul_l_jamo' = 'hangul_l_jamo';
  export const HANGUL_V_JAMO: 'hangul_v_jamo' = 'hangul_v_jamo';
  export const HANGUL_T_JAMO: 'hangul_t_jamo' = 'hangul_t_jamo';
  export const HANGUL_LV_SYLLABLE: 'hangul_lv_syllable' = 'hangul_lv_syllable';
  export const HANGUL_LVT_SYLLABLE: 'hangul_lvt_syllable' = 'hangul_lvt_syllable';
  export const CLOSE_PARANTHESIS: 'close_paranthesis' = 'close_paranthesis';
  export const CLOSE_PARENTHESIS: 'close_parenthesis' = 'close_parenthesis';
  export const CONDITIONAL_JAPANESE_STARTER: 'conditional_japanese_starter' = 'conditional_japanese_starter';
  export const HEBREW_LETTER: 'hebrew_letter' = 'hebrew_letter';
  export const REGIONAL_INDICATOR: 'regional_indicator' = 'regional_indicator';
  export const EMOJI_BASE: 'emoji_base' = 'emoji_base';
  export const EMOJI_MODIFIER: 'emoji_modifier' = 'emoji_modifier';
  export const ZERO_WIDTH_JOINER: 'zero_width_joiner' = 'zero_width_joiner';
  export const AKSARA: 'aksara' = 'aksara';
  export const AKSARA_PRE_BASE: 'aksara_pre_base' = 'aksara_pre_base';
  export const AKSARA_START: 'aksara_start' = 'aksara_start';
  export const VIRAMA_FINAL: 'virama_final' = 'virama_final';
  export const VIRAMA: 'virama' = 'virama';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeBreakType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GLibUnicodeBreakTypeValue = "mandatory" | "carriage_return" | "line_feed" | "combining_mark" | "surrogate" | "zero_width_space" | "inseparable" | "non_breaking_glue" | "contingent" | "space" | "after" | "before" | "before_and_after" | "hyphen" | "non_starter" | "open_punctuation" | "close_punctuation" | "quotation" | "exclamation" | "ideographic" | "numeric" | "infix_separator" | "symbol" | "alphabetic" | "prefix" | "postfix" | "complex_context" | "ambiguous" | "unknown" | "next_line" | "word_joiner" | "hangul_l_jamo" | "hangul_v_jamo" | "hangul_t_jamo" | "hangul_lv_syllable" | "hangul_lvt_syllable" | "close_paranthesis" | "close_parenthesis" | "conditional_japanese_starter" | "hebrew_letter" | "regional_indicator" | "emoji_base" | "emoji_modifier" | "zero_width_joiner" | "aksara" | "aksara_pre_base" | "aksara_start" | "virama_final" | "virama";

  export namespace GLibUnicodeScript {
  export const INVALID_CODE: 'invalid_code' = 'invalid_code';
  export const COMMON: 'common' = 'common';
  export const INHERITED: 'inherited' = 'inherited';
  export const ARABIC: 'arabic' = 'arabic';
  export const ARMENIAN: 'armenian' = 'armenian';
  export const BENGALI: 'bengali' = 'bengali';
  export const BOPOMOFO: 'bopomofo' = 'bopomofo';
  export const CHEROKEE: 'cherokee' = 'cherokee';
  export const COPTIC: 'coptic' = 'coptic';
  export const CYRILLIC: 'cyrillic' = 'cyrillic';
  export const DESERET: 'deseret' = 'deseret';
  export const DEVANAGARI: 'devanagari' = 'devanagari';
  export const ETHIOPIC: 'ethiopic' = 'ethiopic';
  export const GEORGIAN: 'georgian' = 'georgian';
  export const GOTHIC: 'gothic' = 'gothic';
  export const GREEK: 'greek' = 'greek';
  export const GUJARATI: 'gujarati' = 'gujarati';
  export const GURMUKHI: 'gurmukhi' = 'gurmukhi';
  export const HAN: 'han' = 'han';
  export const HANGUL: 'hangul' = 'hangul';
  export const HEBREW: 'hebrew' = 'hebrew';
  export const HIRAGANA: 'hiragana' = 'hiragana';
  export const KANNADA: 'kannada' = 'kannada';
  export const KATAKANA: 'katakana' = 'katakana';
  export const KHMER: 'khmer' = 'khmer';
  export const LAO: 'lao' = 'lao';
  export const LATIN: 'latin' = 'latin';
  export const MALAYALAM: 'malayalam' = 'malayalam';
  export const MONGOLIAN: 'mongolian' = 'mongolian';
  export const MYANMAR: 'myanmar' = 'myanmar';
  export const OGHAM: 'ogham' = 'ogham';
  export const OLD_ITALIC: 'old_italic' = 'old_italic';
  export const ORIYA: 'oriya' = 'oriya';
  export const RUNIC: 'runic' = 'runic';
  export const SINHALA: 'sinhala' = 'sinhala';
  export const SYRIAC: 'syriac' = 'syriac';
  export const TAMIL: 'tamil' = 'tamil';
  export const TELUGU: 'telugu' = 'telugu';
  export const THAANA: 'thaana' = 'thaana';
  export const THAI: 'thai' = 'thai';
  export const TIBETAN: 'tibetan' = 'tibetan';
  export const CANADIAN_ABORIGINAL: 'canadian_aboriginal' = 'canadian_aboriginal';
  export const YI: 'yi' = 'yi';
  export const TAGALOG: 'tagalog' = 'tagalog';
  export const HANUNOO: 'hanunoo' = 'hanunoo';
  export const BUHID: 'buhid' = 'buhid';
  export const TAGBANWA: 'tagbanwa' = 'tagbanwa';
  export const BRAILLE: 'braille' = 'braille';
  export const CYPRIOT: 'cypriot' = 'cypriot';
  export const LIMBU: 'limbu' = 'limbu';
  export const OSMANYA: 'osmanya' = 'osmanya';
  export const SHAVIAN: 'shavian' = 'shavian';
  export const LINEAR_B: 'linear_b' = 'linear_b';
  export const TAI_LE: 'tai_le' = 'tai_le';
  export const UGARITIC: 'ugaritic' = 'ugaritic';
  export const NEW_TAI_LUE: 'new_tai_lue' = 'new_tai_lue';
  export const BUGINESE: 'buginese' = 'buginese';
  export const GLAGOLITIC: 'glagolitic' = 'glagolitic';
  export const TIFINAGH: 'tifinagh' = 'tifinagh';
  export const SYLOTI_NAGRI: 'syloti_nagri' = 'syloti_nagri';
  export const OLD_PERSIAN: 'old_persian' = 'old_persian';
  export const KHAROSHTHI: 'kharoshthi' = 'kharoshthi';
  export const UNKNOWN: 'unknown' = 'unknown';
  export const BALINESE: 'balinese' = 'balinese';
  export const CUNEIFORM: 'cuneiform' = 'cuneiform';
  export const PHOENICIAN: 'phoenician' = 'phoenician';
  export const PHAGS_PA: 'phags_pa' = 'phags_pa';
  export const NKO: 'nko' = 'nko';
  export const KAYAH_LI: 'kayah_li' = 'kayah_li';
  export const LEPCHA: 'lepcha' = 'lepcha';
  export const REJANG: 'rejang' = 'rejang';
  export const SUNDANESE: 'sundanese' = 'sundanese';
  export const SAURASHTRA: 'saurashtra' = 'saurashtra';
  export const CHAM: 'cham' = 'cham';
  export const OL_CHIKI: 'ol_chiki' = 'ol_chiki';
  export const VAI: 'vai' = 'vai';
  export const CARIAN: 'carian' = 'carian';
  export const LYCIAN: 'lycian' = 'lycian';
  export const LYDIAN: 'lydian' = 'lydian';
  export const AVESTAN: 'avestan' = 'avestan';
  export const BAMUM: 'bamum' = 'bamum';
  export const EGYPTIAN_HIEROGLYPHS: 'egyptian_hieroglyphs' = 'egyptian_hieroglyphs';
  export const IMPERIAL_ARAMAIC: 'imperial_aramaic' = 'imperial_aramaic';
  export const INSCRIPTIONAL_PAHLAVI: 'inscriptional_pahlavi' = 'inscriptional_pahlavi';
  export const INSCRIPTIONAL_PARTHIAN: 'inscriptional_parthian' = 'inscriptional_parthian';
  export const JAVANESE: 'javanese' = 'javanese';
  export const KAITHI: 'kaithi' = 'kaithi';
  export const LISU: 'lisu' = 'lisu';
  export const MEETEI_MAYEK: 'meetei_mayek' = 'meetei_mayek';
  export const OLD_SOUTH_ARABIAN: 'old_south_arabian' = 'old_south_arabian';
  export const OLD_TURKIC: 'old_turkic' = 'old_turkic';
  export const SAMARITAN: 'samaritan' = 'samaritan';
  export const TAI_THAM: 'tai_tham' = 'tai_tham';
  export const TAI_VIET: 'tai_viet' = 'tai_viet';
  export const BATAK: 'batak' = 'batak';
  export const BRAHMI: 'brahmi' = 'brahmi';
  export const MANDAIC: 'mandaic' = 'mandaic';
  export const CHAKMA: 'chakma' = 'chakma';
  export const MEROITIC_CURSIVE: 'meroitic_cursive' = 'meroitic_cursive';
  export const MEROITIC_HIEROGLYPHS: 'meroitic_hieroglyphs' = 'meroitic_hieroglyphs';
  export const MIAO: 'miao' = 'miao';
  export const SHARADA: 'sharada' = 'sharada';
  export const SORA_SOMPENG: 'sora_sompeng' = 'sora_sompeng';
  export const TAKRI: 'takri' = 'takri';
  export const BASSA_VAH: 'bassa_vah' = 'bassa_vah';
  export const CAUCASIAN_ALBANIAN: 'caucasian_albanian' = 'caucasian_albanian';
  export const DUPLOYAN: 'duployan' = 'duployan';
  export const ELBASAN: 'elbasan' = 'elbasan';
  export const GRANTHA: 'grantha' = 'grantha';
  export const KHOJKI: 'khojki' = 'khojki';
  export const KHUDAWADI: 'khudawadi' = 'khudawadi';
  export const LINEAR_A: 'linear_a' = 'linear_a';
  export const MAHAJANI: 'mahajani' = 'mahajani';
  export const MANICHAEAN: 'manichaean' = 'manichaean';
  export const MENDE_KIKAKUI: 'mende_kikakui' = 'mende_kikakui';
  export const MODI: 'modi' = 'modi';
  export const MRO: 'mro' = 'mro';
  export const NABATAEAN: 'nabataean' = 'nabataean';
  export const OLD_NORTH_ARABIAN: 'old_north_arabian' = 'old_north_arabian';
  export const OLD_PERMIC: 'old_permic' = 'old_permic';
  export const PAHAWH_HMONG: 'pahawh_hmong' = 'pahawh_hmong';
  export const PALMYRENE: 'palmyrene' = 'palmyrene';
  export const PAU_CIN_HAU: 'pau_cin_hau' = 'pau_cin_hau';
  export const PSALTER_PAHLAVI: 'psalter_pahlavi' = 'psalter_pahlavi';
  export const SIDDHAM: 'siddham' = 'siddham';
  export const TIRHUTA: 'tirhuta' = 'tirhuta';
  export const WARANG_CITI: 'warang_citi' = 'warang_citi';
  export const AHOM: 'ahom' = 'ahom';
  export const ANATOLIAN_HIEROGLYPHS: 'anatolian_hieroglyphs' = 'anatolian_hieroglyphs';
  export const HATRAN: 'hatran' = 'hatran';
  export const MULTANI: 'multani' = 'multani';
  export const OLD_HUNGARIAN: 'old_hungarian' = 'old_hungarian';
  export const SIGNWRITING: 'signwriting' = 'signwriting';
  export const ADLAM: 'adlam' = 'adlam';
  export const BHAIKSUKI: 'bhaiksuki' = 'bhaiksuki';
  export const MARCHEN: 'marchen' = 'marchen';
  export const NEWA: 'newa' = 'newa';
  export const OSAGE: 'osage' = 'osage';
  export const TANGUT: 'tangut' = 'tangut';
  export const MASARAM_GONDI: 'masaram_gondi' = 'masaram_gondi';
  export const NUSHU: 'nushu' = 'nushu';
  export const SOYOMBO: 'soyombo' = 'soyombo';
  export const ZANABAZAR_SQUARE: 'zanabazar_square' = 'zanabazar_square';
  export const DOGRA: 'dogra' = 'dogra';
  export const GUNJALA_GONDI: 'gunjala_gondi' = 'gunjala_gondi';
  export const HANIFI_ROHINGYA: 'hanifi_rohingya' = 'hanifi_rohingya';
  export const MAKASAR: 'makasar' = 'makasar';
  export const MEDEFAIDRIN: 'medefaidrin' = 'medefaidrin';
  export const OLD_SOGDIAN: 'old_sogdian' = 'old_sogdian';
  export const SOGDIAN: 'sogdian' = 'sogdian';
  export const ELYMAIC: 'elymaic' = 'elymaic';
  export const NANDINAGARI: 'nandinagari' = 'nandinagari';
  export const NYIAKENG_PUACHUE_HMONG: 'nyiakeng_puachue_hmong' = 'nyiakeng_puachue_hmong';
  export const WANCHO: 'wancho' = 'wancho';
  export const CHORASMIAN: 'chorasmian' = 'chorasmian';
  export const DIVES_AKURU: 'dives_akuru' = 'dives_akuru';
  export const KHITAN_SMALL_SCRIPT: 'khitan_small_script' = 'khitan_small_script';
  export const YEZIDI: 'yezidi' = 'yezidi';
  export const CYPRO_MINOAN: 'cypro_minoan' = 'cypro_minoan';
  export const OLD_UYGHUR: 'old_uyghur' = 'old_uyghur';
  export const TANGSA: 'tangsa' = 'tangsa';
  export const TOTO: 'toto' = 'toto';
  export const VITHKUQI: 'vithkuqi' = 'vithkuqi';
  export const MATH: 'math' = 'math';
  export const KAWI: 'kawi' = 'kawi';
  export const NAG_MUNDARI: 'nag_mundari' = 'nag_mundari';
    





 
  export async function from_iso15924(iso15924: number): Promise<GLibUnicodeScriptValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeScript/from_iso15924`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iso15924', String(iso15924));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function to_iso15924(script: GLibUnicodeScriptValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeScript/to_iso15924`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('script', String(script));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeScript/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GLibUnicodeScriptValue = "invalid_code" | "common" | "inherited" | "arabic" | "armenian" | "bengali" | "bopomofo" | "cherokee" | "coptic" | "cyrillic" | "deseret" | "devanagari" | "ethiopic" | "georgian" | "gothic" | "greek" | "gujarati" | "gurmukhi" | "han" | "hangul" | "hebrew" | "hiragana" | "kannada" | "katakana" | "khmer" | "lao" | "latin" | "malayalam" | "mongolian" | "myanmar" | "ogham" | "old_italic" | "oriya" | "runic" | "sinhala" | "syriac" | "tamil" | "telugu" | "thaana" | "thai" | "tibetan" | "canadian_aboriginal" | "yi" | "tagalog" | "hanunoo" | "buhid" | "tagbanwa" | "braille" | "cypriot" | "limbu" | "osmanya" | "shavian" | "linear_b" | "tai_le" | "ugaritic" | "new_tai_lue" | "buginese" | "glagolitic" | "tifinagh" | "syloti_nagri" | "old_persian" | "kharoshthi" | "unknown" | "balinese" | "cuneiform" | "phoenician" | "phags_pa" | "nko" | "kayah_li" | "lepcha" | "rejang" | "sundanese" | "saurashtra" | "cham" | "ol_chiki" | "vai" | "carian" | "lycian" | "lydian" | "avestan" | "bamum" | "egyptian_hieroglyphs" | "imperial_aramaic" | "inscriptional_pahlavi" | "inscriptional_parthian" | "javanese" | "kaithi" | "lisu" | "meetei_mayek" | "old_south_arabian" | "old_turkic" | "samaritan" | "tai_tham" | "tai_viet" | "batak" | "brahmi" | "mandaic" | "chakma" | "meroitic_cursive" | "meroitic_hieroglyphs" | "miao" | "sharada" | "sora_sompeng" | "takri" | "bassa_vah" | "caucasian_albanian" | "duployan" | "elbasan" | "grantha" | "khojki" | "khudawadi" | "linear_a" | "mahajani" | "manichaean" | "mende_kikakui" | "modi" | "mro" | "nabataean" | "old_north_arabian" | "old_permic" | "pahawh_hmong" | "palmyrene" | "pau_cin_hau" | "psalter_pahlavi" | "siddham" | "tirhuta" | "warang_citi" | "ahom" | "anatolian_hieroglyphs" | "hatran" | "multani" | "old_hungarian" | "signwriting" | "adlam" | "bhaiksuki" | "marchen" | "newa" | "osage" | "tangut" | "masaram_gondi" | "nushu" | "soyombo" | "zanabazar_square" | "dogra" | "gunjala_gondi" | "hanifi_rohingya" | "makasar" | "medefaidrin" | "old_sogdian" | "sogdian" | "elymaic" | "nandinagari" | "nyiakeng_puachue_hmong" | "wancho" | "chorasmian" | "dives_akuru" | "khitan_small_script" | "yezidi" | "cypro_minoan" | "old_uyghur" | "tangsa" | "toto" | "vithkuqi" | "math" | "kawi" | "nag_mundari";

  export namespace GLibUnicodeType {
  export const CONTROL: 'control' = 'control';
  export const FORMAT: 'format' = 'format';
  export const UNASSIGNED: 'unassigned' = 'unassigned';
  export const PRIVATE_USE: 'private_use' = 'private_use';
  export const SURROGATE: 'surrogate' = 'surrogate';
  export const LOWERCASE_LETTER: 'lowercase_letter' = 'lowercase_letter';
  export const MODIFIER_LETTER: 'modifier_letter' = 'modifier_letter';
  export const OTHER_LETTER: 'other_letter' = 'other_letter';
  export const TITLECASE_LETTER: 'titlecase_letter' = 'titlecase_letter';
  export const UPPERCASE_LETTER: 'uppercase_letter' = 'uppercase_letter';
  export const SPACING_MARK: 'spacing_mark' = 'spacing_mark';
  export const ENCLOSING_MARK: 'enclosing_mark' = 'enclosing_mark';
  export const NON_SPACING_MARK: 'non_spacing_mark' = 'non_spacing_mark';
  export const DECIMAL_NUMBER: 'decimal_number' = 'decimal_number';
  export const LETTER_NUMBER: 'letter_number' = 'letter_number';
  export const OTHER_NUMBER: 'other_number' = 'other_number';
  export const CONNECT_PUNCTUATION: 'connect_punctuation' = 'connect_punctuation';
  export const DASH_PUNCTUATION: 'dash_punctuation' = 'dash_punctuation';
  export const CLOSE_PUNCTUATION: 'close_punctuation' = 'close_punctuation';
  export const FINAL_PUNCTUATION: 'final_punctuation' = 'final_punctuation';
  export const INITIAL_PUNCTUATION: 'initial_punctuation' = 'initial_punctuation';
  export const OTHER_PUNCTUATION: 'other_punctuation' = 'other_punctuation';
  export const OPEN_PUNCTUATION: 'open_punctuation' = 'open_punctuation';
  export const CURRENCY_SYMBOL: 'currency_symbol' = 'currency_symbol';
  export const MODIFIER_SYMBOL: 'modifier_symbol' = 'modifier_symbol';
  export const MATH_SYMBOL: 'math_symbol' = 'math_symbol';
  export const OTHER_SYMBOL: 'other_symbol' = 'other_symbol';
  export const LINE_SEPARATOR: 'line_separator' = 'line_separator';
  export const PARAGRAPH_SEPARATOR: 'paragraph_separator' = 'paragraph_separator';
  export const SPACE_SEPARATOR: 'space_separator' = 'space_separator';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UnicodeType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GLibUnicodeTypeValue = "control" | "format" | "unassigned" | "private_use" | "surrogate" | "lowercase_letter" | "modifier_letter" | "other_letter" | "titlecase_letter" | "uppercase_letter" | "spacing_mark" | "enclosing_mark" | "non_spacing_mark" | "decimal_number" | "letter_number" | "other_number" | "connect_punctuation" | "dash_punctuation" | "close_punctuation" | "final_punctuation" | "initial_punctuation" | "other_punctuation" | "open_punctuation" | "currency_symbol" | "modifier_symbol" | "math_symbol" | "other_symbol" | "line_separator" | "paragraph_separator" | "space_separator";

  
// Finalization registry for GLibUnixPipe
const glibunixpipeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/UnixPipe/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibUnixPipe:', ptr, err));
});

export class GLibUnixPipe {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibunixpipeRegistry.register(this, ptr);
  }


}
  export type GLibUnixPipeEnd = "read" | "write";

  
// Finalization registry for GLibUri
const gliburiRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/Uri/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibUri:', ptr, err));
});

export class GLibUri {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gliburiRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibUri(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_auth_params(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_auth_params`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<GLibUriFlags> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_fragment(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_fragment`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_host(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_host`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_password(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_password`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_path(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_path`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_port(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_port`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_query(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_query`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_scheme(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_scheme`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_user(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_user`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_userinfo(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/get_userinfo`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_relative(uri_ref: string, flags: GLibUriFlags): Promise<GLibUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/parse_relative`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_string_partial(flags: GLibUriHideFlags): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/ptr,${this.ptr}/to_string_partial`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async build(flags: GLibUriFlags, scheme: string, port: number, path: string, userinfo?: string, host?: string, query?: string, fragment?: string): Promise<GLibUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/build`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async build_with_user(flags: GLibUriFlags, scheme: string, port: number, path: string, user?: string, password?: string, auth_params?: string, host?: string, query?: string, fragment?: string): Promise<GLibUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/build_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (user !== undefined) url.searchParams.append('user', String(user));
    // Primitive parameter
    if (password !== undefined) url.searchParams.append('password', String(password));
    // Primitive parameter
    if (auth_params !== undefined) url.searchParams.append('auth_params', String(auth_params));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async escape_bytes(unescaped: Pointer, length: number, reserved_chars_allowed?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/escape_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    if (reserved_chars_allowed !== undefined) url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async escape_string(unescaped: string, allow_utf8: boolean, reserved_chars_allowed?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/escape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    if (reserved_chars_allowed !== undefined) url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    // Primitive parameter
    url.searchParams.append('allow_utf8', String(allow_utf8));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async is_valid(uri_string: string, flags: GLibUriFlags): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async join(flags: GLibUriFlags, port: number, path: string, scheme?: string, userinfo?: string, host?: string, query?: string, fragment?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/join`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async join_with_user(flags: GLibUriFlags, port: number, path: string, scheme?: string, user?: string, password?: string, auth_params?: string, host?: string, query?: string, fragment?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/join_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (user !== undefined) url.searchParams.append('user', String(user));
    // Primitive parameter
    if (password !== undefined) url.searchParams.append('password', String(password));
    // Primitive parameter
    if (auth_params !== undefined) url.searchParams.append('auth_params', String(auth_params));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async list_extract_uris(uri_list: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/list_extract_uris`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_list', String(uri_list));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async parse(uri_string: string, flags: GLibUriFlags): Promise<GLibUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async parse_params(params: string, length: number, separators: string, flags: GLibUriParamsFlags): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/parse_params`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('params', String(params));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('separators', String(separators));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async parse_scheme(uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/parse_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async peek_scheme(uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/peek_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async resolve_relative(uri_ref: string, flags: GLibUriFlags, base_uri_string?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/resolve_relative`, apiConfig.baseUrl);
    // Primitive parameter
    if (base_uri_string !== undefined) url.searchParams.append('base_uri_string', String(base_uri_string));
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async split(uri_ref: string, flags: GLibUriFlags): Promise<{scheme: string, userinfo: string, host: string, port: number, path: string, query: string, fragment: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/split`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: scheme
      result.scheme = (() => {
        return data.scheme;

      })();
      // Handle return parameter: userinfo
      result.userinfo = (() => {
        return data.userinfo;

      })();
      // Handle return parameter: host
      result.host = (() => {
        return data.host;

      })();
      // Handle return parameter: port
      result.port = (() => {
        return data.port;

      })();
      // Handle return parameter: path
      result.path = (() => {
        return data.path;

      })();
      // Handle return parameter: query
      result.query = (() => {
        return data.query;

      })();
      // Handle return parameter: fragment
      result.fragment = (() => {
        return data.fragment;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async split_network(uri_string: string, flags: GLibUriFlags): Promise<{scheme: string, host: string, port: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/split_network`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: scheme
      result.scheme = (() => {
        return data.scheme;

      })();
      // Handle return parameter: host
      result.host = (() => {
        return data.host;

      })();
      // Handle return parameter: port
      result.port = (() => {
        return data.port;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async split_with_user(uri_ref: string, flags: GLibUriFlags): Promise<{scheme: string, user: string, password: string, auth_params: string, host: string, port: number, path: string, query: string, fragment: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/split_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: scheme
      result.scheme = (() => {
        return data.scheme;

      })();
      // Handle return parameter: user
      result.user = (() => {
        return data.user;

      })();
      // Handle return parameter: password
      result.password = (() => {
        return data.password;

      })();
      // Handle return parameter: auth_params
      result.auth_params = (() => {
        return data.auth_params;

      })();
      // Handle return parameter: host
      result.host = (() => {
        return data.host;

      })();
      // Handle return parameter: port
      result.port = (() => {
        return data.port;

      })();
      // Handle return parameter: path
      result.path = (() => {
        return data.path;

      })();
      // Handle return parameter: query
      result.query = (() => {
        return data.query;

      })();
      // Handle return parameter: fragment
      result.fragment = (() => {
        return data.fragment;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async unescape_bytes(escaped_string: string, length: number, illegal_characters?: string): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/unescape_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async unescape_segment(escaped_string?: string, escaped_string_end?: string, illegal_characters?: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/unescape_segment`, apiConfig.baseUrl);
    // Primitive parameter
    if (escaped_string !== undefined) url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    if (escaped_string_end !== undefined) url.searchParams.append('escaped_string_end', String(escaped_string_end));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async unescape_string(escaped_string: string, illegal_characters?: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/unescape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/Uri/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibUriFlags = "none" | "parse_relaxed" | "has_password" | "has_auth_params" | "encoded" | "non_dns" | "encoded_query" | "encoded_path" | "encoded_fragment" | "scheme_normalize";

  export type GLibUriHideFlags = "none" | "userinfo" | "password" | "auth_params" | "query" | "fragment";

  export type GLibUriParamsFlags = "none" | "case_insensitive" | "www_form" | "parse_relaxed";

  export type GLibUriError = "failed" | "bad_scheme" | "bad_user" | "bad_password" | "bad_auth_params" | "bad_host" | "bad_port" | "bad_path" | "bad_query" | "bad_fragment";

  
// Finalization registry for GLibUriParamsIter
const gliburiparamsiterRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/UriParamsIter/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibUriParamsIter:', ptr, err));
});

export class GLibUriParamsIter {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gliburiparamsiterRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GLibUriParamsIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibUriParamsIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async init(params: string, length: number, separators: string, flags: GLibUriParamsFlags): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('params', String(params));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('separators', String(separators));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async next(): Promise<{attribute: string, value: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: attribute
      result.attribute = (() => {
        return data.attribute;

      })();
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy0(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/fields/dummy0`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy1(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/fields/dummy1`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy2(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/fields/dummy2`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dummy3(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/UriParamsIter/ptr,${this.ptr}/fields/dummy3`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibUserDirectory = "directory_desktop" | "directory_documents" | "directory_download" | "directory_music" | "directory_pictures" | "directory_public_share" | "directory_templates" | "directory_videos" | "n_directories";

  
// Finalization registry for GLibVariantBuilder
const glibvariantbuilderRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/VariantBuilder/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibVariantBuilder:', ptr, err));
});

export class GLibVariantBuilder {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibvariantbuilderRegistry.register(this, ptr);
  }
    





 
  static async new(type_: GLibVariantType): Promise<GLibVariantBuilder> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantBuilder(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_value(value_: GLibVariant): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/add_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async close(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/close`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async end(): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/end`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async open(type_: GLibVariantType): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/open`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibVariantBuilder> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantBuilder(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantBuilder/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GLibVariantDict
const glibvariantdictRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GLib/VariantDict/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GLibVariantDict:', ptr, err));
});

export class GLibVariantDict {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      glibvariantdictRegistry.register(this, ptr);
  }
    





 
  static async new(from_asv?: GLibVariant): Promise<GLibVariantDict> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (from_asv !== undefined && typeof from_asv === 'object' && 'ptr' in from_asv) {
      url.searchParams.append('from_asv', 'ptr,' + from_asv.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantDict(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async clear(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async contains(key: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async end(): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/end`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_value(key: string, value_: GLibVariant): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/insert_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lookup_value(key: string, expected_type?: GLibVariantType): Promise<GLibVariant | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/lookup_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Object with explode=false: serialize as comma-separated
    if (expected_type !== undefined && typeof expected_type === 'object' && 'ptr' in expected_type) {
      url.searchParams.append('expected_type', 'ptr,' + expected_type.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GLibVariantDict> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantDict(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(key: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/VariantDict/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GLibVariantParseError = "failed" | "basic_type_expected" | "cannot_infer_type" | "definite_type_expected" | "input_not_at_end" | "invalid_character" | "invalid_format_string" | "invalid_object_path" | "invalid_signature" | "invalid_type_string" | "no_common_type" | "number_out_of_range" | "number_too_big" | "type_error" | "unexpected_token" | "unknown_keyword" | "unterminated_string_constant" | "value_expected" | "recursion";

  export type GLibVoidFunc = () => void;

export function convertGLibVoidFuncArgs(data: any): Parameters<GLibVoidFunc> {
  return [
  ];
}
  export type GLibChildWatchFunc = (pid: number, wait_status: number, user_data: Pointer) => void;

export function convertGLibChildWatchFuncArgs(data: any): Parameters<GLibChildWatchFunc> {
  return [
    data.pid,
    data.wait_status,
    data.user_data  ];
}
  export type GLibDataForeachFunc = (key_id: number, data_: Pointer, user_data: Pointer) => void;

export function convertGLibDataForeachFuncArgs(data: any): Parameters<GLibDataForeachFunc> {
  return [
    data.key_id,
    data.data,
    data.user_data  ];
}
  export type GLibIOFunc = (source: GLibIOChannel, condition: GLibIOConditionValue, data_: Pointer) => boolean;

export function convertGLibIOFuncArgs(data: any): Parameters<GLibIOFunc> {
  return [
    new GLibIOChannel(data.source, 'none'),
    data.condition,
    data.data  ];
}
  export type GLibLogFunc = (log_domain: string, log_level: GLibLogLevelFlags, message: string, user_data: Pointer) => void;

export function convertGLibLogFuncArgs(data: any): Parameters<GLibLogFunc> {
  return [
    data.log_domain,
    data.log_level,
    data.message,
    data.user_data  ];
}
  export type GLibSpawnChildSetupFunc = (data_: Pointer) => void;

export function convertGLibSpawnChildSetupFuncArgs(data: any): Parameters<GLibSpawnChildSetupFunc> {
  return [
    data.data  ];
}
  export type GLibTestDataFunc = (user_data: Pointer) => void;

export function convertGLibTestDataFuncArgs(data: any): Parameters<GLibTestDataFunc> {
  return [
    data.user_data  ];
}
  export type GLibTestFunc = () => void;

export function convertGLibTestFuncArgs(data: any): Parameters<GLibTestFunc> {
  return [
  ];
}
  export type GLibUnixFDSourceFunc = (fd: number, condition: GLibIOConditionValue, user_data: Pointer) => boolean;

export function convertGLibUnixFDSourceFuncArgs(data: any): Parameters<GLibUnixFDSourceFunc> {
  return [
    data.fd,
    data.condition,
    data.user_data  ];
}
  
// Finalization registry for GstAllocationParams
const gstallocationparamsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/AllocationParams/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstAllocationParams:', ptr, err));
});

export class GstAllocationParams {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstallocationparamsRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstAllocationParams> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstAllocationParams(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(): Promise<GstAllocationParams | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstAllocationParams(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<GstMemoryFlagsValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_flags(value_: GstMemoryFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_align(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/fields/align`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_align(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/fields/align`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_prefix(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/fields/prefix`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_prefix(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/fields/prefix`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_padding(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/fields/padding`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_padding(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/fields/padding`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get__gst_reserved(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/ptr,${this.ptr}/fields/_gst_reserved`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocationParams/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstMemoryFlags {
  export const READONLY: 'readonly' = 'readonly';
  export const NO_SHARE: 'no_share' = 'no_share';
  export const ZERO_PREFIXED: 'zero_prefixed' = 'zero_prefixed';
  export const ZERO_PADDED: 'zero_padded' = 'zero_padded';
  export const PHYSICALLY_CONTIGUOUS: 'physically_contiguous' = 'physically_contiguous';
  export const NOT_MAPPABLE: 'not_mappable' = 'not_mappable';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MemoryFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstMemoryFlagsValue = "readonly" | "no_share" | "zero_prefixed" | "zero_padded" | "physically_contiguous" | "not_mappable" | "last";

  
export class GstObject extends GObjectInitiallyUnowned {



      





 
  async unref_2(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  static async check_uniqueness(list: GLibList, name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/check_uniqueness`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async default_deep_notify(object: GObjectObject, orig: GstObject, pspec: GObjectParamSpec, excluded_props?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/default_deep_notify`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (orig && typeof orig === 'object' && 'ptr' in orig) {
      url.searchParams.append('orig', 'ptr,' + orig.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Primitive parameter
    if (excluded_props !== undefined) url.searchParams.append('excluded_props', String(excluded_props));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async replace(oldobj?: GstObject, newobj?: GstObject): Promise<{oldobj: GstObject, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + oldobj.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/replace`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (oldobj !== undefined && typeof oldobj === 'object' && 'ptr' in oldobj) {
      url.searchParams.append('oldobj', 'ptr,' + oldobj.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newobj !== undefined && typeof newobj === 'object' && 'ptr' in newobj) {
      url.searchParams.append('newobj', 'ptr,' + newobj.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + oldobj.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: oldobj
      result.oldobj = (() => {
              // Return value is an object, instantiate it from the ptr
              if (data.oldobj && typeof data.oldobj === 'object' && 'ptr' in data.oldobj) {
                // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
                const instance = new GstObject(data.oldobj.ptr, 'none');
                return instance;
              }
              return Promise.reject("Call failed");
      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + oldobj.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

      





 
  async add_control_binding(binding: GstControlBinding): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/add_control_binding`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (binding && typeof binding === 'object' && 'ptr' in binding) {
      url.searchParams.append('binding', 'ptr,' + binding.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async default_error(error_: Pointer, debug?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/default_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_control_binding(property_name: string): Promise<GstControlBinding | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_control_binding`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstControlBinding(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_control_rate(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_control_rate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_g_value_array(property_name: string, timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_g_value_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_name(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_parent(): Promise<GstObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstObject(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_path_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_path_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_value(property_name: string, timestamp: number): Promise<GObjectValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_active_control_bindings(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/has_active_control_bindings`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_ancestor(ancestor: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/has_ancestor`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ancestor && typeof ancestor === 'object' && 'ptr' in ancestor) {
      url.searchParams.append('ancestor', 'ptr,' + ancestor.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_as_ancestor(ancestor: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/has_as_ancestor`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ancestor && typeof ancestor === 'object' && 'ptr' in ancestor) {
      url.searchParams.append('ancestor', 'ptr,' + ancestor.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_as_parent(parent: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/has_as_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async ref_2(): Promise<GstObject> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstObject(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove_control_binding(binding: GstControlBinding): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/remove_control_binding`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (binding && typeof binding === 'object' && 'ptr' in binding) {
      url.searchParams.append('binding', 'ptr,' + binding.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_control_binding_disabled(property_name: string, disabled: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_control_binding_disabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('disabled', String(disabled));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_control_bindings_disabled(disabled: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_control_bindings_disabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('disabled', String(disabled));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_control_rate(control_rate: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_control_rate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('control_rate', String(control_rate));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_name(name?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_parent(parent: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/set_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async suggest_next_sync(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/suggest_next_sync`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async sync_values(timestamp: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/sync_values`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unparent(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/ptr,${this.ptr}/unparent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Object/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstAllocator extends GstObject {




      





 
  static async find(name?: string): Promise<GstAllocator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/find`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstAllocator(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async register(name: string, allocator: GstAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

      





 
  async alloc(size: number, params?: GstAllocationParams): Promise<GstMemory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/ptr,${this.ptr}/alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMemory(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async free(memory: GstMemory): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (memory && typeof memory === 'object' && 'ptr' in memory) {
      url.searchParams.append('memory', 'ptr,' + memory.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_default(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/ptr,${this.ptr}/set_default`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Allocator/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstMemory
const gstmemoryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Memory/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMemory:', ptr, err));
});

export class GstMemory {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstmemoryRegistry.register(this, ptr);
  }
    





 
  static async new_wrapped(flags: GstMemoryFlagsValue, data_: Pointer, maxsize: number, offset: number, size: number, notify: GLibDestroyNotify): Promise<{notify: number, return: GstMemory | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/new_wrapped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.notify !== undefined) {
        callbackDispatcher.set(data.notify.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: notify
        });
      }
        const result: any = {};
      // Handle return parameter: notify
      result.notify = (() => {
        return data.notify;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GstMemory(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(offset: number, size: number): Promise<GstMemory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMemory(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_sizes(): Promise<{offset: number, maxsize: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/get_sizes`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: offset
      result.offset = (() => {
        return data.offset;

      })();
      // Handle return parameter: maxsize
      result.maxsize = (() => {
        return data.maxsize;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_span(mem2: GstMemory): Promise<{offset: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/is_span`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem2 && typeof mem2 === 'object' && 'ptr' in mem2) {
      url.searchParams.append('mem2', 'ptr,' + mem2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: offset
      result.offset = (() => {
        return data.offset;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_type(mem_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/is_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_type', String(mem_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async make_mapped(info: GstMapInfo, flags: GstMapFlagsValue): Promise<GstMemory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/make_mapped`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMemory(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async map(info: GstMapInfo, flags: GstMapFlagsValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/map`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async resize(offset: number, size: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/resize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async share(offset: number, size: number): Promise<GstMemory> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/share`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMemory(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unmap(info: GstMapInfo): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/unmap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_mini_object(): Promise<GstMiniObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMiniObject(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_mini_object(value_: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_allocator(): Promise<GstAllocator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/allocator`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstAllocator(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_allocator(value_: GstAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/allocator`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_parent(): Promise<GstMemory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMemory(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_parent(value_: GstMemory): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_maxsize(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/maxsize`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_maxsize(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/maxsize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_align(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/align`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_align(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/align`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_offset(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/offset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_offset(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_size(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/ptr,${this.ptr}/fields/size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Memory/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstMapInfo
const gstmapinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/MapInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMapInfo:', ptr, err));
});

export class GstMapInfo {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstmapinfoRegistry.register(this, ptr);
  }


}
  export namespace GstMapFlags {
  export const READ: 'read' = 'read';
  export const WRITE: 'write' = 'write';
  export const FLAG_LAST: 'flag_last' = 'flag_last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MapFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstMapFlagsValue = "read" | "write" | "flag_last";

  
// Finalization registry for GstMiniObject
const gstminiobjectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/MiniObject/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMiniObject:', ptr, err));
});

export class GstMiniObject {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstminiobjectRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstMiniObject> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMiniObject(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_parent(parent: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/add_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_qdata(quark: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_writable(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/is_writable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async lock(flags: GstLockFlagsValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/lock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_parent(parent: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/remove_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_qdata(quark: number, destroy: GLibDestroyNotify, data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/set_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.destroy !== undefined) {
        callbackDispatcher.set(data.destroy.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: destroy
        });
      }
    return data.destroy;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async steal_qdata(quark: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unlock(flags: GstLockFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/unlock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async replace(olddata?: GstMiniObject, newdata?: GstMiniObject): Promise<{olddata: GstMiniObject, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/replace`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata !== undefined && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata !== undefined && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: olddata
      result.olddata = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.olddata && typeof data.olddata === 'object' && 'ptr' in data.olddata) {
          const instance = new GstMiniObject(data.olddata.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async take(olddata: GstMiniObject, newdata: GstMiniObject): Promise<{olddata: GstMiniObject, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: olddata
      result.olddata = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.olddata && typeof data.olddata === 'object' && 'ptr' in data.olddata) {
          const instance = new GstMiniObject(data.olddata.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_type(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_refcount(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/refcount`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_refcount(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/refcount`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_lockstate(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/lockstate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_lockstate(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/lockstate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_flags(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_copy(): Promise<GstMiniObjectCopyFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_copy(value_: GstMiniObjectCopyFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dispose(): Promise<GstMiniObjectDisposeFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/dispose`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_dispose(value_: GstMiniObjectDisposeFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/dispose`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_free(): Promise<GstMiniObjectFreeFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_free(value_: GstMiniObjectFreeFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_priv_uint(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/priv_uint`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_priv_pointer(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/ptr,${this.ptr}/fields/priv_pointer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObject/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstLockFlags {
  export const READ: 'read' = 'read';
  export const WRITE: 'write' = 'write';
  export const EXCLUSIVE: 'exclusive' = 'exclusive';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/LockFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstLockFlagsValue = "read" | "write" | "exclusive" | "last";

  export type GstMiniObjectCopyFunction = (obj: GstMiniObject) => GstMiniObject;

export function convertGstMiniObjectCopyFunctionArgs(data: any): Parameters<GstMiniObjectCopyFunction> {
  return [
    new GstMiniObject(data.obj, 'none')  ];
}
  export type GstMiniObjectDisposeFunction = (obj: GstMiniObject) => boolean;

export function convertGstMiniObjectDisposeFunctionArgs(data: any): Parameters<GstMiniObjectDisposeFunction> {
  return [
    new GstMiniObject(data.obj, 'none')  ];
}
  export type GstMiniObjectFreeFunction = (obj: GstMiniObject) => void;

export function convertGstMiniObjectFreeFunctionArgs(data: any): Parameters<GstMiniObjectFreeFunction> {
  return [
    new GstMiniObject(data.obj, 'none')  ];
}
  export namespace GstAllocatorFlags {
  export const CUSTOM_ALLOC: 'custom_alloc' = 'custom_alloc';
  export const NO_COPY: 'no_copy' = 'no_copy';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AllocatorFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstAllocatorFlagsValue = "custom_alloc" | "no_copy" | "last";

  
// Finalization registry for GstAllocatorPrivate
const gstallocatorprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/AllocatorPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstAllocatorPrivate:', ptr, err));
});

export class GstAllocatorPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstallocatorprivateRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GstAtomicQueue
const gstatomicqueueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/AtomicQueue/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstAtomicQueue:', ptr, err));
});

export class GstAtomicQueue {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstatomicqueueRegistry.register(this, ptr);
  }
    





 
  static async new(initial_size: number): Promise<GstAtomicQueue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('initial_size', String(initial_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstAtomicQueue(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async length(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/length`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/peek`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async pop(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push(data_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/AtomicQueue/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GstElementCallAsyncFunc = (element: GstElement, user_data: Pointer) => void;

export function convertGstElementCallAsyncFuncArgs(data: any): Parameters<GstElementCallAsyncFunc> {
  return [
    new GstElement(data.element, 'none'),
    data.user_data  ];
}
  export type GstElementForeachPadFunc = (element: GstElement, pad: GstPad, user_data: Pointer) => boolean;

export function convertGstElementForeachPadFuncArgs(data: any): Parameters<GstElementForeachPadFunc> {
  return [
    new GstElement(data.element, 'none'),
    new GstPad(data.pad, 'none'),
    data.user_data  ];
}
  
export class GstElement extends GstObject {




      





 
  static async make_from_uri(type_: GstURITypeValue, uri: string, elementname?: string): Promise<GstElement> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/make_from_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    if (elementname !== undefined) url.searchParams.append('elementname', String(elementname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async register(name: string, rank: number, type_: string, plugin?: GstPlugin): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async state_change_return_get_name(state_ret: GstStateChangeReturnValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/state_change_return_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state_ret', String(state_ret));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async state_get_name(state: GstStateValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/state_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async type_set_skip_documentation(type_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/type_set_skip_documentation`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async abort_state(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/abort_state`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_pad(pad: GstPad): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/add_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_property_deep_notify_watch(include_value: boolean, property_name?: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/add_property_deep_notify_watch`, apiConfig.baseUrl);
    // Primitive parameter
    if (property_name !== undefined) url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('include_value', String(include_value));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_property_notify_watch(include_value: boolean, property_name?: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/add_property_notify_watch`, apiConfig.baseUrl);
    // Primitive parameter
    if (property_name !== undefined) url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('include_value', String(include_value));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async call_async(func: GstElementCallAsyncFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/call_async`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstElementCallAsyncFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async change_state(transition: GstStateChangeValue): Promise<GstStateChangeReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/change_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('transition', String(transition));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async continue_state(ret: GstStateChangeReturnValue): Promise<GstStateChangeReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/continue_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async create_all_pads(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/create_all_pads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async decorate_stream_id(stream_id: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/decorate_stream_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stream_id', String(stream_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async foreach_pad(func: GstElementForeachPadFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/foreach_pad`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstElementForeachPadFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async foreach_sink_pad(func: GstElementForeachPadFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/foreach_sink_pad`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstElementForeachPadFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async foreach_src_pad(func: GstElementForeachPadFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/foreach_src_pad`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstElementForeachPadFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_base_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_base_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_bus(): Promise<GstBus | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstBus(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_clock(): Promise<GstClock | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_clock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstClock(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_compatible_pad(pad: GstPad, caps?: GstCaps): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_compatible_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_compatible_pad_template(compattempl: GstPadTemplate): Promise<GstPadTemplate | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_compatible_pad_template`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (compattempl && typeof compattempl === 'object' && 'ptr' in compattempl) {
      url.searchParams.append('compattempl', 'ptr,' + compattempl.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPadTemplate(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_context(context_type: string): Promise<GstContext | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_context_unlocked(context_type: string): Promise<GstContext | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_context_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_contexts(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_contexts`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstContext, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_current_clock_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_current_clock_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_current_running_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_current_running_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_factory(): Promise<GstElementFactory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_factory`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElementFactory(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_metadata(key: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_pad_template(name: string): Promise<GstPadTemplate | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_pad_template`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPadTemplate(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_pad_template_list(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_pad_template_list`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', GstPadTemplate, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_request_pad(name: string): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_request_pad`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_start_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_start_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_state(state: GstStateValue, pending: GstStateValue, timeout: number): Promise<GstStateChangeReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    // Primitive parameter
    url.searchParams.append('pending', String(pending));
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_static_pad(name: string): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/get_static_pad`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_locked_state(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/is_locked_state`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_pads(): Promise<GstIterator> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/iterate_pads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_sink_pads(): Promise<GstIterator> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/iterate_sink_pads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_src_pads(): Promise<GstIterator> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/iterate_src_pads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async link(dest: GstElement): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async link_filtered(dest: GstElement, filter?: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link_filtered`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async link_pads(dest: GstElement, srcpadname?: string, destpadname?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link_pads`, apiConfig.baseUrl);
    // Primitive parameter
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async link_pads_filtered(dest: GstElement, srcpadname?: string, destpadname?: string, filter?: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link_pads_filtered`, apiConfig.baseUrl);
    // Primitive parameter
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async link_pads_full(dest: GstElement, flags: GstPadLinkCheckValue, srcpadname?: string, destpadname?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/link_pads_full`, apiConfig.baseUrl);
    // Primitive parameter
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async lost_state(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/lost_state`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async message_full(type_: GstMessageTypeValue, domain: number, code: number, file: string, function_: string, line: number, text?: string, debug?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/message_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    if (text !== undefined) url.searchParams.append('text', String(text));
    // Primitive parameter
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async message_full_with_details(type_: GstMessageTypeValue, domain: number, code: number, file: string, function_: string, line: number, structure: GstStructure, text?: string, debug?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/message_full_with_details`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    if (text !== undefined) url.searchParams.append('text', String(text));
    // Primitive parameter
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async no_more_pads(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/no_more_pads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async post_message(message: GstMessage): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/post_message`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async provide_clock(): Promise<GstClock | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/provide_clock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstClock(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query(query: GstQuery): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/query`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<{dest_val: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/query_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_val', String(src_val));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: dest_val
      result.dest_val = (() => {
        return data.dest_val;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query_duration(format: GstFormatValue): Promise<{duration: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/query_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: duration
      result.duration = (() => {
        return data.duration;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query_position(format: GstFormatValue): Promise<{cur: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/query_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: cur
      result.cur = (() => {
        return data.cur;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async release_request_pad(pad: GstPad): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/release_request_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove_pad(pad: GstPad): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/remove_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove_property_notify_watch(watch_id: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/remove_property_notify_watch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('watch_id', String(watch_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async request_pad(templ: GstPadTemplate, name?: string, caps?: GstCaps): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/request_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async request_pad_simple(name: string): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/request_pad_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async seek(rate: number, format: GstFormatValue, flags: GstSeekFlagsValue, start_type: GstSeekTypeValue, start: number, stop_type: GstSeekTypeValue, stop: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async seek_simple(format: GstFormatValue, seek_flags: GstSeekFlagsValue, seek_pos: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/seek_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('seek_flags', String(seek_flags));
    // Primitive parameter
    url.searchParams.append('seek_pos', String(seek_pos));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async send_event(event: GstEvent): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/send_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_base_time(time: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_base_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_bus(bus?: GstBus): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_bus`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bus !== undefined && typeof bus === 'object' && 'ptr' in bus) {
      url.searchParams.append('bus', 'ptr,' + bus.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_clock(clock?: GstClock): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock !== undefined && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_context(context: GstContext): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_locked_state(locked_state: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_locked_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('locked_state', String(locked_state));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_start_time(time: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_start_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_state(state: GstStateValue): Promise<GstStateChangeReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/set_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async sync_state_with_parent(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/sync_state_with_parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unlink(dest: GstElement): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/unlink`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unlink_pads(srcpadname: string, dest: GstElement, destpadname: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/ptr,${this.ptr}/unlink_pads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    url.searchParams.append('destpadname', String(destpadname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Element/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstBin extends GstElement {


    





 
  static async new(name?: string): Promise<GstElement> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async add(element: GstElement): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async find_unlinked_pad(direction: GstPadDirectionValue): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/find_unlinked_pad`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_by_interface(iface: string): Promise<GstElement | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/get_by_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iface', String(iface));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_by_name(name: string): Promise<GstElement | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/get_by_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_by_name_recurse_up(name: string): Promise<GstElement | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/get_by_name_recurse_up`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_suppressed_flags(): Promise<GstElementFlagsValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/get_suppressed_flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_all_by_element_factory_name(factory_name: string): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_all_by_element_factory_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factory_name', String(factory_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_all_by_interface(iface: string): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_all_by_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iface', String(iface));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_elements(): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_elements`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_recurse(): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_recurse`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_sinks(): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_sinks`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_sorted(): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_sorted`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_sources(): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/iterate_sources`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async recalculate_latency(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/recalculate_latency`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove(element: GstElement): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_suppressed_flags(flags: GstElementFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/set_suppressed_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async sync_children_states(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/ptr,${this.ptr}/sync_children_states`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bin/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstURIType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const SINK: 'sink' = 'sink';
  export const SRC: 'src' = 'src';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/URIType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstURITypeValue = "unknown" | "sink" | "src";

  export type GstPluginInitFunc = (plugin: GstPlugin) => boolean;

export function convertGstPluginInitFuncArgs(data: any): Parameters<GstPluginInitFunc> {
  return [
    new GstPlugin(data.plugin, 'none')  ];
}
  export type GstPluginInitFullFunc = (plugin: GstPlugin, user_data: Pointer) => boolean;

export function convertGstPluginInitFullFuncArgs(data: any): Parameters<GstPluginInitFullFunc> {
  return [
    new GstPlugin(data.plugin, 'none'),
    data.user_data  ];
}
  
export class GstPlugin extends GstObject {




      





 
  static async list_free(list: GLibList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/list_free`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async load_by_name(name: string): Promise<GstPlugin | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/load_by_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPlugin(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async load_file(filename: Pointer): Promise<GstPlugin> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/load_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPlugin(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async register_static(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package_: string, origin: string, init_func: GstPluginInitFunc): Promise<{init_func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('major_version', String(major_version));
    // Primitive parameter
    url.searchParams.append('minor_version', String(minor_version));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    // Primitive parameter
    url.searchParams.append('version', String(version));
    // Primitive parameter
    url.searchParams.append('license', String(license));
    // Primitive parameter
    url.searchParams.append('source', String(source));
    // Primitive parameter
    url.searchParams.append('package', String(package_));
    // Primitive parameter
    url.searchParams.append('origin', String(origin));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.init_func !== undefined) {
        callbackDispatcher.set(data.init_func.toString(), {
          converter: convertGstPluginInitFuncArgs,
          userFunction: init_func
        });
      }
        const result: any = {};
      // Handle return parameter: init_func
      result.init_func = (() => {
        return data.init_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async register_static_full(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package_: string, origin: string, init_full_func: GstPluginInitFullFunc): Promise<{init_full_func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/register_static_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('major_version', String(major_version));
    // Primitive parameter
    url.searchParams.append('minor_version', String(minor_version));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    // Primitive parameter
    url.searchParams.append('version', String(version));
    // Primitive parameter
    url.searchParams.append('license', String(license));
    // Primitive parameter
    url.searchParams.append('source', String(source));
    // Primitive parameter
    url.searchParams.append('package', String(package_));
    // Primitive parameter
    url.searchParams.append('origin', String(origin));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.init_full_func !== undefined) {
        callbackDispatcher.set(data.init_full_func.toString(), {
          converter: convertGstPluginInitFullFuncArgs,
          userFunction: init_full_func
        });
      }
        const result: any = {};
      // Handle return parameter: init_full_func
      result.init_full_func = (() => {
        return data.init_full_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_dependency(flags: GstPluginDependencyFlagsValue, env_vars?: Pointer, paths?: Pointer, names?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_dependency`, apiConfig.baseUrl);
    // Primitive parameter
    if (env_vars !== undefined) url.searchParams.append('env_vars', String(env_vars));
    // Primitive parameter
    if (paths !== undefined) url.searchParams.append('paths', String(paths));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_dependency_simple(flags: GstPluginDependencyFlagsValue, env_vars?: string, paths?: string, names?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_dependency_simple`, apiConfig.baseUrl);
    // Primitive parameter
    if (env_vars !== undefined) url.searchParams.append('env_vars', String(env_vars));
    // Primitive parameter
    if (paths !== undefined) url.searchParams.append('paths', String(paths));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_status_error(message: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_status_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('message', String(message));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_status_info(message: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_status_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('message', String(message));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_status_warning(message: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/add_status_warning`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('message', String(message));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_cache_data(): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_cache_data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_description(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_filename(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_filename`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_license(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_license`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_name_2(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_origin(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_origin`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_package(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_package`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_release_date_string(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_release_date_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_source(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_source`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_status_errors(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_status_errors`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_status_infos(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_status_infos`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_status_warnings(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_status_warnings`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_version(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/get_version`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_loaded(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/is_loaded`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async load(): Promise<GstPlugin | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/load`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPlugin(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_cache_data(cache_data: GstStructure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/ptr,${this.ptr}/set_cache_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (cache_data && typeof cache_data === 'object' && 'ptr' in cache_data) {
      url.searchParams.append('cache_data', 'ptr,' + cache_data.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Plugin/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstPluginDependencyFlags {
  export const NONE: 'none' = 'none';
  export const RECURSE: 'recurse' = 'recurse';
  export const PATHS_ARE_DEFAULT_ONLY: 'paths_are_default_only' = 'paths_are_default_only';
  export const FILE_NAME_IS_SUFFIX: 'file_name_is_suffix' = 'file_name_is_suffix';
  export const FILE_NAME_IS_PREFIX: 'file_name_is_prefix' = 'file_name_is_prefix';
  export const PATHS_ARE_RELATIVE_TO_EXE: 'paths_are_relative_to_exe' = 'paths_are_relative_to_exe';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginDependencyFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPluginDependencyFlagsValue = "none" | "recurse" | "paths_are_default_only" | "file_name_is_suffix" | "file_name_is_prefix" | "paths_are_relative_to_exe";

  export type GstStructureFilterMapFunc = (field_id: number, value_: GObjectValue, user_data: Pointer) => boolean;

export function convertGstStructureFilterMapFuncArgs(data: any): Parameters<GstStructureFilterMapFunc> {
  return [
    data.field_id,
    new GObjectValue(data.value, 'none'),
    data.user_data  ];
}
  export type GstStructureForeachFunc = (field_id: number, value_: GObjectValue, user_data: Pointer) => boolean;

export function convertGstStructureForeachFuncArgs(data: any): Parameters<GstStructureForeachFunc> {
  return [
    data.field_id,
    new GObjectValue(data.value, 'none'),
    data.user_data  ];
}
  export type GstStructureMapFunc = (field_id: number, value_: GObjectValue, user_data: Pointer) => boolean;

export function convertGstStructureMapFuncArgs(data: any): Parameters<GstStructureMapFunc> {
  return [
    data.field_id,
    new GObjectValue(data.value, 'none'),
    data.user_data  ];
}
  
// Finalization registry for GstStructure
const gststructureRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Structure/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstStructure:', ptr, err));
});

export class GstStructure {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gststructureRegistry.register(this, ptr);
  }
    





 
  static async from_string(string: string): Promise<{end: string, return: GstStructure | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: end
      result.end = (() => {
        return data.end;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GstStructure(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_empty(name: string): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/new_empty`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_string(string: string): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/new_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_id_empty(quark: number): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/new_id_empty`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async can_intersect(struct2: GstStructure): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/can_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (struct2 && typeof struct2 === 'object' && 'ptr' in struct2) {
      url.searchParams.append('struct2', 'ptr,' + struct2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy(): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async filter_and_map_in_place(func: GstStructureFilterMapFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/filter_and_map_in_place`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstStructureFilterMapFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fixate(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fixate_field(field_name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fixate_field_boolean(field_name: string, target: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fixate_field_nearest_double(field_name: string, target: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_nearest_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fixate_field_nearest_fraction(field_name: string, target_numerator: number, target_denominator: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_nearest_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target_numerator', String(target_numerator));
    // Primitive parameter
    url.searchParams.append('target_denominator', String(target_denominator));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fixate_field_nearest_int(field_name: string, target: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_nearest_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fixate_field_string(field_name: string, target: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fixate_field_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach(func: GstStructureForeachFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstStructureForeachFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_array(fieldname: string, array: GObjectValueArray): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_boolean(fieldname: string): Promise<{value: boolean, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_clock_time(fieldname: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_clock_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_date(fieldname: string, value_: GLibDate): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_date`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_date_time(fieldname: string, value_: GstDateTime): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_double(fieldname: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_enum(fieldname: string, enumtype: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Primitive parameter
    url.searchParams.append('enumtype', String(enumtype));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_field_type(fieldname: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_field_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(fieldname: string, flags_type: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flagset(fieldname: string): Promise<{value_flags: number, value_mask: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_flagset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value_flags
      result.value_flags = (() => {
        return data.value_flags;

      })();
      // Handle return parameter: value_mask
      result.value_mask = (() => {
        return data.value_mask;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_fraction(fieldname: string): Promise<{value_numerator: number, value_denominator: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value_numerator
      result.value_numerator = (() => {
        return data.value_numerator;

      })();
      // Handle return parameter: value_denominator
      result.value_denominator = (() => {
        return data.value_denominator;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int(fieldname: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int64(fieldname: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_list(fieldname: string, array: GObjectValueArray): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_name(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_name_id(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_name_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string(fieldname: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint(fieldname: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint64(fieldname: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_value(fieldname: string): Promise<GObjectValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_field(fieldname: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/has_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_field_typed(fieldname: string, type_: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/has_field_typed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_name(name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async id_get_value(field: number): Promise<GObjectValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async id_has_field(field: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_has_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async id_has_field_typed(field: number, type_: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_has_field_typed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async id_set_value(field: number, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async id_take_value(field: number, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/id_take_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async intersect(struct2: GstStructure): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (struct2 && typeof struct2 === 'object' && 'ptr' in struct2) {
      url.searchParams.append('struct2', 'ptr,' + struct2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_equal(structure2: GstStructure): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure2 && typeof structure2 === 'object' && 'ptr' in structure2) {
      url.searchParams.append('structure2', 'ptr,' + structure2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_subset(superset: GstStructure): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/is_subset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (superset && typeof superset === 'object' && 'ptr' in superset) {
      url.searchParams.append('superset', 'ptr,' + superset.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async map_in_place(func: GstStructureMapFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/map_in_place`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstStructureMapFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async n_fields(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/n_fields`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async nth_field_name(index: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/nth_field_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_all_fields(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/remove_all_fields`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_field(fieldname: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/remove_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async serialize(flags: GstSerializeFlagsValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/serialize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async serialize_full(flags: GstSerializeFlagsValue): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/serialize_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_array(fieldname: string, array: GObjectValueArray): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_list(fieldname: string, array: GObjectValueArray): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_name(name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_parent_refcount(refcount: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_parent_refcount`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('refcount', String(refcount));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_value(fieldname: string, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async take_value(fieldname: string, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/take_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async take(oldstr_ptr?: GstStructure, newstr?: GstStructure): Promise<{oldstr_ptr: GstStructure, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (oldstr_ptr !== undefined && typeof oldstr_ptr === 'object' && 'ptr' in oldstr_ptr) {
      url.searchParams.append('oldstr_ptr', 'ptr,' + oldstr_ptr.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newstr !== undefined && typeof newstr === 'object' && 'ptr' in newstr) {
      url.searchParams.append('newstr', 'ptr,' + newstr.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: oldstr_ptr
      result.oldstr_ptr = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.oldstr_ptr && typeof data.oldstr_ptr === 'object' && 'ptr' in data.oldstr_ptr) {
          const instance = new GstStructure(data.oldstr_ptr.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_type(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Structure/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstDateTime
const gstdatetimeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/DateTime/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstDateTime:', ptr, err));
});

export class GstDateTime {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstdatetimeRegistry.register(this, ptr);
  }
    





 
  static async new(tzoffset: number, year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tzoffset', String(tzoffset));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_g_date_time(dt?: GLibDateTime): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_g_date_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dt !== undefined && typeof dt === 'object' && 'ptr' in dt) {
      url.searchParams.append('dt', 'ptr,' + dt.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_iso8601_string(string: string): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_iso8601_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_unix_epoch_local_time(secs: number): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_unix_epoch_local_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('secs', String(secs));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_unix_epoch_local_time_usecs(usecs: number): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_unix_epoch_local_time_usecs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_unix_epoch_utc(secs: number): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_unix_epoch_utc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('secs', String(secs));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_unix_epoch_utc_usecs(usecs: number): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_from_unix_epoch_utc_usecs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_local_time(year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_local_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_now_local_time(): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_now_local_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_now_utc(): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_now_utc`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_y(year: number): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_y`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_ym(year: number, month: number): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_ym`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_ymd(year: number, month: number, day: number): Promise<GstDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/new_ymd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_day(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_day`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_hour(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_hour`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_microsecond(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_microsecond`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_minute(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_minute`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_month(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_month`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_second(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_second`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_time_zone_offset(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_time_zone_offset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_year(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/get_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_day(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_day`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_month(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_month`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_second(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_second`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_time(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_year(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/has_year`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async ref(): Promise<GstDateTime> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_g_date_time(): Promise<GLibDateTime | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/to_g_date_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibDateTime(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_iso8601_string(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/to_iso8601_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unref(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DateTime/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstSerializeFlags {
  export const NONE: 'none' = 'none';
  export const BACKWARD_COMPAT: 'backward_compat' = 'backward_compat';
  export const STRICT: 'strict' = 'strict';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SerializeFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstSerializeFlagsValue = "none" | "backward_compat" | "strict";

  export namespace GstStateChangeReturn {
  export const FAILURE: 'failure' = 'failure';
  export const SUCCESS: 'success' = 'success';
  export const ASYNC: 'async' = 'async';
  export const NO_PREROLL: 'no_preroll' = 'no_preroll';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StateChangeReturn/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstStateChangeReturnValue = "failure" | "success" | "async" | "no_preroll";

  export namespace GstState {
  export const VOID_PENDING: 'void_pending' = 'void_pending';
  export const NULL: 'null' = 'null';
  export const READY: 'ready' = 'ready';
  export const PAUSED: 'paused' = 'paused';
  export const PLAYING: 'playing' = 'playing';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/State/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstStateValue = "void_pending" | "null" | "ready" | "paused" | "playing";

  export type GstPadProbeCallback = (pad: GstPad, info: GstPadProbeInfo, user_data: Pointer) => GstPadProbeReturnValue;

export function convertGstPadProbeCallbackArgs(data: any): Parameters<GstPadProbeCallback> {
  return [
    new GstPad(data.pad, 'none'),
    new GstPadProbeInfo(data.info, 'none'),
    data.user_data  ];
}
  export type GstPadForwardFunction = (pad: GstPad, user_data: Pointer) => boolean;

export function convertGstPadForwardFunctionArgs(data: any): Parameters<GstPadForwardFunction> {
  return [
    new GstPad(data.pad, 'none'),
    data.user_data  ];
}
  export type GstPadActivateFunction = (pad: GstPad, parent: GstObject) => boolean;

export function convertGstPadActivateFunctionArgs(data: any): Parameters<GstPadActivateFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none')  ];
}
  export type GstPadActivateModeFunction = (pad: GstPad, parent: GstObject, mode: GstPadModeValue, active: boolean) => boolean;

export function convertGstPadActivateModeFunctionArgs(data: any): Parameters<GstPadActivateModeFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none'),
    data.mode,
    data.active  ];
}
  export type GstPadChainFunction = (pad: GstPad, parent: GstObject, buffer: GstBuffer) => GstFlowReturnValue;

export function convertGstPadChainFunctionArgs(data: any): Parameters<GstPadChainFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none'),
    new GstBuffer(data.buffer, 'full')  ];
}
  export type GstPadChainListFunction = (pad: GstPad, parent: GstObject, list: GstBufferList) => GstFlowReturnValue;

export function convertGstPadChainListFunctionArgs(data: any): Parameters<GstPadChainListFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none'),
    new GstBufferList(data.list, 'full')  ];
}
  export type GstPadEventFullFunction = (pad: GstPad, parent: GstObject, event: GstEvent) => GstFlowReturnValue;

export function convertGstPadEventFullFunctionArgs(data: any): Parameters<GstPadEventFullFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none'),
    new GstEvent(data.event, 'full')  ];
}
  export type GstPadEventFunction = (pad: GstPad, parent: GstObject, event: GstEvent) => boolean;

export function convertGstPadEventFunctionArgs(data: any): Parameters<GstPadEventFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none'),
    new GstEvent(data.event, 'full')  ];
}
  export type GstPadGetRangeFunction = (pad: GstPad, parent: GstObject, offset: number, length: number, buffer: GstBuffer) => GstFlowReturnValue;

export function convertGstPadGetRangeFunctionArgs(data: any): Parameters<GstPadGetRangeFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none'),
    data.offset,
    data.length,
    new GstBuffer(data.buffer, 'none')  ];
}
  export type GstPadIterIntLinkFunction = (pad: GstPad, parent: GstObject) => GstIterator;

export function convertGstPadIterIntLinkFunctionArgs(data: any): Parameters<GstPadIterIntLinkFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none')  ];
}
  export type GstPadLinkFunction = (pad: GstPad, parent: GstObject, peer: GstPad) => GstPadLinkReturnValue;

export function convertGstPadLinkFunctionArgs(data: any): Parameters<GstPadLinkFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none'),
    new GstPad(data.peer, 'none')  ];
}
  export type GstPadQueryFunction = (pad: GstPad, parent: GstObject, query: GstQuery) => boolean;

export function convertGstPadQueryFunctionArgs(data: any): Parameters<GstPadQueryFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none'),
    new GstQuery(data.query, 'none')  ];
}
  export type GstPadUnlinkFunction = (pad: GstPad, parent: GstObject) => void;

export function convertGstPadUnlinkFunctionArgs(data: any): Parameters<GstPadUnlinkFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstObject(data.parent, 'none')  ];
}
  export type GstTaskFunction = (user_data: Pointer) => void;

export function convertGstTaskFunctionArgs(data: any): Parameters<GstTaskFunction> {
  return [
    data.user_data  ];
}
  export type GstPadStickyEventsForeachFunction = (pad: GstPad, event: GstEvent, user_data: Pointer) => boolean;

export function convertGstPadStickyEventsForeachFunctionArgs(data: any): Parameters<GstPadStickyEventsForeachFunction> {
  return [
    new GstPad(data.pad, 'none'),
    new GstEvent(data.event, 'none'),
    data.user_data  ];
}
  
export class GstPad extends GstObject {


    





 
  static async new(direction: GstPadDirectionValue, name?: string): Promise<GstPad> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_static_template(templ: GstStaticPadTemplate, name: string): Promise<GstPad> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/new_from_static_template`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_template(templ: GstPadTemplate, name?: string): Promise<GstPad> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/new_from_template`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  static async link_get_name(ret: GstPadLinkReturnValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/link_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async activate_mode(mode: GstPadModeValue, active: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/activate_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('active', String(active));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_probe(mask: GstPadProbeTypeValue, callback: GstPadProbeCallback): Promise<{callback: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/add_probe`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.callback !== undefined) {
        callbackDispatcher.set(data.callback.toString(), {
          converter: convertGstPadProbeCallbackArgs,
          userFunction: callback
        });
      }
        const result: any = {};
      // Handle return parameter: callback
      result.callback = (() => {
        return data.callback;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async can_link(sinkpad: GstPad): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/can_link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async chain(buffer: GstBuffer): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/chain`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async chain_list(list: GstBufferList): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/chain_list`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async check_reconfigure(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/check_reconfigure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async create_stream_id(parent: GstElement, stream_id?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/create_stream_id`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    if (stream_id !== undefined) url.searchParams.append('stream_id', String(stream_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async event_default(event: GstEvent, parent?: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/event_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async forward(forward: GstPadForwardFunction): Promise<{forward: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/forward`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.forward !== undefined) {
        callbackDispatcher.set(data.forward.toString(), {
          converter: convertGstPadForwardFunctionArgs,
          userFunction: forward
        });
      }
        const result: any = {};
      // Handle return parameter: forward
      result.forward = (() => {
        return data.forward;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_allowed_caps(): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_allowed_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_current_caps(): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_current_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_direction(): Promise<GstPadDirectionValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_direction`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_element_private(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_element_private`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_last_flow_return(): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_last_flow_return`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_offset(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_offset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_pad_template(): Promise<GstPadTemplate | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_pad_template`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPadTemplate(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_pad_template_caps(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_pad_template_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_parent_element(): Promise<GstElement | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_parent_element`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_peer(): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_peer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_range(offset: number, size: number, buffer: GstBuffer): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_single_internal_link(): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_single_internal_link`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_sticky_event(event_type: GstEventTypeValue, idx: number): Promise<GstEvent | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_sticky_event`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('event_type', String(event_type));
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_stream(): Promise<GstStream | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_stream`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstStream(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_stream_id(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_stream_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_task_state(): Promise<GstTaskStateValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/get_task_state`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_current_caps(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/has_current_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_active(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/is_active`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_blocked(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/is_blocked`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_blocking(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/is_blocking`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_linked(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/is_linked`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_internal_links(): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/iterate_internal_links`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async iterate_internal_links_default(parent?: GstObject): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/iterate_internal_links_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async link(sinkpad: GstPad): Promise<GstPadLinkReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async link_full(sinkpad: GstPad, flags: GstPadLinkCheckValue): Promise<GstPadLinkReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/link_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async link_maybe_ghosting(sink: GstPad): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/link_maybe_ghosting`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sink && typeof sink === 'object' && 'ptr' in sink) {
      url.searchParams.append('sink', 'ptr,' + sink.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async link_maybe_ghosting_full(sink: GstPad, flags: GstPadLinkCheckValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/link_maybe_ghosting_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sink && typeof sink === 'object' && 'ptr' in sink) {
      url.searchParams.append('sink', 'ptr,' + sink.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async mark_reconfigure(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/mark_reconfigure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async needs_reconfigure(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/needs_reconfigure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async pause_task(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/pause_task`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async peer_query(query: GstQuery): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async peer_query_accept_caps(caps: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async peer_query_caps(filter?: GstCaps): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async peer_query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<{dest_val: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_val', String(src_val));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: dest_val
      result.dest_val = (() => {
        return data.dest_val;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async peer_query_duration(format: GstFormatValue): Promise<{duration: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: duration
      result.duration = (() => {
        return data.duration;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async peer_query_position(format: GstFormatValue): Promise<{cur: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/peer_query_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: cur
      result.cur = (() => {
        return data.cur;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async proxy_query_accept_caps(query: GstQuery): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/proxy_query_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async proxy_query_caps(query: GstQuery): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/proxy_query_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async pull_range(offset: number, size: number, buffer: GstBuffer): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/pull_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async push(buffer: GstBuffer): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async push_event(event: GstEvent): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/push_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async push_list(list: GstBufferList): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/push_list`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query(query: GstQuery): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query_accept_caps(caps: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query_caps(filter?: GstCaps): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<{dest_val: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_val', String(src_val));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: dest_val
      result.dest_val = (() => {
        return data.dest_val;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query_default(query: GstQuery, parent?: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query_duration(format: GstFormatValue): Promise<{duration: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: duration
      result.duration = (() => {
        return data.duration;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async query_position(format: GstFormatValue): Promise<{cur: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/query_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: cur
      result.cur = (() => {
        return data.cur;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove_probe(id: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/remove_probe`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async send_event(event: GstEvent): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/send_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_activate_function_full(activate: GstPadActivateFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_activate_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.activate !== undefined) {
        callbackDispatcher.set(data.activate.toString(), {
          converter: convertGstPadActivateFunctionArgs,
          userFunction: activate
        });
      }
    return data.activate;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_activatemode_function_full(activatemode: GstPadActivateModeFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_activatemode_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.activatemode !== undefined) {
        callbackDispatcher.set(data.activatemode.toString(), {
          converter: convertGstPadActivateModeFunctionArgs,
          userFunction: activatemode
        });
      }
    return data.activatemode;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_active(active: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_active`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('active', String(active));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_chain_function_full(chain: GstPadChainFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_chain_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.chain !== undefined) {
        callbackDispatcher.set(data.chain.toString(), {
          converter: convertGstPadChainFunctionArgs,
          userFunction: chain
        });
      }
    return data.chain;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_chain_list_function_full(chainlist: GstPadChainListFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_chain_list_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.chainlist !== undefined) {
        callbackDispatcher.set(data.chainlist.toString(), {
          converter: convertGstPadChainListFunctionArgs,
          userFunction: chainlist
        });
      }
    return data.chainlist;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_element_private(priv?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_element_private`, apiConfig.baseUrl);
    // Primitive parameter
    if (priv !== undefined) url.searchParams.append('priv', String(priv));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_event_full_function_full(event: GstPadEventFullFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_event_full_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.event !== undefined) {
        callbackDispatcher.set(data.event.toString(), {
          converter: convertGstPadEventFullFunctionArgs,
          userFunction: event
        });
      }
    return data.event;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_event_function_full(event: GstPadEventFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_event_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.event !== undefined) {
        callbackDispatcher.set(data.event.toString(), {
          converter: convertGstPadEventFunctionArgs,
          userFunction: event
        });
      }
    return data.event;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_getrange_function_full(get: GstPadGetRangeFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_getrange_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.get !== undefined) {
        callbackDispatcher.set(data.get.toString(), {
          converter: convertGstPadGetRangeFunctionArgs,
          userFunction: get
        });
      }
    return data.get;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_iterate_internal_links_function_full(iterintlink: GstPadIterIntLinkFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_iterate_internal_links_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.iterintlink !== undefined) {
        callbackDispatcher.set(data.iterintlink.toString(), {
          converter: convertGstPadIterIntLinkFunctionArgs,
          userFunction: iterintlink
        });
      }
    return data.iterintlink;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_link_function_full(link: GstPadLinkFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_link_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.link !== undefined) {
        callbackDispatcher.set(data.link.toString(), {
          converter: convertGstPadLinkFunctionArgs,
          userFunction: link
        });
      }
    return data.link;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_offset(offset: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_query_function_full(query: GstPadQueryFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_query_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.query !== undefined) {
        callbackDispatcher.set(data.query.toString(), {
          converter: convertGstPadQueryFunctionArgs,
          userFunction: query
        });
      }
    return data.query;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_unlink_function_full(unlink: GstPadUnlinkFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/set_unlink_function_full`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.unlink !== undefined) {
        callbackDispatcher.set(data.unlink.toString(), {
          converter: convertGstPadUnlinkFunctionArgs,
          userFunction: unlink
        });
      }
    return data.unlink;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async start_task(func: GstTaskFunction): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/start_task`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstTaskFunctionArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async sticky_events_foreach(foreach_func: GstPadStickyEventsForeachFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/sticky_events_foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.foreach_func !== undefined) {
        callbackDispatcher.set(data.foreach_func.toString(), {
          converter: convertGstPadStickyEventsForeachFunctionArgs,
          userFunction: foreach_func
        });
      }
    return data.foreach_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async stop_task(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/stop_task`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async store_sticky_event(event: GstEvent): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/store_sticky_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unlink(sinkpad: GstPad): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/unlink`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async use_fixed_caps(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/ptr,${this.ptr}/use_fixed_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pad/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstPadDirection {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const SRC: 'src' = 'src';
  export const SINK: 'sink' = 'sink';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadDirection/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPadDirectionValue = "unknown" | "src" | "sink";

  
// Finalization registry for GstStaticPadTemplate
const gststaticpadtemplateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/StaticPadTemplate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstStaticPadTemplate:', ptr, err));
});

export class GstStaticPadTemplate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gststaticpadtemplateRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstStaticPadTemplate> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStaticPadTemplate(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get(): Promise<GstPadTemplate | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPadTemplate(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_caps(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_name_template(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/fields/name_template`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_name_template(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/fields/name_template`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_direction(): Promise<GstPadDirectionValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/fields/direction`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_direction(value_: GstPadDirectionValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/fields/direction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_presence(): Promise<GstPadPresenceValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/fields/presence`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_presence(value_: GstPadPresenceValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/fields/presence`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_static_caps(): Promise<GstStaticCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/fields/static_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStaticCaps(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_static_caps(value_: GstStaticCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticPadTemplate/ptr,${this.ptr}/fields/static_caps`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstPadTemplate extends GstObject {


    





 
  static async new(name_template: string, direction: GstPadDirectionValue, presence: GstPadPresenceValue, caps: GstCaps): Promise<GstPadTemplate | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name_template', String(name_template));
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    // Primitive parameter
    url.searchParams.append('presence', String(presence));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPadTemplate(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_static_pad_template_with_gtype(pad_template: GstStaticPadTemplate, pad_type: string): Promise<GstPadTemplate | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/new_from_static_pad_template_with_gtype`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad_template && typeof pad_template === 'object' && 'ptr' in pad_template) {
      url.searchParams.append('pad_template', 'ptr,' + pad_template.ptr);
    }
    // Primitive parameter
    url.searchParams.append('pad_type', String(pad_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPadTemplate(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_with_gtype(name_template: string, direction: GstPadDirectionValue, presence: GstPadPresenceValue, caps: GstCaps, pad_type: string): Promise<GstPadTemplate | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/new_with_gtype`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name_template', String(name_template));
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    // Primitive parameter
    url.searchParams.append('presence', String(presence));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('pad_type', String(pad_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPadTemplate(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async get_caps(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_documentation_caps(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/ptr,${this.ptr}/get_documentation_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async pad_created(pad: GstPad): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/ptr,${this.ptr}/pad_created`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_documentation_caps(caps: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/ptr,${this.ptr}/set_documentation_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplate/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstPadPresence {
  export const ALWAYS: 'always' = 'always';
  export const SOMETIMES: 'sometimes' = 'sometimes';
  export const REQUEST: 'request' = 'request';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadPresence/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPadPresenceValue = "always" | "sometimes" | "request";

  export type GstCapsFilterMapFunc = (features: GstCapsFeatures, structure: GstStructure, user_data: Pointer) => boolean;

export function convertGstCapsFilterMapFuncArgs(data: any): Parameters<GstCapsFilterMapFunc> {
  return [
    new GstCapsFeatures(data.features, 'none'),
    new GstStructure(data.structure, 'none'),
    data.user_data  ];
}
  export type GstCapsForeachFunc = (features: GstCapsFeatures, structure: GstStructure, user_data: Pointer) => boolean;

export function convertGstCapsForeachFuncArgs(data: any): Parameters<GstCapsForeachFunc> {
  return [
    new GstCapsFeatures(data.features, 'none'),
    new GstStructure(data.structure, 'none'),
    data.user_data  ];
}
  export type GstCapsMapFunc = (features: GstCapsFeatures, structure: GstStructure, user_data: Pointer) => boolean;

export function convertGstCapsMapFuncArgs(data: any): Parameters<GstCapsMapFunc> {
  return [
    new GstCapsFeatures(data.features, 'none'),
    new GstStructure(data.structure, 'none'),
    data.user_data  ];
}
  
// Finalization registry for GstCaps
const gstcapsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Caps/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstCaps:', ptr, err));
});

export class GstCaps {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstcapsRegistry.register(this, ptr);
  }
    





 
  static async new_any(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/new_any`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_empty(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/new_empty`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_empty_simple(media_type: string): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/new_empty_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('media_type', String(media_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async append(caps2: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append_structure(structure: GstStructure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/append_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append_structure_full(structure: GstStructure, features?: GstCapsFeatures): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/append_structure_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async can_intersect(caps2: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/can_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy_nth(nth: number): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/copy_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nth', String(nth));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async filter_and_map_in_place(func: GstCapsFilterMapFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/filter_and_map_in_place`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstCapsFilterMapFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fixate(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/fixate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach(func: GstCapsForeachFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstCapsForeachFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_features(index: number): Promise<GstCapsFeatures | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/get_features`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCapsFeatures(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_structure(index: number): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async intersect(caps2: GstCaps): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async intersect_full(caps2: GstCaps, mode: GstCapsIntersectModeValue): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/intersect_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_always_compatible(caps2: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_always_compatible`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_any(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_any`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_empty(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_equal(caps2: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_equal_fixed(caps2: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_equal_fixed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_fixed(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_fixed`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_strictly_equal(caps2: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_strictly_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_subset(superset: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_subset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (superset && typeof superset === 'object' && 'ptr' in superset) {
      url.searchParams.append('superset', 'ptr,' + superset.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_subset_structure(structure: GstStructure): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_subset_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_subset_structure_full(structure: GstStructure, features?: GstCapsFeatures): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/is_subset_structure_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async map_in_place(func: GstCapsMapFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/map_in_place`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstCapsMapFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async merge(caps2: GstCaps): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/merge`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async merge_structure(structure: GstStructure): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/merge_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async merge_structure_full(structure: GstStructure, features?: GstCapsFeatures): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/merge_structure_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async normalize(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/normalize`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_structure(idx: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/remove_structure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async serialize(flags: GstSerializeFlagsValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/serialize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_features(index: number, features?: GstCapsFeatures): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/set_features`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_features_simple(features?: GstCapsFeatures): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/set_features_simple`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_value(field: string, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async simplify(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/simplify`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async steal_structure(index: number): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/steal_structure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async subtract(subtrahend: GstCaps): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async truncate(): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/truncate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async from_string(string: string): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_mini_object(): Promise<GstMiniObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMiniObject(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_mini_object(value_: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Caps/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstCapsFeatures
const gstcapsfeaturesRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/CapsFeatures/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstCapsFeatures:', ptr, err));
});

export class GstCapsFeatures {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstcapsfeaturesRegistry.register(this, ptr);
  }
    





 
  static async new_any(): Promise<GstCapsFeatures> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/new_any`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCapsFeatures(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_empty(): Promise<GstCapsFeatures> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/new_empty`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCapsFeatures(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_single(feature: string): Promise<GstCapsFeatures> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/new_single`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCapsFeatures(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add(feature: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_id(feature: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/add_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async contains(feature: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async contains_id(feature: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/contains_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy(): Promise<GstCapsFeatures> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCapsFeatures(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_nth(i: number): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/get_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('i', String(i));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_nth_id(i: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/get_nth_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('i', String(i));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_any(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/is_any`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_equal(features2: GstCapsFeatures): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (features2 && typeof features2 === 'object' && 'ptr' in features2) {
      url.searchParams.append('features2', 'ptr,' + features2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(feature: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_id(feature: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/remove_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_parent_refcount(refcount: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/set_parent_refcount`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('refcount', String(refcount));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async from_string(features: string): Promise<GstCapsFeatures | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('features', String(features));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCapsFeatures(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFeatures/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstCapsIntersectMode {
  export const ZIG_ZAG: 'zig_zag' = 'zig_zag';
  export const FIRST: 'first' = 'first';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsIntersectMode/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstCapsIntersectModeValue = "zig_zag" | "first";

  
// Finalization registry for GstStaticCaps
const gststaticcapsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/StaticCaps/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstStaticCaps:', ptr, err));
});

export class GstStaticCaps {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gststaticcapsRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstStaticCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStaticCaps(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async cleanup(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/cleanup`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get(): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_caps(): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/fields/caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_caps(value_: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/fields/caps`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/fields/string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_string(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/fields/string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get__gst_reserved(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StaticCaps/ptr,${this.ptr}/fields/_gst_reserved`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstPadLinkReturn {
  export const OK: 'ok' = 'ok';
  export const WRONG_HIERARCHY: 'wrong_hierarchy' = 'wrong_hierarchy';
  export const WAS_LINKED: 'was_linked' = 'was_linked';
  export const WRONG_DIRECTION: 'wrong_direction' = 'wrong_direction';
  export const NOFORMAT: 'noformat' = 'noformat';
  export const NOSCHED: 'nosched' = 'nosched';
  export const REFUSED: 'refused' = 'refused';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadLinkReturn/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPadLinkReturnValue = "ok" | "wrong_hierarchy" | "was_linked" | "wrong_direction" | "noformat" | "nosched" | "refused";

  export namespace GstPadMode {
  export const NONE: 'none' = 'none';
  export const PUSH: 'push' = 'push';
  export const PULL: 'pull' = 'pull';
    





 
  export async function get_name(mode: GstPadModeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadMode/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadMode/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPadModeValue = "none" | "push" | "pull";

  export namespace GstPadProbeType {
  export const INVALID: 'invalid' = 'invalid';
  export const IDLE: 'idle' = 'idle';
  export const BLOCK: 'block' = 'block';
  export const BUFFER: 'buffer' = 'buffer';
  export const BUFFER_LIST: 'buffer_list' = 'buffer_list';
  export const EVENT_DOWNSTREAM: 'event_downstream' = 'event_downstream';
  export const EVENT_UPSTREAM: 'event_upstream' = 'event_upstream';
  export const EVENT_FLUSH: 'event_flush' = 'event_flush';
  export const QUERY_DOWNSTREAM: 'query_downstream' = 'query_downstream';
  export const QUERY_UPSTREAM: 'query_upstream' = 'query_upstream';
  export const PUSH: 'push' = 'push';
  export const PULL: 'pull' = 'pull';
  export const BLOCKING: 'blocking' = 'blocking';
  export const DATA_DOWNSTREAM: 'data_downstream' = 'data_downstream';
  export const DATA_UPSTREAM: 'data_upstream' = 'data_upstream';
  export const DATA_BOTH: 'data_both' = 'data_both';
  export const BLOCK_DOWNSTREAM: 'block_downstream' = 'block_downstream';
  export const BLOCK_UPSTREAM: 'block_upstream' = 'block_upstream';
  export const EVENT_BOTH: 'event_both' = 'event_both';
  export const QUERY_BOTH: 'query_both' = 'query_both';
  export const ALL_BOTH: 'all_both' = 'all_both';
  export const SCHEDULING: 'scheduling' = 'scheduling';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPadProbeTypeValue = "invalid" | "idle" | "block" | "buffer" | "buffer_list" | "event_downstream" | "event_upstream" | "event_flush" | "query_downstream" | "query_upstream" | "push" | "pull" | "blocking" | "data_downstream" | "data_upstream" | "data_both" | "block_downstream" | "block_upstream" | "event_both" | "query_both" | "all_both" | "scheduling";

  
// Finalization registry for GstPadProbeInfo
const gstpadprobeinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/PadProbeInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPadProbeInfo:', ptr, err));
});

export class GstPadProbeInfo {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstpadprobeinfoRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstPadProbeInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstPadProbeInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_buffer(): Promise<GstBuffer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/get_buffer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_buffer_list(): Promise<GstBufferList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/get_buffer_list`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBufferList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_event(): Promise<GstEvent | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/get_event`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_query(): Promise<GstQuery | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/get_query`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type(): Promise<GstPadProbeTypeValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_type(value_: GstPadProbeTypeValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_id(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_id(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_data(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_offset(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/offset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_offset(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_size(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeInfo/ptr,${this.ptr}/fields/size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GstBufferForeachMetaFunc = (buffer: GstBuffer, meta: GstMeta, user_data: Pointer) => boolean;

export function convertGstBufferForeachMetaFuncArgs(data: any): Parameters<GstBufferForeachMetaFunc> {
  return [
    new GstBuffer(data.buffer, 'none'),
    new GstMeta(data.meta, 'full'),
    data.user_data  ];
}
  
// Finalization registry for GstBuffer
const gstbufferRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Buffer/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstBuffer:', ptr, err));
});

export class GstBuffer {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstbufferRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstBuffer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_allocate(size: number, allocator?: GstAllocator, params?: GstAllocationParams): Promise<GstBuffer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_allocate`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_memdup(data_: Pointer, size: number): Promise<GstBuffer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_memdup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_wrapped(data_: Pointer, size: number): Promise<GstBuffer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_wrapped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_wrapped_bytes(bytes: GLibBytes): Promise<GstBuffer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_wrapped_bytes`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes && typeof bytes === 'object' && 'ptr' in bytes) {
      url.searchParams.append('bytes', 'ptr,' + bytes.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_wrapped_full(flags: GstMemoryFlagsValue, data_: Pointer, maxsize: number, offset: number, size: number, notify: GLibDestroyNotify): Promise<{notify: number, return: GstBuffer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/new_wrapped_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.notify !== undefined) {
        callbackDispatcher.set(data.notify.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: notify
        });
      }
        const result: any = {};
      // Handle return parameter: notify
      result.notify = (() => {
        return data.notify;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GstBuffer(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_custom_meta(name: string): Promise<GstCustomMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_custom_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCustomMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_meta(info: GstMetaInfo, params?: Pointer): Promise<GstMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    if (params !== undefined) url.searchParams.append('params', String(params));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_parent_buffer_meta(ref: GstBuffer): Promise<GstParentBufferMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_parent_buffer_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ref && typeof ref === 'object' && 'ptr' in ref) {
      url.searchParams.append('ref', 'ptr,' + ref.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstParentBufferMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_protection_meta(info: GstStructure): Promise<GstProtectionMeta> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_protection_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstProtectionMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_reference_timestamp_meta(reference: GstCaps, timestamp: number, duration: number): Promise<GstReferenceTimestampMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/add_reference_timestamp_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (reference && typeof reference === 'object' && 'ptr' in reference) {
      url.searchParams.append('reference', 'ptr,' + reference.ptr);
    }
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstReferenceTimestampMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append(buf2: GstBuffer): Promise<GstBuffer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buf2 && typeof buf2 === 'object' && 'ptr' in buf2) {
      url.searchParams.append('buf2', 'ptr,' + buf2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append_memory(mem: GstMemory): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/append_memory`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append_region(buf2: GstBuffer, offset: number, size: number): Promise<GstBuffer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/append_region`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buf2 && typeof buf2 === 'object' && 'ptr' in buf2) {
      url.searchParams.append('buf2', 'ptr,' + buf2.ptr);
    }
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy_deep(): Promise<GstBuffer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/copy_deep`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy_into(src: GstBuffer, flags: GstBufferCopyFlagsValue, offset: number, size: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/copy_into`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy_region(flags: GstBufferCopyFlagsValue, offset: number, size: number): Promise<GstBuffer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/copy_region`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async extract(offset: number): Promise<{dest: Pointer, size: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/extract`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: dest
      result.dest = (() => {
        return data.dest;

      })();
      // Handle return parameter: size
      result.size = (() => {
        return data.size;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async extract_dup(offset: number, size: number): Promise<{dest: Pointer, dest_size: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/extract_dup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: dest
      result.dest = (() => {
        return data.dest;

      })();
      // Handle return parameter: dest_size
      result.dest_size = (() => {
        return data.dest_size;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fill(offset: number, src: Pointer, size: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fill`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async find_memory(offset: number, size: number): Promise<{idx: number, length: number, skip: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/find_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: idx
      result.idx = (() => {
        return data.idx;

      })();
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: skip
      result.skip = (() => {
        return data.skip;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach_meta(func: GstBufferForeachMetaFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/foreach_meta`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstBufferForeachMetaFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_all_memory(): Promise<GstMemory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_all_memory`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMemory(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_custom_meta(name: string): Promise<GstCustomMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_custom_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCustomMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<GstBufferFlagsValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_memory(idx: number): Promise<GstMemory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMemory(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_memory_range(idx: number, length: number): Promise<GstMemory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_memory_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMemory(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_meta(api: string): Promise<GstMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_meta(api_type: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_n_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api_type', String(api_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_reference_timestamp_meta(reference?: GstCaps): Promise<GstReferenceTimestampMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_reference_timestamp_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (reference !== undefined && typeof reference === 'object' && 'ptr' in reference) {
      url.searchParams.append('reference', 'ptr,' + reference.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstReferenceTimestampMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_sizes(): Promise<{offset: number, maxsize: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_sizes`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: offset
      result.offset = (() => {
        return data.offset;

      })();
      // Handle return parameter: maxsize
      result.maxsize = (() => {
        return data.maxsize;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_sizes_range(idx: number, length: number): Promise<{offset: number, maxsize: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/get_sizes_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: offset
      result.offset = (() => {
        return data.offset;

      })();
      // Handle return parameter: maxsize
      result.maxsize = (() => {
        return data.maxsize;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_flags(flags: GstBufferFlagsValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/has_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert_memory(idx: number, mem: GstMemory): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/insert_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_all_memory_writable(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/is_all_memory_writable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_memory_range_writable(idx: number, length: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/is_memory_range_writable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async map(info: GstMapInfo, flags: GstMapFlagsValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/map`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async map_range(idx: number, length: number, info: GstMapInfo, flags: GstMapFlagsValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/map_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async memcmp(offset: number, mem: Pointer, size: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/memcmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async memset(offset: number, val: number, size: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/memset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async n_memory(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/n_memory`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek_memory(idx: number): Promise<GstMemory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/peek_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMemory(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async prepend_memory(mem: GstMemory): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/prepend_memory`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_all_memory(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/remove_all_memory`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_memory(idx: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/remove_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_memory_range(idx: number, length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/remove_memory_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_meta(meta: GstMeta): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/remove_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (meta && typeof meta === 'object' && 'ptr' in meta) {
      url.searchParams.append('meta', 'ptr,' + meta.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace_all_memory(mem: GstMemory): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/replace_all_memory`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace_memory(idx: number, mem: GstMemory): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/replace_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async replace_memory_range(idx: number, length: number, mem: GstMemory): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/replace_memory_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async resize(offset: number, size: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/resize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async resize_range(idx: number, length: number, offset: number, size: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/resize_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_flags(flags: GstBufferFlagsValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/set_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_size(size: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/set_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unmap(info: GstMapInfo): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/unmap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async unset_flags(flags: GstBufferFlagsValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/unset_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_max_memory(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/get_max_memory`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_mini_object(): Promise<GstMiniObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMiniObject(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_mini_object(value_: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_pool(): Promise<GstBufferPool | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/pool`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstBufferPool(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_pool(value_: GstBufferPool): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/pool`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_pts(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/pts`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_pts(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/pts`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_dts(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/dts`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_dts(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/dts`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_duration(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/duration`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_duration(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_offset(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/offset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_offset(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_offset_end(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/offset_end`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_offset_end(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/ptr,${this.ptr}/fields/offset_end`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Buffer/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstCustomMeta
const gstcustommetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/CustomMeta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstCustomMeta:', ptr, err));
});

export class GstCustomMeta {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstcustommetaRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstCustomMeta> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCustomMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_structure(): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_name(name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_meta(): Promise<GstMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/ptr,${this.ptr}/fields/meta`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_meta(value_: GstMeta): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CustomMeta/ptr,${this.ptr}/fields/meta`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GstCustomMetaTransformFunction = (transbuf: GstBuffer, meta: GstCustomMeta, buffer: GstBuffer, type_: number, data_: Pointer, user_data: Pointer) => boolean;

export function convertGstCustomMetaTransformFunctionArgs(data: any): Parameters<GstCustomMetaTransformFunction> {
  return [
    new GstBuffer(data.transbuf, 'none'),
    new GstCustomMeta(data.meta, 'none'),
    new GstBuffer(data.buffer, 'none'),
    data.type,
    data.data,
    data.user_data  ];
}
  
// Finalization registry for GstMeta
const gstmetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Meta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMeta:', ptr, err));
});

export class GstMeta {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstmetaRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstMeta> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async compare_seqnum(meta2: GstMeta): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/compare_seqnum`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (meta2 && typeof meta2 === 'object' && 'ptr' in meta2) {
      url.searchParams.append('meta2', 'ptr,' + meta2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_seqnum(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/get_seqnum`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async serialize(data_: GstByteArrayInterface): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/serialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async serialize_simple(data_: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/serialize_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async api_type_get_tags(api: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/api_type_get_tags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async api_type_has_tag(api: string, tag: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/api_type_has_tag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async api_type_register(api: string, tags: Pointer): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/api_type_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async deserialize(buffer: GstBuffer, data_: number, size: number): Promise<{consumed: number, return: GstMeta | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/deserialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: consumed
      result.consumed = (() => {
        return data.consumed;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GstMeta(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_info(impl: string): Promise<GstMetaInfo | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/get_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('impl', String(impl));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async register_custom(name: string, tags: Pointer, transform_func: GstCustomMetaTransformFunction): Promise<{transform_func: number, return: GstMetaInfo}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/register_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.transform_func !== undefined) {
        callbackDispatcher.set(data.transform_func.toString(), {
          converter: convertGstCustomMetaTransformFunctionArgs,
          userFunction: transform_func
        });
      }
        const result: any = {};
      // Handle return parameter: transform_func
      result.transform_func = (() => {
        return data.transform_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GstMetaInfo(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async register_custom_simple(name: string): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/register_custom_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<GstMetaFlagsValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_flags(value_: GstMetaFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Meta/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstByteArrayInterface
const gstbytearrayinterfaceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ByteArrayInterface/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstByteArrayInterface:', ptr, err));
});

export class GstByteArrayInterface {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstbytearrayinterfaceRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GstMetaInfo
const gstmetainfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/MetaInfo/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMetaInfo:', ptr, err));
});

export class GstMetaInfo {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstmetainfoRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async is_custom(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/is_custom`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async register(): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/register`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_api(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/api`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_api(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/api`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_type(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_size(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_init_func(): Promise<GstMetaInitFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/init_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_init_func(value_: GstMetaInitFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/init_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_free_func(): Promise<GstMetaFreeFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/free_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_free_func(value_: GstMetaFreeFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/free_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_transform_func(): Promise<GstMetaTransformFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/transform_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_transform_func(value_: GstMetaTransformFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/transform_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_serialize_func(): Promise<GstMetaSerializeFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/serialize_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_serialize_func(value_: GstMetaSerializeFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/serialize_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_deserialize_func(): Promise<GstMetaDeserializeFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/deserialize_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_deserialize_func(value_: GstMetaDeserializeFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/deserialize_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_clear_func(): Promise<GstMetaClearFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/clear_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_clear_func(value_: GstMetaClearFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaInfo/ptr,${this.ptr}/fields/clear_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GstMetaInitFunction = (meta: GstMeta, params: Pointer, buffer: GstBuffer) => boolean;

export function convertGstMetaInitFunctionArgs(data: any): Parameters<GstMetaInitFunction> {
  return [
    new GstMeta(data.meta, 'none'),
    data.params,
    new GstBuffer(data.buffer, 'none')  ];
}
  export type GstMetaFreeFunction = (meta: GstMeta, buffer: GstBuffer) => void;

export function convertGstMetaFreeFunctionArgs(data: any): Parameters<GstMetaFreeFunction> {
  return [
    new GstMeta(data.meta, 'none'),
    new GstBuffer(data.buffer, 'none')  ];
}
  export type GstMetaTransformFunction = (transbuf: GstBuffer, meta: GstMeta, buffer: GstBuffer, type_: number, data_: Pointer) => boolean;

export function convertGstMetaTransformFunctionArgs(data: any): Parameters<GstMetaTransformFunction> {
  return [
    new GstBuffer(data.transbuf, 'none'),
    new GstMeta(data.meta, 'none'),
    new GstBuffer(data.buffer, 'none'),
    data.type,
    data.data  ];
}
  export type GstMetaSerializeFunction = (meta: GstMeta, data_: GstByteArrayInterface, version: number) => boolean;

export function convertGstMetaSerializeFunctionArgs(data: any): Parameters<GstMetaSerializeFunction> {
  return [
    new GstMeta(data.meta, 'none'),
    new GstByteArrayInterface(data.data, 'none'),
    data.version  ];
}
  export type GstMetaDeserializeFunction = (info: GstMetaInfo, buffer: GstBuffer, data_: number, size: number, version: number) => GstMeta;

export function convertGstMetaDeserializeFunctionArgs(data: any): Parameters<GstMetaDeserializeFunction> {
  return [
    new GstMetaInfo(data.info, 'none'),
    new GstBuffer(data.buffer, 'none'),
    data.data,
    data.size,
    data.version  ];
}
  export type GstMetaClearFunction = (buffer: GstBuffer, meta: GstMeta) => void;

export function convertGstMetaClearFunctionArgs(data: any): Parameters<GstMetaClearFunction> {
  return [
    new GstBuffer(data.buffer, 'none'),
    new GstMeta(data.meta, 'none')  ];
}
  export namespace GstMetaFlags {
  export const NONE: 'none' = 'none';
  export const READONLY: 'readonly' = 'readonly';
  export const POOLED: 'pooled' = 'pooled';
  export const LOCKED: 'locked' = 'locked';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MetaFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstMetaFlagsValue = "none" | "readonly" | "pooled" | "locked" | "last";

  
// Finalization registry for GstParentBufferMeta
const gstparentbuffermetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ParentBufferMeta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstParentBufferMeta:', ptr, err));
});

export class GstParentBufferMeta {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstparentbuffermetaRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstParentBufferMeta> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstParentBufferMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  static async get_info(): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/get_info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_parent(): Promise<GstMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_parent(value_: GstMeta): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_buffer(): Promise<GstBuffer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/ptr,${this.ptr}/fields/buffer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_buffer(value_: GstBuffer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParentBufferMeta/ptr,${this.ptr}/fields/buffer`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstProtectionMeta
const gstprotectionmetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ProtectionMeta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstProtectionMeta:', ptr, err));
});

export class GstProtectionMeta {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstprotectionmetaRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstProtectionMeta> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProtectionMeta/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstProtectionMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProtectionMeta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  static async get_info(): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProtectionMeta/get_info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_meta(): Promise<GstMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProtectionMeta/ptr,${this.ptr}/fields/meta`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_meta(value_: GstMeta): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProtectionMeta/ptr,${this.ptr}/fields/meta`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstReferenceTimestampMeta
const gstreferencetimestampmetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ReferenceTimestampMeta/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstReferenceTimestampMeta:', ptr, err));
});

export class GstReferenceTimestampMeta {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstreferencetimestampmetaRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstReferenceTimestampMeta> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstReferenceTimestampMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  static async get_info(): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/get_info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_parent(): Promise<GstMeta | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMeta(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_parent(value_: GstMeta): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_reference(): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/fields/reference`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_reference(value_: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/fields/reference`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_timestamp(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/fields/timestamp`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_timestamp(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/fields/timestamp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_duration(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/fields/duration`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_duration(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ReferenceTimestampMeta/ptr,${this.ptr}/fields/duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstBufferCopyFlags {
  export const NONE: 'none' = 'none';
  export const FLAGS: 'flags' = 'flags';
  export const TIMESTAMPS: 'timestamps' = 'timestamps';
  export const META: 'meta' = 'meta';
  export const MEMORY: 'memory' = 'memory';
  export const MERGE: 'merge' = 'merge';
  export const DEEP: 'deep' = 'deep';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferCopyFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstBufferCopyFlagsValue = "none" | "flags" | "timestamps" | "meta" | "memory" | "merge" | "deep";

  export namespace GstBufferFlags {
  export const LIVE: 'live' = 'live';
  export const DECODE_ONLY: 'decode_only' = 'decode_only';
  export const DISCONT: 'discont' = 'discont';
  export const RESYNC: 'resync' = 'resync';
  export const CORRUPTED: 'corrupted' = 'corrupted';
  export const MARKER: 'marker' = 'marker';
  export const HEADER: 'header' = 'header';
  export const GAP: 'gap' = 'gap';
  export const DROPPABLE: 'droppable' = 'droppable';
  export const DELTA_UNIT: 'delta_unit' = 'delta_unit';
  export const TAG_MEMORY: 'tag_memory' = 'tag_memory';
  export const SYNC_AFTER: 'sync_after' = 'sync_after';
  export const NON_DROPPABLE: 'non_droppable' = 'non_droppable';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstBufferFlagsValue = "live" | "decode_only" | "discont" | "resync" | "corrupted" | "marker" | "header" | "gap" | "droppable" | "delta_unit" | "tag_memory" | "sync_after" | "non_droppable" | "last";

  
export class GstBufferPool extends GstObject {


    





 
  static async new(): Promise<GstBufferPool> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstBufferPool(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  static async config_add_option(config: GstStructure, option: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_add_option`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Primitive parameter
    url.searchParams.append('option', String(option));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async config_get_allocator(config: GstStructure, params: GstAllocationParams, allocator?: GstAllocator): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_get_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async config_get_option(config: GstStructure, index: number): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_get_option`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async config_get_params(config: GstStructure, caps?: GstCaps): Promise<{size: number, min_buffers: number, max_buffers: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_get_params`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: size
      result.size = (() => {
        return data.size;

      })();
      // Handle return parameter: min_buffers
      result.min_buffers = (() => {
        return data.min_buffers;

      })();
      // Handle return parameter: max_buffers
      result.max_buffers = (() => {
        return data.max_buffers;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async config_has_option(config: GstStructure, option: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_has_option`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Primitive parameter
    url.searchParams.append('option', String(option));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async config_n_options(config: GstStructure): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_n_options`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async config_set_allocator(config: GstStructure, allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_set_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async config_set_params(config: GstStructure, size: number, min_buffers: number, max_buffers: number, caps?: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_set_params`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async config_validate_params(config: GstStructure, size: number, min_buffers: number, max_buffers: number, caps?: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/config_validate_params`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async acquire_buffer(buffer?: GstBuffer, params?: GstBufferPoolAcquireParams): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/acquire_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer !== undefined && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_config(): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/get_config`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_options(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/get_options`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_option(option: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/has_option`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('option', String(option));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_active(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/is_active`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async release_buffer(buffer: GstBuffer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/release_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_active(active: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/set_active`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('active', String(active));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_config(config: GstStructure): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/set_config`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_flushing(flushing: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/ptr,${this.ptr}/set_flushing`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flushing', String(flushing));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPool/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstBufferPoolAcquireParams
const gstbufferpoolacquireparamsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/BufferPoolAcquireParams/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstBufferPoolAcquireParams:', ptr, err));
});

export class GstBufferPoolAcquireParams {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstbufferpoolacquireparamsRegistry.register(this, ptr);
  }


}
  export namespace GstFlowReturn {
  export const CUSTOM_SUCCESS_2: 'custom_success_2' = 'custom_success_2';
  export const CUSTOM_SUCCESS_1: 'custom_success_1' = 'custom_success_1';
  export const CUSTOM_SUCCESS: 'custom_success' = 'custom_success';
  export const OK: 'ok' = 'ok';
  export const NOT_LINKED: 'not_linked' = 'not_linked';
  export const FLUSHING: 'flushing' = 'flushing';
  export const EOS: 'eos' = 'eos';
  export const NOT_NEGOTIATED: 'not_negotiated' = 'not_negotiated';
  export const ERROR: 'error' = 'error';
  export const NOT_SUPPORTED: 'not_supported' = 'not_supported';
  export const CUSTOM_ERROR: 'custom_error' = 'custom_error';
  export const CUSTOM_ERROR_1: 'custom_error_1' = 'custom_error_1';
  export const CUSTOM_ERROR_2: 'custom_error_2' = 'custom_error_2';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/FlowReturn/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstFlowReturnValue = "custom_success_2" | "custom_success_1" | "custom_success" | "ok" | "not_linked" | "flushing" | "eos" | "not_negotiated" | "error" | "not_supported" | "custom_error" | "custom_error_1" | "custom_error_2";

  export type GstBufferListFunc = (buffer: GstBuffer, idx: number, user_data: Pointer) => boolean;

export function convertGstBufferListFuncArgs(data: any): Parameters<GstBufferListFunc> {
  return [
    new GstBuffer(data.buffer, 'full'),
    data.idx,
    data.user_data  ];
}
  
// Finalization registry for GstBufferList
const gstbufferlistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/BufferList/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstBufferList:', ptr, err));
});

export class GstBufferList {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstbufferlistRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstBufferList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBufferList(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_sized(size: number): Promise<GstBufferList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/new_sized`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBufferList(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async calculate_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/calculate_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy_deep(): Promise<GstBufferList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/copy_deep`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBufferList(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach(func: GstBufferListFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstBufferListFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get(idx: number): Promise<GstBuffer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_writable(idx: number): Promise<GstBuffer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/get_writable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert(idx: number, buffer: GstBuffer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async length(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/length`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove(idx: number, length: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferList/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstEvent
const gsteventRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Event/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstEvent:', ptr, err));
});

export class GstEvent {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gsteventRegistry.register(this, ptr);
  }
    





 
  static async new_buffer_size(format: GstFormatValue, minsize: number, maxsize: number, async_: boolean): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_buffer_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('minsize', String(minsize));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('async', String(async_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_caps(caps: GstCaps): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_custom(type_: GstEventTypeValue, structure: GstStructure): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_eos(): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_eos`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_flush_start(): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_flush_start`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_flush_stop(reset_time: boolean): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_flush_stop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('reset_time', String(reset_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_gap(timestamp: number, duration: number): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_gap`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_instant_rate_change(rate_multiplier: number, new_flags: GstSegmentFlagsValue): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_instant_rate_change`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate_multiplier', String(rate_multiplier));
    // Primitive parameter
    url.searchParams.append('new_flags', String(new_flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_instant_rate_sync_time(rate_multiplier: number, running_time: number, upstream_running_time: number): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_instant_rate_sync_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate_multiplier', String(rate_multiplier));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    // Primitive parameter
    url.searchParams.append('upstream_running_time', String(upstream_running_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_latency(latency: number): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_latency`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('latency', String(latency));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_navigation(structure: GstStructure): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_navigation`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_protection(system_id: string, data_: GstBuffer, origin: string): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_protection`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('system_id', String(system_id));
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('origin', String(origin));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_qos(type_: GstQOSTypeValue, proportion: number, diff: number, timestamp: number): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_qos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('proportion', String(proportion));
    // Primitive parameter
    url.searchParams.append('diff', String(diff));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_reconfigure(): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_reconfigure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_seek(rate: number, format: GstFormatValue, flags: GstSeekFlagsValue, start_type: GstSeekTypeValue, start: number, stop_type: GstSeekTypeValue, stop: number): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_segment(segment: GstSegment): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_segment_done(format: GstFormatValue, position: number): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_segment_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_select_streams(streams: GLibList): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_select_streams`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (streams && typeof streams === 'object' && 'ptr' in streams) {
      url.searchParams.append('streams', 'ptr,' + streams.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_sink_message(name: string, msg: GstMessage): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_sink_message`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (msg && typeof msg === 'object' && 'ptr' in msg) {
      url.searchParams.append('msg', 'ptr,' + msg.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_step(format: GstFormatValue, amount: number, rate: number, flush: boolean, intermediate: boolean): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_step`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('amount', String(amount));
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    // Primitive parameter
    url.searchParams.append('intermediate', String(intermediate));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_stream_collection(collection: GstStreamCollection): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_stream_group_done(group_id: number): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_stream_group_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_id', String(group_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_stream_start(stream_id: string): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_stream_start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stream_id', String(stream_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_tag(taglist: GstTagList): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (taglist && typeof taglist === 'object' && 'ptr' in taglist) {
      url.searchParams.append('taglist', 'ptr,' + taglist.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_toc(toc: GstToc, updated: boolean): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    // Primitive parameter
    url.searchParams.append('updated', String(updated));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_toc_select(uid: string): Promise<GstEvent> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/new_toc_select`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uid', String(uid));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstEvent(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy_segment(segment: GstSegment): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/copy_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_running_time_offset(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/get_running_time_offset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_seqnum(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/get_seqnum`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_structure(): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_name(name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_name_id(name: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/has_name_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_buffer_size(format: GstFormatValue): Promise<{minsize: number, maxsize: number, async: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_buffer_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: minsize
      result.minsize = (() => {
        return data.minsize;

      })();
      // Handle return parameter: maxsize
      result.maxsize = (() => {
        return data.maxsize;

      })();
      // Handle return parameter: async
      result.async = (() => {
        return data.async;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_caps(caps: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_flush_stop(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_flush_stop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.reset_time;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_gap(): Promise<{timestamp: number, duration: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_gap`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: timestamp
      result.timestamp = (() => {
        return data.timestamp;

      })();
      // Handle return parameter: duration
      result.duration = (() => {
        return data.duration;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_gap_flags(flags: GstGapFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_gap_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_group_id(): Promise<{group_id: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_group_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: group_id
      result.group_id = (() => {
        return data.group_id;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_instant_rate_change(new_flags: GstSegmentFlagsValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_instant_rate_change`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('new_flags', String(new_flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.rate_multiplier;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_instant_rate_sync_time(): Promise<{rate_multiplier: number, running_time: number, upstream_running_time: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_instant_rate_sync_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: rate_multiplier
      result.rate_multiplier = (() => {
        return data.rate_multiplier;

      })();
      // Handle return parameter: running_time
      result.running_time = (() => {
        return data.running_time;

      })();
      // Handle return parameter: upstream_running_time
      result.upstream_running_time = (() => {
        return data.upstream_running_time;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_latency(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_latency`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.latency;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_protection(data_: GstBuffer): Promise<{system_id: string, origin: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_protection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: system_id
      result.system_id = (() => {
        return data.system_id;

      })();
      // Handle return parameter: origin
      result.origin = (() => {
        return data.origin;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_qos(type_: GstQOSTypeValue): Promise<{proportion: number, diff: number, timestamp: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_qos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: proportion
      result.proportion = (() => {
        return data.proportion;

      })();
      // Handle return parameter: diff
      result.diff = (() => {
        return data.diff;

      })();
      // Handle return parameter: timestamp
      result.timestamp = (() => {
        return data.timestamp;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_seek(format: GstFormatValue, flags: GstSeekFlagsValue, start_type: GstSeekTypeValue, stop_type: GstSeekTypeValue): Promise<{rate: number, start: number, stop: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: rate
      result.rate = (() => {
        return data.rate;

      })();
      // Handle return parameter: start
      result.start = (() => {
        return data.start;

      })();
      // Handle return parameter: stop
      result.stop = (() => {
        return data.stop;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_seek_trickmode_interval(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_seek_trickmode_interval`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.interval;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_segment(segment: GstSegment): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_segment_done(format: GstFormatValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_segment_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.position;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_select_streams(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_select_streams`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.streams && typeof data.streams === 'object' && 'ptr' in data.streams) {
  const instance = new GLibList(data.streams.ptr, 'none', string, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_sink_message(msg: GstMessage): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_sink_message`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (msg && typeof msg === 'object' && 'ptr' in msg) {
      url.searchParams.append('msg', 'ptr,' + msg.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_step(format: GstFormatValue): Promise<{amount: number, rate: number, flush: boolean, intermediate: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_step`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: amount
      result.amount = (() => {
        return data.amount;

      })();
      // Handle return parameter: rate
      result.rate = (() => {
        return data.rate;

      })();
      // Handle return parameter: flush
      result.flush = (() => {
        return data.flush;

      })();
      // Handle return parameter: intermediate
      result.intermediate = (() => {
        return data.intermediate;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_stream(stream: GstStream): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (stream && typeof stream === 'object' && 'ptr' in stream) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (stream && typeof stream === 'object' && 'ptr' in stream) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

    





 
  async parse_stream_collection(collection: GstStreamCollection): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

    





 
  async parse_stream_flags(flags: GstStreamFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_stream_group_done(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream_group_done`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.group_id;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_stream_start(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_stream_start`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.stream_id;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_tag(taglist: GstTagList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (taglist && typeof taglist === 'object' && 'ptr' in taglist) {
      url.searchParams.append('taglist', 'ptr,' + taglist.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_toc(toc: GstToc): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.updated;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_toc_select(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/parse_toc_select`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.uid;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_gap_flags(flags: GstGapFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_gap_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_group_id(group_id: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_group_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_id', String(group_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_running_time_offset(offset: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_running_time_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_seek_trickmode_interval(interval: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_seek_trickmode_interval`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_seqnum(seqnum: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_seqnum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seqnum', String(seqnum));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_stream(stream: GstStream): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_stream`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_stream_flags(flags: GstStreamFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/set_stream_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async writable_structure(): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_mini_object(): Promise<GstMiniObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMiniObject(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_mini_object(value_: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type(): Promise<GstEventTypeValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_type(value_: GstEventTypeValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_timestamp(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/fields/timestamp`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_timestamp(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/ptr,${this.ptr}/fields/timestamp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Event/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstFormat {
  export const UNDEFINED: 'undefined' = 'undefined';
  export const DEFAULT: 'default' = 'default';
  export const BYTES: 'bytes' = 'bytes';
  export const TIME: 'time' = 'time';
  export const BUFFERS: 'buffers' = 'buffers';
  export const PERCENT: 'percent' = 'percent';
    





 
  export async function get_by_nick(nick: string): Promise<GstFormatValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/get_by_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_details(format: GstFormatValue): Promise<GstFormatDefinition | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/get_details`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstFormatDefinition(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_name(format: GstFormatValue): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function iterate_definitions(): Promise<GstIterator> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/iterate_definitions`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function register(nick: string, description: string): Promise<GstFormatValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function to_quark(format: GstFormatValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Format/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstFormatValue = "undefined" | "default" | "bytes" | "time" | "buffers" | "percent";

  
// Finalization registry for GstFormatDefinition
const gstformatdefinitionRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/FormatDefinition/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstFormatDefinition:', ptr, err));
});

export class GstFormatDefinition {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstformatdefinitionRegistry.register(this, ptr);
  }


}
  export type GstIteratorFoldFunction = (item: GObjectValue, ret: GObjectValue, user_data: Pointer) => boolean;

export function convertGstIteratorFoldFunctionArgs(data: any): Parameters<GstIteratorFoldFunction> {
  return [
    new GObjectValue(data.item, 'none'),
    new GObjectValue(data.ret, 'none'),
    data.user_data  ];
}
  export type GstIteratorForeachFunction = (item: GObjectValue, user_data: Pointer) => void;

export function convertGstIteratorForeachFunctionArgs(data: any): Parameters<GstIteratorForeachFunction> {
  return [
    new GObjectValue(data.item, 'none'),
    data.user_data  ];
}
  
// Finalization registry for GstIterator
const gstiteratorRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Iterator/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstIterator:', ptr, err));
});

export class GstIterator implements AsyncIterable<GObjectObject> {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstiteratorRegistry.register(this, ptr);
  }
    





 
  static async new_single(type_: string, object: GObjectValue): Promise<GstIterator> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/new_single`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


  // Implement AsyncIterable interface
  [Symbol.asyncIterator](): AsyncIterator<GObjectObject, any, any> {
    let value: GObjectValue | null = null;
    
    return {
      next: async (): Promise<IteratorResult<GObjectObject>> => {
        // Initialize value lazily on first call
        if (!value) {
          value = await GObjectValue.new();
        }
        
        while (true) {
          await value.unset();
          const res = await this.next(value);
          
          switch (res) {
            case GstIteratorResult.DONE:
              return { done: true, value: undefined };
              
            case GstIteratorResult.OK:
              // Get the current value and return it
              const obj = await value.get_object();
              return { done: false, value: obj };
              
            case GstIteratorResult.RESYNC:
              // Iterator was modified, resync and continue
              await this.resync();
              break;
              
            case GstIteratorResult.ERROR:
              throw new Error('Iterator error');
          }
        }
      }
    };
  }

    





 
  async copy(): Promise<GstIterator> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async filter(user_data: GObjectValue, func: GLibCompareFunc): Promise<{func: number, return: GstIterator}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/filter`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (user_data && typeof user_data === 'object' && 'ptr' in user_data) {
      url.searchParams.append('user_data', 'ptr,' + user_data.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibCompareFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GstIterator(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async find_custom(elem: GObjectValue, func: GLibCompareFunc): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/find_custom`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (elem && typeof elem === 'object' && 'ptr' in elem) {
      url.searchParams.append('elem', 'ptr,' + elem.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibCompareFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fold(ret: GObjectValue, func: GstIteratorFoldFunction): Promise<{func: number, return: GstIteratorResultValue}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fold`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ret && typeof ret === 'object' && 'ptr' in ret) {
      url.searchParams.append('ret', 'ptr,' + ret.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstIteratorFoldFunctionArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach(func: GstIteratorForeachFunction): Promise<{func: number, return: GstIteratorResultValue}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstIteratorForeachFunctionArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async next(elem: GObjectValue): Promise<GstIteratorResultValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (elem && typeof elem === 'object' && 'ptr' in elem) {
      url.searchParams.append('elem', 'ptr,' + elem.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async push(other: GstIterator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (other && typeof other === 'object' && 'ptr' in other) {
      url.searchParams.append('other', 'ptr,' + other.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async resync(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/resync`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_copy(): Promise<GstIteratorCopyFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_copy(value_: GstIteratorCopyFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_next(): Promise<GstIteratorNextFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_next(value_: GstIteratorNextFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/next`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_item(): Promise<GstIteratorItemFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/item`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_item(value_: GstIteratorItemFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/item`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_resync(): Promise<GstIteratorResyncFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/resync`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_resync(value_: GstIteratorResyncFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/resync`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_free(): Promise<GstIteratorFreeFunction | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_free(value_: GstIteratorFreeFunction): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_pushed(): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/pushed`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_pushed(value_: GstIterator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/pushed`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_type(value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_lock(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/lock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_lock(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/lock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_cookie(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/cookie`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_cookie(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/cookie`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_master_cookie(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/master_cookie`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_master_cookie(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/master_cookie`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_size(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get__gst_reserved(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/ptr,${this.ptr}/fields/_gst_reserved`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Iterator/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


}
  export namespace GstIteratorResult {
  export const DONE: 'done' = 'done';
  export const OK: 'ok' = 'ok';
  export const RESYNC: 'resync' = 'resync';
  export const ERROR: 'error' = 'error';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/IteratorResult/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstIteratorResultValue = "done" | "ok" | "resync" | "error";

  export type GstIteratorCopyFunction = (it: GstIterator, copy: GstIterator) => void;

export function convertGstIteratorCopyFunctionArgs(data: any): Parameters<GstIteratorCopyFunction> {
  return [
    new GstIterator(data.it, 'none'),
    new GstIterator(data.copy, 'none')  ];
}
  export type GstIteratorNextFunction = (it: GstIterator, result_: GObjectValue) => GstIteratorResultValue;

export function convertGstIteratorNextFunctionArgs(data: any): Parameters<GstIteratorNextFunction> {
  return [
    new GstIterator(data.it, 'none'),
    new GObjectValue(data.result, 'none')  ];
}
  export namespace GstIteratorItem {
  export const SKIP: 'skip' = 'skip';
  export const PASS: 'pass' = 'pass';
  export const END: 'end' = 'end';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/IteratorItem/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstIteratorItemValue = "skip" | "pass" | "end";

  export type GstIteratorItemFunction = (it: GstIterator, item: GObjectValue) => GstIteratorItemValue;

export function convertGstIteratorItemFunctionArgs(data: any): Parameters<GstIteratorItemFunction> {
  return [
    new GstIterator(data.it, 'none'),
    new GObjectValue(data.item, 'none')  ];
}
  export type GstIteratorResyncFunction = (it: GstIterator) => void;

export function convertGstIteratorResyncFunctionArgs(data: any): Parameters<GstIteratorResyncFunction> {
  return [
    new GstIterator(data.it, 'none')  ];
}
  export type GstIteratorFreeFunction = (it: GstIterator) => void;

export function convertGstIteratorFreeFunctionArgs(data: any): Parameters<GstIteratorFreeFunction> {
  return [
    new GstIterator(data.it, 'none')  ];
}
  export namespace GstEventType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const FLUSH_START: 'flush_start' = 'flush_start';
  export const FLUSH_STOP: 'flush_stop' = 'flush_stop';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const CAPS: 'caps' = 'caps';
  export const SEGMENT: 'segment' = 'segment';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const TAG: 'tag' = 'tag';
  export const BUFFERSIZE: 'buffersize' = 'buffersize';
  export const SINK_MESSAGE: 'sink_message' = 'sink_message';
  export const STREAM_GROUP_DONE: 'stream_group_done' = 'stream_group_done';
  export const EOS: 'eos' = 'eos';
  export const TOC: 'toc' = 'toc';
  export const PROTECTION: 'protection' = 'protection';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const GAP: 'gap' = 'gap';
  export const INSTANT_RATE_CHANGE: 'instant_rate_change' = 'instant_rate_change';
  export const QOS: 'qos' = 'qos';
  export const SEEK: 'seek' = 'seek';
  export const NAVIGATION: 'navigation' = 'navigation';
  export const LATENCY: 'latency' = 'latency';
  export const STEP: 'step' = 'step';
  export const RECONFIGURE: 'reconfigure' = 'reconfigure';
  export const TOC_SELECT: 'toc_select' = 'toc_select';
  export const SELECT_STREAMS: 'select_streams' = 'select_streams';
  export const INSTANT_RATE_SYNC_TIME: 'instant_rate_sync_time' = 'instant_rate_sync_time';
  export const CUSTOM_UPSTREAM: 'custom_upstream' = 'custom_upstream';
  export const CUSTOM_DOWNSTREAM: 'custom_downstream' = 'custom_downstream';
  export const CUSTOM_DOWNSTREAM_OOB: 'custom_downstream_oob' = 'custom_downstream_oob';
  export const CUSTOM_DOWNSTREAM_STICKY: 'custom_downstream_sticky' = 'custom_downstream_sticky';
  export const CUSTOM_BOTH: 'custom_both' = 'custom_both';
  export const CUSTOM_BOTH_OOB: 'custom_both_oob' = 'custom_both_oob';
    





 
  export async function get_flags(type_: GstEventTypeValue): Promise<GstEventTypeFlagsValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_name(type_: GstEventTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function to_quark(type_: GstEventTypeValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function to_sticky_ordering(type_: GstEventTypeValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/to_sticky_ordering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstEventTypeValue = "unknown" | "flush_start" | "flush_stop" | "stream_start" | "caps" | "segment" | "stream_collection" | "tag" | "buffersize" | "sink_message" | "stream_group_done" | "eos" | "toc" | "protection" | "segment_done" | "gap" | "instant_rate_change" | "qos" | "seek" | "navigation" | "latency" | "step" | "reconfigure" | "toc_select" | "select_streams" | "instant_rate_sync_time" | "custom_upstream" | "custom_downstream" | "custom_downstream_oob" | "custom_downstream_sticky" | "custom_both" | "custom_both_oob";

  export namespace GstEventTypeFlags {
  export const UPSTREAM: 'upstream' = 'upstream';
  export const DOWNSTREAM: 'downstream' = 'downstream';
  export const SERIALIZED: 'serialized' = 'serialized';
  export const STICKY: 'sticky' = 'sticky';
  export const STICKY_MULTI: 'sticky_multi' = 'sticky_multi';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/EventTypeFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstEventTypeFlagsValue = "upstream" | "downstream" | "serialized" | "sticky" | "sticky_multi";

  export namespace GstSegmentFlags {
  export const NONE: 'none' = 'none';
  export const RESET: 'reset' = 'reset';
  export const TRICKMODE: 'trickmode' = 'trickmode';
  export const SKIP: 'skip' = 'skip';
  export const SEGMENT: 'segment' = 'segment';
  export const TRICKMODE_KEY_UNITS: 'trickmode_key_units' = 'trickmode_key_units';
  export const TRICKMODE_FORWARD_PREDICTED: 'trickmode_forward_predicted' = 'trickmode_forward_predicted';
  export const TRICKMODE_NO_AUDIO: 'trickmode_no_audio' = 'trickmode_no_audio';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SegmentFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstSegmentFlagsValue = "none" | "reset" | "trickmode" | "skip" | "segment" | "trickmode_key_units" | "trickmode_forward_predicted" | "trickmode_no_audio";

  export namespace GstQOSType {
  export const OVERFLOW: 'overflow' = 'overflow';
  export const UNDERFLOW: 'underflow' = 'underflow';
  export const THROTTLE: 'throttle' = 'throttle';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QOSType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstQOSTypeValue = "overflow" | "underflow" | "throttle";

  export namespace GstSeekFlags {
  export const NONE: 'none' = 'none';
  export const FLUSH: 'flush' = 'flush';
  export const ACCURATE: 'accurate' = 'accurate';
  export const KEY_UNIT: 'key_unit' = 'key_unit';
  export const SEGMENT: 'segment' = 'segment';
  export const TRICKMODE: 'trickmode' = 'trickmode';
  export const SKIP: 'skip' = 'skip';
  export const SNAP_BEFORE: 'snap_before' = 'snap_before';
  export const SNAP_AFTER: 'snap_after' = 'snap_after';
  export const SNAP_NEAREST: 'snap_nearest' = 'snap_nearest';
  export const TRICKMODE_KEY_UNITS: 'trickmode_key_units' = 'trickmode_key_units';
  export const TRICKMODE_NO_AUDIO: 'trickmode_no_audio' = 'trickmode_no_audio';
  export const TRICKMODE_FORWARD_PREDICTED: 'trickmode_forward_predicted' = 'trickmode_forward_predicted';
  export const INSTANT_RATE_CHANGE: 'instant_rate_change' = 'instant_rate_change';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SeekFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstSeekFlagsValue = "none" | "flush" | "accurate" | "key_unit" | "segment" | "trickmode" | "skip" | "snap_before" | "snap_after" | "snap_nearest" | "trickmode_key_units" | "trickmode_no_audio" | "trickmode_forward_predicted" | "instant_rate_change";

  export namespace GstSeekType {
  export const NONE: 'none' = 'none';
  export const SET: 'set' = 'set';
  export const END: 'end' = 'end';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SeekType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstSeekTypeValue = "none" | "set" | "end";

  
// Finalization registry for GstSegment
const gstsegmentRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Segment/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstSegment:', ptr, err));
});

export class GstSegment {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstsegmentRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstSegment> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstSegment(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async clip(format: GstFormatValue, start: number, stop: number): Promise<{clip_start: number, clip_stop: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/clip`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: clip_start
      result.clip_start = (() => {
        return data.clip_start;

      })();
      // Handle return parameter: clip_stop
      result.clip_stop = (() => {
        return data.clip_stop;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy(): Promise<GstSegment> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstSegment(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy_into(dest: GstSegment): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/copy_into`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async do_seek(rate: number, format: GstFormatValue, flags: GstSeekFlagsValue, start_type: GstSeekTypeValue, start: number, stop_type: GstSeekTypeValue, stop: number): Promise<{update: boolean, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/do_seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: update
      result.update = (() => {
        return data.update;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async init(format: GstFormatValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_equal(s1: GstSegment): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (s1 && typeof s1 === 'object' && 'ptr' in s1) {
      url.searchParams.append('s1', 'ptr,' + s1.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async offset_running_time(format: GstFormatValue, offset: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/offset_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async position_from_running_time(format: GstFormatValue, running_time: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/position_from_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async position_from_running_time_full(format: GstFormatValue, running_time: number): Promise<{position: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/position_from_running_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: position
      result.position = (() => {
        return data.position;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async position_from_stream_time(format: GstFormatValue, stream_time: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/position_from_stream_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('stream_time', String(stream_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async position_from_stream_time_full(format: GstFormatValue, stream_time: number): Promise<{position: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/position_from_stream_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('stream_time', String(stream_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: position
      result.position = (() => {
        return data.position;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_running_time(format: GstFormatValue, running_time: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/set_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_position(format: GstFormatValue, running_time: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_running_time(format: GstFormatValue, position: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_running_time_full(format: GstFormatValue, position: number): Promise<{running_time: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_running_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: running_time
      result.running_time = (() => {
        return data.running_time;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_stream_time(format: GstFormatValue, position: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_stream_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_stream_time_full(format: GstFormatValue, position: number): Promise<{stream_time: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/to_stream_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: stream_time
      result.stream_time = (() => {
        return data.stream_time;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_flags(): Promise<GstSegmentFlagsValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_flags(value_: GstSegmentFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_rate(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/rate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_rate(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/rate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_applied_rate(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/applied_rate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_applied_rate(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/applied_rate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_format(): Promise<GstFormatValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/format`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_format(value_: GstFormatValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/format`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_base(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/base`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_base(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/base`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_offset(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/offset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_offset(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_start(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/start`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_start(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_stop(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/stop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_stop(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/stop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_time(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_position(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/position`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_position(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_duration(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/duration`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_duration(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get__gst_reserved(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/ptr,${this.ptr}/fields/_gst_reserved`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Segment/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstMessage
const gstmessageRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Message/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMessage:', ptr, err));
});

export class GstMessage {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstmessageRegistry.register(this, ptr);
  }
    





 
  static async new_application(structure: GstStructure, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_application`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_async_done(running_time: number, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_async_done`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_async_start(src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_async_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_buffering(percent: number, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_buffering`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('percent', String(percent));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_clock_lost(clock: GstClock, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_clock_lost`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_clock_provide(clock: GstClock, ready: boolean, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_clock_provide`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    // Primitive parameter
    url.searchParams.append('ready', String(ready));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_custom(type_: GstMessageTypeValue, src?: GstObject, structure?: GstStructure): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_device_added(device: GstDevice, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_device_added`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_device_changed(device: GstDevice, changed_device: GstDevice, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_device_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      url.searchParams.append('changed_device', 'ptr,' + changed_device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_device_removed(device: GstDevice, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_device_removed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_duration_changed(src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_duration_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_element(structure: GstStructure, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_element`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_eos(src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_eos`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_error(error_: Pointer, debug: string, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_error`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_error_with_details(error_: Pointer, debug: string, src?: GstObject, details?: GstStructure): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_error_with_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    // Object with explode=false: serialize as comma-separated
    if (details !== undefined && typeof details === 'object' && 'ptr' in details) {
      url.searchParams.append('details', 'ptr,' + details.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_have_context(context: GstContext, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_have_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (context && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_info(error_: Pointer, debug: string, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_info`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_info_with_details(error_: Pointer, debug: string, src?: GstObject, details?: GstStructure): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_info_with_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    // Object with explode=false: serialize as comma-separated
    if (details !== undefined && typeof details === 'object' && 'ptr' in details) {
      url.searchParams.append('details', 'ptr,' + details.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_instant_rate_request(rate_multiplier: number, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_instant_rate_request`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('rate_multiplier', String(rate_multiplier));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_latency(src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_latency`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_need_context(context_type: string, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_need_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_new_clock(clock: GstClock, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_new_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_progress(type_: GstProgressTypeValue, code: string, text: string, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_progress`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    url.searchParams.append('text', String(text));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_property_notify(src: GstObject, property_name: string, val?: GObjectValue): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_property_notify`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Object with explode=false: serialize as comma-separated
    if (val !== undefined && typeof val === 'object' && 'ptr' in val) {
      url.searchParams.append('val', 'ptr,' + val.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_qos(live: boolean, running_time: number, stream_time: number, timestamp: number, duration: number, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_qos`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('live', String(live));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    // Primitive parameter
    url.searchParams.append('stream_time', String(stream_time));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_redirect(location: string, src?: GstObject, tag_list?: GstTagList, entry_struct?: GstStructure): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_redirect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Object with explode=false: serialize as comma-separated
    if (tag_list !== undefined && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (entry_struct !== undefined && typeof entry_struct === 'object' && 'ptr' in entry_struct) {
      url.searchParams.append('entry_struct', 'ptr,' + entry_struct.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_request_state(state: GstStateValue, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_request_state`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('state', String(state));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_reset_time(running_time: number, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_reset_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_segment_done(format: GstFormatValue, position: number, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_segment_done`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_segment_start(format: GstFormatValue, position: number, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_segment_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_state_changed(oldstate: GstStateValue, newstate: GstStateValue, pending: GstStateValue, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_state_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('oldstate', String(oldstate));
    // Primitive parameter
    url.searchParams.append('newstate', String(newstate));
    // Primitive parameter
    url.searchParams.append('pending', String(pending));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_state_dirty(src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_state_dirty`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_step_done(format: GstFormatValue, amount: number, rate: number, flush: boolean, intermediate: boolean, duration: number, eos: boolean, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_step_done`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('amount', String(amount));
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    // Primitive parameter
    url.searchParams.append('intermediate', String(intermediate));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    // Primitive parameter
    url.searchParams.append('eos', String(eos));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_step_start(active: boolean, format: GstFormatValue, amount: number, rate: number, flush: boolean, intermediate: boolean, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_step_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('amount', String(amount));
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    // Primitive parameter
    url.searchParams.append('intermediate', String(intermediate));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_stream_collection(collection: GstStreamCollection, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_stream_start(src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_stream_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_stream_status(type_: GstStreamStatusTypeValue, owner: GstElement, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_stream_status`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_streams_selected(collection: GstStreamCollection, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_streams_selected`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_structure_change(type_: GstStructureChangeTypeValue, owner: GstElement, busy: boolean, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_structure_change`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    // Primitive parameter
    url.searchParams.append('busy', String(busy));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_tag(tag_list: GstTagList, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (tag_list && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_toc(toc: GstToc, updated: boolean, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    // Primitive parameter
    url.searchParams.append('updated', String(updated));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_warning(error_: Pointer, debug: string, src?: GstObject): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_warning`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_warning_with_details(error_: Pointer, debug: string, src?: GstObject, details?: GstStructure): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/new_warning_with_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    // Object with explode=false: serialize as comma-separated
    if (details !== undefined && typeof details === 'object' && 'ptr' in details) {
      url.searchParams.append('details', 'ptr,' + details.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_redirect_entry(location: string, tag_list?: GstTagList, entry_struct?: GstStructure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/add_redirect_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Object with explode=false: serialize as comma-separated
    if (tag_list !== undefined && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (entry_struct !== undefined && typeof entry_struct === 'object' && 'ptr' in entry_struct) {
      url.searchParams.append('entry_struct', 'ptr,' + entry_struct.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_num_redirect_entries(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/get_num_redirect_entries`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_seqnum(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/get_seqnum`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_stream_status_object(): Promise<GObjectValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/get_stream_status_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_structure(): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_name(name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_async_done(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_async_done`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.running_time;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_buffering(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_buffering`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.percent;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_buffering_stats(mode: GstBufferingModeValue): Promise<{avg_in: number, avg_out: number, buffering_left: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: avg_in
      result.avg_in = (() => {
        return data.avg_in;

      })();
      // Handle return parameter: avg_out
      result.avg_out = (() => {
        return data.avg_out;

      })();
      // Handle return parameter: buffering_left
      result.buffering_left = (() => {
        return data.buffering_left;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_clock_lost(clock: GstClock): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_clock_lost`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_clock_provide(clock: GstClock): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_clock_provide`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.ready;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_context_type(): Promise<{context_type: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_context_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: context_type
      result.context_type = (() => {
        return data.context_type;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_device_added(device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (device && typeof device === 'object' && 'ptr' in device) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_device_added`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

    





 
  async parse_device_changed(device: GstDevice, changed_device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (device && typeof device === 'object' && 'ptr' in device) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/ref').catch(() => {});
    }
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + changed_device.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_device_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      url.searchParams.append('changed_device', 'ptr,' + changed_device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + changed_device.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + changed_device.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

    





 
  async parse_device_removed(device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (device && typeof device === 'object' && 'ptr' in device) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_device_removed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

    





 
  async parse_error(): Promise<{gerror: Pointer, debug: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_error`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: gerror
      result.gerror = (() => {
        return data.gerror;

      })();
      // Handle return parameter: debug
      result.debug = (() => {
        return data.debug;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_error_details(structure?: GstStructure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_error_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_group_id(): Promise<{group_id: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_group_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: group_id
      result.group_id = (() => {
        return data.group_id;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_have_context(context: GstContext): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_have_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_info(): Promise<{gerror: Pointer, debug: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: gerror
      result.gerror = (() => {
        return data.gerror;

      })();
      // Handle return parameter: debug
      result.debug = (() => {
        return data.debug;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_info_details(structure?: GstStructure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_info_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_instant_rate_request(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_instant_rate_request`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.rate_multiplier;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_new_clock(clock: GstClock): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_new_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_progress(type_: GstProgressTypeValue): Promise<{code: string, text: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_progress`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: code
      result.code = (() => {
        return data.code;

      })();
      // Handle return parameter: text
      result.text = (() => {
        return data.text;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_property_notify(object: GstObject, property_value?: GObjectValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_property_notify`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (property_value !== undefined && typeof property_value === 'object' && 'ptr' in property_value) {
      url.searchParams.append('property_value', 'ptr,' + property_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.property_name;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_qos(): Promise<{live: boolean, running_time: number, stream_time: number, timestamp: number, duration: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_qos`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: live
      result.live = (() => {
        return data.live;

      })();
      // Handle return parameter: running_time
      result.running_time = (() => {
        return data.running_time;

      })();
      // Handle return parameter: stream_time
      result.stream_time = (() => {
        return data.stream_time;

      })();
      // Handle return parameter: timestamp
      result.timestamp = (() => {
        return data.timestamp;

      })();
      // Handle return parameter: duration
      result.duration = (() => {
        return data.duration;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_qos_stats(format: GstFormatValue): Promise<{processed: number, dropped: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_qos_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: processed
      result.processed = (() => {
        return data.processed;

      })();
      // Handle return parameter: dropped
      result.dropped = (() => {
        return data.dropped;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_qos_values(): Promise<{jitter: number, proportion: number, quality: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_qos_values`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: jitter
      result.jitter = (() => {
        return data.jitter;

      })();
      // Handle return parameter: proportion
      result.proportion = (() => {
        return data.proportion;

      })();
      // Handle return parameter: quality
      result.quality = (() => {
        return data.quality;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_redirect_entry(entry_index: number, tag_list?: GstTagList, entry_struct?: GstStructure): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_redirect_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('entry_index', String(entry_index));
    // Object with explode=false: serialize as comma-separated
    if (tag_list !== undefined && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (entry_struct !== undefined && typeof entry_struct === 'object' && 'ptr' in entry_struct) {
      url.searchParams.append('entry_struct', 'ptr,' + entry_struct.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.location;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_request_state(state: GstStateValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_request_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_reset_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_reset_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.running_time;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_segment_done(format: GstFormatValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_segment_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.position;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_segment_start(format: GstFormatValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_segment_start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.position;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_state_changed(oldstate: GstStateValue, newstate: GstStateValue, pending: GstStateValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_state_changed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('oldstate', String(oldstate));
    // Primitive parameter
    url.searchParams.append('newstate', String(newstate));
    // Primitive parameter
    url.searchParams.append('pending', String(pending));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_step_done(format: GstFormatValue): Promise<{amount: number, rate: number, flush: boolean, intermediate: boolean, duration: number, eos: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_step_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: amount
      result.amount = (() => {
        return data.amount;

      })();
      // Handle return parameter: rate
      result.rate = (() => {
        return data.rate;

      })();
      // Handle return parameter: flush
      result.flush = (() => {
        return data.flush;

      })();
      // Handle return parameter: intermediate
      result.intermediate = (() => {
        return data.intermediate;

      })();
      // Handle return parameter: duration
      result.duration = (() => {
        return data.duration;

      })();
      // Handle return parameter: eos
      result.eos = (() => {
        return data.eos;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_step_start(format: GstFormatValue): Promise<{active: boolean, amount: number, rate: number, flush: boolean, intermediate: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_step_start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: active
      result.active = (() => {
        return data.active;

      })();
      // Handle return parameter: amount
      result.amount = (() => {
        return data.amount;

      })();
      // Handle return parameter: rate
      result.rate = (() => {
        return data.rate;

      })();
      // Handle return parameter: flush
      result.flush = (() => {
        return data.flush;

      })();
      // Handle return parameter: intermediate
      result.intermediate = (() => {
        return data.intermediate;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_stream_collection(collection: GstStreamCollection): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

    





 
  async parse_stream_status(type_: GstStreamStatusTypeValue, owner: GstElement): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_stream_status`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_streams_selected(collection: GstStreamCollection): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_streams_selected`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

    





 
  async parse_structure_change(type_: GstStructureChangeTypeValue, owner: GstElement): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_structure_change`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.busy;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_tag(tag_list: GstTagList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tag_list && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_toc(toc: GstToc): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.updated;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_warning(): Promise<{gerror: Pointer, debug: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_warning`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: gerror
      result.gerror = (() => {
        return data.gerror;

      })();
      // Handle return parameter: debug
      result.debug = (() => {
        return data.debug;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_warning_details(structure?: GstStructure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/parse_warning_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_buffering_stats(mode: GstBufferingModeValue, avg_in: number, avg_out: number, buffering_left: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('avg_in', String(avg_in));
    // Primitive parameter
    url.searchParams.append('avg_out', String(avg_out));
    // Primitive parameter
    url.searchParams.append('buffering_left', String(buffering_left));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_group_id(group_id: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_group_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_id', String(group_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_qos_stats(format: GstFormatValue, processed: number, dropped: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_qos_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('processed', String(processed));
    // Primitive parameter
    url.searchParams.append('dropped', String(dropped));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_qos_values(jitter: number, proportion: number, quality: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_qos_values`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('jitter', String(jitter));
    // Primitive parameter
    url.searchParams.append('proportion', String(proportion));
    // Primitive parameter
    url.searchParams.append('quality', String(quality));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_seqnum(seqnum: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_seqnum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seqnum', String(seqnum));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_stream_status_object(object: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/set_stream_status_object`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async streams_selected_add(stream: GstStream): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/streams_selected_add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async streams_selected_get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/streams_selected_get_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async streams_selected_get_stream(idx: number): Promise<GstStream | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/streams_selected_get_stream`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstStream(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async writable_structure(): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_mini_object(): Promise<GstMiniObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMiniObject(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_mini_object(value_: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type(): Promise<GstMessageTypeValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_type(value_: GstMessageTypeValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_timestamp(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/timestamp`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_timestamp(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/timestamp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_src(): Promise<GstObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/src`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstObject(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_src(value_: GstObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/src`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_lock(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/lock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_cond(): Promise<GLibCond | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/ptr,${this.ptr}/fields/cond`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibCond(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Message/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstControlBinding extends GstObject {




      





 
  async get_g_value_array_2(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/get_g_value_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_value_2(timestamp: number): Promise<GObjectValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_disabled(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/is_disabled`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_disabled(disabled: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/set_disabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('disabled', String(disabled));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async sync_values_2(object: GstObject, timestamp: number, last_sync: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/ptr,${this.ptr}/sync_values`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('last_sync', String(last_sync));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlBinding/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GstClockCallback = (clock: GstClock, time: number, id: Pointer, user_data: Pointer) => boolean;

export function convertGstClockCallbackArgs(data: any): Parameters<GstClockCallback> {
  return [
    new GstClock(data.clock, 'none'),
    data.time,
    data.id,
    data.user_data  ];
}
  
export class GstClock extends GstObject {




      





 
  static async id_compare_func(id1?: Pointer, id2?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_compare_func`, apiConfig.baseUrl);
    // Primitive parameter
    if (id1 !== undefined) url.searchParams.append('id1', String(id1));
    // Primitive parameter
    if (id2 !== undefined) url.searchParams.append('id2', String(id2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async id_get_clock(id: Pointer): Promise<GstClock | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_get_clock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstClock(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async id_get_time(id: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_get_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async id_ref(id: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async id_unref(id: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async id_unschedule(id: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_unschedule`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async id_uses_clock(id: Pointer, clock: GstClock): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_uses_clock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async id_wait(id: Pointer): Promise<{jitter: number, return: GstClockReturnValue}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_wait`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: jitter
      result.jitter = (() => {
        return data.jitter;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async id_wait_async(id: Pointer, func: GstClockCallback): Promise<{func: number, return: GstClockReturnValue}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/id_wait_async`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstClockCallbackArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_observation(slave: number, master: number): Promise<{r_squared: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/add_observation`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('slave', String(slave));
    // Primitive parameter
    url.searchParams.append('master', String(master));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: r_squared
      result.r_squared = (() => {
        return data.r_squared;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_observation_unapplied(slave: number, master: number): Promise<{r_squared: number, internal: number, external: number, rate_num: number, rate_denom: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/add_observation_unapplied`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('slave', String(slave));
    // Primitive parameter
    url.searchParams.append('master', String(master));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: r_squared
      result.r_squared = (() => {
        return data.r_squared;

      })();
      // Handle return parameter: internal
      result.internal = (() => {
        return data.internal;

      })();
      // Handle return parameter: external
      result.external = (() => {
        return data.external;

      })();
      // Handle return parameter: rate_num
      result.rate_num = (() => {
        return data.rate_num;

      })();
      // Handle return parameter: rate_denom
      result.rate_denom = (() => {
        return data.rate_denom;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async adjust_unlocked(internal: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/adjust_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('internal', String(internal));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async adjust_with_calibration(internal_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/adjust_with_calibration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('internal_target', String(internal_target));
    // Primitive parameter
    url.searchParams.append('cinternal', String(cinternal));
    // Primitive parameter
    url.searchParams.append('cexternal', String(cexternal));
    // Primitive parameter
    url.searchParams.append('cnum', String(cnum));
    // Primitive parameter
    url.searchParams.append('cdenom', String(cdenom));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_calibration(): Promise<{internal: number, external: number, rate_num: number, rate_denom: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_calibration`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: internal
      result.internal = (() => {
        return data.internal;

      })();
      // Handle return parameter: external
      result.external = (() => {
        return data.external;

      })();
      // Handle return parameter: rate_num
      result.rate_num = (() => {
        return data.rate_num;

      })();
      // Handle return parameter: rate_denom
      result.rate_denom = (() => {
        return data.rate_denom;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_internal_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_internal_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_master(): Promise<GstClock | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_master`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstClock(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_resolution(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_resolution`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_timeout(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/get_timeout`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_synced(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/is_synced`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async new_periodic_id(start_time: number, interval: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/new_periodic_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start_time', String(start_time));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async new_single_shot_id(time: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/new_single_shot_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async periodic_id_reinit(id: Pointer, start_time: number, interval: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/periodic_id_reinit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    // Primitive parameter
    url.searchParams.append('start_time', String(start_time));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_calibration(internal: number, external: number, rate_num: number, rate_denom: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_calibration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('internal', String(internal));
    // Primitive parameter
    url.searchParams.append('external', String(external));
    // Primitive parameter
    url.searchParams.append('rate_num', String(rate_num));
    // Primitive parameter
    url.searchParams.append('rate_denom', String(rate_denom));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_master(master?: GstClock): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_master`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (master !== undefined && typeof master === 'object' && 'ptr' in master) {
      url.searchParams.append('master', 'ptr,' + master.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_resolution(resolution: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_resolution`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('resolution', String(resolution));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_synced(synced: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_synced`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('synced', String(synced));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_timeout(timeout: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/set_timeout`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async single_shot_id_reinit(id: Pointer, time: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/single_shot_id_reinit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    // Primitive parameter
    url.searchParams.append('time', String(time));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unadjust_unlocked(external: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/unadjust_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('external', String(external));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unadjust_with_calibration(external_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/unadjust_with_calibration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('external_target', String(external_target));
    // Primitive parameter
    url.searchParams.append('cinternal', String(cinternal));
    // Primitive parameter
    url.searchParams.append('cexternal', String(cexternal));
    // Primitive parameter
    url.searchParams.append('cnum', String(cnum));
    // Primitive parameter
    url.searchParams.append('cdenom', String(cdenom));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async wait_for_sync(timeout: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/ptr,${this.ptr}/wait_for_sync`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Clock/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstClockReturn {
  export const OK: 'ok' = 'ok';
  export const EARLY: 'early' = 'early';
  export const UNSCHEDULED: 'unscheduled' = 'unscheduled';
  export const BUSY: 'busy' = 'busy';
  export const BADTIME: 'badtime' = 'badtime';
  export const ERROR: 'error' = 'error';
  export const UNSUPPORTED: 'unsupported' = 'unsupported';
  export const DONE: 'done' = 'done';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ClockReturn/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstClockReturnValue = "ok" | "early" | "unscheduled" | "busy" | "badtime" | "error" | "unsupported" | "done";

  export namespace GstMessageType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const EOS: 'eos' = 'eos';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const INFO: 'info' = 'info';
  export const TAG: 'tag' = 'tag';
  export const BUFFERING: 'buffering' = 'buffering';
  export const STATE_CHANGED: 'state_changed' = 'state_changed';
  export const STATE_DIRTY: 'state_dirty' = 'state_dirty';
  export const STEP_DONE: 'step_done' = 'step_done';
  export const CLOCK_PROVIDE: 'clock_provide' = 'clock_provide';
  export const CLOCK_LOST: 'clock_lost' = 'clock_lost';
  export const NEW_CLOCK: 'new_clock' = 'new_clock';
  export const STRUCTURE_CHANGE: 'structure_change' = 'structure_change';
  export const STREAM_STATUS: 'stream_status' = 'stream_status';
  export const APPLICATION: 'application' = 'application';
  export const ELEMENT: 'element' = 'element';
  export const SEGMENT_START: 'segment_start' = 'segment_start';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const DURATION_CHANGED: 'duration_changed' = 'duration_changed';
  export const LATENCY: 'latency' = 'latency';
  export const ASYNC_START: 'async_start' = 'async_start';
  export const ASYNC_DONE: 'async_done' = 'async_done';
  export const REQUEST_STATE: 'request_state' = 'request_state';
  export const STEP_START: 'step_start' = 'step_start';
  export const QOS: 'qos' = 'qos';
  export const PROGRESS: 'progress' = 'progress';
  export const TOC: 'toc' = 'toc';
  export const RESET_TIME: 'reset_time' = 'reset_time';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const NEED_CONTEXT: 'need_context' = 'need_context';
  export const HAVE_CONTEXT: 'have_context' = 'have_context';
  export const EXTENDED: 'extended' = 'extended';
  export const DEVICE_ADDED: 'device_added' = 'device_added';
  export const DEVICE_REMOVED: 'device_removed' = 'device_removed';
  export const PROPERTY_NOTIFY: 'property_notify' = 'property_notify';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const STREAMS_SELECTED: 'streams_selected' = 'streams_selected';
  export const REDIRECT: 'redirect' = 'redirect';
  export const DEVICE_CHANGED: 'device_changed' = 'device_changed';
  export const INSTANT_RATE_REQUEST: 'instant_rate_request' = 'instant_rate_request';
  export const ANY: 'any' = 'any';
    





 
  export async function get_name(type_: GstMessageTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MessageType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function to_quark(type_: GstMessageTypeValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MessageType/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MessageType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstMessageTypeValue = "unknown" | "eos" | "error" | "warning" | "info" | "tag" | "buffering" | "state_changed" | "state_dirty" | "step_done" | "clock_provide" | "clock_lost" | "new_clock" | "structure_change" | "stream_status" | "application" | "element" | "segment_start" | "segment_done" | "duration_changed" | "latency" | "async_start" | "async_done" | "request_state" | "step_start" | "qos" | "progress" | "toc" | "reset_time" | "stream_start" | "need_context" | "have_context" | "extended" | "device_added" | "device_removed" | "property_notify" | "stream_collection" | "streams_selected" | "redirect" | "device_changed" | "instant_rate_request" | "any";

  
export class GstDevice extends GstObject {




      





 
  async create_element(name?: string): Promise<GstElement | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/create_element`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_caps(): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_device_class(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/get_device_class`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_display_name(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/get_display_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_properties(): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/get_properties`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_classes(classes: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/has_classes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('classes', String(classes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_classesv(classes: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/has_classesv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('classes', String(classes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async reconfigure_element(element: GstElement): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/ptr,${this.ptr}/reconfigure_element`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Device/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstContext
const gstcontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Context/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstContext:', ptr, err));
});

export class GstContext {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstcontextRegistry.register(this, ptr);
  }
    





 
  static async new(context_type: string, persistent: boolean): Promise<GstContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    // Primitive parameter
    url.searchParams.append('persistent', String(persistent));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_context_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/get_context_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_structure(): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_context_type(context_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/has_context_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_persistent(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/is_persistent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async writable_structure(): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Context/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstProgressType {
  export const START: 'start' = 'start';
  export const CONTINUE: 'continue' = 'continue';
  export const COMPLETE: 'complete' = 'complete';
  export const CANCELED: 'canceled' = 'canceled';
  export const ERROR: 'error' = 'error';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProgressType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstProgressTypeValue = "start" | "continue" | "complete" | "canceled" | "error";

  export type GstTagForeachFunc = (list: GstTagList, tag: string, user_data: Pointer) => void;

export function convertGstTagForeachFuncArgs(data: any): Parameters<GstTagForeachFunc> {
  return [
    new GstTagList(data.list, 'none'),
    data.tag,
    data.user_data  ];
}
  
// Finalization registry for GstTagList
const gsttaglistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/TagList/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstTagList:', ptr, err));
});

export class GstTagList {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gsttaglistRegistry.register(this, ptr);
  }
    





 
  static async new_empty(): Promise<GstTagList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/new_empty`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTagList(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_string(str: string): Promise<GstTagList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/new_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTagList(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_value(mode: GstTagMergeModeValue, tag: string, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/add_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async copy(): Promise<GstTagList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTagList(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async foreach(func: GstTagForeachFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstTagForeachFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_boolean(tag: string): Promise<{value: boolean, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_boolean_index(tag: string, index: number): Promise<{value: boolean, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_boolean_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_date(tag: string, value_: GLibDate): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_date`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_date_index(tag: string, index: number, value_: GLibDate): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_date_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_date_time(tag: string, value_: GstDateTime): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_date_time_index(tag: string, index: number, value_: GstDateTime): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_date_time_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_double(tag: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_double_index(tag: string, index: number): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_double_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_float(tag: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_float`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_float_index(tag: string, index: number): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_float_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int(tag: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int64(tag: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int64_index(tag: string, index: number): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_int64_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_int_index(tag: string, index: number): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_int_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_pointer(tag: string): Promise<{value: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_pointer_index(tag: string, index: number): Promise<{value: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_pointer_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_sample(tag: string, sample: GstSample): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_sample`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (sample && typeof sample === 'object' && 'ptr' in sample) {
      url.searchParams.append('sample', 'ptr,' + sample.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_sample_index(tag: string, index: number, sample: GstSample): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_sample_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (sample && typeof sample === 'object' && 'ptr' in sample) {
      url.searchParams.append('sample', 'ptr,' + sample.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_scope(): Promise<GstTagScopeValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_scope`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string(tag: string): Promise<{value: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_string_index(tag: string, index: number): Promise<{value: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_string_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_tag_size(tag: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_tag_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint(tag: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint64(tag: string): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint64_index(tag: string, index: number): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_uint64_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uint_index(tag: string, index: number): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_uint_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_value_index(tag: string, index: number): Promise<GObjectValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/get_value_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async insert(from: GstTagList, mode: GstTagMergeModeValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (from && typeof from === 'object' && 'ptr' in from) {
      url.searchParams.append('from', 'ptr,' + from.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_empty(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_equal(list2: GstTagList): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list2 && typeof list2 === 'object' && 'ptr' in list2) {
      url.searchParams.append('list2', 'ptr,' + list2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async merge(mode: GstTagMergeModeValue, list2?: GstTagList): Promise<GstTagList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/merge`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list2 !== undefined && typeof list2 === 'object' && 'ptr' in list2) {
      url.searchParams.append('list2', 'ptr,' + list2.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTagList(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async n_tags(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/n_tags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async nth_tag_name(index: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/nth_tag_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek_string_index(tag: string, index: number): Promise<{value: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/peek_string_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_tag(tag: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/remove_tag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_scope(scope: GstTagScopeValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/set_scope`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope', String(scope));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async copy_value(dest: GObjectValue, list: GstTagList, tag: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/copy_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_mini_object(): Promise<GstMiniObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMiniObject(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_mini_object(value_: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagList/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstTagMergeMode {
  export const UNDEFINED: 'undefined' = 'undefined';
  export const REPLACE_ALL: 'replace_all' = 'replace_all';
  export const REPLACE: 'replace' = 'replace';
  export const APPEND: 'append' = 'append';
  export const PREPEND: 'prepend' = 'prepend';
  export const KEEP: 'keep' = 'keep';
  export const KEEP_ALL: 'keep_all' = 'keep_all';
  export const COUNT: 'count' = 'count';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagMergeMode/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTagMergeModeValue = "undefined" | "replace_all" | "replace" | "append" | "prepend" | "keep" | "keep_all" | "count";

  
// Finalization registry for GstSample
const gstsampleRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Sample/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstSample:', ptr, err));
});

export class GstSample {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstsampleRegistry.register(this, ptr);
  }
    





 
  static async new(buffer?: GstBuffer, caps?: GstCaps, segment?: GstSegment, info?: GstStructure): Promise<GstSample> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer !== undefined && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (segment !== undefined && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (info !== undefined && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstSample(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_buffer(): Promise<GstBuffer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_buffer`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBuffer(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_buffer_list(): Promise<GstBufferList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_buffer_list`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstBufferList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_caps(): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_info(): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_segment(): Promise<GstSegment> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/get_segment`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstSegment(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_buffer(buffer: GstBuffer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_buffer_list(buffer_list: GstBufferList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_buffer_list`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer_list && typeof buffer_list === 'object' && 'ptr' in buffer_list) {
      url.searchParams.append('buffer_list', 'ptr,' + buffer_list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_caps(caps: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_info(info: GstStructure): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_info`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_segment(segment: GstSegment): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/ptr,${this.ptr}/set_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Sample/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstTagScope {
  export const STREAM: 'stream' = 'stream';
  export const GLOBAL: 'global' = 'global';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagScope/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTagScopeValue = "stream" | "global";

  
export class GstStreamCollection extends GstObject {


    





 
  static async new(upstream_id?: string): Promise<GstStreamCollection> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (upstream_id !== undefined) url.searchParams.append('upstream_id', String(upstream_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstStreamCollection(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async add_stream(stream: GstStream): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/ptr,${this.ptr}/add_stream`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (stream && typeof stream === 'object' && 'ptr' in stream) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (stream && typeof stream === 'object' && 'ptr' in stream) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

      





 
  async get_size(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_stream(index: number): Promise<GstStream | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/ptr,${this.ptr}/get_stream`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstStream(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_upstream_id(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/ptr,${this.ptr}/get_upstream_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamCollection/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstStream extends GstObject {


    





 
  static async new(type_: GstStreamTypeValue, flags: GstStreamFlagsValue, stream_id?: string, caps?: GstCaps): Promise<GstStream> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (stream_id !== undefined) url.searchParams.append('stream_id', String(stream_id));
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstStream(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async get_caps(): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_stream_flags(): Promise<GstStreamFlagsValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_stream_flags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_stream_id(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_stream_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_stream_type(): Promise<GstStreamTypeValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_stream_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_tags(): Promise<GstTagList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/get_tags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTagList(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_caps(caps?: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/set_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_stream_flags(flags: GstStreamFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/set_stream_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_stream_type(stream_type: GstStreamTypeValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/set_stream_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stream_type', String(stream_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_tags(tags?: GstTagList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/ptr,${this.ptr}/set_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Stream/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstStreamType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const AUDIO: 'audio' = 'audio';
  export const VIDEO: 'video' = 'video';
  export const CONTAINER: 'container' = 'container';
  export const TEXT: 'text' = 'text';
    





 
  export async function get_name(stype: GstStreamTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stype', String(stype));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstStreamTypeValue = "unknown" | "audio" | "video" | "container" | "text";

  export namespace GstStreamFlags {
  export const NONE: 'none' = 'none';
  export const SPARSE: 'sparse' = 'sparse';
  export const SELECT: 'select' = 'select';
  export const UNSELECT: 'unselect' = 'unselect';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstStreamFlagsValue = "none" | "sparse" | "select" | "unselect";

  export namespace GstStreamStatusType {
  export const CREATE: 'create' = 'create';
  export const ENTER: 'enter' = 'enter';
  export const LEAVE: 'leave' = 'leave';
  export const DESTROY: 'destroy' = 'destroy';
  export const START: 'start' = 'start';
  export const PAUSE: 'pause' = 'pause';
  export const STOP: 'stop' = 'stop';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamStatusType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstStreamStatusTypeValue = "create" | "enter" | "leave" | "destroy" | "start" | "pause" | "stop";

  export namespace GstStructureChangeType {
  export const LINK: 'link' = 'link';
  export const UNLINK: 'unlink' = 'unlink';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StructureChangeType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstStructureChangeTypeValue = "link" | "unlink";

  
// Finalization registry for GstToc
const gsttocRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Toc/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstToc:', ptr, err));
});

export class GstToc {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gsttocRegistry.register(this, ptr);
  }
    





 
  static async new(scope: GstTocScopeValue): Promise<GstToc> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope', String(scope));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstToc(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async append_entry(entry: GstTocEntry): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/append_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (entry && typeof entry === 'object' && 'ptr' in entry) {
      url.searchParams.append('entry', 'ptr,' + entry.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async dump(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/dump`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async find_entry(uid: string): Promise<GstTocEntry | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/find_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uid', String(uid));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTocEntry(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_entries(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/get_entries`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', GstTocEntry, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_scope(): Promise<GstTocScopeValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/get_scope`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_tags(): Promise<GstTagList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/get_tags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTagList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async merge_tags(mode: GstTagMergeModeValue, tags?: GstTagList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/merge_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_tags(tags?: GstTagList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/ptr,${this.ptr}/set_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Toc/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstTocScope {
  export const GLOBAL: 'global' = 'global';
  export const CURRENT: 'current' = 'current';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocScope/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTocScopeValue = "global" | "current";

  
// Finalization registry for GstTocEntry
const gsttocentryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/TocEntry/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstTocEntry:', ptr, err));
});

export class GstTocEntry {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gsttocentryRegistry.register(this, ptr);
  }
    





 
  static async new(type_: GstTocEntryTypeValue, uid: string): Promise<GstTocEntry> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('uid', String(uid));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTocEntry(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async append_sub_entry(subentry: GstTocEntry): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/append_sub_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (subentry && typeof subentry === 'object' && 'ptr' in subentry) {
      url.searchParams.append('subentry', 'ptr,' + subentry.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_entry_type(): Promise<GstTocEntryTypeValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_entry_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_loop(loop_type: GstTocLoopTypeValue): Promise<{repeat_count: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_loop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('loop_type', String(loop_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: repeat_count
      result.repeat_count = (() => {
        return data.repeat_count;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_parent(): Promise<GstTocEntry | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTocEntry(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_start_stop_times(): Promise<{start: number, stop: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_start_stop_times`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: start
      result.start = (() => {
        return data.start;

      })();
      // Handle return parameter: stop
      result.stop = (() => {
        return data.stop;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_sub_entries(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_sub_entries`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', GstTocEntry, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_tags(): Promise<GstTagList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_tags`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTagList(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_toc(): Promise<GstToc | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_toc`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstToc(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_uid(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/get_uid`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_alternative(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/is_alternative`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_sequence(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/is_sequence`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async merge_tags(mode: GstTagMergeModeValue, tags?: GstTagList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/merge_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_loop(loop_type: GstTocLoopTypeValue, repeat_count: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/set_loop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('loop_type', String(loop_type));
    // Primitive parameter
    url.searchParams.append('repeat_count', String(repeat_count));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_start_stop_times(start: number, stop: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/set_start_stop_times`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_tags(tags?: GstTagList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/ptr,${this.ptr}/set_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntry/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstTocEntryType {
  export const ANGLE: 'angle' = 'angle';
  export const VERSION: 'version' = 'version';
  export const EDITION: 'edition' = 'edition';
  export const INVALID: 'invalid' = 'invalid';
  export const TITLE: 'title' = 'title';
  export const TRACK: 'track' = 'track';
  export const CHAPTER: 'chapter' = 'chapter';
    





 
  export async function get_nick(type_: GstTocEntryTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntryType/get_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocEntryType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTocEntryTypeValue = "angle" | "version" | "edition" | "invalid" | "title" | "track" | "chapter";

  export namespace GstTocLoopType {
  export const NONE: 'none' = 'none';
  export const FORWARD: 'forward' = 'forward';
  export const REVERSE: 'reverse' = 'reverse';
  export const PING_PONG: 'ping_pong' = 'ping_pong';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TocLoopType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTocLoopTypeValue = "none" | "forward" | "reverse" | "ping_pong";

  export namespace GstBufferingMode {
  export const STREAM: 'stream' = 'stream';
  export const DOWNLOAD: 'download' = 'download';
  export const TIMESHIFT: 'timeshift' = 'timeshift';
  export const LIVE: 'live' = 'live';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferingMode/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstBufferingModeValue = "stream" | "download" | "timeshift" | "live";

  export namespace GstGapFlags {
  export const DATA: 'data' = 'data';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GapFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstGapFlagsValue = "data";

  
// Finalization registry for GstQuery
const gstqueryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Query/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstQuery:', ptr, err));
});

export class GstQuery {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstqueryRegistry.register(this, ptr);
  }
    





 
  static async new_accept_caps(caps: GstCaps): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_allocation(need_pool: boolean, caps?: GstCaps): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_allocation`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('need_pool', String(need_pool));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_bitrate(): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_bitrate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_buffering(format: GstFormatValue): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_buffering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_caps(filter: GstCaps): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_context(context_type: string): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_convert(src_format: GstFormatValue, value_: number, dest_format: GstFormatValue): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_custom(type_: GstQueryTypeValue, structure?: GstStructure): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_drain(): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_drain`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_duration(format: GstFormatValue): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_formats(): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_formats`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_latency(): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_latency`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_position(format: GstFormatValue): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_scheduling(): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_scheduling`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_seeking(format: GstFormatValue): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_seeking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_segment(format: GstFormatValue): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_segment`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_selectable(): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_selectable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_uri(): Promise<GstQuery> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/new_uri`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstQuery(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_allocation_meta(api: string, params?: GstStructure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_allocation_param(allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_allocation_param`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_allocation_pool(size: number, min_buffers: number, max_buffers: number, pool?: GstBufferPool): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_allocation_pool`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pool !== undefined && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_buffering_range(start: number, stop: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async add_scheduling_mode(mode: GstPadModeValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/add_scheduling_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async find_allocation_meta(api: string): Promise<{index: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/find_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: index
      result.index = (() => {
        return data.index;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_allocation_metas(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_allocation_metas`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_allocation_params(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_allocation_params`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_allocation_pools(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_allocation_pools`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_buffering_ranges(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_buffering_ranges`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_n_scheduling_modes(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_n_scheduling_modes`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_structure(): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_scheduling_mode(mode: GstPadModeValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/has_scheduling_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async has_scheduling_mode_with_flags(mode: GstPadModeValue, flags: GstSchedulingFlagsValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/has_scheduling_mode_with_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_accept_caps(caps: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_accept_caps_result(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_accept_caps_result`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.result;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_allocation(caps?: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_allocation`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.need_pool;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_bitrate(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_bitrate`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.nominal_bitrate;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_buffering_percent(): Promise<{busy: boolean, percent: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_buffering_percent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: busy
      result.busy = (() => {
        return data.busy;

      })();
      // Handle return parameter: percent
      result.percent = (() => {
        return data.percent;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_buffering_range(format: GstFormatValue): Promise<{start: number, stop: number, estimated_total: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: start
      result.start = (() => {
        return data.start;

      })();
      // Handle return parameter: stop
      result.stop = (() => {
        return data.stop;

      })();
      // Handle return parameter: estimated_total
      result.estimated_total = (() => {
        return data.estimated_total;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_buffering_stats(mode: GstBufferingModeValue): Promise<{avg_in: number, avg_out: number, buffering_left: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: avg_in
      result.avg_in = (() => {
        return data.avg_in;

      })();
      // Handle return parameter: avg_out
      result.avg_out = (() => {
        return data.avg_out;

      })();
      // Handle return parameter: buffering_left
      result.buffering_left = (() => {
        return data.buffering_left;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_caps(filter: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_caps_result(caps?: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_caps_result`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_context(context?: GstContext): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_context_type(): Promise<{context_type: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_context_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: context_type
      result.context_type = (() => {
        return data.context_type;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_convert(src_format: GstFormatValue, dest_format: GstFormatValue): Promise<{src_value: number, dest_value: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: src_value
      result.src_value = (() => {
        return data.src_value;

      })();
      // Handle return parameter: dest_value
      result.dest_value = (() => {
        return data.dest_value;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_duration(format: GstFormatValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.duration;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_latency(): Promise<{live: boolean, min_latency: number, max_latency: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_latency`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: live
      result.live = (() => {
        return data.live;

      })();
      // Handle return parameter: min_latency
      result.min_latency = (() => {
        return data.min_latency;

      })();
      // Handle return parameter: max_latency
      result.max_latency = (() => {
        return data.max_latency;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_n_formats(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_n_formats`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.n_formats;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_nth_allocation_meta(index: number, params: GstStructure): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (params && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_nth_allocation_param(index: number, params: GstAllocationParams, allocator?: GstAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_allocation_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

    





 
  async parse_nth_allocation_pool(index: number, pool?: GstBufferPool): Promise<{size: number, min_buffers: number, max_buffers: number}> {
    // Increment ref for parameters with full transfer ownership
    if (pool && typeof pool === 'object' && 'ptr' in pool) {
      await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + pool.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_allocation_pool`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (pool !== undefined && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (pool && typeof pool === 'object' && 'ptr' in pool) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + pool.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: size
      result.size = (() => {
        return data.size;

      })();
      // Handle return parameter: min_buffers
      result.min_buffers = (() => {
        return data.min_buffers;

      })();
      // Handle return parameter: max_buffers
      result.max_buffers = (() => {
        return data.max_buffers;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
        if (pool && typeof pool === 'object' && 'ptr' in pool) {
          await fetch(apiConfig.fullBaseUrl + '/GObject/Object/' + pool.ptr + '/unref').catch(() => {});
        }
      throw error;
    }
  }

    





 
  async parse_nth_buffering_range(index: number): Promise<{start: number, stop: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: start
      result.start = (() => {
        return data.start;

      })();
      // Handle return parameter: stop
      result.stop = (() => {
        return data.stop;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_nth_format(nth: number, format: GstFormatValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_format`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nth', String(nth));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_nth_scheduling_mode(index: number): Promise<GstPadModeValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_nth_scheduling_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_position(format: GstFormatValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.cur;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_scheduling(flags: GstSchedulingFlagsValue): Promise<{minsize: number, maxsize: number, align: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_scheduling`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: minsize
      result.minsize = (() => {
        return data.minsize;

      })();
      // Handle return parameter: maxsize
      result.maxsize = (() => {
        return data.maxsize;

      })();
      // Handle return parameter: align
      result.align = (() => {
        return data.align;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_seeking(format: GstFormatValue): Promise<{seekable: boolean, segment_start: number, segment_end: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_seeking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: seekable
      result.seekable = (() => {
        return data.seekable;

      })();
      // Handle return parameter: segment_start
      result.segment_start = (() => {
        return data.segment_start;

      })();
      // Handle return parameter: segment_end
      result.segment_end = (() => {
        return data.segment_end;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_segment(format: GstFormatValue): Promise<{rate: number, start_value: number, stop_value: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_segment`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: rate
      result.rate = (() => {
        return data.rate;

      })();
      // Handle return parameter: start_value
      result.start_value = (() => {
        return data.start_value;

      })();
      // Handle return parameter: stop_value
      result.stop_value = (() => {
        return data.stop_value;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_selectable(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_selectable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.selectable;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_uri(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_uri`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.uri;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_uri_redirection(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_uri_redirection`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.uri;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async parse_uri_redirection_permanent(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/parse_uri_redirection_permanent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.permanent;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_nth_allocation_meta(index: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/remove_nth_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_nth_allocation_param(index: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/remove_nth_allocation_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_nth_allocation_pool(index: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/remove_nth_allocation_pool`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_accept_caps_result(result_: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_accept_caps_result`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('result', String(result_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_bitrate(nominal_bitrate: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_bitrate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nominal_bitrate', String(nominal_bitrate));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_buffering_percent(busy: boolean, percent: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_buffering_percent`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('busy', String(busy));
    // Primitive parameter
    url.searchParams.append('percent', String(percent));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_buffering_range(format: GstFormatValue, start: number, stop: number, estimated_total: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    // Primitive parameter
    url.searchParams.append('estimated_total', String(estimated_total));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_buffering_stats(mode: GstBufferingModeValue, avg_in: number, avg_out: number, buffering_left: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('avg_in', String(avg_in));
    // Primitive parameter
    url.searchParams.append('avg_out', String(avg_out));
    // Primitive parameter
    url.searchParams.append('buffering_left', String(buffering_left));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_caps_result(caps?: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_caps_result`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_context(context?: GstContext): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_convert(src_format: GstFormatValue, src_value: number, dest_format: GstFormatValue, dest_value: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_value', String(src_value));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    // Primitive parameter
    url.searchParams.append('dest_value', String(dest_value));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_duration(format: GstFormatValue, duration: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_formatsv(n_formats: number, formats: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_formatsv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_formats', String(n_formats));
    // Primitive parameter
    url.searchParams.append('formats', String(formats));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_latency(live: boolean, min_latency: number, max_latency: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_latency`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('live', String(live));
    // Primitive parameter
    url.searchParams.append('min_latency', String(min_latency));
    // Primitive parameter
    url.searchParams.append('max_latency', String(max_latency));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_nth_allocation_param(index: number, allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_nth_allocation_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_nth_allocation_pool(index: number, size: number, min_buffers: number, max_buffers: number, pool?: GstBufferPool): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_nth_allocation_pool`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (pool !== undefined && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_position(format: GstFormatValue, cur: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('cur', String(cur));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_scheduling(flags: GstSchedulingFlagsValue, minsize: number, maxsize: number, align: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_scheduling`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('minsize', String(minsize));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('align', String(align));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_seeking(format: GstFormatValue, seekable: boolean, segment_start: number, segment_end: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_seeking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('seekable', String(seekable));
    // Primitive parameter
    url.searchParams.append('segment_start', String(segment_start));
    // Primitive parameter
    url.searchParams.append('segment_end', String(segment_end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_segment(rate: number, format: GstFormatValue, start_value: number, stop_value: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_segment`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('start_value', String(start_value));
    // Primitive parameter
    url.searchParams.append('stop_value', String(stop_value));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_selectable(selectable: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_selectable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('selectable', String(selectable));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_uri(uri?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_uri`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_uri_redirection(uri?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_uri_redirection`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_uri_redirection_permanent(permanent: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/set_uri_redirection_permanent`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('permanent', String(permanent));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async writable_structure(): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_mini_object(): Promise<GstMiniObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMiniObject(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_mini_object(value_: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/fields/mini_object`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_type(): Promise<GstQueryTypeValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_type(value_: GstQueryTypeValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/ptr,${this.ptr}/fields/type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Query/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstQueryType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const POSITION: 'position' = 'position';
  export const DURATION: 'duration' = 'duration';
  export const LATENCY: 'latency' = 'latency';
  export const JITTER: 'jitter' = 'jitter';
  export const RATE: 'rate' = 'rate';
  export const SEEKING: 'seeking' = 'seeking';
  export const SEGMENT: 'segment' = 'segment';
  export const CONVERT: 'convert' = 'convert';
  export const FORMATS: 'formats' = 'formats';
  export const BUFFERING: 'buffering' = 'buffering';
  export const CUSTOM: 'custom' = 'custom';
  export const URI: 'uri' = 'uri';
  export const ALLOCATION: 'allocation' = 'allocation';
  export const SCHEDULING: 'scheduling' = 'scheduling';
  export const ACCEPT_CAPS: 'accept_caps' = 'accept_caps';
  export const CAPS: 'caps' = 'caps';
  export const DRAIN: 'drain' = 'drain';
  export const CONTEXT: 'context' = 'context';
  export const BITRATE: 'bitrate' = 'bitrate';
  export const SELECTABLE: 'selectable' = 'selectable';
    





 
  export async function get_flags(type_: GstQueryTypeValue): Promise<GstQueryTypeFlagsValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryType/get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_name(type_: GstQueryTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function to_quark(type_: GstQueryTypeValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryType/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstQueryTypeValue = "unknown" | "position" | "duration" | "latency" | "jitter" | "rate" | "seeking" | "segment" | "convert" | "formats" | "buffering" | "custom" | "uri" | "allocation" | "scheduling" | "accept_caps" | "caps" | "drain" | "context" | "bitrate" | "selectable";

  export namespace GstQueryTypeFlags {
  export const UPSTREAM: 'upstream' = 'upstream';
  export const DOWNSTREAM: 'downstream' = 'downstream';
  export const SERIALIZED: 'serialized' = 'serialized';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/QueryTypeFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstQueryTypeFlagsValue = "upstream" | "downstream" | "serialized";

  export namespace GstSchedulingFlags {
  export const SEEKABLE: 'seekable' = 'seekable';
  export const SEQUENTIAL: 'sequential' = 'sequential';
  export const BANDWIDTH_LIMITED: 'bandwidth_limited' = 'bandwidth_limited';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SchedulingFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstSchedulingFlagsValue = "seekable" | "sequential" | "bandwidth_limited";

  export namespace GstPadProbeReturn {
  export const DROP: 'drop' = 'drop';
  export const OK: 'ok' = 'ok';
  export const REMOVE: 'remove' = 'remove';
  export const PASS: 'pass' = 'pass';
  export const HANDLED: 'handled' = 'handled';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadProbeReturn/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPadProbeReturnValue = "drop" | "ok" | "remove" | "pass" | "handled";

  export namespace GstTaskState {
  export const STARTED: 'started' = 'started';
  export const STOPPED: 'stopped' = 'stopped';
  export const PAUSED: 'paused' = 'paused';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskState/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTaskStateValue = "started" | "stopped" | "paused";

  export namespace GstPadLinkCheck {
  export const NOTHING: 'nothing' = 'nothing';
  export const HIERARCHY: 'hierarchy' = 'hierarchy';
  export const TEMPLATE_CAPS: 'template_caps' = 'template_caps';
  export const CAPS: 'caps' = 'caps';
  export const NO_RECONFIGURE: 'no_reconfigure' = 'no_reconfigure';
  export const DEFAULT: 'default' = 'default';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadLinkCheck/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPadLinkCheckValue = "nothing" | "hierarchy" | "template_caps" | "caps" | "no_reconfigure" | "default";

  export namespace GstStateChange {
  export const NULL_TO_READY: 'null_to_ready' = 'null_to_ready';
  export const READY_TO_PAUSED: 'ready_to_paused' = 'ready_to_paused';
  export const PAUSED_TO_PLAYING: 'paused_to_playing' = 'paused_to_playing';
  export const PLAYING_TO_PAUSED: 'playing_to_paused' = 'playing_to_paused';
  export const PAUSED_TO_READY: 'paused_to_ready' = 'paused_to_ready';
  export const READY_TO_NULL: 'ready_to_null' = 'ready_to_null';
  export const NULL_TO_NULL: 'null_to_null' = 'null_to_null';
  export const READY_TO_READY: 'ready_to_ready' = 'ready_to_ready';
  export const PAUSED_TO_PAUSED: 'paused_to_paused' = 'paused_to_paused';
  export const PLAYING_TO_PLAYING: 'playing_to_playing' = 'playing_to_playing';
    





 
  export async function get_name(transition: GstStateChangeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StateChange/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('transition', String(transition));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StateChange/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstStateChangeValue = "null_to_ready" | "ready_to_paused" | "paused_to_playing" | "playing_to_paused" | "paused_to_ready" | "ready_to_null" | "null_to_null" | "ready_to_ready" | "paused_to_paused" | "playing_to_playing";

  export type GstBusFunc = (bus: GstBus, message: GstMessage, user_data: Pointer) => boolean;

export function convertGstBusFuncArgs(data: any): Parameters<GstBusFunc> {
  return [
    new GstBus(data.bus, 'none'),
    new GstMessage(data.message, 'none'),
    data.user_data  ];
}
  export type GstBusSyncHandler = (bus: GstBus, message: GstMessage, user_data: Pointer) => GstBusSyncReplyValue;

export function convertGstBusSyncHandlerArgs(data: any): Parameters<GstBusSyncHandler> {
  return [
    new GstBus(data.bus, 'none'),
    new GstMessage(data.message, 'none'),
    data.user_data  ];
}
  
export class GstBus extends GstObject {


    





 
  static async new(): Promise<GstBus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstBus(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async add_signal_watch(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/add_signal_watch`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_signal_watch_full(priority: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/add_signal_watch_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_watch(priority: number, func: GstBusFunc): Promise<{func: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/add_watch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstBusFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async async_signal_func(message: GstMessage, data_?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/async_signal_func`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async create_watch(): Promise<GLibSource | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/create_watch`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async disable_sync_message_emission(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/disable_sync_message_emission`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async enable_sync_message_emission(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/enable_sync_message_emission`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_pollfd(fd: GLibPollFD): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/get_pollfd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async have_pending(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/have_pending`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async peek(): Promise<GstMessage | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/peek`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async poll(events: GstMessageTypeValue, timeout: number): Promise<GstMessage | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/poll`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('events', String(events));
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async pop(): Promise<GstMessage | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async pop_filtered(types: GstMessageTypeValue): Promise<GstMessage | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/pop_filtered`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('types', String(types));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async post(message: GstMessage): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/post`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove_signal_watch(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/remove_signal_watch`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove_watch(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/remove_watch`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_flushing(flushing: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/set_flushing`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flushing', String(flushing));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_sync_handler(func: GstBusSyncHandler): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/set_sync_handler`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstBusSyncHandlerArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async sync_signal_handler(message: GstMessage, data_?: Pointer): Promise<GstBusSyncReplyValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/sync_signal_handler`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async timed_pop(timeout: number): Promise<GstMessage | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/timed_pop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async timed_pop_filtered(timeout: number, types: GstMessageTypeValue): Promise<GstMessage | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/ptr,${this.ptr}/timed_pop_filtered`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    // Primitive parameter
    url.searchParams.append('types', String(types));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMessage(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bus/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstBusSyncReply {
  export const DROP: 'drop' = 'drop';
  export const PASS: 'pass' = 'pass';
  export const ASYNC: 'async' = 'async';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BusSyncReply/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstBusSyncReplyValue = "drop" | "pass" | "async";

  
export class GstPluginFeature extends GstObject {




      





 
  static async list_copy(list: GLibList): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/list_copy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstPluginFeature, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async list_debug(list: GLibList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/list_debug`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async list_free(list: GLibList): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/list_free`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async rank_compare_func(p1?: Pointer, p2?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/rank_compare_func`, apiConfig.baseUrl);
    // Primitive parameter
    if (p1 !== undefined) url.searchParams.append('p1', String(p1));
    // Primitive parameter
    if (p2 !== undefined) url.searchParams.append('p2', String(p2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async check_version(min_major: number, min_minor: number, min_micro: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/check_version`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('min_major', String(min_major));
    // Primitive parameter
    url.searchParams.append('min_minor', String(min_minor));
    // Primitive parameter
    url.searchParams.append('min_micro', String(min_micro));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_plugin(): Promise<GstPlugin | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/get_plugin`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPlugin(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_plugin_name(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/get_plugin_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_rank(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/get_rank`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async load(): Promise<GstPluginFeature | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/load`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPluginFeature(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_rank(rank: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/ptr,${this.ptr}/set_rank`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFeature/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstElementFactory extends GstPluginFeature {




      





 
  static async find(name: string): Promise<GstElementFactory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElementFactory(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async list_filter(list: GLibList, caps: GstCaps, direction: GstPadDirectionValue, subsetonly: boolean): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/list_filter`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    // Primitive parameter
    url.searchParams.append('subsetonly', String(subsetonly));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstElementFactory, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async list_get_elements(type_: number, minrank: GstRankValue): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/list_get_elements`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('minrank', String(minrank));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstElementFactory, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async make(factoryname: string, name?: string): Promise<GstElement | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/make`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async make_with_properties(factoryname: string, n: number, names?: Pointer, values?: Pointer): Promise<GstElement | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/make_with_properties`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    if (values !== undefined) url.searchParams.append('values', String(values));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async can_sink_all_caps(caps: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/can_sink_all_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async can_sink_any_caps(caps: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/can_sink_any_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async can_src_all_caps(caps: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/can_src_all_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async can_src_any_caps(caps: GstCaps): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/can_src_any_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async create(name?: string): Promise<GstElement | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/create`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async create_with_properties(n: number, names?: Pointer, values?: Pointer): Promise<GstElement | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/create_with_properties`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n', String(n));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    if (values !== undefined) url.searchParams.append('values', String(values));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_element_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_element_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_metadata(key: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_metadata_keys(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_metadata_keys`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_num_pad_templates(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_num_pad_templates`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_skip_documentation(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_skip_documentation`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_static_pad_templates(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_static_pad_templates`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'none', GstStaticPadTemplate, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_uri_protocols(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_uri_protocols`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_uri_type(): Promise<GstURITypeValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/get_uri_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_interface(interfacename: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/has_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interfacename', String(interfacename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async list_is_type(type_: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/ptr,${this.ptr}/list_is_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFactory/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstRank {
  export const NONE: 'none' = 'none';
  export const MARGINAL: 'marginal' = 'marginal';
  export const SECONDARY: 'secondary' = 'secondary';
  export const PRIMARY: 'primary' = 'primary';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Rank/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstRankValue = "none" | "marginal" | "secondary" | "primary";

  export namespace GstElementFlags {
  export const LOCKED_STATE: 'locked_state' = 'locked_state';
  export const SINK: 'sink' = 'sink';
  export const SOURCE: 'source' = 'source';
  export const PROVIDE_CLOCK: 'provide_clock' = 'provide_clock';
  export const REQUIRE_CLOCK: 'require_clock' = 'require_clock';
  export const INDEXABLE: 'indexable' = 'indexable';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ElementFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstElementFlagsValue = "locked_state" | "sink" | "source" | "provide_clock" | "require_clock" | "indexable" | "last";

  export namespace GstBinFlags {
  export const NO_RESYNC: 'no_resync' = 'no_resync';
  export const STREAMS_AWARE: 'streams_aware' = 'streams_aware';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BinFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstBinFlagsValue = "no_resync" | "streams_aware" | "last";

  
// Finalization registry for GstBinPrivate
const gstbinprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/BinPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstBinPrivate:', ptr, err));
});

export class GstBinPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstbinprivateRegistry.register(this, ptr);
  }


}
  
export class GstBitmask {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Bitmask/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstBufferPoolAcquireFlags {
  export const NONE: 'none' = 'none';
  export const KEY_UNIT: 'key_unit' = 'key_unit';
  export const DONTWAIT: 'dontwait' = 'dontwait';
  export const DISCONT: 'discont' = 'discont';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BufferPoolAcquireFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstBufferPoolAcquireFlagsValue = "none" | "key_unit" | "dontwait" | "discont" | "last";

  
// Finalization registry for GstBufferPoolPrivate
const gstbufferpoolprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/BufferPoolPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstBufferPoolPrivate:', ptr, err));
});

export class GstBufferPoolPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstbufferpoolprivateRegistry.register(this, ptr);
  }


}
  export namespace GstBusFlags {
  export const FLUSHING: 'flushing' = 'flushing';
  export const FLAG_LAST: 'flag_last' = 'flag_last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/BusFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstBusFlagsValue = "flushing" | "flag_last";

  
// Finalization registry for GstBusPrivate
const gstbusprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/BusPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstBusPrivate:', ptr, err));
});

export class GstBusPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstbusprivateRegistry.register(this, ptr);
  }


}
  export namespace GstCapsFlags {
  export const ANY: 'any' = 'any';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CapsFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstCapsFlagsValue = "any";

  
// Finalization registry for GstClockEntry
const gstclockentryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ClockEntry/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstClockEntry:', ptr, err));
});

export class GstClockEntry {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstclockentryRegistry.register(this, ptr);
  }


}
  export namespace GstClockEntryType {
  export const SINGLE: 'single' = 'single';
  export const PERIODIC: 'periodic' = 'periodic';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ClockEntryType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstClockEntryTypeValue = "single" | "periodic";

  export namespace GstClockFlags {
  export const CAN_DO_SINGLE_SYNC: 'can_do_single_sync' = 'can_do_single_sync';
  export const CAN_DO_SINGLE_ASYNC: 'can_do_single_async' = 'can_do_single_async';
  export const CAN_DO_PERIODIC_SYNC: 'can_do_periodic_sync' = 'can_do_periodic_sync';
  export const CAN_DO_PERIODIC_ASYNC: 'can_do_periodic_async' = 'can_do_periodic_async';
  export const CAN_SET_RESOLUTION: 'can_set_resolution' = 'can_set_resolution';
  export const CAN_SET_MASTER: 'can_set_master' = 'can_set_master';
  export const NEEDS_STARTUP_SYNC: 'needs_startup_sync' = 'needs_startup_sync';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ClockFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstClockFlagsValue = "can_do_single_sync" | "can_do_single_async" | "can_do_periodic_sync" | "can_do_periodic_async" | "can_set_resolution" | "can_set_master" | "needs_startup_sync" | "last";

  
// Finalization registry for GstClockPrivate
const gstclockprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ClockPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstClockPrivate:', ptr, err));
});

export class GstClockPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstclockprivateRegistry.register(this, ptr);
  }


}
  export namespace GstClockType {
  export const REALTIME: 'realtime' = 'realtime';
  export const MONOTONIC: 'monotonic' = 'monotonic';
  export const OTHER: 'other' = 'other';
  export const TAI: 'tai' = 'tai';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ClockType/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstClockTypeValue = "realtime" | "monotonic" | "other" | "tai";

  
// Finalization registry for GstControlBindingPrivate
const gstcontrolbindingprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ControlBindingPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstControlBindingPrivate:', ptr, err));
});

export class GstControlBindingPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstcontrolbindingprivateRegistry.register(this, ptr);
  }


}
  
export class GstControlSource extends GstObject {




      





 
  async control_source_get_value(timestamp: number): Promise<{value: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlSource/ptr,${this.ptr}/control_source_get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async control_source_get_value_array(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlSource/ptr,${this.ptr}/control_source_get_value_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ControlSource/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstCoreError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const STATE_CHANGE: 'state_change' = 'state_change';
  export const PAD: 'pad' = 'pad';
  export const THREAD: 'thread' = 'thread';
  export const NEGOTIATION: 'negotiation' = 'negotiation';
  export const EVENT: 'event' = 'event';
  export const SEEK: 'seek' = 'seek';
  export const CAPS: 'caps' = 'caps';
  export const TAG: 'tag' = 'tag';
  export const MISSING_PLUGIN: 'missing_plugin' = 'missing_plugin';
  export const CLOCK: 'clock' = 'clock';
  export const DISABLED: 'disabled' = 'disabled';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
    





 
  export async function quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CoreError/quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/CoreError/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstCoreErrorValue = "failed" | "too_lazy" | "not_implemented" | "state_change" | "pad" | "thread" | "negotiation" | "event" | "seek" | "caps" | "tag" | "missing_plugin" | "clock" | "disabled" | "num_errors";

  
// Finalization registry for GstDebugCategory
const gstdebugcategoryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/DebugCategory/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstDebugCategory:', ptr, err));
});

export class GstDebugCategory {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstdebugcategoryRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstDebugCategory> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDebugCategory(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_color(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/get_color`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_description(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_name(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_threshold(): Promise<GstDebugLevelValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/get_threshold`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reset_threshold(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/reset_threshold`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_threshold(level: GstDebugLevelValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugCategory/ptr,${this.ptr}/set_threshold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstDebugLevel {
  export const NONE: 'none' = 'none';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const FIXME: 'fixme' = 'fixme';
  export const INFO: 'info' = 'info';
  export const DEBUG: 'debug' = 'debug';
  export const LOG: 'log' = 'log';
  export const TRACE: 'trace' = 'trace';
  export const MEMDUMP: 'memdump' = 'memdump';
  export const COUNT: 'count' = 'count';
    





 
  export async function get_name(level: GstDebugLevelValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugLevel/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugLevel/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstDebugLevelValue = "none" | "error" | "warning" | "fixme" | "info" | "debug" | "log" | "trace" | "memdump" | "count";

  export namespace GstDebugColorFlags {
  export const FG_BLACK: 'fg_black' = 'fg_black';
  export const FG_RED: 'fg_red' = 'fg_red';
  export const FG_GREEN: 'fg_green' = 'fg_green';
  export const FG_YELLOW: 'fg_yellow' = 'fg_yellow';
  export const FG_BLUE: 'fg_blue' = 'fg_blue';
  export const FG_MAGENTA: 'fg_magenta' = 'fg_magenta';
  export const FG_CYAN: 'fg_cyan' = 'fg_cyan';
  export const FG_WHITE: 'fg_white' = 'fg_white';
  export const BG_BLACK: 'bg_black' = 'bg_black';
  export const BG_RED: 'bg_red' = 'bg_red';
  export const BG_GREEN: 'bg_green' = 'bg_green';
  export const BG_YELLOW: 'bg_yellow' = 'bg_yellow';
  export const BG_BLUE: 'bg_blue' = 'bg_blue';
  export const BG_MAGENTA: 'bg_magenta' = 'bg_magenta';
  export const BG_CYAN: 'bg_cyan' = 'bg_cyan';
  export const BG_WHITE: 'bg_white' = 'bg_white';
  export const BOLD: 'bold' = 'bold';
  export const UNDERLINE: 'underline' = 'underline';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugColorFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstDebugColorFlagsValue = "fg_black" | "fg_red" | "fg_green" | "fg_yellow" | "fg_blue" | "fg_magenta" | "fg_cyan" | "fg_white" | "bg_black" | "bg_red" | "bg_green" | "bg_yellow" | "bg_blue" | "bg_magenta" | "bg_cyan" | "bg_white" | "bold" | "underline";

  export namespace GstDebugColorMode {
  export const OFF: 'off' = 'off';
  export const ON: 'on' = 'on';
  export const UNIX: 'unix' = 'unix';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugColorMode/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstDebugColorModeValue = "off" | "on" | "unix";

  export namespace GstDebugGraphDetails {
  export const MEDIA_TYPE: 'media_type' = 'media_type';
  export const CAPS_DETAILS: 'caps_details' = 'caps_details';
  export const NON_DEFAULT_PARAMS: 'non_default_params' = 'non_default_params';
  export const STATES: 'states' = 'states';
  export const FULL_PARAMS: 'full_params' = 'full_params';
  export const ALL: 'all' = 'all';
  export const VERBOSE: 'verbose' = 'verbose';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugGraphDetails/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstDebugGraphDetailsValue = "media_type" | "caps_details" | "non_default_params" | "states" | "full_params" | "all" | "verbose";

  
// Finalization registry for GstDebugMessage
const gstdebugmessageRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/DebugMessage/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstDebugMessage:', ptr, err));
});

export class GstDebugMessage {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstdebugmessageRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstDebugMessage> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugMessage/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstDebugMessage(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugMessage/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugMessage/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_id(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DebugMessage/ptr,${this.ptr}/get_id`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstDeviceMonitor extends GstObject {


    





 
  static async new(): Promise<GstDeviceMonitor> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstDeviceMonitor(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async add_filter(classes?: string, caps?: GstCaps): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/add_filter`, apiConfig.baseUrl);
    // Primitive parameter
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_bus(): Promise<GstBus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstBus(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_devices(): Promise<GLibList | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/get_devices`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstDevice, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_providers(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/get_providers`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_show_all_devices(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/get_show_all_devices`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove_filter(filter_id: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/remove_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filter_id', String(filter_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_show_all_devices(show_all: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/set_show_all_devices`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('show_all', String(show_all));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async start(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async stop(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceMonitor/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstDeviceMonitorPrivate
const gstdevicemonitorprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/DeviceMonitorPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstDeviceMonitorPrivate:', ptr, err));
});

export class GstDeviceMonitorPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstdevicemonitorprivateRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GstDevicePrivate
const gstdeviceprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/DevicePrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstDevicePrivate:', ptr, err));
});

export class GstDevicePrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstdeviceprivateRegistry.register(this, ptr);
  }


}
  
export class GstDeviceProvider extends GstObject {




      





 
  static async register(name: string, rank: number, type_: string, plugin?: GstPlugin): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async can_monitor(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/can_monitor`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async device_add(device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/device_add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async device_changed(device: GstDevice, changed_device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/device_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      url.searchParams.append('changed_device', 'ptr,' + changed_device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async device_remove(device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/device_remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_bus(): Promise<GstBus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstBus(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_devices(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_devices`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstDevice, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_factory(): Promise<GstDeviceProviderFactory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_factory`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstDeviceProviderFactory(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_hidden_providers(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_hidden_providers`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_metadata(key: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async hide_provider(name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/hide_provider`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_started(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/is_started`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async start(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async stop(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async unhide_provider(name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/ptr,${this.ptr}/unhide_provider`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProvider/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstDeviceProviderFactory extends GstPluginFeature {




      





 
  static async find(name: string): Promise<GstDeviceProviderFactory | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstDeviceProviderFactory(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_by_name(factoryname: string): Promise<GstDeviceProvider | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/get_by_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstDeviceProvider(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async list_get_device_providers(minrank: GstRankValue): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/list_get_device_providers`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('minrank', String(minrank));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstDeviceProviderFactory, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get(): Promise<GstDeviceProvider | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstDeviceProvider(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_device_provider_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/get_device_provider_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_metadata(key: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_metadata_keys(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/get_metadata_keys`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_classes(classes?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/has_classes`, apiConfig.baseUrl);
    // Primitive parameter
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_classesv(classes?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/ptr,${this.ptr}/has_classesv`, apiConfig.baseUrl);
    // Primitive parameter
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DeviceProviderFactory/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstDeviceProviderPrivate
const gstdeviceproviderprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/DeviceProviderPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstDeviceProviderPrivate:', ptr, err));
});

export class GstDeviceProviderPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstdeviceproviderprivateRegistry.register(this, ptr);
  }


}
  
export class GstDoubleRange {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DoubleRange/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstDynamicTypeFactory extends GstPluginFeature {




      





 
  static async load_2(factoryname: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DynamicTypeFactory/load`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/DynamicTypeFactory/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstFlagSet {




      





 
  static async register(flags_type: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/FlagSet/register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/FlagSet/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstFraction {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Fraction/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstFractionRange {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/FractionRange/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstProxyPad extends GstPad {




      





 
  static async chain_default(pad: GstPad, buffer: GstBuffer, parent?: GstObject): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/chain_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async chain_list_default(pad: GstPad, list: GstBufferList, parent?: GstObject): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/chain_list_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async getrange_default(pad: GstPad, parent: GstObject, offset: number, size: number, buffer: GstBuffer): Promise<GstFlowReturnValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/getrange_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async iterate_internal_links_default(pad: GstPad, parent?: GstObject): Promise<GstIterator | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/iterate_internal_links_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_internal(): Promise<GstProxyPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/ptr,${this.ptr}/get_internal`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstProxyPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ProxyPad/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstGhostPad extends GstProxyPad {


    





 
  static async new_2(target: GstPad, name?: string): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_from_template_2(target: GstPad, templ: GstPadTemplate, name?: string): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/new_from_template`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_no_target(dir: GstPadDirectionValue, name?: string): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/new_no_target`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('dir', String(dir));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_no_target_from_template(templ: GstPadTemplate, name?: string): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/new_no_target_from_template`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  static async activate_mode_default(pad: GstPad, mode: GstPadModeValue, active: boolean, parent?: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/activate_mode_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('active', String(active));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async internal_activate_mode_default(pad: GstPad, mode: GstPadModeValue, active: boolean, parent?: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/internal_activate_mode_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('active', String(active));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async construct(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/ptr,${this.ptr}/construct`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_target(): Promise<GstPad | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/ptr,${this.ptr}/get_target`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPad(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_target(newtarget?: GstPad): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/ptr,${this.ptr}/set_target`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (newtarget !== undefined && typeof newtarget === 'object' && 'ptr' in newtarget) {
      url.searchParams.append('newtarget', 'ptr,' + newtarget.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/GhostPad/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstGhostPadPrivate
const gstghostpadprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/GhostPadPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstGhostPadPrivate:', ptr, err));
});

export class GstGhostPadPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstghostpadprivateRegistry.register(this, ptr);
  }


}
  
export class GstInt64Range {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Int64Range/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstIntRange {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/IntRange/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstLibraryError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const INIT: 'init' = 'init';
  export const SHUTDOWN: 'shutdown' = 'shutdown';
  export const SETTINGS: 'settings' = 'settings';
  export const ENCODE: 'encode' = 'encode';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
    





 
  export async function quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/LibraryError/quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/LibraryError/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstLibraryErrorValue = "failed" | "too_lazy" | "init" | "shutdown" | "settings" | "encode" | "num_errors";

  
// Finalization registry for GstMetaTransformCopy
const gstmetatransformcopyRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/MetaTransformCopy/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstMetaTransformCopy:', ptr, err));
});

export class GstMetaTransformCopy {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstmetatransformcopyRegistry.register(this, ptr);
  }


}
  export namespace GstMiniObjectFlags {
  export const LOCKABLE: 'lockable' = 'lockable';
  export const LOCK_READONLY: 'lock_readonly' = 'lock_readonly';
  export const MAY_BE_LEAKED: 'may_be_leaked' = 'may_be_leaked';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/MiniObjectFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstMiniObjectFlagsValue = "lockable" | "lock_readonly" | "may_be_leaked" | "last";

  export namespace GstObjectFlags {
  export const MAY_BE_LEAKED: 'may_be_leaked' = 'may_be_leaked';
  export const CONSTRUCTED: 'constructed' = 'constructed';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ObjectFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstObjectFlagsValue = "may_be_leaked" | "constructed" | "last";

  export namespace GstPadFlags {
  export const BLOCKED: 'blocked' = 'blocked';
  export const FLUSHING: 'flushing' = 'flushing';
  export const EOS: 'eos' = 'eos';
  export const BLOCKING: 'blocking' = 'blocking';
  export const NEED_PARENT: 'need_parent' = 'need_parent';
  export const NEED_RECONFIGURE: 'need_reconfigure' = 'need_reconfigure';
  export const PENDING_EVENTS: 'pending_events' = 'pending_events';
  export const FIXED_CAPS: 'fixed_caps' = 'fixed_caps';
  export const PROXY_CAPS: 'proxy_caps' = 'proxy_caps';
  export const PROXY_ALLOCATION: 'proxy_allocation' = 'proxy_allocation';
  export const PROXY_SCHEDULING: 'proxy_scheduling' = 'proxy_scheduling';
  export const ACCEPT_INTERSECT: 'accept_intersect' = 'accept_intersect';
  export const ACCEPT_TEMPLATE: 'accept_template' = 'accept_template';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPadFlagsValue = "blocked" | "flushing" | "eos" | "blocking" | "need_parent" | "need_reconfigure" | "pending_events" | "fixed_caps" | "proxy_caps" | "proxy_allocation" | "proxy_scheduling" | "accept_intersect" | "accept_template" | "last";

  
// Finalization registry for GstPadPrivate
const gstpadprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/PadPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPadPrivate:', ptr, err));
});

export class GstPadPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstpadprivateRegistry.register(this, ptr);
  }


}
  export namespace GstPadTemplateFlags {
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PadTemplateFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPadTemplateFlagsValue = "last";

  
export class GstParamArray extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParamArray/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstParamFraction extends GObjectParamSpec {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParamFraction/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstParamSpecArray
const gstparamspecarrayRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ParamSpecArray/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstParamSpecArray:', ptr, err));
});

export class GstParamSpecArray {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstparamspecarrayRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GstParamSpecFraction
const gstparamspecfractionRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ParamSpecFraction/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstParamSpecFraction:', ptr, err));
});

export class GstParamSpecFraction {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstparamspecfractionRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GstParseContext
const gstparsecontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ParseContext/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstParseContext:', ptr, err));
});

export class GstParseContext {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstparsecontextRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstParseContext | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstParseContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async copy(): Promise<GstParseContext | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstParseContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_missing_elements(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/ptr,${this.ptr}/get_missing_elements`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseContext/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstParseError {
  export const SYNTAX: 'syntax' = 'syntax';
  export const NO_SUCH_ELEMENT: 'no_such_element' = 'no_such_element';
  export const NO_SUCH_PROPERTY: 'no_such_property' = 'no_such_property';
  export const LINK: 'link' = 'link';
  export const COULD_NOT_SET_PROPERTY: 'could_not_set_property' = 'could_not_set_property';
  export const EMPTY_BIN: 'empty_bin' = 'empty_bin';
  export const EMPTY: 'empty' = 'empty';
  export const DELAYED_LINK: 'delayed_link' = 'delayed_link';
    





 
  export async function quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseError/quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseError/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstParseErrorValue = "syntax" | "no_such_element" | "no_such_property" | "link" | "could_not_set_property" | "empty_bin" | "empty" | "delayed_link";

  export namespace GstParseFlags {
  export const NONE: 'none' = 'none';
  export const FATAL_ERRORS: 'fatal_errors' = 'fatal_errors';
  export const NO_SINGLE_ELEMENT_BINS: 'no_single_element_bins' = 'no_single_element_bins';
  export const PLACE_IN_BIN: 'place_in_bin' = 'place_in_bin';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ParseFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstParseFlagsValue = "none" | "fatal_errors" | "no_single_element_bins" | "place_in_bin";

  
export class GstPipeline extends GstBin {


    





 
  static async new(name?: string): Promise<GstElement> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async auto_clock(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/auto_clock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_auto_flush_bus(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_auto_flush_bus`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_bus_2(): Promise<GstBus> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstBus(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_configured_latency(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_configured_latency`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_delay(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_delay`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_latency(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_latency`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_pipeline_clock(): Promise<GstClock> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/get_pipeline_clock`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstClock(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async is_live(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/is_live`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_auto_flush_bus(auto_flush: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/set_auto_flush_bus`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('auto_flush', String(auto_flush));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_delay(delay: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/set_delay`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('delay', String(delay));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_latency(latency: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/set_latency`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('latency', String(latency));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async use_clock(clock?: GstClock): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/ptr,${this.ptr}/use_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock !== undefined && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Pipeline/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstPipelineFlags {
  export const FIXED_CLOCK: 'fixed_clock' = 'fixed_clock';
  export const LAST: 'last' = 'last';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PipelineFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPipelineFlagsValue = "fixed_clock" | "last";

  
// Finalization registry for GstPipelinePrivate
const gstpipelineprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/PipelinePrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPipelinePrivate:', ptr, err));
});

export class GstPipelinePrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstpipelineprivateRegistry.register(this, ptr);
  }


}
  export namespace GstPluginAPIFlags {
  export const MEMBERS: 'members' = 'members';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginAPIFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPluginAPIFlagsValue = "members";

  
// Finalization registry for GstPluginDesc
const gstplugindescRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/PluginDesc/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPluginDesc:', ptr, err));
});

export class GstPluginDesc {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstplugindescRegistry.register(this, ptr);
  }


}
  export namespace GstPluginError {
  export const MODULE: 'module' = 'module';
  export const DEPENDENCIES: 'dependencies' = 'dependencies';
  export const NAME_MISMATCH: 'name_mismatch' = 'name_mismatch';
    





 
  export async function quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginError/quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginError/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPluginErrorValue = "module" | "dependencies" | "name_mismatch";

  export namespace GstPluginFlags {
  export const CACHED: 'cached' = 'cached';
  export const BLACKLISTED: 'blacklisted' = 'blacklisted';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PluginFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPluginFlagsValue = "cached" | "blacklisted";

  
// Finalization registry for GstPoll
const gstpollRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Poll/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPoll:', ptr, err));
});

export class GstPoll {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstpollRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstPoll> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstPoll(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async add_fd(fd: GstPollFD): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/add_fd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fd_can_read(fd: GstPollFD): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_can_read`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fd_can_write(fd: GstPollFD): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_can_write`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fd_ctl_pri(fd: GstPollFD, active: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_ctl_pri`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fd_ctl_read(fd: GstPollFD, active: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_ctl_read`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fd_ctl_write(fd: GstPollFD, active: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_ctl_write`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fd_has_closed(fd: GstPollFD): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_has_closed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fd_has_error(fd: GstPollFD): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_has_error`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fd_has_pri(fd: GstPollFD): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_has_pri`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async fd_ignored(fd: GstPollFD): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/fd_ignored`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_read_gpollfd(fd: GLibPollFD): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/get_read_gpollfd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async read_control(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/read_control`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_fd(fd: GstPollFD): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/remove_fd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async restart(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/restart`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_controllable(controllable: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/set_controllable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('controllable', String(controllable));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_flushing(flushing: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/set_flushing`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flushing', String(flushing));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async wait(timeout: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async write_control(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Poll/ptr,${this.ptr}/write_control`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstPollFD
const gstpollfdRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/PollFD/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPollFD:', ptr, err));
});

export class GstPollFD {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstpollfdRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstPollFD> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PollFD/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstPollFD(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PollFD/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async init(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PollFD/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_fd(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PollFD/ptr,${this.ptr}/fields/fd`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_fd(value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PollFD/ptr,${this.ptr}/fields/fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_idx(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PollFD/ptr,${this.ptr}/fields/idx`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type GstPromiseChangeFunc = (promise: GstPromise, user_data: Pointer) => void;

export function convertGstPromiseChangeFuncArgs(data: any): Parameters<GstPromiseChangeFunc> {
  return [
    new GstPromise(data.promise, 'none'),
    data.user_data  ];
}
  
// Finalization registry for GstPromise
const gstpromiseRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Promise/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstPromise:', ptr, err));
});

export class GstPromise {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstpromiseRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstPromise> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstPromise(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async new_with_change_func(func: GstPromiseChangeFunc): Promise<{func: number, return: GstPromise}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/new_with_change_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstPromiseChangeFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GstPromise(data.return.ptr, 'full');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async expire(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/expire`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_reply(): Promise<GstStructure | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/get_reply`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async interrupt(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/interrupt`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async reply(s?: GstStructure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/reply`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (s !== undefined && typeof s === 'object' && 'ptr' in s) {
      url.searchParams.append('s', 'ptr,' + s.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async wait(): Promise<GstPromiseResultValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_parent(): Promise<GstMiniObject | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMiniObject(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_parent(value_: GstMiniObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/ptr,${this.ptr}/fields/parent`, apiConfig.baseUrl);
    // Object with explode=true: add each property as separate parameter
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('ptr', value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Promise/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstPromiseResult {
  export const PENDING: 'pending' = 'pending';
  export const INTERRUPTED: 'interrupted' = 'interrupted';
  export const REPLIED: 'replied' = 'replied';
  export const EXPIRED: 'expired' = 'expired';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/PromiseResult/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstPromiseResultValue = "pending" | "interrupted" | "replied" | "expired";

  
// Finalization registry for GstProxyPadPrivate
const gstproxypadprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ProxyPadPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstProxyPadPrivate:', ptr, err));
});

export class GstProxyPadPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstproxypadprivateRegistry.register(this, ptr);
  }


}
  export type GstPluginFeatureFilter = (feature: GstPluginFeature, user_data: Pointer) => boolean;

export function convertGstPluginFeatureFilterArgs(data: any): Parameters<GstPluginFeatureFilter> {
  return [
    new GstPluginFeature(data.feature, 'none'),
    data.user_data  ];
}
  export type GstPluginFilter = (plugin: GstPlugin, user_data: Pointer) => boolean;

export function convertGstPluginFilterArgs(data: any): Parameters<GstPluginFilter> {
  return [
    new GstPlugin(data.plugin, 'none'),
    data.user_data  ];
}
  
export class GstRegistry extends GstObject {




      





 
  static async fork_is_enabled(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/fork_is_enabled`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async fork_set_enabled(enabled: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/fork_set_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('enabled', String(enabled));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get(): Promise<GstRegistry> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/get`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstRegistry(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_feature(feature: GstPluginFeature): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/add_feature`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (feature && typeof feature === 'object' && 'ptr' in feature) {
      url.searchParams.append('feature', 'ptr,' + feature.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async add_plugin(plugin: GstPlugin): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/add_plugin`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async check_feature_version(feature_name: string, min_major: number, min_minor: number, min_micro: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/check_feature_version`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature_name', String(feature_name));
    // Primitive parameter
    url.searchParams.append('min_major', String(min_major));
    // Primitive parameter
    url.searchParams.append('min_minor', String(min_minor));
    // Primitive parameter
    url.searchParams.append('min_micro', String(min_micro));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async feature_filter(first: boolean, filter: GstPluginFeatureFilter): Promise<{filter: number, return: GLibList}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/feature_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('first', String(first));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.filter !== undefined) {
        callbackDispatcher.set(data.filter.toString(), {
          converter: convertGstPluginFeatureFilterArgs,
          userFunction: filter
        });
      }
        const result: any = {};
      // Handle return parameter: filter
      result.filter = (() => {
        return data.filter;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a List, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibList(data.return.ptr, 'full', GstPluginFeature, undefined);
          return instance;
        }
        return Promise.reject("Call failed");

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async find_feature(name: string, type_: string): Promise<GstPluginFeature | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/find_feature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPluginFeature(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async find_plugin(name: string): Promise<GstPlugin | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/find_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPlugin(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_feature_list(type_: string): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/get_feature_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstPluginFeature, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_feature_list_by_plugin(name: string): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/get_feature_list_by_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstPluginFeature, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_feature_list_cookie(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/get_feature_list_cookie`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_plugin_list(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/get_plugin_list`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstPlugin, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async lookup(filename: string): Promise<GstPlugin | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPlugin(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async lookup_feature(name: string): Promise<GstPluginFeature | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/lookup_feature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstPluginFeature(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async plugin_filter(first: boolean, filter: GstPluginFilter): Promise<{filter: number, return: GLibList}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/plugin_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('first', String(first));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.filter !== undefined) {
        callbackDispatcher.set(data.filter.toString(), {
          converter: convertGstPluginFilterArgs,
          userFunction: filter
        });
      }
        const result: any = {};
      // Handle return parameter: filter
      result.filter = (() => {
        return data.filter;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a List, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GLibList(data.return.ptr, 'full', GstPlugin, undefined);
          return instance;
        }
        return Promise.reject("Call failed");

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove_feature(feature: GstPluginFeature): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/remove_feature`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (feature && typeof feature === 'object' && 'ptr' in feature) {
      url.searchParams.append('feature', 'ptr,' + feature.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async remove_plugin(plugin: GstPlugin): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/remove_plugin`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async scan_path(path: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/ptr,${this.ptr}/scan_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Registry/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstRegistryPrivate
const gstregistryprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/RegistryPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstRegistryPrivate:', ptr, err));
});

export class GstRegistryPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstregistryprivateRegistry.register(this, ptr);
  }


}
  export namespace GstResourceError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_FOUND: 'not_found' = 'not_found';
  export const BUSY: 'busy' = 'busy';
  export const OPEN_READ: 'open_read' = 'open_read';
  export const OPEN_WRITE: 'open_write' = 'open_write';
  export const OPEN_READ_WRITE: 'open_read_write' = 'open_read_write';
  export const CLOSE: 'close' = 'close';
  export const READ: 'read' = 'read';
  export const WRITE: 'write' = 'write';
  export const SEEK: 'seek' = 'seek';
  export const SYNC: 'sync' = 'sync';
  export const SETTINGS: 'settings' = 'settings';
  export const NO_SPACE_LEFT: 'no_space_left' = 'no_space_left';
  export const NOT_AUTHORIZED: 'not_authorized' = 'not_authorized';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
    





 
  export async function quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ResourceError/quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ResourceError/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstResourceErrorValue = "failed" | "too_lazy" | "not_found" | "busy" | "open_read" | "open_write" | "open_read_write" | "close" | "read" | "write" | "seek" | "sync" | "settings" | "no_space_left" | "not_authorized" | "num_errors";

  export namespace GstSearchMode {
  export const EXACT: 'exact' = 'exact';
  export const BEFORE: 'before' = 'before';
  export const AFTER: 'after' = 'after';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SearchMode/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstSearchModeValue = "exact" | "before" | "after";

  export type GstTaskPoolFunction = (user_data: Pointer) => void;

export function convertGstTaskPoolFunctionArgs(data: any): Parameters<GstTaskPoolFunction> {
  return [
    data.user_data  ];
}
  
export class GstTaskPool extends GstObject {


    





 
  static async new(): Promise<GstTaskPool> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstTaskPool(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async cleanup(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/cleanup`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async dispose_handle(id?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/dispose_handle`, apiConfig.baseUrl);
    // Primitive parameter
    if (id !== undefined) url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async join(id?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    // Primitive parameter
    if (id !== undefined) url.searchParams.append('id', String(id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async prepare(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/prepare`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async push(func: GstTaskPoolFunction): Promise<{func: number, return: Pointer | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstTaskPoolFunctionArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TaskPool/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstSharedTaskPool extends GstTaskPool {


    





 
  static async new(): Promise<GstTaskPool> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SharedTaskPool/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstTaskPool(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  async get_max_threads(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SharedTaskPool/ptr,${this.ptr}/get_max_threads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_max_threads(max_threads: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SharedTaskPool/ptr,${this.ptr}/set_max_threads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_threads', String(max_threads));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SharedTaskPool/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstSharedTaskPoolPrivate
const gstsharedtaskpoolprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/SharedTaskPoolPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstSharedTaskPoolPrivate:', ptr, err));
});

export class GstSharedTaskPoolPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstsharedtaskpoolprivateRegistry.register(this, ptr);
  }


}
  export namespace GstStackTraceFlags {
  export const NONE: 'none' = 'none';
  export const FULL: 'full' = 'full';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StackTraceFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstStackTraceFlagsValue = "none" | "full";

  
// Finalization registry for GstStreamCollectionPrivate
const gststreamcollectionprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/StreamCollectionPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstStreamCollectionPrivate:', ptr, err));
});

export class GstStreamCollectionPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gststreamcollectionprivateRegistry.register(this, ptr);
  }


}
  export namespace GstStreamError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const TYPE_NOT_FOUND: 'type_not_found' = 'type_not_found';
  export const WRONG_TYPE: 'wrong_type' = 'wrong_type';
  export const CODEC_NOT_FOUND: 'codec_not_found' = 'codec_not_found';
  export const DECODE: 'decode' = 'decode';
  export const ENCODE: 'encode' = 'encode';
  export const DEMUX: 'demux' = 'demux';
  export const MUX: 'mux' = 'mux';
  export const FORMAT: 'format' = 'format';
  export const DECRYPT: 'decrypt' = 'decrypt';
  export const DECRYPT_NOKEY: 'decrypt_nokey' = 'decrypt_nokey';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
    





 
  export async function quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamError/quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/StreamError/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstStreamErrorValue = "failed" | "too_lazy" | "not_implemented" | "type_not_found" | "wrong_type" | "codec_not_found" | "decode" | "encode" | "demux" | "mux" | "format" | "decrypt" | "decrypt_nokey" | "num_errors";

  
// Finalization registry for GstStreamPrivate
const gststreamprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/StreamPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstStreamPrivate:', ptr, err));
});

export class GstStreamPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gststreamprivateRegistry.register(this, ptr);
  }


}
  
export class GstSystemClock extends GstClock {




      





 
  static async obtain(): Promise<GstClock> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SystemClock/obtain`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstClock(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async set_default(new_clock?: GstClock): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SystemClock/set_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (new_clock !== undefined && typeof new_clock === 'object' && 'ptr' in new_clock) {
      url.searchParams.append('new_clock', 'ptr,' + new_clock.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/SystemClock/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstSystemClockPrivate
const gstsystemclockprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/SystemClockPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstSystemClockPrivate:', ptr, err));
});

export class GstSystemClockPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstsystemclockprivateRegistry.register(this, ptr);
  }


}
  export namespace GstTagFlag {
  export const UNDEFINED: 'undefined' = 'undefined';
  export const META: 'meta' = 'meta';
  export const ENCODED: 'encoded' = 'encoded';
  export const DECODED: 'decoded' = 'decoded';
  export const COUNT: 'count' = 'count';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TagFlag/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTagFlagValue = "undefined" | "meta" | "encoded" | "decoded" | "count";

  export type GstTaskThreadFunc = (task: GstTask, thread: GLibThread, user_data: Pointer) => void;

export function convertGstTaskThreadFuncArgs(data: any): Parameters<GstTaskThreadFunc> {
  return [
    new GstTask(data.task, 'none'),
    new GLibThread(data.thread, 'none'),
    data.user_data  ];
}
  
export class GstTask extends GstObject {


    





 
  static async new(func: GstTaskFunction): Promise<{func: number, return: GstTask}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstTaskFunctionArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
              // Return value is an object, instantiate it from the ptr
              if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
                // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
                const instance = new GstTask(data.return.ptr, 'full');
                return instance;
              }
              return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }



      





 
  static async cleanup_all(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/cleanup_all`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_pool(): Promise<GstTaskPool> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/get_pool`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstTaskPool(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_state(): Promise<GstTaskStateValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/get_state`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async join(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async pause(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/pause`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async resume(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/resume`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_enter_callback(enter_func: GstTaskThreadFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_enter_callback`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.enter_func !== undefined) {
        callbackDispatcher.set(data.enter_func.toString(), {
          converter: convertGstTaskThreadFuncArgs,
          userFunction: enter_func
        });
      }
    return data.enter_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_leave_callback(leave_func: GstTaskThreadFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_leave_callback`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.leave_func !== undefined) {
        callbackDispatcher.set(data.leave_func.toString(), {
          converter: convertGstTaskThreadFuncArgs,
          userFunction: leave_func
        });
      }
    return data.leave_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_lock(mutex: GLibRecMutex): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_lock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mutex && typeof mutex === 'object' && 'ptr' in mutex) {
      url.searchParams.append('mutex', 'ptr,' + mutex.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_pool(pool: GstTaskPool): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_pool`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pool && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async set_state(state: GstTaskStateValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/set_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async start(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async stop(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Task/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstTaskPrivate
const gsttaskprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/TaskPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstTaskPrivate:', ptr, err));
});

export class GstTaskPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gsttaskprivateRegistry.register(this, ptr);
  }


}
  
// Finalization registry for GstTimedValue
const gsttimedvalueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/TimedValue/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstTimedValue:', ptr, err));
});

export class GstTimedValue {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gsttimedvalueRegistry.register(this, ptr);
  }


}
  
export class GstTracer extends GstObject {




      





 
  static async register(name: string, type_: string, plugin?: GstPlugin): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Tracer/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Tracer/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstTracerFactory extends GstPluginFeature {




      





 
  static async get_list(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerFactory/get_list`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstTracerFactory, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_tracer_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerFactory/ptr,${this.ptr}/get_tracer_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerFactory/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstTracerPrivate
const gsttracerprivateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/TracerPrivate/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstTracerPrivate:', ptr, err));
});

export class GstTracerPrivate {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gsttracerprivateRegistry.register(this, ptr);
  }


}
  
export class GstTracerRecord extends GstObject {




      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerRecord/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstTracerValueFlags {
  export const NONE: 'none' = 'none';
  export const OPTIONAL: 'optional' = 'optional';
  export const AGGREGATED: 'aggregated' = 'aggregated';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerValueFlags/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTracerValueFlagsValue = "none" | "optional" | "aggregated";

  export namespace GstTracerValueScope {
  export const PROCESS: 'process' = 'process';
  export const THREAD: 'thread' = 'thread';
  export const ELEMENT: 'element' = 'element';
  export const PAD: 'pad' = 'pad';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TracerValueScope/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTracerValueScopeValue = "process" | "thread" | "element" | "pad";

  export type GstTypeFindFunction = (find: GstTypeFind, user_data: Pointer) => void;

export function convertGstTypeFindFunctionArgs(data: any): Parameters<GstTypeFindFunction> {
  return [
    new GstTypeFind(data.find, 'none'),
    data.user_data  ];
}
  
// Finalization registry for GstTypeFind
const gsttypefindRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/TypeFind/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstTypeFind:', ptr, err));
});

export class GstTypeFind {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gsttypefindRegistry.register(this, ptr);
  }
    





 
  static async new(): Promise<GstTypeFind> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstTypeFind(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async get_length(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/get_length`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async peek(offset: number, size: number): Promise<number | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async suggest(probability: number, caps: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/suggest`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('probability', String(probability));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async suggest_empty_simple(probability: number, media_type: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/suggest_empty_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('probability', String(probability));
    // Primitive parameter
    url.searchParams.append('media_type', String(media_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async register(name: string, rank: number, func: GstTypeFindFunction, plugin?: GstPlugin, extensions?: string, possible_caps?: GstCaps): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    if (extensions !== undefined) url.searchParams.append('extensions', String(extensions));
    // Object with explode=false: serialize as comma-separated
    if (possible_caps !== undefined && typeof possible_caps === 'object' && 'ptr' in possible_caps) {
      url.searchParams.append('possible_caps', 'ptr,' + possible_caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstTypeFindFunctionArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_peek(): Promise<Gstpeek | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/fields/peek`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_suggest(): Promise<Gstsuggest | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/fields/suggest`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_data(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async put_data(value_: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/fields/data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_get_length(): Promise<Gstget_length | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/fields/get_length`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get__gst_reserved(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFind/ptr,${this.ptr}/fields/_gst_reserved`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export type Gstpeek = (data_: Pointer, offset: number, size: number) => number;

export function convertGstpeekArgs(data: any): Parameters<Gstpeek> {
  return [
    data.data,
    data.offset,
    data.size  ];
}
  export type Gstsuggest = (data_: Pointer, probability: number, caps: GstCaps) => void;

export function convertGstsuggestArgs(data: any): Parameters<Gstsuggest> {
  return [
    data.data,
    data.probability,
    new GstCaps(data.caps, 'none')  ];
}
  export type Gstget_length = (data_: Pointer) => number;

export function convertGstget_lengthArgs(data: any): Parameters<Gstget_length> {
  return [
    data.data  ];
}
  
export class GstTypeFindFactory extends GstPluginFeature {




      





 
  static async get_list(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/get_list`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstTypeFindFactory, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async call_function(find: GstTypeFind): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/ptr,${this.ptr}/call_function`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (find && typeof find === 'object' && 'ptr' in find) {
      url.searchParams.append('find', 'ptr,' + find.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_caps(): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async get_extensions(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/ptr,${this.ptr}/get_extensions`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  async has_function(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/ptr,${this.ptr}/has_function`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindFactory/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GstTypeFindProbability {
  export const NONE: 'none' = 'none';
  export const MINIMUM: 'minimum' = 'minimum';
  export const POSSIBLE: 'possible' = 'possible';
  export const LIKELY: 'likely' = 'likely';
  export const NEARLY_CERTAIN: 'nearly_certain' = 'nearly_certain';
  export const MAXIMUM: 'maximum' = 'maximum';
    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/TypeFindProbability/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstTypeFindProbabilityValue = "none" | "minimum" | "possible" | "likely" | "nearly_certain" | "maximum";

  export namespace GstURIError {
  export const UNSUPPORTED_PROTOCOL: 'unsupported_protocol' = 'unsupported_protocol';
  export const BAD_URI: 'bad_uri' = 'bad_uri';
  export const BAD_STATE: 'bad_state' = 'bad_state';
  export const BAD_REFERENCE: 'bad_reference' = 'bad_reference';
    





 
  export async function quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/URIError/quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  export async function get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/URIError/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  }
  export type GstURIErrorValue = "unsupported_protocol" | "bad_uri" | "bad_state" | "bad_reference";

  
// Finalization registry for GstUri
const gsturiRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/Uri/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstUri:', ptr, err));
});

export class GstUri {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gsturiRegistry.register(this, ptr);
  }
    





 
  static async new(port: number, scheme?: string, userinfo?: string, host?: string, path?: string, query?: string, fragment?: string): Promise<GstUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


      





 
  async free(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }


    





 
  async append_path(relative_path?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/append_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (relative_path !== undefined) url.searchParams.append('relative_path', String(relative_path));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async append_path_segment(path_segment?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/append_path_segment`, apiConfig.baseUrl);
    // Primitive parameter
    if (path_segment !== undefined) url.searchParams.append('path_segment', String(path_segment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async equal(second: GstUri): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (second && typeof second === 'object' && 'ptr' in second) {
      url.searchParams.append('second', 'ptr,' + second.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async from_string_with_base(uri: string): Promise<GstUri | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/from_string_with_base`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_fragment(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_fragment`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_host(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_host`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_media_fragment_table(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_media_fragment_table`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_path(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_path`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_path_segments(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_path_segments`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', string, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_path_string(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_path_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_port(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_port`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_query_keys(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_keys`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'container', string, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_query_string(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_query_string_ordered(keys?: GLibList): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_string_ordered`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (keys !== undefined && typeof keys === 'object' && 'ptr' in keys) {
      url.searchParams.append('keys', 'ptr,' + keys.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_query_table(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_table`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_query_value(query_key: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_query_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_scheme(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_scheme`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async get_userinfo(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/get_userinfo`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_normalized(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/is_normalized`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async is_writable(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/is_writable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async join(ref_uri?: GstUri): Promise<GstUri | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ref_uri !== undefined && typeof ref_uri === 'object' && 'ptr' in ref_uri) {
      url.searchParams.append('ref_uri', 'ptr,' + ref_uri.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async make_writable(): Promise<GstUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/make_writable`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async new_with_base(port: number, scheme?: string, userinfo?: string, host?: string, path?: string, query?: string, fragment?: string): Promise<GstUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/new_with_base`, apiConfig.baseUrl);
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async normalize(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/normalize`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async query_has_key(query_key: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/query_has_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async remove_query_key(query_key: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/remove_query_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_fragment(fragment?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_fragment`, apiConfig.baseUrl);
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_host(host: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_host`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('host', String(host));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_path(path?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_path_segments(path_segments?: GLibList): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_path_segments`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (path_segments !== undefined && typeof path_segments === 'object' && 'ptr' in path_segments) {
      url.searchParams.append('path_segments', 'ptr,' + path_segments.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_path_string(path: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_path_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_port(port: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_port`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('port', String(port));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_query_string(query?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_query_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_query_table(query_table?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_query_table`, apiConfig.baseUrl);
    // Primitive parameter
    if (query_table !== undefined) url.searchParams.append('query_table', String(query_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_query_value(query_key: string, query_value?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_query_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    // Primitive parameter
    if (query_value !== undefined) url.searchParams.append('query_value', String(query_value));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_scheme(scheme: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async set_userinfo(userinfo: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/set_userinfo`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('userinfo', String(userinfo));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  async to_string_with_keys(keys?: GLibList): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/ptr,${this.ptr}/to_string_with_keys`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (keys !== undefined && typeof keys === 'object' && 'ptr' in keys) {
      url.searchParams.append('keys', 'ptr,' + keys.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async construct(protocol: string, location: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/construct`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    // Primitive parameter
    url.searchParams.append('location', String(location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async from_string(uri: string): Promise<GstUri | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async from_string_escaped(uri: string): Promise<GstUri | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/from_string_escaped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_location(uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/get_location`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_protocol(uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/get_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async has_protocol(uri: string, protocol: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/has_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async is_valid(uri: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async join_strings(base_uri: string, ref_uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/join_strings`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('base_uri', String(base_uri));
    // Primitive parameter
    url.searchParams.append('ref_uri', String(ref_uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async protocol_is_supported(type_: GstURITypeValue, protocol: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/protocol_is_supported`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async protocol_is_valid(protocol: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/protocol_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

    





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/Uri/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstValueArray {




      





 
  static async append_and_take_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/append_and_take_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async append_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/append_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_size(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/get_size`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_value(value_: GObjectValue, index: number): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/get_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async init(value_: GObjectValue, prealloc: number): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/init`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('prealloc', String(prealloc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async prepend_value(value_: GObjectValue, prepend_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/prepend_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (prepend_value && typeof prepend_value === 'object' && 'ptr' in prepend_value) {
      url.searchParams.append('prepend_value', 'ptr,' + prepend_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueArray/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
export class GstValueList {




      





 
  static async append_and_take_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/append_and_take_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async append_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/append_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async concat(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/concat`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_size(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/get_size`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_value(value_: GObjectValue, index: number): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/get_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('index', String(index));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async init(value_: GObjectValue, prealloc: number): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/init`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('prealloc', String(prealloc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async merge(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/merge`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async prepend_value(value_: GObjectValue, prepend_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/prepend_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (prepend_value && typeof prepend_value === 'object' && 'ptr' in prepend_value) {
      url.searchParams.append('prepend_value', 'ptr,' + prepend_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

      





 
  static async get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/ValueList/get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  
// Finalization registry for GstValueTable
const gstvaluetableRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/Gst/ValueTable/ptr,' + ptr + '/free')
    .catch(err => console.error('Failed to free GstValueTable:', ptr, err));
});

export class GstValueTable {

  ptr!: string;

  constructor(ptr: string, transferType: transferType) {
    this.ptr = ptr;
    if (transferType === 'full')
      gstvaluetableRegistry.register(this, ptr);
  }


}
  export type GstLogFunction = (category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, object: GObjectObject, message: GstDebugMessage, user_data: Pointer) => void;

export function convertGstLogFunctionArgs(data: any): Parameters<GstLogFunction> {
  return [
    new GstDebugCategory(data.category, 'none'),
    data.level,
    data.file,
    data.function,
    data.line,
    new GObjectObject(data.object, 'none'),
    new GstDebugMessage(data.message, 'none'),
    data.user_data  ];
}
  export namespace GIRest {
  





 
  export async function callbacks(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GIRest/callbacks`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace Gst {
  





 
  export async function buffer_get_max_memory(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/buffer_get_max_memory`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function caps_features_from_string(features: string): Promise<GstCapsFeatures | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/caps_features_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('features', String(features));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCapsFeatures(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function caps_from_string(string: string): Promise<GstCaps | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/caps_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function core_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/core_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_add_log_function(func: GstLogFunction): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_add_log_function`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstLogFunctionArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_add_ring_buffer_logger(max_size_per_thread: number, thread_timeout: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_add_ring_buffer_logger`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_size_per_thread', String(max_size_per_thread));
    // Primitive parameter
    url.searchParams.append('thread_timeout', String(thread_timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_bin_to_dot_data(bin: GstBin, details: GstDebugGraphDetailsValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_bin_to_dot_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bin && typeof bin === 'object' && 'ptr' in bin) {
      url.searchParams.append('bin', 'ptr,' + bin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('details', String(details));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_bin_to_dot_file(bin: GstBin, details: GstDebugGraphDetailsValue, file_name: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_bin_to_dot_file`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bin && typeof bin === 'object' && 'ptr' in bin) {
      url.searchParams.append('bin', 'ptr,' + bin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('details', String(details));
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_bin_to_dot_file_with_ts(bin: GstBin, details: GstDebugGraphDetailsValue, file_name: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_bin_to_dot_file_with_ts`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bin && typeof bin === 'object' && 'ptr' in bin) {
      url.searchParams.append('bin', 'ptr,' + bin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('details', String(details));
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_construct_term_color(colorinfo: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_construct_term_color`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('colorinfo', String(colorinfo));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_construct_win_color(colorinfo: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_construct_win_color`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('colorinfo', String(colorinfo));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_get_all_categories(): Promise<GLibSList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_get_all_categories`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSList(data.return.ptr, 'container');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_get_color_mode(): Promise<GstDebugColorModeValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_get_color_mode`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_get_default_threshold(): Promise<GstDebugLevelValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_get_default_threshold`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_get_stack_trace(flags: GstStackTraceFlagsValue): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_get_stack_trace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_is_active(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_is_active`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_is_colored(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_is_colored`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_level_get_name(level: GstDebugLevelValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_level_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_log_default(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message: GstDebugMessage, object?: GObjectObject, user_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_log_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (object !== undefined && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_log_get_line(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message: GstDebugMessage, object?: GObjectObject): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_log_get_line`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (object !== undefined && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_log_id_literal(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message_string: string, id?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_log_id_literal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    if (id !== undefined) url.searchParams.append('id', String(id));
    // Primitive parameter
    url.searchParams.append('message_string', String(message_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_log_literal(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message_string: string, object?: GObjectObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_log_literal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (object !== undefined && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('message_string', String(message_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_print_stack_trace(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_print_stack_trace`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_remove_log_function(func: GstLogFunction): Promise<{func: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_remove_log_function`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstLogFunctionArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_remove_log_function_by_data(data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_remove_log_function_by_data`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_remove_ring_buffer_logger(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_remove_ring_buffer_logger`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_ring_buffer_logger_get_logs(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_ring_buffer_logger_get_logs`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_set_active(active: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_active`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('active', String(active));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_set_color_mode(mode: GstDebugColorModeValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_color_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_set_color_mode_from_string(mode: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_color_mode_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_set_colored(colored: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_colored`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('colored', String(colored));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_set_default_threshold(level: GstDebugLevelValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_default_threshold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_set_threshold_for_name(name: string, level: GstDebugLevelValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_threshold_for_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('level', String(level));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_set_threshold_from_string(list: string, reset: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_set_threshold_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('reset', String(reset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function debug_unset_threshold_for_name(name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/debug_unset_threshold_for_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function deinit(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/deinit`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dynamic_type_register(plugin: GstPlugin, type_: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/dynamic_type_register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function error_get_message(domain: number, code: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/error_get_message`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function event_type_get_flags(type_: GstEventTypeValue): Promise<GstEventTypeFlagsValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/event_type_get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function event_type_get_name(type_: GstEventTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/event_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function event_type_to_quark(type_: GstEventTypeValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/event_type_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function event_type_to_sticky_ordering(type_: GstEventTypeValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/event_type_to_sticky_ordering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function filename_to_uri(filename: Pointer): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/filename_to_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function flow_get_name(ret: GstFlowReturnValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/flow_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function flow_to_quark(ret: GstFlowReturnValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/flow_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function format_get_by_nick(nick: string): Promise<GstFormatValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_get_by_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function format_get_details(format: GstFormatValue): Promise<GstFormatDefinition | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_get_details`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstFormatDefinition(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function format_get_name(format: GstFormatValue): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function format_iterate_definitions(): Promise<GstIterator> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_iterate_definitions`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstIterator(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function format_register(nick: string, description: string): Promise<GstFormatValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function format_to_quark(format: GstFormatValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/format_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function formats_contains(formats: Pointer, format: GstFormatValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/formats_contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('formats', String(formats));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_main_executable_path(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/get_main_executable_path`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function init(argc?: number, argv?: Pointer): Promise<{argc: number, argv: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/init`, apiConfig.baseUrl);
    // Primitive parameter
    if (argc !== undefined) url.searchParams.append('argc', String(argc));
    // Primitive parameter
    if (argv !== undefined) url.searchParams.append('argv', String(argv));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: argc
      result.argc = (() => {
        return data.argc;

      })();
      // Handle return parameter: argv
      result.argv = (() => {
        return data.argv;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function init_check(argc?: number, argv?: Pointer): Promise<{argc: number, argv: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/init_check`, apiConfig.baseUrl);
    // Primitive parameter
    if (argc !== undefined) url.searchParams.append('argc', String(argc));
    // Primitive parameter
    if (argv !== undefined) url.searchParams.append('argv', String(argv));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: argc
      result.argc = (() => {
        return data.argc;

      })();
      // Handle return parameter: argv
      result.argv = (() => {
        return data.argv;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function is_caps_features(obj?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/is_caps_features`, apiConfig.baseUrl);
    // Primitive parameter
    if (obj !== undefined) url.searchParams.append('obj', String(obj));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function is_initialized(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/is_initialized`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function library_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/library_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function message_type_get_name(type_: GstMessageTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/message_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function message_type_to_quark(type_: GstMessageTypeValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/message_type_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function meta_api_type_get_tags(api: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_api_type_get_tags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function meta_api_type_has_tag(api: string, tag: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_api_type_has_tag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function meta_api_type_register(api: string, tags: Pointer): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_api_type_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function meta_deserialize(buffer: GstBuffer, data_: number, size: number): Promise<{consumed: number, return: GstMeta | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_deserialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: consumed
      result.consumed = (() => {
        return data.consumed;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GstMeta(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function meta_get_info(impl: string): Promise<GstMetaInfo | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_get_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('impl', String(impl));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function meta_register_custom(name: string, tags: Pointer, transform_func: GstCustomMetaTransformFunction): Promise<{transform_func: number, return: GstMetaInfo}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_register_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.transform_func !== undefined) {
        callbackDispatcher.set(data.transform_func.toString(), {
          converter: convertGstCustomMetaTransformFunctionArgs,
          userFunction: transform_func
        });
      }
        const result: any = {};
      // Handle return parameter: transform_func
      result.transform_func = (() => {
        return data.transform_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
          const instance = new GstMetaInfo(data.return.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function meta_register_custom_simple(name: string): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/meta_register_custom_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function mini_object_replace(olddata?: GstMiniObject, newdata?: GstMiniObject): Promise<{olddata: GstMiniObject, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/mini_object_replace`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata !== undefined && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata !== undefined && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: olddata
      result.olddata = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.olddata && typeof data.olddata === 'object' && 'ptr' in data.olddata) {
          const instance = new GstMiniObject(data.olddata.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function mini_object_take(olddata: GstMiniObject, newdata: GstMiniObject): Promise<{olddata: GstMiniObject, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/mini_object_take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: olddata
      result.olddata = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.olddata && typeof data.olddata === 'object' && 'ptr' in data.olddata) {
          const instance = new GstMiniObject(data.olddata.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function pad_mode_get_name(mode: GstPadModeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/pad_mode_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_array(name: string, nick: string, blurb: string, element_spec: GObjectParamSpec, flags: GObjectParamFlags): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/param_spec_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('blurb', String(blurb));
    // Object with explode=false: serialize as comma-separated
    if (element_spec && typeof element_spec === 'object' && 'ptr' in element_spec) {
      url.searchParams.append('element_spec', 'ptr,' + element_spec.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_fraction(name: string, nick: string, blurb: string, min_num: number, min_denom: number, max_num: number, max_denom: number, default_num: number, default_denom: number, flags: GObjectParamFlags): Promise<GObjectParamSpec | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/param_spec_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('min_num', String(min_num));
    // Primitive parameter
    url.searchParams.append('min_denom', String(min_denom));
    // Primitive parameter
    url.searchParams.append('max_num', String(max_num));
    // Primitive parameter
    url.searchParams.append('max_denom', String(max_denom));
    // Primitive parameter
    url.searchParams.append('default_num', String(default_num));
    // Primitive parameter
    url.searchParams.append('default_denom', String(default_denom));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parent_buffer_meta_api_get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parent_buffer_meta_api_get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parent_buffer_meta_get_info(): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parent_buffer_meta_get_info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parse_bin_from_description(bin_description: string, ghost_unlinked_pads: boolean): Promise<GstBin> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_bin_from_description`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('bin_description', String(bin_description));
    // Primitive parameter
    url.searchParams.append('ghost_unlinked_pads', String(ghost_unlinked_pads));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstBin(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parse_bin_from_description_full(bin_description: string, ghost_unlinked_pads: boolean, flags: GstParseFlagsValue, context?: GstParseContext): Promise<GstElement> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_bin_from_description_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('bin_description', String(bin_description));
    // Primitive parameter
    url.searchParams.append('ghost_unlinked_pads', String(ghost_unlinked_pads));
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parse_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parse_launch(pipeline_description: string): Promise<GstElement> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_launch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pipeline_description', String(pipeline_description));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parse_launch_full(pipeline_description: string, flags: GstParseFlagsValue, context?: GstParseContext): Promise<GstElement> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_launch_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pipeline_description', String(pipeline_description));
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parse_launchv(argv: Pointer): Promise<GstElement> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_launchv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parse_launchv_full(argv: Pointer, flags: GstParseFlagsValue, context?: GstParseContext): Promise<GstElement> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/parse_launchv_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GstElement(data.return.ptr, 'none');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function plugin_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/plugin_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function preset_get_app_dir(): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/preset_get_app_dir`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function preset_set_app_dir(app_dir: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/preset_set_app_dir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('app_dir', String(app_dir));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function protection_filter_systems_by_available_decryptors(system_identifiers: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/protection_filter_systems_by_available_decryptors`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('system_identifiers', String(system_identifiers));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function protection_meta_api_get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/protection_meta_api_get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function protection_meta_get_info(): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/protection_meta_get_info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function protection_select_system(system_identifiers: Pointer): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/protection_select_system`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('system_identifiers', String(system_identifiers));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function query_type_get_flags(type_: GstQueryTypeValue): Promise<GstQueryTypeFlagsValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/query_type_get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function query_type_get_name(type_: GstQueryTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/query_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function query_type_to_quark(type_: GstQueryTypeValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/query_type_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function reference_timestamp_meta_api_get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/reference_timestamp_meta_api_get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function reference_timestamp_meta_get_info(): Promise<GstMetaInfo> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/reference_timestamp_meta_get_info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstMetaInfo(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function resource_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/resource_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function segtrap_is_enabled(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/segtrap_is_enabled`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function segtrap_set_enabled(enabled: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/segtrap_set_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('enabled', String(enabled));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function state_change_get_name(transition: GstStateChangeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/state_change_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('transition', String(transition));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function static_caps_get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/static_caps_get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function static_pad_template_get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/static_pad_template_get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function stream_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/stream_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function stream_type_get_name(stype: GstStreamTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/stream_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stype', String(stype));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function structure_take(oldstr_ptr?: GstStructure, newstr?: GstStructure): Promise<{oldstr_ptr: GstStructure, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/structure_take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (oldstr_ptr !== undefined && typeof oldstr_ptr === 'object' && 'ptr' in oldstr_ptr) {
      url.searchParams.append('oldstr_ptr', 'ptr,' + oldstr_ptr.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newstr !== undefined && typeof newstr === 'object' && 'ptr' in newstr) {
      url.searchParams.append('newstr', 'ptr,' + newstr.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: oldstr_ptr
      result.oldstr_ptr = (() => {
        // Return value is a struct, instantiate it from the ptr
        if (data.oldstr_ptr && typeof data.oldstr_ptr === 'object' && 'ptr' in data.oldstr_ptr) {
          const instance = new GstStructure(data.oldstr_ptr.ptr, 'none');
          return instance;
        }
        return Promise.reject("Call failed");
      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tag_exists(tag: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_exists`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tag_get_description(tag: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_get_description`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tag_get_flag(tag: string): Promise<GstTagFlagValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_get_flag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tag_get_nick(tag: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_get_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tag_get_type(tag: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_get_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tag_is_fixed(tag: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_is_fixed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tag_list_copy_value(dest: GObjectValue, list: GstTagList, tag: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_list_copy_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tag_merge_strings_with_comma(dest: GObjectValue, src: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_merge_strings_with_comma`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tag_merge_use_first(dest: GObjectValue, src: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tag_merge_use_first`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function toc_entry_type_get_nick(type_: GstTocEntryTypeValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/toc_entry_type_get_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tracing_get_active_tracers(): Promise<GLibList> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tracing_get_active_tracers`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a List, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibList(data.return.ptr, 'full', GstTracer, undefined);
  return instance;
}
return Promise.reject("Call failed");


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function tracing_register_hook(tracer: GstTracer, detail: string, func: GObjectCallback): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/tracing_register_hook`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tracer && typeof tracer === 'object' && 'ptr' in tracer) {
      url.searchParams.append('tracer', 'ptr,' + tracer.ptr);
    }
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGObjectCallbackArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_find_get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/type_find_get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_find_register(name: string, rank: number, func: GstTypeFindFunction, plugin?: GstPlugin, extensions?: string, possible_caps?: GstCaps): Promise<{func: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/type_find_register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    if (extensions !== undefined) url.searchParams.append('extensions', String(extensions));
    // Object with explode=false: serialize as comma-separated
    if (possible_caps !== undefined && typeof possible_caps === 'object' && 'ptr' in possible_caps) {
      url.searchParams.append('possible_caps', 'ptr,' + possible_caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGstTypeFindFunctionArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_is_plugin_api(type_: string, flags: GstPluginAPIFlagsValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/type_is_plugin_api`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_mark_as_plugin_api(type_: string, flags: GstPluginAPIFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/type_mark_as_plugin_api`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function update_registry(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/update_registry`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_construct(protocol: string, location: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_construct`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    // Primitive parameter
    url.searchParams.append('location', String(location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_from_string(uri: string): Promise<GstUri | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_from_string_escaped(uri: string): Promise<GstUri | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_from_string_escaped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_get_location(uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_get_location`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_get_protocol(uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_get_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_has_protocol(uri: string, protocol: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_has_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_is_valid(uri: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_join_strings(base_uri: string, ref_uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_join_strings`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('base_uri', String(base_uri));
    // Primitive parameter
    url.searchParams.append('ref_uri', String(ref_uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_protocol_is_supported(type_: GstURITypeValue, protocol: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_protocol_is_supported`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_protocol_is_valid(protocol: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/uri_protocol_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_array_binary_search(num_elements: number, element_size: number, mode: GstSearchModeValue, search_func: GLibCompareDataFunc, array?: Pointer, search_data?: Pointer): Promise<{search_func: number, return: Pointer | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_array_binary_search`, apiConfig.baseUrl);
    // Primitive parameter
    if (array !== undefined) url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('num_elements', String(num_elements));
    // Primitive parameter
    url.searchParams.append('element_size', String(element_size));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    if (search_data !== undefined) url.searchParams.append('search_data', String(search_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.search_func !== undefined) {
        callbackDispatcher.set(data.search_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: search_func
        });
      }
        const result: any = {};
      // Handle return parameter: search_func
      result.search_func = (() => {
        return data.search_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_ceil_log2(v: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_ceil_log2`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v', String(v));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_double_to_fraction(src: number): Promise<{dest_n: number, dest_d: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_double_to_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src', String(src));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: dest_n
      result.dest_n = (() => {
        return data.dest_n;

      })();
      // Handle return parameter: dest_d
      result.dest_d = (() => {
        return data.dest_d;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_dump_buffer(buf: GstBuffer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_dump_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buf && typeof buf === 'object' && 'ptr' in buf) {
      url.searchParams.append('buf', 'ptr,' + buf.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_dump_mem(mem: Pointer, size: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_dump_mem`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_filename_compare(a: Pointer, b: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_filename_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_fraction_add(a_n: number, a_d: number, b_n: number, b_d: number): Promise<{res_n: number, res_d: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_fraction_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a_n', String(a_n));
    // Primitive parameter
    url.searchParams.append('a_d', String(a_d));
    // Primitive parameter
    url.searchParams.append('b_n', String(b_n));
    // Primitive parameter
    url.searchParams.append('b_d', String(b_d));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: res_n
      result.res_n = (() => {
        return data.res_n;

      })();
      // Handle return parameter: res_d
      result.res_d = (() => {
        return data.res_d;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_fraction_compare(a_n: number, a_d: number, b_n: number, b_d: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_fraction_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a_n', String(a_n));
    // Primitive parameter
    url.searchParams.append('a_d', String(a_d));
    // Primitive parameter
    url.searchParams.append('b_n', String(b_n));
    // Primitive parameter
    url.searchParams.append('b_d', String(b_d));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_fraction_multiply(a_n: number, a_d: number, b_n: number, b_d: number): Promise<{res_n: number, res_d: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_fraction_multiply`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a_n', String(a_n));
    // Primitive parameter
    url.searchParams.append('a_d', String(a_d));
    // Primitive parameter
    url.searchParams.append('b_n', String(b_n));
    // Primitive parameter
    url.searchParams.append('b_d', String(b_d));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: res_n
      result.res_n = (() => {
        return data.res_n;

      })();
      // Handle return parameter: res_d
      result.res_d = (() => {
        return data.res_d;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_fraction_to_double(src_n: number, src_d: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_fraction_to_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_n', String(src_n));
    // Primitive parameter
    url.searchParams.append('src_d', String(src_d));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.dest;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_gdouble_to_guint64(value_: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_gdouble_to_guint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_get_object_array(object: GObjectObject, name: string, array: GObjectValueArray): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_get_object_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_get_timestamp(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_get_timestamp`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_greatest_common_divisor(a: number, b: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_greatest_common_divisor`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_greatest_common_divisor_int64(a: number, b: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_greatest_common_divisor_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_group_id_next(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_group_id_next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_guint64_to_gdouble(value_: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_guint64_to_gdouble`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_seqnum_compare(s1: number, s2: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_seqnum_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_seqnum_next(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_seqnum_next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_set_object_arg(object: GObjectObject, name: string, value_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_set_object_arg`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_set_object_array(object: GObjectObject, name: string, array: GObjectValueArray): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_set_object_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_set_value_from_string(value_: GObjectValue, value_str: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_set_value_from_string`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('value_str', String(value_str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_simplify_fraction(numerator: number, denominator: number, n_terms: number, threshold: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_simplify_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('numerator', String(numerator));
    // Primitive parameter
    url.searchParams.append('denominator', String(denominator));
    // Primitive parameter
    url.searchParams.append('n_terms', String(n_terms));
    // Primitive parameter
    url.searchParams.append('threshold', String(threshold));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_uint64_scale(val: number, num: number, denom: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_uint64_scale_ceil(val: number, num: number, denom: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_ceil`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_uint64_scale_int(val: number, num: number, denom: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_uint64_scale_int_ceil(val: number, num: number, denom: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_int_ceil`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_uint64_scale_int_round(val: number, num: number, denom: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_int_round`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function util_uint64_scale_round(val: number, num: number, denom: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/util_uint64_scale_round`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_can_compare(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_can_compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_can_intersect(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_can_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_can_subtract(minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_can_subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (minuend && typeof minuend === 'object' && 'ptr' in minuend) {
      url.searchParams.append('minuend', 'ptr,' + minuend.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_can_union(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_can_union`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_compare(value1: GObjectValue, value2: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_deserialize(dest: GObjectValue, src: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_deserialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    url.searchParams.append('src', String(src));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_deserialize_with_pspec(dest: GObjectValue, src: string, pspec?: GObjectParamSpec): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_deserialize_with_pspec`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Object with explode=false: serialize as comma-separated
    if (pspec !== undefined && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_fixate(dest: GObjectValue, src: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_fixate`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_fraction_multiply(product: GObjectValue, factor1: GObjectValue, factor2: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_fraction_multiply`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (product && typeof product === 'object' && 'ptr' in product) {
      url.searchParams.append('product', 'ptr,' + product.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (factor1 && typeof factor1 === 'object' && 'ptr' in factor1) {
      url.searchParams.append('factor1', 'ptr,' + factor1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (factor2 && typeof factor2 === 'object' && 'ptr' in factor2) {
      url.searchParams.append('factor2', 'ptr,' + factor2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_fraction_subtract(dest: GObjectValue, minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_fraction_subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (minuend && typeof minuend === 'object' && 'ptr' in minuend) {
      url.searchParams.append('minuend', 'ptr,' + minuend.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_bitmask(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_bitmask`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_caps(value_: GObjectValue): Promise<GstCaps> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCaps(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_caps_features(value_: GObjectValue): Promise<GstCapsFeatures> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_caps_features`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstCapsFeatures(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_double_range_max(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_double_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_double_range_min(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_double_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_flagset_flags(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_flagset_flags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_flagset_mask(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_flagset_mask`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_fraction_denominator(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_fraction_denominator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_fraction_numerator(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_fraction_numerator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_fraction_range_max(value_: GObjectValue): Promise<GObjectValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_fraction_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_fraction_range_min(value_: GObjectValue): Promise<GObjectValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_fraction_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_int64_range_max(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int64_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_int64_range_min(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int64_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_int64_range_step(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int64_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_int_range_max(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_int_range_min(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_int_range_step(value_: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_int_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_get_structure(value_: GObjectValue): Promise<GstStructure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_get_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GstStructure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_init_and_copy(dest: GObjectValue, src: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_init_and_copy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_intersect(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_is_fixed(value_: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_is_fixed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_is_subset(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_is_subset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_register(table: GstValueTable): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (table && typeof table === 'object' && 'ptr' in table) {
      url.searchParams.append('table', 'ptr,' + table.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_serialize(value_: GObjectValue): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_serialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_bitmask(value_: GObjectValue, bitmask: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_bitmask`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('bitmask', String(bitmask));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_caps(value_: GObjectValue, caps: GstCaps): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_caps_features(value_: GObjectValue, features: GstCapsFeatures): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_caps_features`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_double_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_double_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_flagset(value_: GObjectValue, flags: number, mask: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_flagset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_fraction(value_: GObjectValue, numerator: number, denominator: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_fraction`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('numerator', String(numerator));
    // Primitive parameter
    url.searchParams.append('denominator', String(denominator));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_fraction_range(value_: GObjectValue, start: GObjectValue, end: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_fraction_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (start && typeof start === 'object' && 'ptr' in start) {
      url.searchParams.append('start', 'ptr,' + start.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_fraction_range_full(value_: GObjectValue, numerator_start: number, denominator_start: number, numerator_end: number, denominator_end: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_fraction_range_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('numerator_start', String(numerator_start));
    // Primitive parameter
    url.searchParams.append('denominator_start', String(denominator_start));
    // Primitive parameter
    url.searchParams.append('numerator_end', String(numerator_end));
    // Primitive parameter
    url.searchParams.append('denominator_end', String(denominator_end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_int64_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_int64_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_int64_range_step(value_: GObjectValue, start: number, end: number, step: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_int64_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    // Primitive parameter
    url.searchParams.append('step', String(step));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_int_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_int_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_int_range_step(value_: GObjectValue, start: number, end: number, step: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_int_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    // Primitive parameter
    url.searchParams.append('step', String(step));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_set_structure(value_: GObjectValue, structure: GstStructure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_set_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_subtract(dest: GObjectValue, minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (minuend && typeof minuend === 'object' && 'ptr' in minuend) {
      url.searchParams.append('minuend', 'ptr,' + minuend.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_union(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/value_union`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function version(): Promise<{major: number, minor: number, micro: number, nano: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/version`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: major
      result.major = (() => {
        return data.major;

      })();
      // Handle return parameter: minor
      result.minor = (() => {
        return data.minor;

      })();
      // Handle return parameter: micro
      result.micro = (() => {
        return data.micro;

      })();
      // Handle return parameter: nano
      result.nano = (() => {
        return data.nano;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function version_string(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/Gst/version_string`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GObject {
  





 
  export async function boxed_copy(boxed_type: string, src_boxed: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/boxed_copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('boxed_type', String(boxed_type));
    // Primitive parameter
    url.searchParams.append('src_boxed', String(src_boxed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function boxed_free(boxed_type: string, boxed: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/boxed_free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('boxed_type', String(boxed_type));
    // Primitive parameter
    url.searchParams.append('boxed', String(boxed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function boxed_type_register_static(name: string, boxed_copy: GObjectBoxedCopyFunc, boxed_free: GObjectBoxedFreeFunc): Promise<{boxed_copy: number, boxed_free: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/boxed_type_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.boxed_copy !== undefined) {
        callbackDispatcher.set(data.boxed_copy.toString(), {
          converter: convertGObjectBoxedCopyFuncArgs,
          userFunction: boxed_copy
        });
      }
      if (data.boxed_free !== undefined) {
        callbackDispatcher.set(data.boxed_free.toString(), {
          converter: convertGObjectBoxedFreeFuncArgs,
          userFunction: boxed_free
        });
      }
        const result: any = {};
      // Handle return parameter: boxed_copy
      result.boxed_copy = (() => {
        return data.boxed_copy;

      })();
      // Handle return parameter: boxed_free
      result.boxed_free = (() => {
        return data.boxed_free;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_BOOLEAN__BOXED_BOXED(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_BOOLEAN__BOXED_BOXED`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_BOOLEAN__FLAGS(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_BOOLEAN__FLAGS`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_STRING__OBJECT_POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_STRING__OBJECT_POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__BOOLEAN(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__BOOLEAN`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__BOXED(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__BOXED`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__CHAR(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__CHAR`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__DOUBLE(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__DOUBLE`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__ENUM(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__ENUM`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__FLAGS(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__FLAGS`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__FLOAT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__FLOAT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__INT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__INT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__LONG(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__LONG`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__OBJECT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__OBJECT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__PARAM(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__PARAM`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__STRING(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__STRING`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__UCHAR(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__UCHAR`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__UINT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__UINT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__UINT_POINTER(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__UINT_POINTER`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__ULONG(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__ULONG`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__VARIANT(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__VARIANT`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_VOID__VOID(closure: GObjectClosure, return_value: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_VOID__VOID`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function cclosure_marshal_generic(closure: GObjectClosure, return_gvalue: GObjectValue, n_param_values: number, param_values: GObjectValue, invocation_hint?: Pointer, marshal_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/cclosure_marshal_generic`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_gvalue && typeof return_gvalue === 'object' && 'ptr' in return_gvalue) {
      url.searchParams.append('return_gvalue', 'ptr,' + return_gvalue.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Object with explode=false: serialize as comma-separated
    if (param_values && typeof param_values === 'object' && 'ptr' in param_values) {
      url.searchParams.append('param_values', 'ptr,' + param_values.ptr);
    }
    // Primitive parameter
    if (invocation_hint !== undefined) url.searchParams.append('invocation_hint', String(invocation_hint));
    // Primitive parameter
    if (marshal_data !== undefined) url.searchParams.append('marshal_data', String(marshal_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function clear_signal_handler(handler_id_ptr: number, instance: GObjectObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/clear_signal_handler`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('handler_id_ptr', String(handler_id_ptr));
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function enum_complete_type_info(g_enum_type: string, info: GObjectTypeInfo, const_values: GObjectEnumValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_complete_type_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_enum_type', String(g_enum_type));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (const_values && typeof const_values === 'object' && 'ptr' in const_values) {
      url.searchParams.append('const_values', 'ptr,' + const_values.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function enum_get_value(enum_class: GObjectEnumClass, value_: number): Promise<GObjectEnumValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_get_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (enum_class && typeof enum_class === 'object' && 'ptr' in enum_class) {
      url.searchParams.append('enum_class', 'ptr,' + enum_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectEnumValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function enum_get_value_by_name(enum_class: GObjectEnumClass, name: string): Promise<GObjectEnumValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_get_value_by_name`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (enum_class && typeof enum_class === 'object' && 'ptr' in enum_class) {
      url.searchParams.append('enum_class', 'ptr,' + enum_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectEnumValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function enum_get_value_by_nick(enum_class: GObjectEnumClass, nick: string): Promise<GObjectEnumValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_get_value_by_nick`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (enum_class && typeof enum_class === 'object' && 'ptr' in enum_class) {
      url.searchParams.append('enum_class', 'ptr,' + enum_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectEnumValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function enum_register_static(name: string, const_static_values: GObjectEnumValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (const_static_values && typeof const_static_values === 'object' && 'ptr' in const_static_values) {
      url.searchParams.append('const_static_values', 'ptr,' + const_static_values.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function enum_to_string(g_enum_type: string, value_: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/enum_to_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_enum_type', String(g_enum_type));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function flags_complete_type_info(g_flags_type: string, info: GObjectTypeInfo, const_values: GObjectFlagsValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_complete_type_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_flags_type', String(g_flags_type));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (const_values && typeof const_values === 'object' && 'ptr' in const_values) {
      url.searchParams.append('const_values', 'ptr,' + const_values.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function flags_get_first_value(flags_class: GObjectFlagsClass, value_: number): Promise<GObjectFlagsValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_get_first_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (flags_class && typeof flags_class === 'object' && 'ptr' in flags_class) {
      url.searchParams.append('flags_class', 'ptr,' + flags_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectFlagsValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function flags_get_value_by_name(flags_class: GObjectFlagsClass, name: string): Promise<GObjectFlagsValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_get_value_by_name`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (flags_class && typeof flags_class === 'object' && 'ptr' in flags_class) {
      url.searchParams.append('flags_class', 'ptr,' + flags_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectFlagsValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function flags_get_value_by_nick(flags_class: GObjectFlagsClass, nick: string): Promise<GObjectFlagsValue | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_get_value_by_nick`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (flags_class && typeof flags_class === 'object' && 'ptr' in flags_class) {
      url.searchParams.append('flags_class', 'ptr,' + flags_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectFlagsValue(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function flags_register_static(name: string, const_static_values: GObjectFlagsValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (const_static_values && typeof const_static_values === 'object' && 'ptr' in const_static_values) {
      url.searchParams.append('const_static_values', 'ptr,' + const_static_values.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function flags_to_string(flags_type: string, value_: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/flags_to_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function gtype_get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/gtype_get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_boolean(name: string, default_value: boolean, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_boxed(name: string, boxed_type: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_boxed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('boxed_type', String(boxed_type));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_char(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_double(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_enum(name: string, enum_type: string, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('enum_type', String(enum_type));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_flags(name: string, flags_type: string, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_float(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_float`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_gtype(name: string, is_a_type: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_gtype`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('is_a_type', String(is_a_type));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_int(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_int64(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_long(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_long`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_object(name: string, object_type: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_object`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('object_type', String(object_type));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_param(name: string, param_type: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('param_type', String(param_type));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_pointer(name: string, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_string(name: string, flags: GObjectParamFlags, nick?: string, blurb?: string, default_value?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    if (default_value !== undefined) url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_uchar(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_uchar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_uint(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_uint64(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_ulong(name: string, minimum: number, maximum: number, default_value: number, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_ulong`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('minimum', String(minimum));
    // Primitive parameter
    url.searchParams.append('maximum', String(maximum));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_unichar(name: string, default_value: Pointer, flags: GObjectParamFlags, nick?: string, blurb?: string): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_unichar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('default_value', String(default_value));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_spec_variant(name: string, type_: GLibVariantType, flags: GObjectParamFlags, nick?: string, blurb?: string, default_value?: GLibVariant): Promise<GObjectParamSpec> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_spec_variant`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    if (nick !== undefined) url.searchParams.append('nick', String(nick));
    // Primitive parameter
    if (blurb !== undefined) url.searchParams.append('blurb', String(blurb));
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (default_value !== undefined && typeof default_value === 'object' && 'ptr' in default_value) {
      url.searchParams.append('default_value', 'ptr,' + default_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
          // Return value is an object, instantiate it from the ptr
      if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
        // If transfer is "full", pass false (caller doesn't own), otherwise pass true (caller owns)
        const instance = new GObjectParamSpec(data.return.ptr, 'full');
        return instance;
      }
      return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_type_register_static(name: string, pspec_info: GObjectParamSpecTypeInfo): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_type_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (pspec_info && typeof pspec_info === 'object' && 'ptr' in pspec_info) {
      url.searchParams.append('pspec_info', 'ptr,' + pspec_info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_value_convert(pspec: GObjectParamSpec, src_value: GObjectValue, dest_value: GObjectValue, strict_validation: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_convert`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src_value && typeof src_value === 'object' && 'ptr' in src_value) {
      url.searchParams.append('src_value', 'ptr,' + src_value.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (dest_value && typeof dest_value === 'object' && 'ptr' in dest_value) {
      url.searchParams.append('dest_value', 'ptr,' + dest_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('strict_validation', String(strict_validation));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_value_defaults(pspec: GObjectParamSpec, value_: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_defaults`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_value_is_valid(pspec: GObjectParamSpec, value_: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_is_valid`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_value_set_default(pspec: GObjectParamSpec, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_set_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_value_validate(pspec: GObjectParamSpec, value_: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_value_validate`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function param_values_cmp(pspec: GObjectParamSpec, value1: GObjectValue, value2: GObjectValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/param_values_cmp`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function pointer_type_register_static(name: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/pointer_type_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_accumulator_first_wins(ihint: GObjectSignalInvocationHint, return_accu: GObjectValue, handler_return: GObjectValue, dummy?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_accumulator_first_wins`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ihint && typeof ihint === 'object' && 'ptr' in ihint) {
      url.searchParams.append('ihint', 'ptr,' + ihint.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_accu && typeof return_accu === 'object' && 'ptr' in return_accu) {
      url.searchParams.append('return_accu', 'ptr,' + return_accu.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (handler_return && typeof handler_return === 'object' && 'ptr' in handler_return) {
      url.searchParams.append('handler_return', 'ptr,' + handler_return.ptr);
    }
    // Primitive parameter
    if (dummy !== undefined) url.searchParams.append('dummy', String(dummy));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_accumulator_true_handled(ihint: GObjectSignalInvocationHint, return_accu: GObjectValue, handler_return: GObjectValue, dummy?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_accumulator_true_handled`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ihint && typeof ihint === 'object' && 'ptr' in ihint) {
      url.searchParams.append('ihint', 'ptr,' + ihint.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (return_accu && typeof return_accu === 'object' && 'ptr' in return_accu) {
      url.searchParams.append('return_accu', 'ptr,' + return_accu.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (handler_return && typeof handler_return === 'object' && 'ptr' in handler_return) {
      url.searchParams.append('handler_return', 'ptr,' + handler_return.ptr);
    }
    // Primitive parameter
    if (dummy !== undefined) url.searchParams.append('dummy', String(dummy));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_add_emission_hook(signal_id: number, detail: number, hook_func: GObjectSignalEmissionHook): Promise<{hook_func: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_add_emission_hook`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.hook_func !== undefined) {
        callbackDispatcher.set(data.hook_func.toString(), {
          converter: convertGObjectSignalEmissionHookArgs,
          userFunction: hook_func
        });
      }
        const result: any = {};
      // Handle return parameter: hook_func
      result.hook_func = (() => {
        return data.hook_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_chain_from_overridden(instance_and_params: Pointer, return_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_chain_from_overridden`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_and_params', String(instance_and_params));
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_connect_closure(instance: GObjectObject, detailed_signal: string, closure: GObjectClosure, after: boolean): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_connect_closure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    url.searchParams.append('after', String(after));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_connect_closure_by_id(instance: GObjectObject, signal_id: number, detail: number, closure: GObjectClosure, after: boolean): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_connect_closure_by_id`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    url.searchParams.append('after', String(after));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_emitv(instance_and_params: Pointer, signal_id: number, detail: number, return_value: GObjectValue): Promise<GObjectValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_emitv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_and_params', String(instance_and_params));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return_value && typeof data.return_value === 'object' && 'ptr' in data.return_value) {
  const instance = new GObjectValue(data.return_value.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_get_invocation_hint(instance: GObjectObject): Promise<GObjectSignalInvocationHint | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_get_invocation_hint`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectSignalInvocationHint(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_handler_block(instance: GObjectObject, handler_id: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_block`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_handler_disconnect(instance: GObjectObject, handler_id: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_disconnect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_handler_find(instance: GObjectObject, mask: GObjectSignalMatchType, signal_id: number, detail: number, closure?: GObjectClosure, func?: Pointer, data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_find`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure !== undefined && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    if (func !== undefined) url.searchParams.append('func', String(func));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_handler_is_connected(instance: GObjectObject, handler_id: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_is_connected`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_handler_unblock(instance: GObjectObject, handler_id: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handler_unblock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_handlers_block_matched(instance: GObjectObject, mask: GObjectSignalMatchType, signal_id: number, detail: number, closure?: GObjectClosure, func?: Pointer, data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handlers_block_matched`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure !== undefined && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    if (func !== undefined) url.searchParams.append('func', String(func));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_handlers_destroy(instance: GObjectObject): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handlers_destroy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_handlers_disconnect_matched(instance: GObjectObject, mask: GObjectSignalMatchType, signal_id: number, detail: number, closure?: GObjectClosure, func?: Pointer, data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handlers_disconnect_matched`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure !== undefined && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    if (func !== undefined) url.searchParams.append('func', String(func));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_handlers_unblock_matched(instance: GObjectObject, mask: GObjectSignalMatchType, signal_id: number, detail: number, closure?: GObjectClosure, func?: Pointer, data_?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_handlers_unblock_matched`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Object with explode=false: serialize as comma-separated
    if (closure !== undefined && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    // Primitive parameter
    if (func !== undefined) url.searchParams.append('func', String(func));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_has_handler_pending(instance: GObjectObject, signal_id: number, detail: number, may_be_blocked: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_has_handler_pending`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    // Primitive parameter
    url.searchParams.append('may_be_blocked', String(may_be_blocked));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_is_valid_name(name: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_is_valid_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_list_ids(itype: string): Promise<{n_ids: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_list_ids`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: n_ids
      result.n_ids = (() => {
        return data.n_ids;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_lookup(name: string, itype: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_name(signal_id: number): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_newv(signal_name: string, itype: string, signal_flags: GObjectSignalFlags, return_type: string, n_params: number, accumulator: GObjectSignalAccumulator, c_marshaller: GObjectClosureMarshal, class_closure?: GObjectClosure, param_types?: Pointer): Promise<{accumulator: number, c_marshaller: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_newv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_name', String(signal_name));
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    // Primitive parameter
    url.searchParams.append('signal_flags', String(signal_flags));
    // Object with explode=false: serialize as comma-separated
    if (class_closure !== undefined && typeof class_closure === 'object' && 'ptr' in class_closure) {
      url.searchParams.append('class_closure', 'ptr,' + class_closure.ptr);
    }
    // Primitive parameter
    url.searchParams.append('return_type', String(return_type));
    // Primitive parameter
    url.searchParams.append('n_params', String(n_params));
    // Primitive parameter
    if (param_types !== undefined) url.searchParams.append('param_types', String(param_types));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.accumulator !== undefined) {
        callbackDispatcher.set(data.accumulator.toString(), {
          converter: convertGObjectSignalAccumulatorArgs,
          userFunction: accumulator
        });
      }
      if (data.c_marshaller !== undefined) {
        callbackDispatcher.set(data.c_marshaller.toString(), {
          converter: convertGObjectClosureMarshalArgs,
          userFunction: c_marshaller
        });
      }
        const result: any = {};
      // Handle return parameter: accumulator
      result.accumulator = (() => {
        return data.accumulator;

      })();
      // Handle return parameter: c_marshaller
      result.c_marshaller = (() => {
        return data.c_marshaller;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_override_class_closure(signal_id: number, instance_type: string, class_closure: GObjectClosure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_override_class_closure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Object with explode=false: serialize as comma-separated
    if (class_closure && typeof class_closure === 'object' && 'ptr' in class_closure) {
      url.searchParams.append('class_closure', 'ptr,' + class_closure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_override_class_handler(signal_name: string, instance_type: string, class_handler: GObjectCallback): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_override_class_handler`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_name', String(signal_name));
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.class_handler !== undefined) {
        callbackDispatcher.set(data.class_handler.toString(), {
          converter: convertGObjectCallbackArgs,
          userFunction: class_handler
        });
      }
    return data.class_handler;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_parse_name(detailed_signal: string, itype: string, force_detail_quark: boolean): Promise<{signal_id_p: number, detail_p: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_parse_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    // Primitive parameter
    url.searchParams.append('force_detail_quark', String(force_detail_quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: signal_id_p
      result.signal_id_p = (() => {
        return data.signal_id_p;

      })();
      // Handle return parameter: detail_p
      result.detail_p = (() => {
        return data.detail_p;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_query(signal_id: number, query: GObjectSignalQuery): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_query`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_remove_emission_hook(signal_id: number, hook_id: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_remove_emission_hook`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('hook_id', String(hook_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_set_va_marshaller(signal_id: number, instance_type: string, va_marshaller: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_set_va_marshaller`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('va_marshaller', String(va_marshaller));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_stop_emission(instance: GObjectObject, signal_id: number, detail: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_stop_emission`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('signal_id', String(signal_id));
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_stop_emission_by_name(instance: GObjectObject, detailed_signal: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_stop_emission_by_name`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('detailed_signal', String(detailed_signal));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function signal_type_cclosure_new(itype: string, struct_offset: number): Promise<GObjectClosure> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/signal_type_cclosure_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('itype', String(itype));
    // Primitive parameter
    url.searchParams.append('struct_offset', String(struct_offset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectClosure(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function source_set_closure(source: GLibSource, closure: GObjectClosure): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/source_set_closure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (source && typeof source === 'object' && 'ptr' in source) {
      url.searchParams.append('source', 'ptr,' + source.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function source_set_dummy_callback(source: GLibSource): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/source_set_dummy_callback`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (source && typeof source === 'object' && 'ptr' in source) {
      url.searchParams.append('source', 'ptr,' + source.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strdup_value_contents(value_: GObjectValue): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/strdup_value_contents`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_add_class_private(class_type: string, private_size: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_add_class_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('class_type', String(class_type));
    // Primitive parameter
    url.searchParams.append('private_size', String(private_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_add_instance_private(class_type: string, private_size: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_add_instance_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('class_type', String(class_type));
    // Primitive parameter
    url.searchParams.append('private_size', String(private_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_add_interface_dynamic(instance_type: string, interface_type: string, plugin: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_add_interface_dynamic`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Primitive parameter
    url.searchParams.append('plugin', String(plugin));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_add_interface_static(instance_type: string, interface_type: string, info: GObjectInterfaceInfo): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_add_interface_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_check_class_is_a(g_class: GObjectTypeClass, is_a_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_class_is_a`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_class && typeof g_class === 'object' && 'ptr' in g_class) {
      url.searchParams.append('g_class', 'ptr,' + g_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('is_a_type', String(is_a_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_check_instance(instance: GObjectTypeInstance): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_instance`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_check_instance_is_a(instance: GObjectTypeInstance, iface_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_instance_is_a`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('iface_type', String(iface_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_check_instance_is_fundamentally_a(instance: GObjectTypeInstance, fundamental_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_instance_is_fundamentally_a`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    // Primitive parameter
    url.searchParams.append('fundamental_type', String(fundamental_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_check_is_value_type(type_: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_is_value_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_check_value(value_: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_check_value_holds(value_: GObjectValue, type_: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_check_value_holds`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_children(type_: string): Promise<{n_children: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_children`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: n_children
      result.n_children = (() => {
        return data.n_children;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_class_adjust_private_offset(private_size_or_offset: number, g_class?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_class_adjust_private_offset`, apiConfig.baseUrl);
    // Primitive parameter
    if (g_class !== undefined) url.searchParams.append('g_class', String(g_class));
    // Primitive parameter
    url.searchParams.append('private_size_or_offset', String(private_size_or_offset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_class_peek(type_: string): Promise<GObjectTypeClass> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_class_peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeClass(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_class_peek_static(type_: string): Promise<GObjectTypeClass> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_class_peek_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeClass(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_class_ref(type_: string): Promise<GObjectTypeClass> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_class_ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeClass(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_default_interface_peek(g_type: string): Promise<GObjectTypeInterface> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_default_interface_peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_type', String(g_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeInterface(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_default_interface_ref(g_type: string): Promise<GObjectTypeInterface> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_default_interface_ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_type', String(g_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeInterface(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_default_interface_unref(g_iface: GObjectTypeInterface): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_default_interface_unref`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_depth(type_: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_depth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_ensure(type_: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_ensure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_free_instance(instance: GObjectTypeInstance): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_free_instance`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_from_name(name: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_from_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_fundamental(type_id: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_fundamental`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_id', String(type_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_fundamental_next(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_fundamental_next`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_get_instance_count(type_: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_get_instance_count`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_get_plugin(type_: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_get_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_get_qdata(type_: string, quark: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_get_type_registration_serial(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_get_type_registration_serial`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_init(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_init`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_init_with_debug_flags(debug_flags: GObjectTypeDebugFlags): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_init_with_debug_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('debug_flags', String(debug_flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_interface_add_prerequisite(interface_type: string, prerequisite_type: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_add_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Primitive parameter
    url.searchParams.append('prerequisite_type', String(prerequisite_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_interface_get_plugin(instance_type: string, interface_type: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_get_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_interface_instantiatable_prerequisite(interface_type: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_instantiatable_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_interface_peek(instance_class: GObjectTypeClass, iface_type: string): Promise<GObjectTypeInterface> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_peek`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance_class && typeof instance_class === 'object' && 'ptr' in instance_class) {
      url.searchParams.append('instance_class', 'ptr,' + instance_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('iface_type', String(iface_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GObjectTypeInterface(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_interface_prerequisites(interface_type: string): Promise<{n_prerequisites: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interface_prerequisites`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: n_prerequisites
      result.n_prerequisites = (() => {
        return data.n_prerequisites;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_interfaces(type_: string): Promise<{n_interfaces: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_interfaces`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: n_interfaces
      result.n_interfaces = (() => {
        return data.n_interfaces;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_is_a(type_: string, is_a_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_is_a`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('is_a_type', String(is_a_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_name(type_: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_name_from_class(g_class: GObjectTypeClass): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_name_from_class`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_class && typeof g_class === 'object' && 'ptr' in g_class) {
      url.searchParams.append('g_class', 'ptr,' + g_class.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_name_from_instance(instance: GObjectTypeInstance): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_name_from_instance`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_next_base(leaf_type: string, root_type: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_next_base`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('leaf_type', String(leaf_type));
    // Primitive parameter
    url.searchParams.append('root_type', String(root_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_parent(type_: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_parent`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_qname(type_: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_qname`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_query(type_: string, query: GObjectTypeQuery): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_query`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_register_dynamic(parent_type: string, type_name: string, plugin: Pointer, flags: GObjectTypeFlags): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_register_dynamic`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('parent_type', String(parent_type));
    // Primitive parameter
    url.searchParams.append('type_name', String(type_name));
    // Primitive parameter
    url.searchParams.append('plugin', String(plugin));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_register_fundamental(type_id: string, type_name: string, info: GObjectTypeInfo, finfo: GObjectTypeFundamentalInfo, flags: GObjectTypeFlags): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_register_fundamental`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_id', String(type_id));
    // Primitive parameter
    url.searchParams.append('type_name', String(type_name));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (finfo && typeof finfo === 'object' && 'ptr' in finfo) {
      url.searchParams.append('finfo', 'ptr,' + finfo.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_register_static(parent_type: string, type_name: string, info: GObjectTypeInfo, flags: GObjectTypeFlags): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('parent_type', String(parent_type));
    // Primitive parameter
    url.searchParams.append('type_name', String(type_name));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_set_qdata(type_: string, quark: number, data_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_set_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function type_test_flags(type_: string, flags: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/type_test_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_type_compatible(src_type: string, dest_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/value_type_compatible`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function value_type_transformable(src_type: string, dest_type: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/value_type_transformable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_get_gtype(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GObject/variant_get_gtype`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GModule {
  





 
  export async function module_build_path(module_name: string, directory?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/module_build_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (directory !== undefined) url.searchParams.append('directory', String(directory));
    // Primitive parameter
    url.searchParams.append('module_name', String(module_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function module_error(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/module_error`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function module_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/module_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function module_supported(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GModule/module_supported`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
  export namespace GLib {
  





 
  export async function access(filename: Pointer, mode: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/access`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function aligned_alloc(n_blocks: number, n_block_bytes: number, alignment: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/aligned_alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    // Primitive parameter
    url.searchParams.append('alignment', String(alignment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function aligned_alloc0(n_blocks: number, n_block_bytes: number, alignment: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/aligned_alloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    // Primitive parameter
    url.searchParams.append('alignment', String(alignment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function aligned_free(mem?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/aligned_free`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function aligned_free_sized(alignment: number, size: number, mem?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/aligned_free_sized`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('alignment', String(alignment));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_digit_value(c: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_digit_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_dtostr(buffer: string, buf_len: number, d: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_dtostr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buffer', String(buffer));
    // Primitive parameter
    url.searchParams.append('buf_len', String(buf_len));
    // Primitive parameter
    url.searchParams.append('d', String(d));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_formatd(buffer: string, buf_len: number, format: string, d: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_formatd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('buffer', String(buffer));
    // Primitive parameter
    url.searchParams.append('buf_len', String(buf_len));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('d', String(d));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_strcasecmp(s1: string, s2: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strcasecmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_strdown(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strdown`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_string_to_signed(str: string, base: number, min: number, max: number): Promise<{out_num: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_string_to_signed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('base', String(base));
    // Primitive parameter
    url.searchParams.append('min', String(min));
    // Primitive parameter
    url.searchParams.append('max', String(max));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: out_num
      result.out_num = (() => {
        return data.out_num;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_string_to_unsigned(str: string, base: number, min: number, max: number): Promise<{out_num: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_string_to_unsigned`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('base', String(base));
    // Primitive parameter
    url.searchParams.append('min', String(min));
    // Primitive parameter
    url.searchParams.append('max', String(max));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: out_num
      result.out_num = (() => {
        return data.out_num;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_strncasecmp(s1: string, s2: string, n: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strncasecmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_strtod(nptr: string): Promise<{endptr: string, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strtod`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nptr', String(nptr));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: endptr
      result.endptr = (() => {
        return data.endptr;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_strtoll(nptr: string, base: number): Promise<{endptr: string, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strtoll`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nptr', String(nptr));
    // Primitive parameter
    url.searchParams.append('base', String(base));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: endptr
      result.endptr = (() => {
        return data.endptr;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_strtoull(nptr: string, base: number): Promise<{endptr: string, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strtoull`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nptr', String(nptr));
    // Primitive parameter
    url.searchParams.append('base', String(base));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: endptr
      result.endptr = (() => {
        return data.endptr;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_strup(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_strup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_tolower(c: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_tolower`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_toupper(c: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_toupper`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ascii_xdigit_value(c: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ascii_xdigit_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function assert_warning(log_domain: string, file: string, line: number, pretty_function: string, expression: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assert_warning`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('pretty_function', String(pretty_function));
    // Primitive parameter
    url.searchParams.append('expression', String(expression));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function assertion_message(domain: string, file: string, line: number, func: string, message: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('message', String(message));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function assertion_message_cmpint(domain: string, file: string, line: number, func: string, expr: string, arg1: number, cmp: string, arg2: number, numtype: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message_cmpint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('expr', String(expr));
    // Primitive parameter
    url.searchParams.append('arg1', String(arg1));
    // Primitive parameter
    url.searchParams.append('cmp', String(cmp));
    // Primitive parameter
    url.searchParams.append('arg2', String(arg2));
    // Primitive parameter
    url.searchParams.append('numtype', String(numtype));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function assertion_message_cmpstr(domain: string, file: string, line: number, func: string, expr: string, arg1: string, cmp: string, arg2: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message_cmpstr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('expr', String(expr));
    // Primitive parameter
    url.searchParams.append('arg1', String(arg1));
    // Primitive parameter
    url.searchParams.append('cmp', String(cmp));
    // Primitive parameter
    url.searchParams.append('arg2', String(arg2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function assertion_message_cmpstrv(domain: string, file: string, line: number, func: string, expr: string, arg1: string, arg2: string, first_wrong_idx: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message_cmpstrv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('expr', String(expr));
    // Primitive parameter
    url.searchParams.append('arg1', String(arg1));
    // Primitive parameter
    url.searchParams.append('arg2', String(arg2));
    // Primitive parameter
    url.searchParams.append('first_wrong_idx', String(first_wrong_idx));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function assertion_message_error(domain: string, file: string, line: number, func: string, expr: string, error_: Pointer, error_domain: number, error_code: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/assertion_message_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('expr', String(expr));
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('error_domain', String(error_domain));
    // Primitive parameter
    url.searchParams.append('error_code', String(error_code));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atexit(func: GLibVoidFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atexit`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibVoidFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_add(atomic: number, val: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_and(atomic: number, val: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_and`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_compare_and_exchange(atomic: number, oldval: number, newval: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_compare_and_exchange`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('oldval', String(oldval));
    // Primitive parameter
    url.searchParams.append('newval', String(newval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_compare_and_exchange_full(atomic: number, oldval: number, newval: number): Promise<{preval: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_compare_and_exchange_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('oldval', String(oldval));
    // Primitive parameter
    url.searchParams.append('newval', String(newval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: preval
      result.preval = (() => {
        return data.preval;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_dec_and_test(atomic: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_dec_and_test`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_exchange(atomic: number, newval: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_exchange`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('newval', String(newval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_exchange_and_add(atomic: number, val: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_exchange_and_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_get(atomic: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_get`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_inc(atomic: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_inc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_or(atomic: number, val: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_or`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_set(atomic: number, newval: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_set`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('newval', String(newval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_int_xor(atomic: number, val: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_int_xor`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_pointer_add(atomic: Pointer, val: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_pointer_and(atomic: Pointer, val: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_and`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_pointer_compare_and_exchange(atomic: Pointer, oldval?: Pointer, newval?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_compare_and_exchange`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    if (oldval !== undefined) url.searchParams.append('oldval', String(oldval));
    // Primitive parameter
    if (newval !== undefined) url.searchParams.append('newval', String(newval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_pointer_compare_and_exchange_full(atomic: Pointer, oldval?: Pointer, newval?: Pointer): Promise<{preval: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_compare_and_exchange_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    if (oldval !== undefined) url.searchParams.append('oldval', String(oldval));
    // Primitive parameter
    if (newval !== undefined) url.searchParams.append('newval', String(newval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: preval
      result.preval = (() => {
        return data.preval;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_pointer_exchange(atomic?: Pointer, newval?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_exchange`, apiConfig.baseUrl);
    // Primitive parameter
    if (atomic !== undefined) url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    if (newval !== undefined) url.searchParams.append('newval', String(newval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_pointer_get(atomic: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_get`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_pointer_or(atomic: Pointer, val: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_or`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_pointer_set(atomic: Pointer, newval?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_set`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    if (newval !== undefined) url.searchParams.append('newval', String(newval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_pointer_xor(atomic: Pointer, val: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_pointer_xor`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('atomic', String(atomic));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_rc_box_acquire(mem_block: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_acquire`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_rc_box_alloc(block_size: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_rc_box_alloc0(block_size: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_alloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_rc_box_dup(block_size: number, mem_block: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_dup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_rc_box_get_size(mem_block: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_get_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_rc_box_release(mem_block: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_release`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_rc_box_release_full(mem_block: Pointer, clear_func: GLibDestroyNotify): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_rc_box_release_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.clear_func !== undefined) {
        callbackDispatcher.set(data.clear_func.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: clear_func
        });
      }
    return data.clear_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_ref_count_compare(arc: number, val: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_ref_count_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arc', String(arc));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_ref_count_dec(arc: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_ref_count_dec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arc', String(arc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_ref_count_inc(arc: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_ref_count_inc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arc', String(arc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function atomic_ref_count_init(arc: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/atomic_ref_count_init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('arc', String(arc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function base64_decode(text: string): Promise<{out_len: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_decode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: out_len
      result.out_len = (() => {
        return data.out_len;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function base64_decode_inplace(text: Pointer, out_len: number): Promise<{text: Pointer, out_len: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_decode_inplace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    url.searchParams.append('out_len', String(out_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: text
      result.text = (() => {
        return data.text;

      })();
      // Handle return parameter: out_len
      result.out_len = (() => {
        return data.out_len;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function base64_encode(len: number, data_?: Pointer): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_encode`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function base64_encode_close(break_lines: boolean, state: number, save: number): Promise<{out: Pointer, state: number, save: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_encode_close`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('break_lines', String(break_lines));
    // Primitive parameter
    url.searchParams.append('state', String(state));
    // Primitive parameter
    url.searchParams.append('save', String(save));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: out
      result.out = (() => {
        return data.out;

      })();
      // Handle return parameter: state
      result.state = (() => {
        return data.state;

      })();
      // Handle return parameter: save
      result.save = (() => {
        return data.save;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function base64_encode_step(in_: Pointer, len: number, break_lines: boolean, state: number, save: number): Promise<{out: Pointer, state: number, save: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/base64_encode_step`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('in', String(in_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('break_lines', String(break_lines));
    // Primitive parameter
    url.searchParams.append('state', String(state));
    // Primitive parameter
    url.searchParams.append('save', String(save));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: out
      result.out = (() => {
        return data.out;

      })();
      // Handle return parameter: state
      result.state = (() => {
        return data.state;

      })();
      // Handle return parameter: save
      result.save = (() => {
        return data.save;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function basename(file_name: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/basename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function bit_lock(address: number, lock_bit: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_lock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function bit_nth_lsf(mask: number, nth_bit: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_nth_lsf`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('nth_bit', String(nth_bit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function bit_nth_msf(mask: number, nth_bit: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_nth_msf`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    // Primitive parameter
    url.searchParams.append('nth_bit', String(nth_bit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function bit_storage(number: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_storage`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('number', String(number));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function bit_trylock(address: number, lock_bit: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_trylock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function bit_unlock(address: number, lock_bit: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bit_unlock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function blow_chunks(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/blow_chunks`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function bookmark_file_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/bookmark_file_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function build_filenamev(args: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/build_filenamev`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('args', String(args));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function build_pathv(separator: string, args: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/build_pathv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('separator', String(separator));
    // Primitive parameter
    url.searchParams.append('args', String(args));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_append(array: Pointer, data_: number, len: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_append`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_free(array: Pointer, free_segment: boolean): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('free_segment', String(free_segment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_free_to_bytes(array: Pointer): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_free_to_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_new(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_new_take(data_: Pointer, len: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_new_take`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_prepend(array: Pointer, data_: number, len: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_prepend`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_ref(array: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_remove_index(array: Pointer, index_: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_remove_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_remove_index_fast(array: Pointer, index_: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_remove_index_fast`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_remove_range(array: Pointer, index_: number, length: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_remove_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_set_size(array: Pointer, length: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_set_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_sized_new(reserved_size: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_sized_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('reserved_size', String(reserved_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_sort(array: Pointer, compare_func: GLibCompareFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_sort`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.compare_func !== undefined) {
        callbackDispatcher.set(data.compare_func.toString(), {
          converter: convertGLibCompareFuncArgs,
          userFunction: compare_func
        });
      }
    return data.compare_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_sort_with_data(array: Pointer, compare_func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_sort_with_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.compare_func !== undefined) {
        callbackDispatcher.set(data.compare_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: compare_func
        });
      }
    return data.compare_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_steal(array: Pointer): Promise<{len: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: len
      result.len = (() => {
        return data.len;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function byte_array_unref(array: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/byte_array_unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('array', String(array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function canonicalize_filename(filename: Pointer, relative_to?: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/canonicalize_filename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    if (relative_to !== undefined) url.searchParams.append('relative_to', String(relative_to));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function chdir(path: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/chdir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function check_version(required_major: number, required_minor: number, required_micro: number): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/check_version`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('required_major', String(required_major));
    // Primitive parameter
    url.searchParams.append('required_minor', String(required_minor));
    // Primitive parameter
    url.searchParams.append('required_micro', String(required_micro));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function checksum_type_get_length(checksum_type: GLibChecksumType): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/checksum_type_get_length`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function child_watch_add(priority: number, pid: number, function_: GLibChildWatchFunc): Promise<{function: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/child_watch_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('pid', String(pid));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.function !== undefined) {
        callbackDispatcher.set(data.function.toString(), {
          converter: convertGLibChildWatchFuncArgs,
          userFunction: function_
        });
      }
        const result: any = {};
      // Handle return parameter: function
      result.function = (() => {
        return data.function;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function child_watch_source_new(pid: number): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/child_watch_source_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pid', String(pid));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function chmod(filename: Pointer, mode: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/chmod`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function clear_error(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/clear_error`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function close(fd: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/close`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function closefrom(lowfd: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/closefrom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lowfd', String(lowfd));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function compute_checksum_for_bytes(checksum_type: GLibChecksumType, data_: GLibBytes): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_checksum_for_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function compute_checksum_for_data(checksum_type: GLibChecksumType, data_: Pointer, length: number): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_checksum_for_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function compute_checksum_for_string(checksum_type: GLibChecksumType, str: string, length: number): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_checksum_for_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('checksum_type', String(checksum_type));
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function compute_hmac_for_bytes(digest_type: GLibChecksumType, key: GLibBytes, data_: GLibBytes): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_hmac_for_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('digest_type', String(digest_type));
    // Object with explode=false: serialize as comma-separated
    if (key && typeof key === 'object' && 'ptr' in key) {
      url.searchParams.append('key', 'ptr,' + key.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function compute_hmac_for_data(digest_type: GLibChecksumType, key: Pointer, key_len: number, data_: Pointer, length: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_hmac_for_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('digest_type', String(digest_type));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('key_len', String(key_len));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function compute_hmac_for_string(digest_type: GLibChecksumType, key: Pointer, key_len: number, str: string, length: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/compute_hmac_for_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('digest_type', String(digest_type));
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Primitive parameter
    url.searchParams.append('key_len', String(key_len));
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function convert(str: Pointer, len: number, to_codeset: string, from_codeset: string): Promise<{bytes_read: number, bytes_written: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('to_codeset', String(to_codeset));
    // Primitive parameter
    url.searchParams.append('from_codeset', String(from_codeset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: bytes_read
      result.bytes_read = (() => {
        return data.bytes_read;

      })();
      // Handle return parameter: bytes_written
      result.bytes_written = (() => {
        return data.bytes_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function convert_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/convert_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function convert_with_fallback(str: Pointer, len: number, to_codeset: string, from_codeset: string, fallback: string): Promise<{bytes_read: number, bytes_written: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/convert_with_fallback`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('to_codeset', String(to_codeset));
    // Primitive parameter
    url.searchParams.append('from_codeset', String(from_codeset));
    // Primitive parameter
    url.searchParams.append('fallback', String(fallback));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: bytes_read
      result.bytes_read = (() => {
        return data.bytes_read;

      })();
      // Handle return parameter: bytes_written
      result.bytes_written = (() => {
        return data.bytes_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function creat(filename: Pointer, mode: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/creat`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function datalist_foreach(datalist: GLibData, func: GLibDataForeachFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_foreach`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibDataForeachFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function datalist_get_data(datalist: GLibData, key: string): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_get_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function datalist_get_flags(datalist: GLibData): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_get_flags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function datalist_id_get_data(datalist: GLibData, key_id: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_id_get_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('key_id', String(key_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function datalist_id_remove_multiple(datalist: GLibData, keys: Pointer, n_keys: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_id_remove_multiple`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('keys', String(keys));
    // Primitive parameter
    url.searchParams.append('n_keys', String(n_keys));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function datalist_set_flags(datalist: GLibData, flags: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_set_flags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function datalist_unset_flags(datalist: GLibData, flags: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/datalist_unset_flags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (datalist && typeof datalist === 'object' && 'ptr' in datalist) {
      url.searchParams.append('datalist', 'ptr,' + datalist.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dataset_destroy(dataset_location: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dataset_destroy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dataset_location', String(dataset_location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dataset_foreach(dataset_location: Pointer, func: GLibDataForeachFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dataset_foreach`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dataset_location', String(dataset_location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibDataForeachFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dataset_id_get_data(dataset_location: Pointer, key_id: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dataset_id_get_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dataset_location', String(dataset_location));
    // Primitive parameter
    url.searchParams.append('key_id', String(key_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_get_days_in_month(month: GLibDateMonth, year: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_get_days_in_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_get_monday_weeks_in_year(year: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_get_monday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_get_sunday_weeks_in_year(year: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_get_sunday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_is_leap_year(year: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_is_leap_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_strftime(s: string, slen: number, format: string, date: GLibDate): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_strftime`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s', String(s));
    // Primitive parameter
    url.searchParams.append('slen', String(slen));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Object with explode=false: serialize as comma-separated
    if (date && typeof date === 'object' && 'ptr' in date) {
      url.searchParams.append('date', 'ptr,' + date.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_valid_day(day: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_day`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_valid_dmy(day: number, month: GLibDateMonth, year: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_valid_julian(julian_date: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_date', String(julian_date));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_valid_month(month: GLibDateMonth): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_valid_weekday(weekday: GLibDateWeekday): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_weekday`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('weekday', String(weekday));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function date_valid_year(year: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/date_valid_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dcgettext(msgid: string, category: number, domain?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dcgettext`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    // Primitive parameter
    url.searchParams.append('category', String(category));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dgettext(msgid: string, domain?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dgettext`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dir_make_tmp(tmpl?: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dir_make_tmp`, apiConfig.baseUrl);
    // Primitive parameter
    if (tmpl !== undefined) url.searchParams.append('tmpl', String(tmpl));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function direct_equal(v1?: Pointer, v2?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/direct_equal`, apiConfig.baseUrl);
    // Primitive parameter
    if (v1 !== undefined) url.searchParams.append('v1', String(v1));
    // Primitive parameter
    if (v2 !== undefined) url.searchParams.append('v2', String(v2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function direct_hash(v?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/direct_hash`, apiConfig.baseUrl);
    // Primitive parameter
    if (v !== undefined) url.searchParams.append('v', String(v));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dngettext(msgid: string, msgid_plural: string, n: number, domain?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dngettext`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    // Primitive parameter
    url.searchParams.append('msgid_plural', String(msgid_plural));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function double_equal(v1: Pointer, v2: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/double_equal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v1', String(v1));
    // Primitive parameter
    url.searchParams.append('v2', String(v2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function double_hash(v: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/double_hash`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v', String(v));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dpgettext(msgctxtid: string, msgidoffset: number, domain?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dpgettext`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('msgctxtid', String(msgctxtid));
    // Primitive parameter
    url.searchParams.append('msgidoffset', String(msgidoffset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function dpgettext2(context: string, msgid: string, domain?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/dpgettext2`, apiConfig.baseUrl);
    // Primitive parameter
    if (domain !== undefined) url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('context', String(context));
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function environ_getenv(variable: Pointer, envp?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/environ_getenv`, apiConfig.baseUrl);
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function environ_setenv(variable: Pointer, value_: Pointer, overwrite: boolean, envp?: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/environ_setenv`, apiConfig.baseUrl);
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    // Primitive parameter
    url.searchParams.append('overwrite', String(overwrite));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function environ_unsetenv(variable: Pointer, envp?: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/environ_unsetenv`, apiConfig.baseUrl);
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function error_domain_register(error_type_name: string, error_type_private_size: number, error_type_init: GLibErrorInitFunc, error_type_copy: GLibErrorCopyFunc, error_type_clear: GLibErrorClearFunc): Promise<{error_type_init: number, error_type_copy: number, error_type_clear: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/error_domain_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error_type_name', String(error_type_name));
    // Primitive parameter
    url.searchParams.append('error_type_private_size', String(error_type_private_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.error_type_init !== undefined) {
        callbackDispatcher.set(data.error_type_init.toString(), {
          converter: convertGLibErrorInitFuncArgs,
          userFunction: error_type_init
        });
      }
      if (data.error_type_copy !== undefined) {
        callbackDispatcher.set(data.error_type_copy.toString(), {
          converter: convertGLibErrorCopyFuncArgs,
          userFunction: error_type_copy
        });
      }
      if (data.error_type_clear !== undefined) {
        callbackDispatcher.set(data.error_type_clear.toString(), {
          converter: convertGLibErrorClearFuncArgs,
          userFunction: error_type_clear
        });
      }
        const result: any = {};
      // Handle return parameter: error_type_init
      result.error_type_init = (() => {
        return data.error_type_init;

      })();
      // Handle return parameter: error_type_copy
      result.error_type_copy = (() => {
        return data.error_type_copy;

      })();
      // Handle return parameter: error_type_clear
      result.error_type_clear = (() => {
        return data.error_type_clear;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function error_domain_register_static(error_type_name: string, error_type_private_size: number, error_type_init: GLibErrorInitFunc, error_type_copy: GLibErrorCopyFunc, error_type_clear: GLibErrorClearFunc): Promise<{error_type_init: number, error_type_copy: number, error_type_clear: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/error_domain_register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error_type_name', String(error_type_name));
    // Primitive parameter
    url.searchParams.append('error_type_private_size', String(error_type_private_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.error_type_init !== undefined) {
        callbackDispatcher.set(data.error_type_init.toString(), {
          converter: convertGLibErrorInitFuncArgs,
          userFunction: error_type_init
        });
      }
      if (data.error_type_copy !== undefined) {
        callbackDispatcher.set(data.error_type_copy.toString(), {
          converter: convertGLibErrorCopyFuncArgs,
          userFunction: error_type_copy
        });
      }
      if (data.error_type_clear !== undefined) {
        callbackDispatcher.set(data.error_type_clear.toString(), {
          converter: convertGLibErrorClearFuncArgs,
          userFunction: error_type_clear
        });
      }
        const result: any = {};
      // Handle return parameter: error_type_init
      result.error_type_init = (() => {
        return data.error_type_init;

      })();
      // Handle return parameter: error_type_copy
      result.error_type_copy = (() => {
        return data.error_type_copy;

      })();
      // Handle return parameter: error_type_clear
      result.error_type_clear = (() => {
        return data.error_type_clear;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function fdwalk_set_cloexec(lowfd: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/fdwalk_set_cloexec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('lowfd', String(lowfd));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function file_error_from_errno(err_no: number): Promise<GLibFileError> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_error_from_errno`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('err_no', String(err_no));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function file_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function file_get_contents(filename: Pointer): Promise<{contents: Pointer, length: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_get_contents`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: contents
      result.contents = (() => {
        return data.contents;

      })();
      // Handle return parameter: length
      result.length = (() => {
        return data.length;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function file_open_tmp(tmpl?: Pointer): Promise<{name_used: Pointer, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_open_tmp`, apiConfig.baseUrl);
    // Primitive parameter
    if (tmpl !== undefined) url.searchParams.append('tmpl', String(tmpl));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: name_used
      result.name_used = (() => {
        return data.name_used;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function file_read_link(filename: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_read_link`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function file_set_contents(filename: Pointer, contents: Pointer, length: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_set_contents`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('contents', String(contents));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function file_set_contents_full(filename: Pointer, contents: Pointer, length: number, flags: GLibFileSetContentsFlags, mode: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_set_contents_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('contents', String(contents));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function file_test(filename: Pointer, test: GLibFileTest): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/file_test`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('test', String(test));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function filename_display_basename(filename: Pointer): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_display_basename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function filename_display_name(filename: Pointer): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_display_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function filename_from_uri(uri: string): Promise<{hostname: string, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_from_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: hostname
      result.hostname = (() => {
        return data.hostname;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function filename_from_utf8(utf8string: string, len: number): Promise<{bytes_read: number, bytes_written: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_from_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('utf8string', String(utf8string));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: bytes_read
      result.bytes_read = (() => {
        return data.bytes_read;

      })();
      // Handle return parameter: bytes_written
      result.bytes_written = (() => {
        return data.bytes_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function filename_to_uri(filename: Pointer, hostname?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_to_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    if (hostname !== undefined) url.searchParams.append('hostname', String(hostname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function filename_to_utf8(opsysstring: Pointer, len: number): Promise<{bytes_read: number, bytes_written: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/filename_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('opsysstring', String(opsysstring));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: bytes_read
      result.bytes_read = (() => {
        return data.bytes_read;

      })();
      // Handle return parameter: bytes_written
      result.bytes_written = (() => {
        return data.bytes_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function find_program_in_path(program: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/find_program_in_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('program', String(program));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function fopen(filename: Pointer, mode: string): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/fopen`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function format_size(size: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/format_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function format_size_for_display(size: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/format_size_for_display`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function format_size_full(size: number, flags: GLibFormatSizeFlags): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/format_size_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function free(mem?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/free`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function free_sized(size: number, mem?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/free_sized`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function freopen(filename: Pointer, mode: string, stream?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/freopen`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    if (stream !== undefined) url.searchParams.append('stream', String(stream));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function fsync(fd: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/fsync`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_application_name(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_application_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_charset(): Promise<{charset: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_charset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: charset
      result.charset = (() => {
        return data.charset;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_codeset(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_codeset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_console_charset(): Promise<{charset: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_console_charset`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: charset
      result.charset = (() => {
        return data.charset;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_current_dir(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_current_dir`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_current_time(result_: GLibTimeVal): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_current_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (result_ && typeof result_ === 'object' && 'ptr' in result_) {
      url.searchParams.append('result', 'ptr,' + result_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_environ(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_environ`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_filename_charsets(): Promise<{filename_charsets: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_filename_charsets`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: filename_charsets
      result.filename_charsets = (() => {
        return data.filename_charsets;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_home_dir(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_home_dir`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_host_name(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_host_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_language_names(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_language_names`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_language_names_with_category(category_name: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_language_names_with_category`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('category_name', String(category_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_locale_variants(locale: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_locale_variants`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('locale', String(locale));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_monotonic_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_monotonic_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_num_processors(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_num_processors`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_os_info(key_name: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_os_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key_name', String(key_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_prgname(): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_prgname`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_real_name(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_real_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_real_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_real_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_system_config_dirs(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_system_config_dirs`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_system_data_dirs(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_system_data_dirs`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_tmp_dir(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_tmp_dir`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_user_cache_dir(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_cache_dir`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_user_config_dir(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_config_dir`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_user_data_dir(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_data_dir`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_user_name(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_name`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_user_runtime_dir(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_runtime_dir`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_user_special_dir(directory: GLibUserDirectory): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_special_dir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('directory', String(directory));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function get_user_state_dir(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/get_user_state_dir`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function getenv(variable: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/getenv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_add(hash_table: Pointer, key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_contains(hash_table: Pointer, key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_destroy(hash_table: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_destroy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_find(hash_table: Pointer, predicate: GLibHRFunc): Promise<{predicate: number, return: Pointer | null}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.predicate !== undefined) {
        callbackDispatcher.set(data.predicate.toString(), {
          converter: convertGLibHRFuncArgs,
          userFunction: predicate
        });
      }
        const result: any = {};
      // Handle return parameter: predicate
      result.predicate = (() => {
        return data.predicate;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_foreach(hash_table: Pointer, func: GLibHFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_foreach`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_foreach_remove(hash_table: Pointer, func: GLibHRFunc): Promise<{func: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_foreach_remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHRFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_foreach_steal(hash_table: Pointer, func: GLibHRFunc): Promise<{func: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_foreach_steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHRFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_insert(hash_table: Pointer, key?: Pointer, value_?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_lookup(hash_table: Pointer, key?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_lookup_extended(hash_table: Pointer, lookup_key?: Pointer): Promise<{orig_key: Pointer, value: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_lookup_extended`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (lookup_key !== undefined) url.searchParams.append('lookup_key', String(lookup_key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: orig_key
      result.orig_key = (() => {
        return data.orig_key;

      })();
      // Handle return parameter: value
      result.value = (() => {
        return data.value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_new_similar(other_hash_table: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_new_similar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('other_hash_table', String(other_hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_ref(hash_table: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_remove(hash_table: Pointer, key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_remove_all(hash_table: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_remove_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_replace(hash_table: Pointer, key?: Pointer, value_?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_replace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    // Primitive parameter
    if (value_ !== undefined) url.searchParams.append('value_', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_size(hash_table: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_steal(hash_table: Pointer, key?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_steal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (key !== undefined) url.searchParams.append('key', String(key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_steal_all(hash_table: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_steal_all`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_steal_extended(hash_table: Pointer, lookup_key?: Pointer): Promise<{stolen_key: Pointer, stolen_value: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_steal_extended`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    // Primitive parameter
    if (lookup_key !== undefined) url.searchParams.append('lookup_key', String(lookup_key));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: stolen_key
      result.stolen_key = (() => {
        return data.stolen_key;

      })();
      // Handle return parameter: stolen_value
      result.stolen_value = (() => {
        return data.stolen_value;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hash_table_unref(hash_table: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hash_table_unref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hash_table', String(hash_table));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hook_destroy(hook_list: GLibHookList, hook_id: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_destroy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('hook_id', String(hook_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hook_destroy_link(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_destroy_link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hook_free(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_free`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hook_insert_before(hook_list: GLibHookList, hook: GLibHook, sibling?: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_insert_before`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (sibling !== undefined && typeof sibling === 'object' && 'ptr' in sibling) {
      url.searchParams.append('sibling', 'ptr,' + sibling.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hook_insert_sorted(hook_list: GLibHookList, hook: GLibHook, func: GLibHookCompareFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_insert_sorted`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibHookCompareFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hook_prepend(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_prepend`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hook_unref(hook_list: GLibHookList, hook: GLibHook): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hook_unref`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (hook_list && typeof hook_list === 'object' && 'ptr' in hook_list) {
      url.searchParams.append('hook_list', 'ptr,' + hook_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (hook && typeof hook === 'object' && 'ptr' in hook) {
      url.searchParams.append('hook', 'ptr,' + hook.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hostname_is_ascii_encoded(hostname: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_is_ascii_encoded`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hostname_is_ip_address(hostname: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_is_ip_address`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hostname_is_non_ascii(hostname: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_is_non_ascii`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hostname_to_ascii(hostname: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_to_ascii`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function hostname_to_unicode(hostname: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/hostname_to_unicode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hostname', String(hostname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function idle_add(priority: number, function_: GLibSourceFunc): Promise<{function: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/idle_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.function !== undefined) {
        callbackDispatcher.set(data.function.toString(), {
          converter: convertGLibSourceFuncArgs,
          userFunction: function_
        });
      }
        const result: any = {};
      // Handle return parameter: function
      result.function = (() => {
        return data.function;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function idle_remove_by_data(data_?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/idle_remove_by_data`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function idle_source_new(): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/idle_source_new`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function int64_equal(v1: Pointer, v2: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/int64_equal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v1', String(v1));
    // Primitive parameter
    url.searchParams.append('v2', String(v2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function int64_hash(v: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/int64_hash`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v', String(v));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function int_equal(v1: Pointer, v2: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/int_equal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v1', String(v1));
    // Primitive parameter
    url.searchParams.append('v2', String(v2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function int_hash(v: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/int_hash`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v', String(v));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function intern_static_string(string?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/intern_static_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function intern_string(string?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/intern_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function io_add_watch(channel: GLibIOChannel, priority: number, condition: GLibIOConditionValue, func: GLibIOFunc): Promise<{func: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/io_add_watch`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (channel && typeof channel === 'object' && 'ptr' in channel) {
      url.searchParams.append('channel', 'ptr,' + channel.ptr);
    }
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('condition', String(condition));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibIOFuncArgs,
          userFunction: func
        });
      }
        const result: any = {};
      // Handle return parameter: func
      result.func = (() => {
        return data.func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function io_channel_error_from_errno(en: number): Promise<GLibIOChannelError> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/io_channel_error_from_errno`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('en', String(en));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function io_channel_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/io_channel_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function io_create_watch(channel: GLibIOChannel, condition: GLibIOConditionValue): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/io_create_watch`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (channel && typeof channel === 'object' && 'ptr' in channel) {
      url.searchParams.append('channel', 'ptr,' + channel.ptr);
    }
    // Primitive parameter
    url.searchParams.append('condition', String(condition));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function key_file_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/key_file_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function list_pop_allocator(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/list_pop_allocator`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function list_push_allocator(allocator: GLibAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/list_push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function listenv(): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/listenv`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function locale_from_utf8(utf8string: string, len: number): Promise<{bytes_read: number, bytes_written: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/locale_from_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('utf8string', String(utf8string));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: bytes_read
      result.bytes_read = (() => {
        return data.bytes_read;

      })();
      // Handle return parameter: bytes_written
      result.bytes_written = (() => {
        return data.bytes_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function locale_to_utf8(opsysstring: Pointer, len: number): Promise<{bytes_read: number, bytes_written: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/locale_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('opsysstring', String(opsysstring));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: bytes_read
      result.bytes_read = (() => {
        return data.bytes_read;

      })();
      // Handle return parameter: bytes_written
      result.bytes_written = (() => {
        return data.bytes_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_default_handler(log_level: GLibLogLevelFlags, log_domain?: string, message?: string, unused_data?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_default_handler`, apiConfig.baseUrl);
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    if (message !== undefined) url.searchParams.append('message', String(message));
    // Primitive parameter
    if (unused_data !== undefined) url.searchParams.append('unused_data', String(unused_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_get_debug_enabled(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_get_debug_enabled`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_remove_handler(log_domain: string, handler_id: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_remove_handler`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('handler_id', String(handler_id));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_set_always_fatal(fatal_mask: GLibLogLevelFlags): Promise<GLibLogLevelFlags> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_always_fatal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fatal_mask', String(fatal_mask));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_set_debug_enabled(enabled: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_debug_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('enabled', String(enabled));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_set_fatal_mask(log_domain: string, fatal_mask: GLibLogLevelFlags): Promise<GLibLogLevelFlags> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_fatal_mask`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('fatal_mask', String(fatal_mask));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_set_handler(log_levels: GLibLogLevelFlags, log_func: GLibLogFunc, log_domain?: string): Promise<{log_func: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_handler`, apiConfig.baseUrl);
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('log_levels', String(log_levels));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.log_func !== undefined) {
        callbackDispatcher.set(data.log_func.toString(), {
          converter: convertGLibLogFuncArgs,
          userFunction: log_func
        });
      }
        const result: any = {};
      // Handle return parameter: log_func
      result.log_func = (() => {
        return data.log_func;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_set_writer_func(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_set_writer_func`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_structured_array(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_structured_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_variant(log_level: GLibLogLevelFlags, fields: GLibVariant, log_domain?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_variant`, apiConfig.baseUrl);
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Object with explode=false: serialize as comma-separated
    if (fields && typeof fields === 'object' && 'ptr' in fields) {
      url.searchParams.append('fields', 'ptr,' + fields.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_default(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number, user_data?: Pointer): Promise<GLibLogWriterOutput> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_default`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_default_set_debug_domains(domains?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_default_set_debug_domains`, apiConfig.baseUrl);
    // Primitive parameter
    if (domains !== undefined) url.searchParams.append('domains', String(domains));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_default_set_use_stderr(use_stderr: boolean): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_default_set_use_stderr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('use_stderr', String(use_stderr));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_default_would_drop(log_level: GLibLogLevelFlags, log_domain?: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_default_would_drop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_format_fields(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number, use_color: boolean): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_format_fields`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    // Primitive parameter
    url.searchParams.append('use_color', String(use_color));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_is_journald(output_fd: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_is_journald`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('output_fd', String(output_fd));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_journald(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number, user_data?: Pointer): Promise<GLibLogWriterOutput> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_journald`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_standard_streams(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number, user_data?: Pointer): Promise<GLibLogWriterOutput> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_standard_streams`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_supports_color(output_fd: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_supports_color`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('output_fd', String(output_fd));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function log_writer_syslog(log_level: GLibLogLevelFlags, fields: Pointer, n_fields: number, user_data?: Pointer): Promise<GLibLogWriterOutput> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/log_writer_syslog`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('fields', String(fields));
    // Primitive parameter
    url.searchParams.append('n_fields', String(n_fields));
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function lstat(filename: Pointer, buf: GLibStatBuf): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/lstat`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Object with explode=false: serialize as comma-separated
    if (buf && typeof buf === 'object' && 'ptr' in buf) {
      url.searchParams.append('buf', 'ptr,' + buf.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function main_context_default(): Promise<GLibMainContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_context_default`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function main_context_get_thread_default(): Promise<GLibMainContext | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_context_get_thread_default`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function main_context_ref_thread_default(): Promise<GLibMainContext> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_context_ref_thread_default`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibMainContext(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function main_current_source(): Promise<GLibSource | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_current_source`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function main_depth(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/main_depth`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function malloc(n_bytes: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/malloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function malloc0(n_bytes: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/malloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function malloc0_n(n_blocks: number, n_block_bytes: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/malloc0_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function malloc_n(n_blocks: number, n_block_bytes: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/malloc_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function markup_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/markup_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function markup_escape_text(text: string, length: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/markup_escape_text`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function mem_chunk_info(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mem_chunk_info`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function mem_is_system_malloc(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mem_is_system_malloc`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function mem_profile(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mem_profile`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function mem_set_vtable(vtable: GLibMemVTable): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mem_set_vtable`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (vtable && typeof vtable === 'object' && 'ptr' in vtable) {
      url.searchParams.append('vtable', 'ptr,' + vtable.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function memdup(byte_size: number, mem?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/memdup`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('byte_size', String(byte_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function memdup2(byte_size: number, mem?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/memdup2`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('byte_size', String(byte_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function mkdir(filename: Pointer, mode: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mkdir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function mkdir_with_parents(pathname: Pointer, mode: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/mkdir_with_parents`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pathname', String(pathname));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function node_pop_allocator(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/node_pop_allocator`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function node_push_allocator(allocator: GLibAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/node_push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function nullify_pointer(nullify_location: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/nullify_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nullify_location', String(nullify_location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function number_parser_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/number_parser_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function on_error_query(prg_name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/on_error_query`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('prg_name', String(prg_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function on_error_stack_trace(prg_name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/on_error_stack_trace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('prg_name', String(prg_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function once_init_enter(location: Pointer): Promise<{location: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_enter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: location
      result.location = (() => {
        return data.location;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function once_init_enter_impl(location: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_enter_impl`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function once_init_enter_pointer(location: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_enter_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function once_init_leave(location: Pointer, result_: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_leave`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Primitive parameter
    url.searchParams.append('result', String(result_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.location;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function once_init_leave_pointer(location: Pointer, result_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/once_init_leave_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Primitive parameter
    if (result_ !== undefined) url.searchParams.append('result_', String(result_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function open(filename: Pointer, flags: number, mode: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/open`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function option_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/option_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function parse_debug_string(keys: Pointer, nkeys: number, string?: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/parse_debug_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('keys', String(keys));
    // Primitive parameter
    url.searchParams.append('nkeys', String(nkeys));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function path_buf_equal(v1: Pointer, v2: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_buf_equal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v1', String(v1));
    // Primitive parameter
    url.searchParams.append('v2', String(v2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function path_get_basename(file_name: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_get_basename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function path_get_dirname(file_name: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_get_dirname`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function path_is_absolute(file_name: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_is_absolute`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function path_skip_root(file_name: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/path_skip_root`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function pattern_match_simple(pattern: string, string: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pattern_match_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function pointer_bit_lock(address: Pointer, lock_bit: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_lock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function pointer_bit_lock_and_get(address: Pointer, lock_bit: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_lock_and_get`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.out_ptr;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function pointer_bit_lock_mask_ptr(lock_bit: number, set: boolean, preserve_mask: number, ptr?: Pointer, preserve_ptr?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_lock_mask_ptr`, apiConfig.baseUrl);
    // Primitive parameter
    if (ptr !== undefined) url.searchParams.append('ptr', String(ptr));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    // Primitive parameter
    url.searchParams.append('set', String(set));
    // Primitive parameter
    url.searchParams.append('preserve_mask', String(preserve_mask));
    // Primitive parameter
    if (preserve_ptr !== undefined) url.searchParams.append('preserve_ptr', String(preserve_ptr));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function pointer_bit_trylock(address: Pointer, lock_bit: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_trylock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function pointer_bit_unlock(address: Pointer, lock_bit: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_unlock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function pointer_bit_unlock_and_set(address: Pointer, lock_bit: number, preserve_mask: number, ptr?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/pointer_bit_unlock_and_set`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('lock_bit', String(lock_bit));
    // Primitive parameter
    if (ptr !== undefined) url.searchParams.append('ptr', String(ptr));
    // Primitive parameter
    url.searchParams.append('preserve_mask', String(preserve_mask));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function poll(fds: GLibPollFD, nfds: number, timeout: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fds && typeof fds === 'object' && 'ptr' in fds) {
      url.searchParams.append('fds', 'ptr,' + fds.ptr);
    }
    // Primitive parameter
    url.searchParams.append('nfds', String(nfds));
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function prefix_error_literal(prefix: string, err?: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/prefix_error_literal`, apiConfig.baseUrl);
    // Primitive parameter
    if (err !== undefined) url.searchParams.append('err', String(err));
    // Primitive parameter
    url.searchParams.append('prefix', String(prefix));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.err;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function propagate_error(src: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/propagate_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src', String(src));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.dest;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function qsort_with_data(pbase: Pointer, total_elems: number, size: number, compare_func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/qsort_with_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pbase', String(pbase));
    // Primitive parameter
    url.searchParams.append('total_elems', String(total_elems));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.compare_func !== undefined) {
        callbackDispatcher.set(data.compare_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: compare_func
        });
      }
    return data.compare_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function quark_from_static_string(string?: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/quark_from_static_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function quark_from_string(string?: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/quark_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function quark_to_string(quark: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/quark_to_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function quark_try_string(string?: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/quark_try_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (string !== undefined) url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function random_double(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_double`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function random_double_range(begin: number, end: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_double_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function random_int(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_int`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function random_int_range(begin: number, end: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_int_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function random_set_seed(seed: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/random_set_seed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seed', String(seed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function rc_box_acquire(mem_block: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_acquire`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function rc_box_alloc(block_size: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function rc_box_alloc0(block_size: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_alloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function rc_box_dup(block_size: number, mem_block: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_dup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function rc_box_get_size(mem_block: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_get_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function rc_box_release(mem_block: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_release`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function rc_box_release_full(mem_block: Pointer, clear_func: GLibDestroyNotify): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rc_box_release_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.clear_func !== undefined) {
        callbackDispatcher.set(data.clear_func.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: clear_func
        });
      }
    return data.clear_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function realloc(n_bytes: number, mem?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/realloc`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function realloc_n(n_blocks: number, n_block_bytes: number, mem?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/realloc_n`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_count_compare(rc: number, val: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_count_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rc', String(rc));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_count_dec(rc: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_count_dec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rc', String(rc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_count_inc(rc: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_count_inc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rc', String(rc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_count_init(rc: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_count_init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rc', String(rc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_string_acquire(str: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_acquire`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_string_length(str: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_length`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_string_new(str: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_string_new_intern(str: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_new_intern`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_string_new_len(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_new_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ref_string_release(str: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ref_string_release`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function regex_check_replacement(replacement: string): Promise<{has_references: boolean, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_check_replacement`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('replacement', String(replacement));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: has_references
      result.has_references = (() => {
        return data.has_references;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function regex_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function regex_escape_nul(string: string, length: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_escape_nul`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function regex_escape_string(string: string, length: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_escape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function regex_match_simple(pattern: string, string: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_match_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function regex_split_simple(pattern: string, string: string, compile_options: GLibRegexCompileFlags, match_options: GLibRegexMatchFlags): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/regex_split_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('compile_options', String(compile_options));
    // Primitive parameter
    url.searchParams.append('match_options', String(match_options));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function reload_user_special_dirs_cache(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/reload_user_special_dirs_cache`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function remove(filename: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function rename(oldfilename: Pointer, newfilename: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('oldfilename', String(oldfilename));
    // Primitive parameter
    url.searchParams.append('newfilename', String(newfilename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function rmdir(filename: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/rmdir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_foreach_range(begin: GLibSequenceIter, end: GLibSequenceIter, func: GLibFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_foreach_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.func !== undefined) {
        callbackDispatcher.set(data.func.toString(), {
          converter: convertGLibFuncArgs,
          userFunction: func
        });
      }
    return data.func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_get(iter: GLibSequenceIter): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_get`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_insert_before(iter: GLibSequenceIter, data_?: Pointer): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_insert_before`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_move(src: GLibSequenceIter, dest: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_move`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_move_range(dest: GLibSequenceIter, begin: GLibSequenceIter, end: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_move_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_range_get_midpoint(begin: GLibSequenceIter, end: GLibSequenceIter): Promise<GLibSequenceIter> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_range_get_midpoint`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSequenceIter(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_remove(iter: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_remove_range(begin: GLibSequenceIter, end: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_remove_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_set(iter: GLibSequenceIter, data_?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_set`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data_', String(data_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_sort_changed(iter: GLibSequenceIter, cmp_func: GLibCompareDataFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_sort_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.cmp_func !== undefined) {
        callbackDispatcher.set(data.cmp_func.toString(), {
          converter: convertGLibCompareDataFuncArgs,
          userFunction: cmp_func
        });
      }
    return data.cmp_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_sort_changed_iter(iter: GLibSequenceIter, iter_cmp: GLibSequenceIterCompareFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_sort_changed_iter`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (iter && typeof iter === 'object' && 'ptr' in iter) {
      url.searchParams.append('iter', 'ptr,' + iter.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.iter_cmp !== undefined) {
        callbackDispatcher.set(data.iter_cmp.toString(), {
          converter: convertGLibSequenceIterCompareFuncArgs,
          userFunction: iter_cmp
        });
      }
    return data.iter_cmp;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function sequence_swap(a: GLibSequenceIter, b: GLibSequenceIter): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/sequence_swap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (a && typeof a === 'object' && 'ptr' in a) {
      url.searchParams.append('a', 'ptr,' + a.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (b && typeof b === 'object' && 'ptr' in b) {
      url.searchParams.append('b', 'ptr,' + b.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function set_application_name(application_name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/set_application_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('application_name', String(application_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function set_error_literal(domain: number, code: number, message: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/set_error_literal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    url.searchParams.append('message', String(message));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.err;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function set_prgname(prgname: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/set_prgname`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('prgname', String(prgname));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function setenv(variable: Pointer, value_: Pointer, overwrite: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/setenv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    // Primitive parameter
    url.searchParams.append('overwrite', String(overwrite));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function shell_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/shell_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function shell_parse_argv(command_line: Pointer): Promise<{argcp: number, argvp: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/shell_parse_argv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('command_line', String(command_line));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: argcp
      result.argcp = (() => {
        return data.argcp;

      })();
      // Handle return parameter: argvp
      result.argvp = (() => {
        return data.argvp;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function shell_quote(unquoted_string: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/shell_quote`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unquoted_string', String(unquoted_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function shell_unquote(quoted_string: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/shell_unquote`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quoted_string', String(quoted_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slice_alloc(block_size: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slice_alloc0(block_size: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_alloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slice_copy(block_size: number, mem_block?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    // Primitive parameter
    if (mem_block !== undefined) url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slice_free1(block_size: number, mem_block?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_free1`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    // Primitive parameter
    if (mem_block !== undefined) url.searchParams.append('mem_block', String(mem_block));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slice_free_chain_with_offset(block_size: number, next_offset: number, mem_chain?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_free_chain_with_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('block_size', String(block_size));
    // Primitive parameter
    if (mem_chain !== undefined) url.searchParams.append('mem_chain', String(mem_chain));
    // Primitive parameter
    url.searchParams.append('next_offset', String(next_offset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slice_get_config(ckey: GLibSliceConfig): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_get_config`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ckey', String(ckey));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slice_get_config_state(ckey: GLibSliceConfig, address: number, n_values: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_get_config_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ckey', String(ckey));
    // Primitive parameter
    url.searchParams.append('address', String(address));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slice_set_config(ckey: GLibSliceConfig, value_: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slice_set_config`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ckey', String(ckey));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slist_pop_allocator(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slist_pop_allocator`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function slist_push_allocator(allocator: GLibAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/slist_push_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function source_remove(tag: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/source_remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function source_remove_by_funcs_user_data(funcs: GLibSourceFuncs, user_data?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/source_remove_by_funcs_user_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function source_remove_by_user_data(user_data?: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/source_remove_by_user_data`, apiConfig.baseUrl);
    // Primitive parameter
    if (user_data !== undefined) url.searchParams.append('user_data', String(user_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function source_set_name_by_id(tag: number, name: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/source_set_name_by_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spaced_primes_closest(num: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spaced_primes_closest`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('num', String(num));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_async(argv: Pointer, flags: GLibSpawnFlags, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer): Promise<{child_setup: number, child_pid: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_async`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.child_setup !== undefined) {
        callbackDispatcher.set(data.child_setup.toString(), {
          converter: convertGLibSpawnChildSetupFuncArgs,
          userFunction: child_setup
        });
      }
        const result: any = {};
      // Handle return parameter: child_setup
      result.child_setup = (() => {
        return data.child_setup;

      })();
      // Handle return parameter: child_pid
      result.child_pid = (() => {
        return data.child_pid;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_async_with_fds(argv: Pointer, flags: GLibSpawnFlags, stdin_fd: number, stdout_fd: number, stderr_fd: number, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer): Promise<{child_setup: number, child_pid: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_async_with_fds`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('stdin_fd', String(stdin_fd));
    // Primitive parameter
    url.searchParams.append('stdout_fd', String(stdout_fd));
    // Primitive parameter
    url.searchParams.append('stderr_fd', String(stderr_fd));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.child_setup !== undefined) {
        callbackDispatcher.set(data.child_setup.toString(), {
          converter: convertGLibSpawnChildSetupFuncArgs,
          userFunction: child_setup
        });
      }
        const result: any = {};
      // Handle return parameter: child_setup
      result.child_setup = (() => {
        return data.child_setup;

      })();
      // Handle return parameter: child_pid
      result.child_pid = (() => {
        return data.child_pid;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_async_with_pipes(argv: Pointer, flags: GLibSpawnFlags, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer): Promise<{child_setup: number, child_pid: number, standard_input: number, standard_output: number, standard_error: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_async_with_pipes`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.child_setup !== undefined) {
        callbackDispatcher.set(data.child_setup.toString(), {
          converter: convertGLibSpawnChildSetupFuncArgs,
          userFunction: child_setup
        });
      }
        const result: any = {};
      // Handle return parameter: child_setup
      result.child_setup = (() => {
        return data.child_setup;

      })();
      // Handle return parameter: child_pid
      result.child_pid = (() => {
        return data.child_pid;

      })();
      // Handle return parameter: standard_input
      result.standard_input = (() => {
        return data.standard_input;

      })();
      // Handle return parameter: standard_output
      result.standard_output = (() => {
        return data.standard_output;

      })();
      // Handle return parameter: standard_error
      result.standard_error = (() => {
        return data.standard_error;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_async_with_pipes_and_fds(argv: Pointer, flags: GLibSpawnFlags, stdin_fd: number, stdout_fd: number, stderr_fd: number, n_fds: number, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer, source_fds?: Pointer, target_fds?: Pointer): Promise<{child_setup: number, child_pid_out: number, stdin_pipe_out: number, stdout_pipe_out: number, stderr_pipe_out: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_async_with_pipes_and_fds`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('stdin_fd', String(stdin_fd));
    // Primitive parameter
    url.searchParams.append('stdout_fd', String(stdout_fd));
    // Primitive parameter
    url.searchParams.append('stderr_fd', String(stderr_fd));
    // Primitive parameter
    if (source_fds !== undefined) url.searchParams.append('source_fds', String(source_fds));
    // Primitive parameter
    if (target_fds !== undefined) url.searchParams.append('target_fds', String(target_fds));
    // Primitive parameter
    url.searchParams.append('n_fds', String(n_fds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.child_setup !== undefined) {
        callbackDispatcher.set(data.child_setup.toString(), {
          converter: convertGLibSpawnChildSetupFuncArgs,
          userFunction: child_setup
        });
      }
        const result: any = {};
      // Handle return parameter: child_setup
      result.child_setup = (() => {
        return data.child_setup;

      })();
      // Handle return parameter: child_pid_out
      result.child_pid_out = (() => {
        return data.child_pid_out;

      })();
      // Handle return parameter: stdin_pipe_out
      result.stdin_pipe_out = (() => {
        return data.stdin_pipe_out;

      })();
      // Handle return parameter: stdout_pipe_out
      result.stdout_pipe_out = (() => {
        return data.stdout_pipe_out;

      })();
      // Handle return parameter: stderr_pipe_out
      result.stderr_pipe_out = (() => {
        return data.stderr_pipe_out;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_check_exit_status(wait_status: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_check_exit_status`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('wait_status', String(wait_status));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_check_wait_status(wait_status: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_check_wait_status`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('wait_status', String(wait_status));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_close_pid(pid: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_close_pid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pid', String(pid));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_command_line_async(command_line: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_command_line_async`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('command_line', String(command_line));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_command_line_sync(command_line: Pointer): Promise<{standard_output: Pointer, standard_error: Pointer, wait_status: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_command_line_sync`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('command_line', String(command_line));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: standard_output
      result.standard_output = (() => {
        return data.standard_output;

      })();
      // Handle return parameter: standard_error
      result.standard_error = (() => {
        return data.standard_error;

      })();
      // Handle return parameter: wait_status
      result.wait_status = (() => {
        return data.wait_status;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_exit_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_exit_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function spawn_sync(argv: Pointer, flags: GLibSpawnFlags, child_setup: GLibSpawnChildSetupFunc, working_directory?: Pointer, envp?: Pointer): Promise<{child_setup: number, standard_output: Pointer, standard_error: Pointer, wait_status: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/spawn_sync`, apiConfig.baseUrl);
    // Primitive parameter
    if (working_directory !== undefined) url.searchParams.append('working_directory', String(working_directory));
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.child_setup !== undefined) {
        callbackDispatcher.set(data.child_setup.toString(), {
          converter: convertGLibSpawnChildSetupFuncArgs,
          userFunction: child_setup
        });
      }
        const result: any = {};
      // Handle return parameter: child_setup
      result.child_setup = (() => {
        return data.child_setup;

      })();
      // Handle return parameter: standard_output
      result.standard_output = (() => {
        return data.standard_output;

      })();
      // Handle return parameter: standard_error
      result.standard_error = (() => {
        return data.standard_error;

      })();
      // Handle return parameter: wait_status
      result.wait_status = (() => {
        return data.wait_status;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function stat(filename: Pointer, buf: GLibStatBuf): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/stat`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Object with explode=false: serialize as comma-separated
    if (buf && typeof buf === 'object' && 'ptr' in buf) {
      url.searchParams.append('buf', 'ptr,' + buf.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function stpcpy(dest: string, src: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/stpcpy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dest', String(dest));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function str_equal(v1: Pointer, v2: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_equal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v1', String(v1));
    // Primitive parameter
    url.searchParams.append('v2', String(v2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function str_has_prefix(str: string, prefix: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_has_prefix`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('prefix', String(prefix));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function str_has_suffix(str: string, suffix: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_has_suffix`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('suffix', String(suffix));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function str_hash(v: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_hash`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v', String(v));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function str_is_ascii(str: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_is_ascii`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function str_match_string(search_term: string, potential_hit: string, accept_alternates: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_match_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('search_term', String(search_term));
    // Primitive parameter
    url.searchParams.append('potential_hit', String(potential_hit));
    // Primitive parameter
    url.searchParams.append('accept_alternates', String(accept_alternates));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function str_to_ascii(str: string, from_locale?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_to_ascii`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    if (from_locale !== undefined) url.searchParams.append('from_locale', String(from_locale));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function str_tokenize_and_fold(string: string, translit_locale?: string): Promise<{ascii_alternates: Pointer, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/str_tokenize_and_fold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (translit_locale !== undefined) url.searchParams.append('translit_locale', String(translit_locale));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: ascii_alternates
      result.ascii_alternates = (() => {
        return data.ascii_alternates;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strcanon(string: string, valid_chars: string, substitutor: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strcanon`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('valid_chars', String(valid_chars));
    // Primitive parameter
    url.searchParams.append('substitutor', String(substitutor));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strcasecmp(s1: string, s2: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strcasecmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strchomp(string: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strchomp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strchug(string: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strchug`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strcmp0(str1?: string, str2?: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strcmp0`, apiConfig.baseUrl);
    // Primitive parameter
    if (str1 !== undefined) url.searchParams.append('str1', String(str1));
    // Primitive parameter
    if (str2 !== undefined) url.searchParams.append('str2', String(str2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strcompress(source: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strcompress`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source', String(source));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strdelimit(string: string, new_delimiter: number, delimiters?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strdelimit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (delimiters !== undefined) url.searchParams.append('delimiters', String(delimiters));
    // Primitive parameter
    url.searchParams.append('new_delimiter', String(new_delimiter));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strdown(string: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strdown`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strdup(str?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strdup`, apiConfig.baseUrl);
    // Primitive parameter
    if (str !== undefined) url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strdupv(str_array?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strdupv`, apiConfig.baseUrl);
    // Primitive parameter
    if (str_array !== undefined) url.searchParams.append('str_array', String(str_array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strerror(errnum: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strerror`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('errnum', String(errnum));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strescape(source: string, exceptions?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strescape`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source', String(source));
    // Primitive parameter
    if (exceptions !== undefined) url.searchParams.append('exceptions', String(exceptions));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strfreev(str_array?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strfreev`, apiConfig.baseUrl);
    // Primitive parameter
    if (str_array !== undefined) url.searchParams.append('str_array', String(str_array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strip_context(msgid: string, msgval: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strip_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('msgid', String(msgid));
    // Primitive parameter
    url.searchParams.append('msgval', String(msgval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strjoinv(str_array: Pointer, separator?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strjoinv`, apiConfig.baseUrl);
    // Primitive parameter
    if (separator !== undefined) url.searchParams.append('separator', String(separator));
    // Primitive parameter
    url.searchParams.append('str_array', String(str_array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strlcat(dest: string, src: string, dest_size: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strlcat`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dest', String(dest));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Primitive parameter
    url.searchParams.append('dest_size', String(dest_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strlcpy(dest: string, src: string, dest_size: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strlcpy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dest', String(dest));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Primitive parameter
    url.searchParams.append('dest_size', String(dest_size));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strncasecmp(s1: string, s2: string, n: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strncasecmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strndup(n: number, str?: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strndup`, apiConfig.baseUrl);
    // Primitive parameter
    if (str !== undefined) url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strnfill(length: number, fill_char: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strnfill`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('fill_char', String(fill_char));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strreverse(string: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strreverse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strrstr(haystack: string, needle: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strrstr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('haystack', String(haystack));
    // Primitive parameter
    url.searchParams.append('needle', String(needle));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strrstr_len(haystack: string, haystack_len: number, needle: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strrstr_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('haystack', String(haystack));
    // Primitive parameter
    url.searchParams.append('haystack_len', String(haystack_len));
    // Primitive parameter
    url.searchParams.append('needle', String(needle));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strsignal(signum: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strsignal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signum', String(signum));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strsplit(string: string, delimiter: string, max_tokens: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strsplit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('delimiter', String(delimiter));
    // Primitive parameter
    url.searchParams.append('max_tokens', String(max_tokens));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strsplit_set(string: string, delimiters: string, max_tokens: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strsplit_set`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('delimiters', String(delimiters));
    // Primitive parameter
    url.searchParams.append('max_tokens', String(max_tokens));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strstr_len(haystack: string, haystack_len: number, needle: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strstr_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('haystack', String(haystack));
    // Primitive parameter
    url.searchParams.append('haystack_len', String(haystack_len));
    // Primitive parameter
    url.searchParams.append('needle', String(needle));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strtod(nptr: string): Promise<{endptr: string, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strtod`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nptr', String(nptr));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: endptr
      result.endptr = (() => {
        return data.endptr;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strup(string: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strv_contains(strv: Pointer, str: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strv_contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strv_equal(strv1: Pointer, strv2: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strv_equal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv1', String(strv1));
    // Primitive parameter
    url.searchParams.append('strv2', String(strv2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strv_get_type(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strv_get_type`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function strv_length(str_array: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/strv_length`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str_array', String(str_array));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_add_data_func(testpath: string, test_func: GLibTestDataFunc, test_data?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_add_data_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('testpath', String(testpath));
    // Primitive parameter
    if (test_data !== undefined) url.searchParams.append('test_data', String(test_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.test_func !== undefined) {
        callbackDispatcher.set(data.test_func.toString(), {
          converter: convertGLibTestDataFuncArgs,
          userFunction: test_func
        });
      }
    return data.test_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_add_data_func_full(testpath: string, test_func: GLibTestDataFunc, test_data?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_add_data_func_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('testpath', String(testpath));
    // Primitive parameter
    if (test_data !== undefined) url.searchParams.append('test_data', String(test_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.test_func !== undefined) {
        callbackDispatcher.set(data.test_func.toString(), {
          converter: convertGLibTestDataFuncArgs,
          userFunction: test_func
        });
      }
    return data.test_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_add_func(testpath: string, test_func: GLibTestFunc): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_add_func`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('testpath', String(testpath));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.test_func !== undefined) {
        callbackDispatcher.set(data.test_func.toString(), {
          converter: convertGLibTestFuncArgs,
          userFunction: test_func
        });
      }
    return data.test_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_assert_expected_messages_internal(domain: string, file: string, line: number, func: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_assert_expected_messages_internal`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_bug(bug_uri_snippet: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_bug`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('bug_uri_snippet', String(bug_uri_snippet));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_bug_base(uri_pattern: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_bug_base`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_pattern', String(uri_pattern));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_disable_crash_reporting(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_disable_crash_reporting`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_expect_message(log_level: GLibLogLevelFlags, pattern: string, log_domain?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_expect_message`, apiConfig.baseUrl);
    // Primitive parameter
    if (log_domain !== undefined) url.searchParams.append('log_domain', String(log_domain));
    // Primitive parameter
    url.searchParams.append('log_level', String(log_level));
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_fail(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_fail`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_failed(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_failed`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_get_dir(file_type: GLibTestFileType): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_get_dir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('file_type', String(file_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_get_path(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_get_path`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_incomplete(msg?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_incomplete`, apiConfig.baseUrl);
    // Primitive parameter
    if (msg !== undefined) url.searchParams.append('msg', String(msg));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_log_type_name(log_type: GLibTestLogType): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_log_type_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('log_type', String(log_type));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_queue_destroy(destroy_func: GLibDestroyNotify, destroy_data?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_queue_destroy`, apiConfig.baseUrl);
    // Primitive parameter
    if (destroy_data !== undefined) url.searchParams.append('destroy_data', String(destroy_data));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.destroy_func !== undefined) {
        callbackDispatcher.set(data.destroy_func.toString(), {
          converter: convertGLibDestroyNotifyArgs,
          userFunction: destroy_func
        });
      }
    return data.destroy_func;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_queue_free(gfree_pointer?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_queue_free`, apiConfig.baseUrl);
    // Primitive parameter
    if (gfree_pointer !== undefined) url.searchParams.append('gfree_pointer', String(gfree_pointer));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_rand_double(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_rand_double`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_rand_double_range(range_start: number, range_end: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_rand_double_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('range_start', String(range_start));
    // Primitive parameter
    url.searchParams.append('range_end', String(range_end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_rand_int(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_rand_int`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_rand_int_range(begin: number, end: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_rand_int_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('begin', String(begin));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_run(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_run`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_run_suite(suite: GLibTestSuite): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_run_suite`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (suite && typeof suite === 'object' && 'ptr' in suite) {
      url.searchParams.append('suite', 'ptr,' + suite.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_set_nonfatal_assertions(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_set_nonfatal_assertions`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_skip(msg?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_skip`, apiConfig.baseUrl);
    // Primitive parameter
    if (msg !== undefined) url.searchParams.append('msg', String(msg));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_subprocess(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_subprocess`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_summary(summary: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_summary`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('summary', String(summary));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_timer_elapsed(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_timer_elapsed`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_timer_last(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_timer_last`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_timer_start(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_timer_start`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_trap_assertions(domain: string, file: string, line: number, func: string, assertion_flags: number, pattern: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_assertions`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    url.searchParams.append('func', String(func));
    // Primitive parameter
    url.searchParams.append('assertion_flags', String(assertion_flags));
    // Primitive parameter
    url.searchParams.append('pattern', String(pattern));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_trap_fork(usec_timeout: number, test_trap_flags: GLibTestTrapFlags): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_fork`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usec_timeout', String(usec_timeout));
    // Primitive parameter
    url.searchParams.append('test_trap_flags', String(test_trap_flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_trap_has_passed(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_has_passed`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_trap_reached_timeout(): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_reached_timeout`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_trap_subprocess(usec_timeout: number, test_flags: GLibTestSubprocessFlags, test_path?: string): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_subprocess`, apiConfig.baseUrl);
    // Primitive parameter
    if (test_path !== undefined) url.searchParams.append('test_path', String(test_path));
    // Primitive parameter
    url.searchParams.append('usec_timeout', String(usec_timeout));
    // Primitive parameter
    url.searchParams.append('test_flags', String(test_flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function test_trap_subprocess_with_envp(usec_timeout: number, test_flags: GLibTestSubprocessFlags, test_path?: string, envp?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/test_trap_subprocess_with_envp`, apiConfig.baseUrl);
    // Primitive parameter
    if (test_path !== undefined) url.searchParams.append('test_path', String(test_path));
    // Primitive parameter
    if (envp !== undefined) url.searchParams.append('envp', String(envp));
    // Primitive parameter
    url.searchParams.append('usec_timeout', String(usec_timeout));
    // Primitive parameter
    url.searchParams.append('test_flags', String(test_flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_exit(retval?: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_exit`, apiConfig.baseUrl);
    // Primitive parameter
    if (retval !== undefined) url.searchParams.append('retval', String(retval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_pool_get_max_idle_time(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_get_max_idle_time`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_pool_get_max_unused_threads(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_get_max_unused_threads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_pool_get_num_unused_threads(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_get_num_unused_threads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_pool_set_max_idle_time(interval: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_set_max_idle_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_pool_set_max_unused_threads(max_threads: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_set_max_unused_threads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_threads', String(max_threads));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_pool_stop_unused_threads(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_pool_stop_unused_threads`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_self(): Promise<GLibThread> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_self`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibThread(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function thread_yield(): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/thread_yield`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function time_val_from_iso8601(iso_date: string, time_: GLibTimeVal): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/time_val_from_iso8601`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iso_date', String(iso_date));
    // Object with explode=false: serialize as comma-separated
    if (time_ && typeof time_ === 'object' && 'ptr' in time_) {
      url.searchParams.append('time_', 'ptr,' + time_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function timeout_add(priority: number, interval: number, function_: GLibSourceFunc): Promise<{function: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/timeout_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.function !== undefined) {
        callbackDispatcher.set(data.function.toString(), {
          converter: convertGLibSourceFuncArgs,
          userFunction: function_
        });
      }
        const result: any = {};
      // Handle return parameter: function
      result.function = (() => {
        return data.function;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function timeout_add_seconds(priority: number, interval: number, function_: GLibSourceFunc): Promise<{function: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/timeout_add_seconds`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.function !== undefined) {
        callbackDispatcher.set(data.function.toString(), {
          converter: convertGLibSourceFuncArgs,
          userFunction: function_
        });
      }
        const result: any = {};
      // Handle return parameter: function
      result.function = (() => {
        return data.function;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function timeout_source_new(interval: number): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/timeout_source_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function timeout_source_new_seconds(interval: number): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/timeout_source_new_seconds`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function trash_stack_height(stack_p: GLibTrashStack): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/trash_stack_height`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function trash_stack_peek(stack_p: GLibTrashStack): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/trash_stack_peek`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function trash_stack_pop(stack_p: GLibTrashStack): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/trash_stack_pop`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function trash_stack_push(stack_p: GLibTrashStack, data_p: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/trash_stack_push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stack_p && typeof stack_p === 'object' && 'ptr' in stack_p) {
      url.searchParams.append('stack_p', 'ptr,' + stack_p.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data_p', String(data_p));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function try_malloc(n_bytes: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_malloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function try_malloc0(n_bytes: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_malloc0`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function try_malloc0_n(n_blocks: number, n_block_bytes: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_malloc0_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function try_malloc_n(n_blocks: number, n_block_bytes: number): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_malloc_n`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function try_realloc(n_bytes: number, mem?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_realloc`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('n_bytes', String(n_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function try_realloc_n(n_blocks: number, n_block_bytes: number, mem?: Pointer): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/try_realloc_n`, apiConfig.baseUrl);
    // Primitive parameter
    if (mem !== undefined) url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('n_blocks', String(n_blocks));
    // Primitive parameter
    url.searchParams.append('n_block_bytes', String(n_block_bytes));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ucs4_to_utf16(str: Pointer, len: number): Promise<{items_read: number, items_written: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ucs4_to_utf16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: items_read
      result.items_read = (() => {
        return data.items_read;

      })();
      // Handle return parameter: items_written
      result.items_written = (() => {
        return data.items_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function ucs4_to_utf8(str: Pointer, len: number): Promise<{items_read: number, items_written: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/ucs4_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: items_read
      result.items_read = (() => {
        return data.items_read;

      })();
      // Handle return parameter: items_written
      result.items_written = (() => {
        return data.items_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_break_type(c: Pointer): Promise<GLibUnicodeBreakTypeValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_break_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_combining_class(uc: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_combining_class`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uc', String(uc));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_compose(a: Pointer, b: Pointer): Promise<{ch: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_compose`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: ch
      result.ch = (() => {
        return data.ch;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_decompose(ch: Pointer): Promise<{a: Pointer, b: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_decompose`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: a
      result.a = (() => {
        return data.a;

      })();
      // Handle return parameter: b
      result.b = (() => {
        return data.b;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_digit_value(c: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_digit_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_fully_decompose(ch: Pointer, compat: boolean, result_len: number): Promise<{result: Pointer, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_fully_decompose`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    // Primitive parameter
    url.searchParams.append('compat', String(compat));
    // Primitive parameter
    url.searchParams.append('result_len', String(result_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: result
      result.result = (() => {
        return data.result;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_get_mirror_char(ch: Pointer): Promise<{mirrored_ch: Pointer, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_get_mirror_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: mirrored_ch
      result.mirrored_ch = (() => {
        return data.mirrored_ch;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_get_script(ch: Pointer): Promise<GLibUnicodeScriptValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_get_script`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_isalnum(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isalnum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_isalpha(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isalpha`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_iscntrl(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_iscntrl`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_isdefined(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isdefined`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_isdigit(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isdigit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_isgraph(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isgraph`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_islower(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_islower`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_ismark(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_ismark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_isprint(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isprint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_ispunct(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_ispunct`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_isspace(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isspace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_istitle(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_istitle`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_isupper(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isupper`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_iswide(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_iswide`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_iswide_cjk(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_iswide_cjk`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_isxdigit(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_isxdigit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_iszerowidth(c: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_iszerowidth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_to_utf8(c: Pointer): Promise<{outbuf: string, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: outbuf
      result.outbuf = (() => {
        return data.outbuf;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_tolower(c: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_tolower`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_totitle(c: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_totitle`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_toupper(c: Pointer): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_toupper`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_type(c: Pointer): Promise<GLibUnicodeTypeValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_validate(ch: Pointer): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_validate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unichar_xdigit_value(c: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unichar_xdigit_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unicode_canonical_decomposition(ch: Pointer, result_len: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unicode_canonical_decomposition`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ch', String(ch));
    // Primitive parameter
    url.searchParams.append('result_len', String(result_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unicode_canonical_ordering(string: Pointer, len: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unicode_canonical_ordering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unicode_script_from_iso15924(iso15924: number): Promise<GLibUnicodeScriptValue> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unicode_script_from_iso15924`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iso15924', String(iso15924));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unicode_script_to_iso15924(script: GLibUnicodeScriptValue): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unicode_script_to_iso15924`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('script', String(script));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unix_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unix_fd_add_full(priority: number, fd: number, condition: GLibIOConditionValue, function_: GLibUnixFDSourceFunc): Promise<{function: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_fd_add_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('condition', String(condition));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.function !== undefined) {
        callbackDispatcher.set(data.function.toString(), {
          converter: convertGLibUnixFDSourceFuncArgs,
          userFunction: function_
        });
      }
        const result: any = {};
      // Handle return parameter: function
      result.function = (() => {
        return data.function;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unix_fd_source_new(fd: number, condition: GLibIOConditionValue): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_fd_source_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('condition', String(condition));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unix_get_passwd_entry(user_name: string): Promise<Pointer | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_get_passwd_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('user_name', String(user_name));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unix_open_pipe(fds: Pointer, flags: number): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_open_pipe`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fds', String(fds));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unix_set_fd_nonblocking(fd: number, nonblock: boolean): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_set_fd_nonblocking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('nonblock', String(nonblock));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unix_signal_add(priority: number, signum: number, handler: GLibSourceFunc): Promise<{handler: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_signal_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    // Primitive parameter
    url.searchParams.append('signum', String(signum));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Register callbacks
      if (data.handler !== undefined) {
        callbackDispatcher.set(data.handler.toString(), {
          converter: convertGLibSourceFuncArgs,
          userFunction: handler
        });
      }
        const result: any = {};
      // Handle return parameter: handler
      result.handler = (() => {
        return data.handler;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unix_signal_source_new(signum: number): Promise<GLibSource> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unix_signal_source_new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signum', String(signum));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibSource(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unlink(filename: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unlink`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function unsetenv(variable: Pointer): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/unsetenv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('variable', String(variable));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_build(flags: GLibUriFlags, scheme: string, port: number, path: string, userinfo?: string, host?: string, query?: string, fragment?: string): Promise<GLibUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_build`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_build_with_user(flags: GLibUriFlags, scheme: string, port: number, path: string, user?: string, password?: string, auth_params?: string, host?: string, query?: string, fragment?: string): Promise<GLibUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_build_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (user !== undefined) url.searchParams.append('user', String(user));
    // Primitive parameter
    if (password !== undefined) url.searchParams.append('password', String(password));
    // Primitive parameter
    if (auth_params !== undefined) url.searchParams.append('auth_params', String(auth_params));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_escape_bytes(unescaped: Pointer, length: number, reserved_chars_allowed?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_escape_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    if (reserved_chars_allowed !== undefined) url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_escape_string(unescaped: string, allow_utf8: boolean, reserved_chars_allowed?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_escape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('unescaped', String(unescaped));
    // Primitive parameter
    if (reserved_chars_allowed !== undefined) url.searchParams.append('reserved_chars_allowed', String(reserved_chars_allowed));
    // Primitive parameter
    url.searchParams.append('allow_utf8', String(allow_utf8));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_is_valid(uri_string: string, flags: GLibUriFlags): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_join(flags: GLibUriFlags, port: number, path: string, scheme?: string, userinfo?: string, host?: string, query?: string, fragment?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_join`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_join_with_user(flags: GLibUriFlags, port: number, path: string, scheme?: string, user?: string, password?: string, auth_params?: string, host?: string, query?: string, fragment?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_join_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (user !== undefined) url.searchParams.append('user', String(user));
    // Primitive parameter
    if (password !== undefined) url.searchParams.append('password', String(password));
    // Primitive parameter
    if (auth_params !== undefined) url.searchParams.append('auth_params', String(auth_params));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_list_extract_uris(uri_list: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_list_extract_uris`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_list', String(uri_list));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_parse(uri_string: string, flags: GLibUriFlags): Promise<GLibUri> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibUri(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_parse_params(params: string, length: number, separators: string, flags: GLibUriParamsFlags): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_parse_params`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('params', String(params));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('separators', String(separators));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_parse_scheme(uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_parse_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_peek_scheme(uri: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_peek_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_resolve_relative(uri_ref: string, flags: GLibUriFlags, base_uri_string?: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_resolve_relative`, apiConfig.baseUrl);
    // Primitive parameter
    if (base_uri_string !== undefined) url.searchParams.append('base_uri_string', String(base_uri_string));
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_split(uri_ref: string, flags: GLibUriFlags): Promise<{scheme: string, userinfo: string, host: string, port: number, path: string, query: string, fragment: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_split`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: scheme
      result.scheme = (() => {
        return data.scheme;

      })();
      // Handle return parameter: userinfo
      result.userinfo = (() => {
        return data.userinfo;

      })();
      // Handle return parameter: host
      result.host = (() => {
        return data.host;

      })();
      // Handle return parameter: port
      result.port = (() => {
        return data.port;

      })();
      // Handle return parameter: path
      result.path = (() => {
        return data.path;

      })();
      // Handle return parameter: query
      result.query = (() => {
        return data.query;

      })();
      // Handle return parameter: fragment
      result.fragment = (() => {
        return data.fragment;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_split_network(uri_string: string, flags: GLibUriFlags): Promise<{scheme: string, host: string, port: number, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_split_network`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_string', String(uri_string));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: scheme
      result.scheme = (() => {
        return data.scheme;

      })();
      // Handle return parameter: host
      result.host = (() => {
        return data.host;

      })();
      // Handle return parameter: port
      result.port = (() => {
        return data.port;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_split_with_user(uri_ref: string, flags: GLibUriFlags): Promise<{scheme: string, user: string, password: string, auth_params: string, host: string, port: number, path: string, query: string, fragment: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_split_with_user`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri_ref', String(uri_ref));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: scheme
      result.scheme = (() => {
        return data.scheme;

      })();
      // Handle return parameter: user
      result.user = (() => {
        return data.user;

      })();
      // Handle return parameter: password
      result.password = (() => {
        return data.password;

      })();
      // Handle return parameter: auth_params
      result.auth_params = (() => {
        return data.auth_params;

      })();
      // Handle return parameter: host
      result.host = (() => {
        return data.host;

      })();
      // Handle return parameter: port
      result.port = (() => {
        return data.port;

      })();
      // Handle return parameter: path
      result.path = (() => {
        return data.path;

      })();
      // Handle return parameter: query
      result.query = (() => {
        return data.query;

      })();
      // Handle return parameter: fragment
      result.fragment = (() => {
        return data.fragment;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_unescape_bytes(escaped_string: string, length: number, illegal_characters?: string): Promise<GLibBytes> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_unescape_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibBytes(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_unescape_segment(escaped_string?: string, escaped_string_end?: string, illegal_characters?: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_unescape_segment`, apiConfig.baseUrl);
    // Primitive parameter
    if (escaped_string !== undefined) url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    if (escaped_string_end !== undefined) url.searchParams.append('escaped_string_end', String(escaped_string_end));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uri_unescape_string(escaped_string: string, illegal_characters?: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uri_unescape_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('escaped_string', String(escaped_string));
    // Primitive parameter
    if (illegal_characters !== undefined) url.searchParams.append('illegal_characters', String(illegal_characters));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function usleep(microseconds: number): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/usleep`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('microseconds', String(microseconds));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf16_to_ucs4(str: Pointer, len: number): Promise<{items_read: number, items_written: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf16_to_ucs4`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: items_read
      result.items_read = (() => {
        return data.items_read;

      })();
      // Handle return parameter: items_written
      result.items_written = (() => {
        return data.items_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf16_to_utf8(str: Pointer, len: number): Promise<{items_read: number, items_written: number, return: string}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf16_to_utf8`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: items_read
      result.items_read = (() => {
        return data.items_read;

      })();
      // Handle return parameter: items_written
      result.items_written = (() => {
        return data.items_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_casefold(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_casefold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_collate(str1: string, str2: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_collate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str1', String(str1));
    // Primitive parameter
    url.searchParams.append('str2', String(str2));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_collate_key(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_collate_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_collate_key_for_filename(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_collate_key_for_filename`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_find_next_char(p: string, end?: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_find_next_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    if (end !== undefined) url.searchParams.append('end', String(end));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_find_prev_char(str: string, p: string): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_find_prev_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('p', String(p));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_get_char(p: string): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_get_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_get_char_validated(p: string, max_len: number): Promise<Pointer> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_get_char_validated`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    url.searchParams.append('max_len', String(max_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_make_valid(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_make_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_normalize(str: string, len: number, mode: GLibNormalizeModeValue): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_normalize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_offset_to_pointer(str: string, offset: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_offset_to_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_pointer_to_offset(str: string, pos: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_pointer_to_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('pos', String(pos));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_prev_char(p: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_prev_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_strchr(p: string, len: number, c: Pointer): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strchr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_strdown(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strdown`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_strlen(p: string, max: number): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strlen`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    url.searchParams.append('max', String(max));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_strncpy(dest: string, src: string, n: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strncpy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('dest', String(dest));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_strrchr(p: string, len: number, c: Pointer): Promise<string | null> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strrchr`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('p', String(p));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    // Primitive parameter
    url.searchParams.append('c', String(c));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_strreverse(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strreverse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_strup(str: string, len: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_strup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_substring(str: string, start_pos: number, end_pos: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_substring`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('start_pos', String(start_pos));
    // Primitive parameter
    url.searchParams.append('end_pos', String(end_pos));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_to_ucs4(str: string, len: number): Promise<{items_read: number, items_written: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_to_ucs4`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: items_read
      result.items_read = (() => {
        return data.items_read;

      })();
      // Handle return parameter: items_written
      result.items_written = (() => {
        return data.items_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_to_ucs4_fast(str: string, len: number): Promise<{items_written: number, return: Pointer}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_to_ucs4_fast`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: items_written
      result.items_written = (() => {
        return data.items_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_to_utf16(str: string, len: number): Promise<{items_read: number, items_written: number, return: number}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_to_utf16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('len', String(len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: items_read
      result.items_read = (() => {
        return data.items_read;

      })();
      // Handle return parameter: items_written
      result.items_written = (() => {
        return data.items_written;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_truncate_middle(string: string, truncate_length: number): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_truncate_middle`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    url.searchParams.append('truncate_length', String(truncate_length));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_validate(str: Pointer, max_len: number): Promise<{end: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_validate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('max_len', String(max_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: end
      result.end = (() => {
        return data.end;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utf8_validate_len(str: Pointer, max_len: number): Promise<{end: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utf8_validate_len`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    // Primitive parameter
    url.searchParams.append('max_len', String(max_len));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: end
      result.end = (() => {
        return data.end;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function utime(filename: Pointer, utb?: Pointer): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/utime`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    // Primitive parameter
    if (utb !== undefined) url.searchParams.append('utb', String(utb));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uuid_string_is_valid(str: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uuid_string_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function uuid_string_random(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/uuid_string_random`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_get_gtype(): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_get_gtype`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_is_object_path(string: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_is_object_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_is_signature(string: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_is_signature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_parse(text: string, type_?: GLibVariantType, limit?: string, endptr?: string): Promise<GLibVariant> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_parse`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ !== undefined && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    // Primitive parameter
    if (endptr !== undefined) url.searchParams.append('endptr', String(endptr));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariant(data.return.ptr, 'full');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_parse_error_print_context(error_: Pointer, source_str: string): Promise<string> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_parse_error_print_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('source_str', String(source_str));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_parse_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_parse_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_parser_get_error_quark(): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_parser_get_error_quark`, apiConfig.baseUrl);
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_type_checked_(type_string: string): Promise<GLibVariantType> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_type_checked_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    // Return value is a struct, instantiate it from the ptr
if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
  const instance = new GLibVariantType(data.return.ptr, 'none');
  return instance;
}
return Promise.reject("Call failed");

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_type_string_get_depth_(type_string: string): Promise<number> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_type_string_get_depth_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_type_string_is_valid(type_string: string): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_type_string_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
    return data.return;


    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

  





 
  export async function variant_type_string_scan(string: string, limit?: string): Promise<{endptr: string, return: boolean}> {
    // Increment ref for parameters with full transfer ownership
    const url = new URL(`${apiConfig.normalizedBasePath}/GLib/variant_type_string_scan`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
        const result: any = {};
      // Handle return parameter: endptr
      result.endptr = (() => {
        return data.endptr;

      })();
      // Handle return parameter: return
      result.return = (() => {
        return data.return;

      })();
      return result;

    } catch (error) {
      // If there's an error, unref the objects we ref'd
      throw error;
    }
  }

}
