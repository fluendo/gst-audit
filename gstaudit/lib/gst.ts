/**
 * Gst REST API
 * Version: 1.0
 * Auto-generated by girest-client-generator
 */

// Base types
export type Pointer = string;

// Configuration for API server location
let apiConfig = {
  host: 'localhost',
  port: 9000,
  get baseUrl(): string {
    return `http://${this.host}:${this.port}`;
  }
};

/**
 * Update the API server configuration
 * @param config New configuration with host and/or port
 */
export function setApiConfig(config: { host?: string; port?: number }): void {
  if (config.host !== undefined) {
    apiConfig.host = config.host;
  }
  if (config.port !== undefined) {
    apiConfig.port = config.port;
  }
  // Reinitialize callback EventSource with new URL
  if (typeof EventSource !== 'undefined' && config.host !== undefined || config.port !== undefined) {
    initializeCallbackSource();
  }
}

/**
 * Get the current API server configuration
 */
export function getApiConfig(): { host: string; port: number; baseUrl: string } {
  return {
    host: apiConfig.host,
    port: apiConfig.port,
    baseUrl: apiConfig.baseUrl
  };
}

// FinalizationRegistry for automatic cleanup of GObject instances
const objectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GObject/Object/' + ptr + '/unref')
    .catch(err => console.error('Failed to unref object:', ptr, err));
});

// Callback dispatcher for handling callbacks from the server
const callbackDispatcher = new Map<string, Function>();

let callbackSource: EventSource | null = null;
let isReinitializing = false;

function initializeCallbackSource(): void {
  // Prevent concurrent reinitialization
  if (isReinitializing) {
    return;
  }
  isReinitializing = true;
  
  // Close existing EventSource if it exists
  if (callbackSource) {
    callbackSource.close();
    callbackSource = null;
  }
  
  // Initialize callback dispatcher with EventSource
  if (typeof EventSource !== 'undefined') {
    callbackSource = new EventSource(apiConfig.baseUrl + '/GIRest/callbacks');
    callbackSource.onmessage = (ev) => {
      try {
        const json = JSON.parse(ev.data);
        const cb = callbackDispatcher.get(json.id.toString());
        if (cb) {
          cb(...Object.values(json.data));
        }
      } catch (error) {
        console.error('Error processing callback:', error);
      }
    };
    callbackSource.onerror = (error) => {
      console.error('Callback EventSource error:', error);
    };
    callbackSource.onopen = () => {
      isReinitializing = false;
    };
  } else {
    isReinitializing = false;
  }
}

// Initialize on module load
initializeCallbackSource();

export interface GstAllocationParams {
  ptr: Pointer;
}
export interface GObjectTypeInterface {
  ptr: Pointer;
}
export interface GObjectValue {
  ptr: Pointer;
}
export type GObjectBindingFlags = "default" | "bidirectional" | "sync_create" | "invert_boolean";
export interface GObjectClosure {
  ptr: Pointer;
}
export interface GstMemory {
  ptr: Pointer;
}
export type GstAllocatorFlags = "custom_alloc" | "no_copy" | "last";
export interface GstAllocatorPrivate {
  ptr: Pointer;
}
export interface GstAtomicQueue {
  ptr: Pointer;
}
export type GstURIType = "unknown" | "sink" | "src";
export type GstPluginDependencyFlags = "none" | "recurse" | "paths_are_default_only" | "file_name_is_suffix" | "file_name_is_prefix" | "paths_are_relative_to_exe";
export interface GstStructure {
  ptr: Pointer;
}
export type GstStateChangeReturn = "failure" | "success" | "async" | "no_preroll";
export type GstState = "void_pending" | "null" | "ready" | "paused" | "playing";
export type GstPadDirection = "unknown" | "src" | "sink";
export interface GstStaticPadTemplate {
  ptr: Pointer;
}
export type GstPadPresence = "always" | "sometimes" | "request";
export interface GstCaps {
  ptr: Pointer;
}
export type GstPadLinkReturn = "ok" | "wrong_hierarchy" | "was_linked" | "wrong_direction" | "noformat" | "nosched" | "refused";
export namespace GstPadMode {
  export const NONE: 'none' = 'none';
  export const PUSH: 'push' = 'push';
  export const PULL: 'pull' = 'pull';
  export async function get_name(mode: GstPadModeValue): Promise<string> {
    const url = new URL(`/Gst/PadMode/get_name`, apiConfig.baseUrl);
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadModeValue = "none" | "push" | "pull";
export type GstPadProbeType = "invalid" | "idle" | "block" | "buffer" | "buffer_list" | "event_downstream" | "event_upstream" | "event_flush" | "query_downstream" | "query_upstream" | "push" | "pull" | "blocking" | "data_downstream" | "data_upstream" | "data_both" | "block_downstream" | "block_upstream" | "event_both" | "query_both" | "all_both" | "scheduling";
export interface GstPadProbeInfo {
  ptr: Pointer;
}
export type GstPadProbeReturn = "drop" | "ok" | "remove" | "pass" | "handled";
export interface GstBuffer {
  ptr: Pointer;
}
export type GstFlowReturn = "custom_success_2" | "custom_success_1" | "custom_success" | "ok" | "not_linked" | "flushing" | "eos" | "not_negotiated" | "error" | "not_supported" | "custom_error" | "custom_error_1" | "custom_error_2";
export interface GstBufferList {
  ptr: Pointer;
}
export interface GstEvent {
  ptr: Pointer;
}
export namespace GstEventType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const FLUSH_START: 'flush_start' = 'flush_start';
  export const FLUSH_STOP: 'flush_stop' = 'flush_stop';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const CAPS: 'caps' = 'caps';
  export const SEGMENT: 'segment' = 'segment';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const TAG: 'tag' = 'tag';
  export const BUFFERSIZE: 'buffersize' = 'buffersize';
  export const SINK_MESSAGE: 'sink_message' = 'sink_message';
  export const STREAM_GROUP_DONE: 'stream_group_done' = 'stream_group_done';
  export const EOS: 'eos' = 'eos';
  export const TOC: 'toc' = 'toc';
  export const PROTECTION: 'protection' = 'protection';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const GAP: 'gap' = 'gap';
  export const INSTANT_RATE_CHANGE: 'instant_rate_change' = 'instant_rate_change';
  export const QOS: 'qos' = 'qos';
  export const SEEK: 'seek' = 'seek';
  export const NAVIGATION: 'navigation' = 'navigation';
  export const LATENCY: 'latency' = 'latency';
  export const STEP: 'step' = 'step';
  export const RECONFIGURE: 'reconfigure' = 'reconfigure';
  export const TOC_SELECT: 'toc_select' = 'toc_select';
  export const SELECT_STREAMS: 'select_streams' = 'select_streams';
  export const INSTANT_RATE_SYNC_TIME: 'instant_rate_sync_time' = 'instant_rate_sync_time';
  export const CUSTOM_UPSTREAM: 'custom_upstream' = 'custom_upstream';
  export const CUSTOM_DOWNSTREAM: 'custom_downstream' = 'custom_downstream';
  export const CUSTOM_DOWNSTREAM_OOB: 'custom_downstream_oob' = 'custom_downstream_oob';
  export const CUSTOM_DOWNSTREAM_STICKY: 'custom_downstream_sticky' = 'custom_downstream_sticky';
  export const CUSTOM_BOTH: 'custom_both' = 'custom_both';
  export const CUSTOM_BOTH_OOB: 'custom_both_oob' = 'custom_both_oob';
  export async function get_flags(type_: GstEventTypeValue): Promise<GstEventTypeFlags> {
    const url = new URL(`/Gst/EventType/get_flags`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_name(type_: GstEventTypeValue): Promise<string> {
    const url = new URL(`/Gst/EventType/get_name`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`/Gst/EventType/to_quark`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_sticky_ordering(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`/Gst/EventType/to_sticky_ordering`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstEventTypeValue = "unknown" | "flush_start" | "flush_stop" | "stream_start" | "caps" | "segment" | "stream_collection" | "tag" | "buffersize" | "sink_message" | "stream_group_done" | "eos" | "toc" | "protection" | "segment_done" | "gap" | "instant_rate_change" | "qos" | "seek" | "navigation" | "latency" | "step" | "reconfigure" | "toc_select" | "select_streams" | "instant_rate_sync_time" | "custom_upstream" | "custom_downstream" | "custom_downstream_oob" | "custom_downstream_sticky" | "custom_both" | "custom_both_oob";
export type GstEventTypeFlags = "upstream" | "downstream" | "serialized" | "sticky" | "sticky_multi";
export namespace GstStreamType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const AUDIO: 'audio' = 'audio';
  export const VIDEO: 'video' = 'video';
  export const CONTAINER: 'container' = 'container';
  export const TEXT: 'text' = 'text';
  export async function get_name(stype: GstStreamTypeValue): Promise<string> {
    const url = new URL(`/Gst/StreamType/get_name`, apiConfig.baseUrl);
    url.searchParams.append('stype', String(stype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStreamTypeValue = "unknown" | "audio" | "video" | "container" | "text";
export type GstStreamFlags = "none" | "sparse" | "select" | "unselect";
export interface GstTagList {
  ptr: Pointer;
}
export type GstTaskState = "started" | "stopped" | "paused";
export interface GstIterator {
  ptr: Pointer;
}
export type GstPadLinkCheck = "nothing" | "hierarchy" | "template_caps" | "caps" | "no_reconfigure" | "default";
export interface GstQuery {
  ptr: Pointer;
}
export namespace GstFormat {
  export const UNDEFINED: 'undefined' = 'undefined';
  export const DEFAULT: 'default' = 'default';
  export const BYTES: 'bytes' = 'bytes';
  export const TIME: 'time' = 'time';
  export const BUFFERS: 'buffers' = 'buffers';
  export const PERCENT: 'percent' = 'percent';
  export async function get_by_nick(nick: string): Promise<GstFormatValue> {
    const url = new URL(`/Gst/Format/get_by_nick`, apiConfig.baseUrl);
    url.searchParams.append('nick', String(nick));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_details(format: GstFormatValue): Promise<GstFormatDefinition> {
    const url = new URL(`/Gst/Format/get_details`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_name(format: GstFormatValue): Promise<string> {
    const url = new URL(`/Gst/Format/get_name`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function iterate_definitions(): Promise<GstIterator> {
    const url = new URL(`/Gst/Format/iterate_definitions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function register(nick: string, description: string): Promise<GstFormatValue> {
    const url = new URL(`/Gst/Format/register`, apiConfig.baseUrl);
    url.searchParams.append('nick', String(nick));
    url.searchParams.append('description', String(description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(format: GstFormatValue): Promise<number> {
    const url = new URL(`/Gst/Format/to_quark`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstFormatValue = "undefined" | "default" | "bytes" | "time" | "buffers" | "percent";
export interface GstFormatDefinition {
  ptr: Pointer;
}
export namespace GstStateChange {
  export const NULL_TO_READY: 'null_to_ready' = 'null_to_ready';
  export const READY_TO_PAUSED: 'ready_to_paused' = 'ready_to_paused';
  export const PAUSED_TO_PLAYING: 'paused_to_playing' = 'paused_to_playing';
  export const PLAYING_TO_PAUSED: 'playing_to_paused' = 'playing_to_paused';
  export const PAUSED_TO_READY: 'paused_to_ready' = 'paused_to_ready';
  export const READY_TO_NULL: 'ready_to_null' = 'ready_to_null';
  export const NULL_TO_NULL: 'null_to_null' = 'null_to_null';
  export const READY_TO_READY: 'ready_to_ready' = 'ready_to_ready';
  export const PAUSED_TO_PAUSED: 'paused_to_paused' = 'paused_to_paused';
  export const PLAYING_TO_PLAYING: 'playing_to_playing' = 'playing_to_playing';
  export async function get_name(transition: GstStateChangeValue): Promise<string> {
    const url = new URL(`/Gst/StateChange/get_name`, apiConfig.baseUrl);
    url.searchParams.append('transition', String(transition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStateChangeValue = "null_to_ready" | "ready_to_paused" | "paused_to_playing" | "playing_to_paused" | "paused_to_ready" | "ready_to_null" | "null_to_null" | "ready_to_ready" | "paused_to_paused" | "playing_to_playing";
export interface GstMessage {
  ptr: Pointer;
}
export interface GLibSource {
  ptr: Pointer;
}
export interface GLibPollFD {
  ptr: Pointer;
}
export namespace GstMessageType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const EOS: 'eos' = 'eos';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const INFO: 'info' = 'info';
  export const TAG: 'tag' = 'tag';
  export const BUFFERING: 'buffering' = 'buffering';
  export const STATE_CHANGED: 'state_changed' = 'state_changed';
  export const STATE_DIRTY: 'state_dirty' = 'state_dirty';
  export const STEP_DONE: 'step_done' = 'step_done';
  export const CLOCK_PROVIDE: 'clock_provide' = 'clock_provide';
  export const CLOCK_LOST: 'clock_lost' = 'clock_lost';
  export const NEW_CLOCK: 'new_clock' = 'new_clock';
  export const STRUCTURE_CHANGE: 'structure_change' = 'structure_change';
  export const STREAM_STATUS: 'stream_status' = 'stream_status';
  export const APPLICATION: 'application' = 'application';
  export const ELEMENT: 'element' = 'element';
  export const SEGMENT_START: 'segment_start' = 'segment_start';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const DURATION_CHANGED: 'duration_changed' = 'duration_changed';
  export const LATENCY: 'latency' = 'latency';
  export const ASYNC_START: 'async_start' = 'async_start';
  export const ASYNC_DONE: 'async_done' = 'async_done';
  export const REQUEST_STATE: 'request_state' = 'request_state';
  export const STEP_START: 'step_start' = 'step_start';
  export const QOS: 'qos' = 'qos';
  export const PROGRESS: 'progress' = 'progress';
  export const TOC: 'toc' = 'toc';
  export const RESET_TIME: 'reset_time' = 'reset_time';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const NEED_CONTEXT: 'need_context' = 'need_context';
  export const HAVE_CONTEXT: 'have_context' = 'have_context';
  export const EXTENDED: 'extended' = 'extended';
  export const DEVICE_ADDED: 'device_added' = 'device_added';
  export const DEVICE_REMOVED: 'device_removed' = 'device_removed';
  export const PROPERTY_NOTIFY: 'property_notify' = 'property_notify';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const STREAMS_SELECTED: 'streams_selected' = 'streams_selected';
  export const REDIRECT: 'redirect' = 'redirect';
  export const DEVICE_CHANGED: 'device_changed' = 'device_changed';
  export const INSTANT_RATE_REQUEST: 'instant_rate_request' = 'instant_rate_request';
  export const ANY: 'any' = 'any';
  export async function get_name(type_: GstMessageTypeValue): Promise<string> {
    const url = new URL(`/Gst/MessageType/get_name`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(type_: GstMessageTypeValue): Promise<number> {
    const url = new URL(`/Gst/MessageType/to_quark`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstMessageTypeValue = "unknown" | "eos" | "error" | "warning" | "info" | "tag" | "buffering" | "state_changed" | "state_dirty" | "step_done" | "clock_provide" | "clock_lost" | "new_clock" | "structure_change" | "stream_status" | "application" | "element" | "segment_start" | "segment_done" | "duration_changed" | "latency" | "async_start" | "async_done" | "request_state" | "step_start" | "qos" | "progress" | "toc" | "reset_time" | "stream_start" | "need_context" | "have_context" | "extended" | "device_added" | "device_removed" | "property_notify" | "stream_collection" | "streams_selected" | "redirect" | "device_changed" | "instant_rate_request" | "any";
export type GstBusSyncReply = "drop" | "pass" | "async";
export type GstClockReturn = "ok" | "early" | "unscheduled" | "busy" | "badtime" | "error" | "unsupported" | "done";
export interface GstContext {
  ptr: Pointer;
}
export type GstRank = "none" | "marginal" | "secondary" | "primary";
export type GstSeekFlags = "none" | "flush" | "accurate" | "key_unit" | "segment" | "trickmode" | "skip" | "snap_before" | "snap_after" | "snap_nearest" | "trickmode_key_units" | "trickmode_no_audio" | "trickmode_forward_predicted" | "instant_rate_change";
export type GstSeekType = "none" | "set" | "end";
export type GstElementFlags = "locked_state" | "sink" | "source" | "provide_clock" | "require_clock" | "indexable" | "last";
export type GstBinFlags = "no_resync" | "streams_aware" | "last";
export interface GstBinPrivate {
  ptr: Pointer;
}
export type GstBufferCopyFlags = "none" | "flags" | "timestamps" | "meta" | "memory" | "merge" | "deep";
export type GstBufferFlags = "live" | "decode_only" | "discont" | "resync" | "corrupted" | "marker" | "header" | "gap" | "droppable" | "delta_unit" | "tag_memory" | "sync_after" | "non_droppable" | "last";
export interface GstBufferPoolAcquireParams {
  ptr: Pointer;
}
export type GstBufferPoolAcquireFlags = "none" | "key_unit" | "dontwait" | "discont" | "last";
export interface GstBufferPoolPrivate {
  ptr: Pointer;
}
export type GstBufferingMode = "stream" | "download" | "timeshift" | "live";
export type GstBusFlags = "flushing" | "flag_last";
export interface GstBusPrivate {
  ptr: Pointer;
}
export interface GstByteArrayInterface {
  ptr: Pointer;
}
export interface GstCapsFeatures {
  ptr: Pointer;
}
export type GstCapsFlags = "any";
export type GstCapsIntersectMode = "zig_zag" | "first";
export interface GstClockEntry {
  ptr: Pointer;
}
export type GstClockEntryType = "single" | "periodic";
export type GstClockFlags = "can_do_single_sync" | "can_do_single_async" | "can_do_periodic_sync" | "can_do_periodic_async" | "can_set_resolution" | "can_set_master" | "needs_startup_sync" | "last";
export interface GstClockPrivate {
  ptr: Pointer;
}
export type GstClockType = "realtime" | "monotonic" | "other" | "tai";
export interface GstControlBindingPrivate {
  ptr: Pointer;
}
export namespace GstCoreError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const STATE_CHANGE: 'state_change' = 'state_change';
  export const PAD: 'pad' = 'pad';
  export const THREAD: 'thread' = 'thread';
  export const NEGOTIATION: 'negotiation' = 'negotiation';
  export const EVENT: 'event' = 'event';
  export const SEEK: 'seek' = 'seek';
  export const CAPS: 'caps' = 'caps';
  export const TAG: 'tag' = 'tag';
  export const MISSING_PLUGIN: 'missing_plugin' = 'missing_plugin';
  export const CLOCK: 'clock' = 'clock';
  export const DISABLED: 'disabled' = 'disabled';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/CoreError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstCoreErrorValue = "failed" | "too_lazy" | "not_implemented" | "state_change" | "pad" | "thread" | "negotiation" | "event" | "seek" | "caps" | "tag" | "missing_plugin" | "clock" | "disabled" | "num_errors";
export interface GstCustomMeta {
  ptr: Pointer;
}
export interface GstDateTime {
  ptr: Pointer;
}
export interface GstDebugCategory {
  ptr: Pointer;
}
export type GstDebugColorFlags = "fg_black" | "fg_red" | "fg_green" | "fg_yellow" | "fg_blue" | "fg_magenta" | "fg_cyan" | "fg_white" | "bg_black" | "bg_red" | "bg_green" | "bg_yellow" | "bg_blue" | "bg_magenta" | "bg_cyan" | "bg_white" | "bold" | "underline";
export type GstDebugColorMode = "off" | "on" | "unix";
export type GstDebugGraphDetails = "media_type" | "caps_details" | "non_default_params" | "states" | "full_params" | "all" | "verbose";
export namespace GstDebugLevel {
  export const NONE: 'none' = 'none';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const FIXME: 'fixme' = 'fixme';
  export const INFO: 'info' = 'info';
  export const DEBUG: 'debug' = 'debug';
  export const LOG: 'log' = 'log';
  export const TRACE: 'trace' = 'trace';
  export const MEMDUMP: 'memdump' = 'memdump';
  export const COUNT: 'count' = 'count';
  export async function get_name(level: GstDebugLevelValue): Promise<string> {
    const url = new URL(`/Gst/DebugLevel/get_name`, apiConfig.baseUrl);
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstDebugLevelValue = "none" | "error" | "warning" | "fixme" | "info" | "debug" | "log" | "trace" | "memdump" | "count";
export interface GstDebugMessage {
  ptr: Pointer;
}
export interface GstDeviceMonitorPrivate {
  ptr: Pointer;
}
export interface GstDevicePrivate {
  ptr: Pointer;
}
export interface GstDeviceProviderPrivate {
  ptr: Pointer;
}
export type GstGapFlags = "data";
export interface GstGhostPadPrivate {
  ptr: Pointer;
}
export type GstIteratorItem = "skip" | "pass" | "end";
export type GstIteratorResult = "done" | "ok" | "resync" | "error";
export namespace GstLibraryError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const INIT: 'init' = 'init';
  export const SHUTDOWN: 'shutdown' = 'shutdown';
  export const SETTINGS: 'settings' = 'settings';
  export const ENCODE: 'encode' = 'encode';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/LibraryError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstLibraryErrorValue = "failed" | "too_lazy" | "init" | "shutdown" | "settings" | "encode" | "num_errors";
export type GstLockFlags = "read" | "write" | "exclusive" | "last";
export type GstMapFlags = "read" | "write" | "flag_last";
export interface GstMapInfo {
  ptr: Pointer;
}
export type GstMemoryFlags = "readonly" | "no_share" | "zero_prefixed" | "zero_padded" | "physically_contiguous" | "not_mappable" | "last";
export interface GstMeta {
  ptr: Pointer;
}
export type GstMetaFlags = "none" | "readonly" | "pooled" | "locked" | "last";
export interface GstMetaInfo {
  ptr: Pointer;
}
export interface GstMetaTransformCopy {
  ptr: Pointer;
}
export interface GstMiniObject {
  ptr: Pointer;
}
export type GstMiniObjectFlags = "lockable" | "lock_readonly" | "may_be_leaked" | "last";
export type GstObjectFlags = "may_be_leaked" | "constructed" | "last";
export type GstPadFlags = "blocked" | "flushing" | "eos" | "blocking" | "need_parent" | "need_reconfigure" | "pending_events" | "fixed_caps" | "proxy_caps" | "proxy_allocation" | "proxy_scheduling" | "accept_intersect" | "accept_template" | "last";
export interface GstPadPrivate {
  ptr: Pointer;
}
export type GstPadTemplateFlags = "last";
export interface GstParamSpecArray {
  ptr: Pointer;
}
export interface GstParamSpecFraction {
  ptr: Pointer;
}
export interface GstParentBufferMeta {
  ptr: Pointer;
}
export interface GstParseContext {
  ptr: Pointer;
}
export namespace GstParseError {
  export const SYNTAX: 'syntax' = 'syntax';
  export const NO_SUCH_ELEMENT: 'no_such_element' = 'no_such_element';
  export const NO_SUCH_PROPERTY: 'no_such_property' = 'no_such_property';
  export const LINK: 'link' = 'link';
  export const COULD_NOT_SET_PROPERTY: 'could_not_set_property' = 'could_not_set_property';
  export const EMPTY_BIN: 'empty_bin' = 'empty_bin';
  export const EMPTY: 'empty' = 'empty';
  export const DELAYED_LINK: 'delayed_link' = 'delayed_link';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/ParseError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstParseErrorValue = "syntax" | "no_such_element" | "no_such_property" | "link" | "could_not_set_property" | "empty_bin" | "empty" | "delayed_link";
export type GstParseFlags = "none" | "fatal_errors" | "no_single_element_bins" | "place_in_bin";
export type GstPipelineFlags = "fixed_clock" | "last";
export interface GstPipelinePrivate {
  ptr: Pointer;
}
export type GstPluginAPIFlags = "members";
export interface GstPluginDesc {
  ptr: Pointer;
}
export namespace GstPluginError {
  export const MODULE: 'module' = 'module';
  export const DEPENDENCIES: 'dependencies' = 'dependencies';
  export const NAME_MISMATCH: 'name_mismatch' = 'name_mismatch';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/PluginError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPluginErrorValue = "module" | "dependencies" | "name_mismatch";
export type GstPluginFlags = "cached" | "blacklisted";
export interface GstPoll {
  ptr: Pointer;
}
export interface GstPollFD {
  ptr: Pointer;
}
export type GstProgressType = "start" | "continue" | "complete" | "canceled" | "error";
export interface GstPromise {
  ptr: Pointer;
}
export type GstPromiseResult = "pending" | "interrupted" | "replied" | "expired";
export interface GstProtectionMeta {
  ptr: Pointer;
}
export interface GstProxyPadPrivate {
  ptr: Pointer;
}
export type GstQOSType = "overflow" | "underflow" | "throttle";
export namespace GstQueryType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const POSITION: 'position' = 'position';
  export const DURATION: 'duration' = 'duration';
  export const LATENCY: 'latency' = 'latency';
  export const JITTER: 'jitter' = 'jitter';
  export const RATE: 'rate' = 'rate';
  export const SEEKING: 'seeking' = 'seeking';
  export const SEGMENT: 'segment' = 'segment';
  export const CONVERT: 'convert' = 'convert';
  export const FORMATS: 'formats' = 'formats';
  export const BUFFERING: 'buffering' = 'buffering';
  export const CUSTOM: 'custom' = 'custom';
  export const URI: 'uri' = 'uri';
  export const ALLOCATION: 'allocation' = 'allocation';
  export const SCHEDULING: 'scheduling' = 'scheduling';
  export const ACCEPT_CAPS: 'accept_caps' = 'accept_caps';
  export const CAPS: 'caps' = 'caps';
  export const DRAIN: 'drain' = 'drain';
  export const CONTEXT: 'context' = 'context';
  export const BITRATE: 'bitrate' = 'bitrate';
  export const SELECTABLE: 'selectable' = 'selectable';
  export async function get_flags(type_: GstQueryTypeValue): Promise<GstQueryTypeFlags> {
    const url = new URL(`/Gst/QueryType/get_flags`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_name(type_: GstQueryTypeValue): Promise<string> {
    const url = new URL(`/Gst/QueryType/get_name`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(type_: GstQueryTypeValue): Promise<number> {
    const url = new URL(`/Gst/QueryType/to_quark`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstQueryTypeValue = "unknown" | "position" | "duration" | "latency" | "jitter" | "rate" | "seeking" | "segment" | "convert" | "formats" | "buffering" | "custom" | "uri" | "allocation" | "scheduling" | "accept_caps" | "caps" | "drain" | "context" | "bitrate" | "selectable";
export type GstQueryTypeFlags = "upstream" | "downstream" | "serialized";
export interface GstReferenceTimestampMeta {
  ptr: Pointer;
}
export interface GstRegistryPrivate {
  ptr: Pointer;
}
export namespace GstResourceError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_FOUND: 'not_found' = 'not_found';
  export const BUSY: 'busy' = 'busy';
  export const OPEN_READ: 'open_read' = 'open_read';
  export const OPEN_WRITE: 'open_write' = 'open_write';
  export const OPEN_READ_WRITE: 'open_read_write' = 'open_read_write';
  export const CLOSE: 'close' = 'close';
  export const READ: 'read' = 'read';
  export const WRITE: 'write' = 'write';
  export const SEEK: 'seek' = 'seek';
  export const SYNC: 'sync' = 'sync';
  export const SETTINGS: 'settings' = 'settings';
  export const NO_SPACE_LEFT: 'no_space_left' = 'no_space_left';
  export const NOT_AUTHORIZED: 'not_authorized' = 'not_authorized';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/ResourceError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstResourceErrorValue = "failed" | "too_lazy" | "not_found" | "busy" | "open_read" | "open_write" | "open_read_write" | "close" | "read" | "write" | "seek" | "sync" | "settings" | "no_space_left" | "not_authorized" | "num_errors";
export interface GstSample {
  ptr: Pointer;
}
export type GstSchedulingFlags = "seekable" | "sequential" | "bandwidth_limited";
export type GstSearchMode = "exact" | "before" | "after";
export interface GstSegment {
  ptr: Pointer;
}
export type GstSegmentFlags = "none" | "reset" | "trickmode" | "skip" | "segment" | "trickmode_key_units" | "trickmode_forward_predicted" | "trickmode_no_audio";
export type GstSerializeFlags = "none" | "backward_compat" | "strict";
export interface GstSharedTaskPoolPrivate {
  ptr: Pointer;
}
export type GstStackTraceFlags = "none" | "full";
export interface GstStaticCaps {
  ptr: Pointer;
}
export interface GstStreamCollectionPrivate {
  ptr: Pointer;
}
export namespace GstStreamError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const TYPE_NOT_FOUND: 'type_not_found' = 'type_not_found';
  export const WRONG_TYPE: 'wrong_type' = 'wrong_type';
  export const CODEC_NOT_FOUND: 'codec_not_found' = 'codec_not_found';
  export const DECODE: 'decode' = 'decode';
  export const ENCODE: 'encode' = 'encode';
  export const DEMUX: 'demux' = 'demux';
  export const MUX: 'mux' = 'mux';
  export const FORMAT: 'format' = 'format';
  export const DECRYPT: 'decrypt' = 'decrypt';
  export const DECRYPT_NOKEY: 'decrypt_nokey' = 'decrypt_nokey';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/StreamError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStreamErrorValue = "failed" | "too_lazy" | "not_implemented" | "type_not_found" | "wrong_type" | "codec_not_found" | "decode" | "encode" | "demux" | "mux" | "format" | "decrypt" | "decrypt_nokey" | "num_errors";
export interface GstStreamPrivate {
  ptr: Pointer;
}
export type GstStreamStatusType = "create" | "enter" | "leave" | "destroy" | "start" | "pause" | "stop";
export type GstStructureChangeType = "link" | "unlink";
export interface GstSystemClockPrivate {
  ptr: Pointer;
}
export type GstTagFlag = "undefined" | "meta" | "encoded" | "decoded" | "count";
export type GstTagMergeMode = "undefined" | "replace_all" | "replace" | "append" | "prepend" | "keep" | "keep_all" | "count";
export type GstTagScope = "stream" | "global";
export interface GLibThread {
  ptr: Pointer;
}
export interface GLibRecMutex {
  ptr: Pointer;
}
export interface GstTaskPrivate {
  ptr: Pointer;
}
export interface GstTimedValue {
  ptr: Pointer;
}
export interface GstToc {
  ptr: Pointer;
}
export interface GstTocEntry {
  ptr: Pointer;
}
export namespace GstTocEntryType {
  export const ANGLE: 'angle' = 'angle';
  export const VERSION: 'version' = 'version';
  export const EDITION: 'edition' = 'edition';
  export const INVALID: 'invalid' = 'invalid';
  export const TITLE: 'title' = 'title';
  export const TRACK: 'track' = 'track';
  export const CHAPTER: 'chapter' = 'chapter';
  export async function get_nick(type_: GstTocEntryTypeValue): Promise<string> {
    const url = new URL(`/Gst/TocEntryType/get_nick`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTocEntryTypeValue = "angle" | "version" | "edition" | "invalid" | "title" | "track" | "chapter";
export type GstTocLoopType = "none" | "forward" | "reverse" | "ping_pong";
export type GstTocScope = "global" | "current";
export interface GstTracerPrivate {
  ptr: Pointer;
}
export type GstTracerValueFlags = "none" | "optional" | "aggregated";
export type GstTracerValueScope = "process" | "thread" | "element" | "pad";
export interface GstTypeFind {
  ptr: Pointer;
}
export type GstTypeFindProbability = "none" | "minimum" | "possible" | "likely" | "nearly_certain" | "maximum";
export namespace GstURIError {
  export const UNSUPPORTED_PROTOCOL: 'unsupported_protocol' = 'unsupported_protocol';
  export const BAD_URI: 'bad_uri' = 'bad_uri';
  export const BAD_STATE: 'bad_state' = 'bad_state';
  export const BAD_REFERENCE: 'bad_reference' = 'bad_reference';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/URIError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstURIErrorValue = "unsupported_protocol" | "bad_uri" | "bad_state" | "bad_reference";
export interface GstUri {
  ptr: Pointer;
}
export interface GstValueTable {
  ptr: Pointer;
}
export type GObjectParamFlags = "readable" | "writable" | "readwrite" | "construct" | "construct_only" | "lax_validation" | "static_name" | "private" | "static_nick" | "static_blurb" | "explicit_notify" | "deprecated";
export interface GObjectValueArray {
  ptr: Pointer;
}

export class GObjectObject {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      objectRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  unref(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    objectRegistry.unregister(this);
    return fetch(apiConfig.baseUrl + '/GObject/Object/' + this.ptr + '/unref')
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
  static async newv(object_type: Pointer, n_parameters: number, parameters: Pointer): Promise<GObjectObject> {
    const url = new URL(`/GObject/Object/newv`, apiConfig.baseUrl);
    url.searchParams.append('object_type', String(object_type));
    url.searchParams.append('n_parameters', String(n_parameters));
    url.searchParams.append('parameters', String(parameters));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectObject();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async compat_control(what: number): Promise<number> {
    const url = new URL(`/GObject/Object/compat_control`, apiConfig.baseUrl);
    url.searchParams.append('what', String(what));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async interface_find_property(g_iface: GObjectTypeInterface, property_name: string): Promise<GObjectParamSpec> {
    const url = new URL(`/GObject/Object/interface_find_property`, apiConfig.baseUrl);
    url.searchParams.append('g_iface', String(g_iface));
    url.searchParams.append('property_name', String(property_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async interface_install_property(g_iface: GObjectTypeInterface, pspec: GObjectParamSpec): Promise<void> {
    const url = new URL(`/GObject/Object/interface_install_property`, apiConfig.baseUrl);
    url.searchParams.append('g_iface', String(g_iface));
    url.searchParams.append('pspec', String(pspec));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async interface_list_properties(g_iface: GObjectTypeInterface): Promise<Pointer> {
    const url = new URL(`/GObject/Object/interface_list_properties`, apiConfig.baseUrl);
    url.searchParams.append('g_iface', String(g_iface));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async bind_property(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlags): Promise<GObjectBinding> {
    const url = new URL(`/GObject/Object/${this.ptr}/bind_property`, apiConfig.baseUrl);
    url.searchParams.append('source_property', String(source_property));
    url.searchParams.append('target', String(target));
    url.searchParams.append('target_property', String(target_property));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async bind_property_full(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlags, transform_to: GObjectClosure, transform_from: GObjectClosure): Promise<GObjectBinding> {
    const url = new URL(`/GObject/Object/${this.ptr}/bind_property_full`, apiConfig.baseUrl);
    url.searchParams.append('source_property', String(source_property));
    url.searchParams.append('target', String(target));
    url.searchParams.append('target_property', String(target_property));
    url.searchParams.append('flags', String(flags));
    url.searchParams.append('transform_to', String(transform_to));
    url.searchParams.append('transform_from', String(transform_from));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async force_floating(): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/force_floating`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async freeze_notify(): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/freeze_notify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_data(key: string): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/get_data`, apiConfig.baseUrl);
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_property(property_name: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/get_property`, apiConfig.baseUrl);
    url.searchParams.append('property_name', String(property_name));
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/get_qdata`, apiConfig.baseUrl);
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async getv(n_properties: number, names: Pointer, values: Pointer): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/getv`, apiConfig.baseUrl);
    url.searchParams.append('n_properties', String(n_properties));
    url.searchParams.append('names', String(names));
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_floating(): Promise<boolean> {
    const url = new URL(`/GObject/Object/${this.ptr}/is_floating`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async notify(property_name: string): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/notify`, apiConfig.baseUrl);
    url.searchParams.append('property_name', String(property_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async notify_by_pspec(pspec: GObjectParamSpec): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/notify_by_pspec`, apiConfig.baseUrl);
    url.searchParams.append('pspec', String(pspec));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Object/${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref_sink(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Object/${this.ptr}/ref_sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async run_dispose(): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/run_dispose`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_data(key: string): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/set_data`, apiConfig.baseUrl);
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_property(property_name: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/set_property`, apiConfig.baseUrl);
    url.searchParams.append('property_name', String(property_name));
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_data(key: string): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/steal_data`, apiConfig.baseUrl);
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async thaw_notify(): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/thaw_notify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async watch_closure(closure: GObjectClosure): Promise<void> {
    const url = new URL(`/GObject/Object/${this.ptr}/watch_closure`, apiConfig.baseUrl);
    url.searchParams.append('closure', String(closure));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GObjectParamSpec extends GObjectObject {

  async is_valid_name(name: string): Promise<boolean> {
    const url = new URL(`/GObject/ParamSpec/is_valid_name`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_blurb(): Promise<string> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/get_blurb`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_default_value(): Promise<GObjectValue> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/get_default_value`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name_quark(): Promise<number> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/get_name_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_nick(): Promise<string> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/get_nick`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/get_qdata`, apiConfig.baseUrl);
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_redirect_target(): Promise<GObjectParamSpec> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/get_redirect_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/set_qdata`, apiConfig.baseUrl);
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sink(): Promise<void> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/ParamSpec/${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GObjectBinding extends GObjectObject {

  async dup_source(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Binding/${this.ptr}/dup_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_target(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Binding/${this.ptr}/dup_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_flags(): Promise<GObjectBindingFlags> {
    const url = new URL(`/GObject/Binding/${this.ptr}/get_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_source(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Binding/${this.ptr}/get_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_source_property(): Promise<string> {
    const url = new URL(`/GObject/Binding/${this.ptr}/get_source_property`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_target(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Binding/${this.ptr}/get_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_target_property(): Promise<string> {
    const url = new URL(`/GObject/Binding/${this.ptr}/get_target_property`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unbind(): Promise<void> {
    const url = new URL(`/GObject/Binding/${this.ptr}/unbind`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstObject extends GObjectObject {

  async check_uniqueness(list: Pointer, name: string): Promise<boolean> {
    const url = new URL(`/Gst/Object/check_uniqueness`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async default_deep_notify(object: GObjectObject, orig: GstObject, pspec: GObjectParamSpec, excluded_props?: Pointer): Promise<void> {
    const url = new URL(`/Gst/Object/default_deep_notify`, apiConfig.baseUrl);
    url.searchParams.append('object', String(object));
    url.searchParams.append('orig', String(orig));
    url.searchParams.append('pspec', String(pspec));
    if (excluded_props !== undefined) url.searchParams.append('excluded_props', String(excluded_props));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace(oldobj?: GstObject, newobj?: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + oldobj.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Object/replace`, apiConfig.baseUrl);
    if (oldobj !== undefined) url.searchParams.append('oldobj', String(oldobj));
    if (newobj !== undefined) url.searchParams.append('newobj', String(newobj));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + oldobj.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + oldobj.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async add_control_binding(binding: GstControlBinding): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/add_control_binding`, apiConfig.baseUrl);
    url.searchParams.append('binding', String(binding));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async default_error(error_: Pointer, debug?: string): Promise<void> {
    const url = new URL(`/Gst/Object/${this.ptr}/default_error`, apiConfig.baseUrl);
    url.searchParams.append('error', String(error_));
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_control_binding(property_name: string): Promise<GstControlBinding> {
    const url = new URL(`/Gst/Object/${this.ptr}/get_control_binding`, apiConfig.baseUrl);
    url.searchParams.append('property_name', String(property_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_control_rate(): Promise<number> {
    const url = new URL(`/Gst/Object/${this.ptr}/get_control_rate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_g_value_array(property_name: string, timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/get_g_value_array`, apiConfig.baseUrl);
    url.searchParams.append('property_name', String(property_name));
    url.searchParams.append('timestamp', String(timestamp));
    url.searchParams.append('interval', String(interval));
    url.searchParams.append('n_values', String(n_values));
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`/Gst/Object/${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_parent(): Promise<GstObject> {
    const url = new URL(`/Gst/Object/${this.ptr}/get_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_path_string(): Promise<string> {
    const url = new URL(`/Gst/Object/${this.ptr}/get_path_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(property_name: string, timestamp: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/Object/${this.ptr}/get_value`, apiConfig.baseUrl);
    url.searchParams.append('property_name', String(property_name));
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_active_control_bindings(): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/has_active_control_bindings`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_ancestor(ancestor: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/has_ancestor`, apiConfig.baseUrl);
    url.searchParams.append('ancestor', String(ancestor));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_as_ancestor(ancestor: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/has_as_ancestor`, apiConfig.baseUrl);
    url.searchParams.append('ancestor', String(ancestor));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_as_parent(parent: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/has_as_parent`, apiConfig.baseUrl);
    url.searchParams.append('parent', String(parent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GstObject> {
    const url = new URL(`/Gst/Object/${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_control_binding(binding: GstControlBinding): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/remove_control_binding`, apiConfig.baseUrl);
    url.searchParams.append('binding', String(binding));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_control_binding_disabled(property_name: string, disabled: boolean): Promise<void> {
    const url = new URL(`/Gst/Object/${this.ptr}/set_control_binding_disabled`, apiConfig.baseUrl);
    url.searchParams.append('property_name', String(property_name));
    url.searchParams.append('disabled', String(disabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_control_bindings_disabled(disabled: boolean): Promise<void> {
    const url = new URL(`/Gst/Object/${this.ptr}/set_control_bindings_disabled`, apiConfig.baseUrl);
    url.searchParams.append('disabled', String(disabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_control_rate(control_rate: number): Promise<void> {
    const url = new URL(`/Gst/Object/${this.ptr}/set_control_rate`, apiConfig.baseUrl);
    url.searchParams.append('control_rate', String(control_rate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_name(name?: string): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/set_name`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_parent(parent: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/set_parent`, apiConfig.baseUrl);
    url.searchParams.append('parent', String(parent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async suggest_next_sync(): Promise<number> {
    const url = new URL(`/Gst/Object/${this.ptr}/suggest_next_sync`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async sync_values(timestamp: number): Promise<boolean> {
    const url = new URL(`/Gst/Object/${this.ptr}/sync_values`, apiConfig.baseUrl);
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unparent(): Promise<void> {
    const url = new URL(`/Gst/Object/${this.ptr}/unparent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`/Gst/Object/${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstControlBinding extends GObjectObject {

  async get_g_value_array(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/ControlBinding/${this.ptr}/get_g_value_array`, apiConfig.baseUrl);
    url.searchParams.append('timestamp', String(timestamp));
    url.searchParams.append('interval', String(interval));
    url.searchParams.append('n_values', String(n_values));
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(timestamp: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ControlBinding/${this.ptr}/get_value`, apiConfig.baseUrl);
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_disabled(): Promise<boolean> {
    const url = new URL(`/Gst/ControlBinding/${this.ptr}/is_disabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_disabled(disabled: boolean): Promise<void> {
    const url = new URL(`/Gst/ControlBinding/${this.ptr}/set_disabled`, apiConfig.baseUrl);
    url.searchParams.append('disabled', String(disabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sync_values(object: GstObject, timestamp: number, last_sync: number): Promise<boolean> {
    const url = new URL(`/Gst/ControlBinding/${this.ptr}/sync_values`, apiConfig.baseUrl);
    url.searchParams.append('object', String(object));
    url.searchParams.append('timestamp', String(timestamp));
    url.searchParams.append('last_sync', String(last_sync));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstAllocator extends GObjectObject {

  async find(name?: string): Promise<GstAllocator> {
    const url = new URL(`/Gst/Allocator/find`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async register(name: string, allocator: GstAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + allocator.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Allocator/register`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    url.searchParams.append('allocator', String(allocator));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async alloc(size: number, params?: GstAllocationParams): Promise<GstMemory> {
    const url = new URL(`/Gst/Allocator/${this.ptr}/alloc`, apiConfig.baseUrl);
    url.searchParams.append('size', String(size));
    if (params !== undefined) url.searchParams.append('params', String(params));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async free(memory: GstMemory): Promise<void> {
    const url = new URL(`/Gst/Allocator/${this.ptr}/free`, apiConfig.baseUrl);
    url.searchParams.append('memory', String(memory));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_default(): Promise<void> {
    const url = new URL(`/Gst/Allocator/${this.ptr}/set_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstElement extends GObjectObject {

  async make_from_uri(type_: GstURIType, uri: string, elementname?: string): Promise<GstElement> {
    const url = new URL(`/Gst/Element/make_from_uri`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    url.searchParams.append('uri', String(uri));
    if (elementname !== undefined) url.searchParams.append('elementname', String(elementname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async register(name: string, rank: number, type_: Pointer, plugin?: GstPlugin): Promise<boolean> {
    const url = new URL(`/Gst/Element/register`, apiConfig.baseUrl);
    if (plugin !== undefined) url.searchParams.append('plugin', String(plugin));
    url.searchParams.append('name', String(name));
    url.searchParams.append('rank', String(rank));
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async state_change_return_get_name(state_ret: GstStateChangeReturn): Promise<string> {
    const url = new URL(`/Gst/Element/state_change_return_get_name`, apiConfig.baseUrl);
    url.searchParams.append('state_ret', String(state_ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async state_get_name(state: GstState): Promise<string> {
    const url = new URL(`/Gst/Element/state_get_name`, apiConfig.baseUrl);
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async type_set_skip_documentation(type_: Pointer): Promise<void> {
    const url = new URL(`/Gst/Element/type_set_skip_documentation`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async abort_state(): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/abort_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_pad(pad: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/add_pad`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_property_deep_notify_watch(include_value: boolean, property_name?: string): Promise<number> {
    const url = new URL(`/Gst/Element/${this.ptr}/add_property_deep_notify_watch`, apiConfig.baseUrl);
    if (property_name !== undefined) url.searchParams.append('property_name', String(property_name));
    url.searchParams.append('include_value', String(include_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_property_notify_watch(include_value: boolean, property_name?: string): Promise<number> {
    const url = new URL(`/Gst/Element/${this.ptr}/add_property_notify_watch`, apiConfig.baseUrl);
    if (property_name !== undefined) url.searchParams.append('property_name', String(property_name));
    url.searchParams.append('include_value', String(include_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async call_async(func: (element: GstElement, user_data: Pointer) => void): Promise<{ func?: number }> {
    const url = new URL(`/Gst/Element/${this.ptr}/call_async`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async change_state(transition: GstStateChangeValue): Promise<GstStateChangeReturn> {
    const url = new URL(`/Gst/Element/${this.ptr}/change_state`, apiConfig.baseUrl);
    url.searchParams.append('transition', String(transition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async continue_state(ret: GstStateChangeReturn): Promise<GstStateChangeReturn> {
    const url = new URL(`/Gst/Element/${this.ptr}/continue_state`, apiConfig.baseUrl);
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_all_pads(): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/create_all_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async decorate_stream_id(stream_id: string): Promise<string> {
    const url = new URL(`/Gst/Element/${this.ptr}/decorate_stream_id`, apiConfig.baseUrl);
    url.searchParams.append('stream_id', String(stream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async foreach_pad(func: (element: GstElement, pad: GstPad, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/foreach_pad`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async foreach_sink_pad(func: (element: GstElement, pad: GstPad, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/foreach_sink_pad`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async foreach_src_pad(func: (element: GstElement, pad: GstPad, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/foreach_src_pad`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get_base_time(): Promise<number> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_base_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_clock(): Promise<GstClock> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_compatible_pad(pad: GstPad, caps?: GstCaps): Promise<GstPad> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_compatible_pad`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    if (caps !== undefined) url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_compatible_pad_template(compattempl: GstPadTemplate): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_compatible_pad_template`, apiConfig.baseUrl);
    url.searchParams.append('compattempl', String(compattempl));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_context(context_type: string): Promise<GstContext> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_context`, apiConfig.baseUrl);
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_context_unlocked(context_type: string): Promise<GstContext> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_context_unlocked`, apiConfig.baseUrl);
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_contexts(): Promise<Pointer> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_contexts`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_current_clock_time(): Promise<number> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_current_clock_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_current_running_time(): Promise<number> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_current_running_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_factory(): Promise<GstElementFactory> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_factory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_metadata`, apiConfig.baseUrl);
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pad_template(name: string): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_pad_template`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pad_template_list(): Promise<Pointer> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_pad_template_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_request_pad(name: string): Promise<GstPad> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_request_pad`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_start_time(): Promise<number> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_start_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_state(timeout: number): Promise<GstStateChangeReturn> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_state`, apiConfig.baseUrl);
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_static_pad(name: string): Promise<GstPad> {
    const url = new URL(`/Gst/Element/${this.ptr}/get_static_pad`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_locked_state(): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/is_locked_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_pads(): Promise<GstIterator> {
    const url = new URL(`/Gst/Element/${this.ptr}/iterate_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_sink_pads(): Promise<GstIterator> {
    const url = new URL(`/Gst/Element/${this.ptr}/iterate_sink_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_src_pads(): Promise<GstIterator> {
    const url = new URL(`/Gst/Element/${this.ptr}/iterate_src_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link(dest: GstElement): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/link`, apiConfig.baseUrl);
    url.searchParams.append('dest', String(dest));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_filtered(dest: GstElement, filter?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/link_filtered`, apiConfig.baseUrl);
    url.searchParams.append('dest', String(dest));
    if (filter !== undefined) url.searchParams.append('filter', String(filter));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_pads(dest: GstElement, srcpadname?: string, destpadname?: string): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/link_pads`, apiConfig.baseUrl);
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    url.searchParams.append('dest', String(dest));
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_pads_filtered(dest: GstElement, srcpadname?: string, destpadname?: string, filter?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/link_pads_filtered`, apiConfig.baseUrl);
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    url.searchParams.append('dest', String(dest));
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    if (filter !== undefined) url.searchParams.append('filter', String(filter));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_pads_full(dest: GstElement, flags: GstPadLinkCheck, srcpadname?: string, destpadname?: string): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/link_pads_full`, apiConfig.baseUrl);
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    url.searchParams.append('dest', String(dest));
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lost_state(): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/lost_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async message_full(type_: GstMessageTypeValue, domain: number, code: number, file: string, function_: string, line: number, text?: string, debug?: string): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/message_full`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    url.searchParams.append('domain', String(domain));
    url.searchParams.append('code', String(code));
    if (text !== undefined) url.searchParams.append('text', String(text));
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    url.searchParams.append('file', String(file));
    url.searchParams.append('function', String(function_));
    url.searchParams.append('line', String(line));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async message_full_with_details(type_: GstMessageTypeValue, domain: number, code: number, file: string, function_: string, line: number, structure: GstStructure, text?: string, debug?: string): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/message_full_with_details`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    url.searchParams.append('domain', String(domain));
    url.searchParams.append('code', String(code));
    if (text !== undefined) url.searchParams.append('text', String(text));
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    url.searchParams.append('file', String(file));
    url.searchParams.append('function', String(function_));
    url.searchParams.append('line', String(line));
    url.searchParams.append('structure', String(structure));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async no_more_pads(): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/no_more_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async post_message(message: GstMessage): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/post_message`, apiConfig.baseUrl);
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async provide_clock(): Promise<GstClock> {
    const url = new URL(`/Gst/Element/${this.ptr}/provide_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/query`, apiConfig.baseUrl);
    url.searchParams.append('query', String(query));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/query_convert`, apiConfig.baseUrl);
    url.searchParams.append('src_format', String(src_format));
    url.searchParams.append('src_val', String(src_val));
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_duration(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/query_duration`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_position(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/query_position`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async release_request_pad(pad: GstPad): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/release_request_pad`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_pad(pad: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/remove_pad`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_property_notify_watch(watch_id: number): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/remove_property_notify_watch`, apiConfig.baseUrl);
    url.searchParams.append('watch_id', String(watch_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async request_pad(templ: GstPadTemplate, name?: string, caps?: GstCaps): Promise<GstPad> {
    const url = new URL(`/Gst/Element/${this.ptr}/request_pad`, apiConfig.baseUrl);
    url.searchParams.append('templ', String(templ));
    if (name !== undefined) url.searchParams.append('name', String(name));
    if (caps !== undefined) url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async request_pad_simple(name: string): Promise<GstPad> {
    const url = new URL(`/Gst/Element/${this.ptr}/request_pad_simple`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async seek(rate: number, format: GstFormatValue, flags: GstSeekFlags, start_type: GstSeekType, start: number, stop_type: GstSeekType, stop: number): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/seek`, apiConfig.baseUrl);
    url.searchParams.append('rate', String(rate));
    url.searchParams.append('format', String(format));
    url.searchParams.append('flags', String(flags));
    url.searchParams.append('start_type', String(start_type));
    url.searchParams.append('start', String(start));
    url.searchParams.append('stop_type', String(stop_type));
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async seek_simple(format: GstFormatValue, seek_flags: GstSeekFlags, seek_pos: number): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/seek_simple`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    url.searchParams.append('seek_flags', String(seek_flags));
    url.searchParams.append('seek_pos', String(seek_pos));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async send_event(event: GstEvent): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/send_event`, apiConfig.baseUrl);
    url.searchParams.append('event', String(event));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_base_time(time: number): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/set_base_time`, apiConfig.baseUrl);
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_bus(bus?: GstBus): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/set_bus`, apiConfig.baseUrl);
    if (bus !== undefined) url.searchParams.append('bus', String(bus));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_clock(clock?: GstClock): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/set_clock`, apiConfig.baseUrl);
    if (clock !== undefined) url.searchParams.append('clock', String(clock));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_context(context: GstContext): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/set_context`, apiConfig.baseUrl);
    url.searchParams.append('context', String(context));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_locked_state(locked_state: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/set_locked_state`, apiConfig.baseUrl);
    url.searchParams.append('locked_state', String(locked_state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_start_time(time: number): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/set_start_time`, apiConfig.baseUrl);
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_state(state: GstState): Promise<GstStateChangeReturn> {
    const url = new URL(`/Gst/Element/${this.ptr}/set_state`, apiConfig.baseUrl);
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async sync_state_with_parent(): Promise<boolean> {
    const url = new URL(`/Gst/Element/${this.ptr}/sync_state_with_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unlink(dest: GstElement): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/unlink`, apiConfig.baseUrl);
    url.searchParams.append('dest', String(dest));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unlink_pads(srcpadname: string, dest: GstElement, destpadname: string): Promise<void> {
    const url = new URL(`/Gst/Element/${this.ptr}/unlink_pads`, apiConfig.baseUrl);
    url.searchParams.append('srcpadname', String(srcpadname));
    url.searchParams.append('dest', String(dest));
    url.searchParams.append('destpadname', String(destpadname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstPlugin extends GObjectObject {

  async list_free(list: Pointer): Promise<void> {
    const url = new URL(`/Gst/Plugin/list_free`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async load_by_name(name: string): Promise<GstPlugin> {
    const url = new URL(`/Gst/Plugin/load_by_name`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load_file(filename: Pointer): Promise<GstPlugin> {
    const url = new URL(`/Gst/Plugin/load_file`, apiConfig.baseUrl);
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async register_static(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package_: string, origin: string, init_func: (plugin: GstPlugin) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Plugin/register_static`, apiConfig.baseUrl);
    url.searchParams.append('major_version', String(major_version));
    url.searchParams.append('minor_version', String(minor_version));
    url.searchParams.append('name', String(name));
    url.searchParams.append('description', String(description));
    url.searchParams.append('version', String(version));
    url.searchParams.append('license', String(license));
    url.searchParams.append('source', String(source));
    url.searchParams.append('package', String(package_));
    url.searchParams.append('origin', String(origin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.init_func !== undefined) {
      callbackDispatcher.set(data.init_func.toString(), init_func);
    }
    return data.return;
  }
  async register_static_full(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package_: string, origin: string, init_full_func: (plugin: GstPlugin, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Plugin/register_static_full`, apiConfig.baseUrl);
    url.searchParams.append('major_version', String(major_version));
    url.searchParams.append('minor_version', String(minor_version));
    url.searchParams.append('name', String(name));
    url.searchParams.append('description', String(description));
    url.searchParams.append('version', String(version));
    url.searchParams.append('license', String(license));
    url.searchParams.append('source', String(source));
    url.searchParams.append('package', String(package_));
    url.searchParams.append('origin', String(origin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.init_full_func !== undefined) {
      callbackDispatcher.set(data.init_full_func.toString(), init_full_func);
    }
    return data.return;
  }
  async add_dependency(flags: GstPluginDependencyFlags, env_vars?: Pointer, paths?: Pointer, names?: Pointer): Promise<void> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/add_dependency`, apiConfig.baseUrl);
    if (env_vars !== undefined) url.searchParams.append('env_vars', String(env_vars));
    if (paths !== undefined) url.searchParams.append('paths', String(paths));
    if (names !== undefined) url.searchParams.append('names', String(names));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_dependency_simple(flags: GstPluginDependencyFlags, env_vars?: string, paths?: string, names?: string): Promise<void> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/add_dependency_simple`, apiConfig.baseUrl);
    if (env_vars !== undefined) url.searchParams.append('env_vars', String(env_vars));
    if (paths !== undefined) url.searchParams.append('paths', String(paths));
    if (names !== undefined) url.searchParams.append('names', String(names));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_status_error(message: string): Promise<void> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/add_status_error`, apiConfig.baseUrl);
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_status_info(message: string): Promise<void> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/add_status_info`, apiConfig.baseUrl);
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_status_warning(message: string): Promise<void> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/add_status_warning`, apiConfig.baseUrl);
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_cache_data(): Promise<GstStructure> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_cache_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_description(): Promise<string> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_description`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_filename(): Promise<Pointer> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_filename`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_license(): Promise<string> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_license`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_origin(): Promise<string> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_origin`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_package(): Promise<string> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_package`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_release_date_string(): Promise<string> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_release_date_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_source(): Promise<string> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_status_errors(): Promise<Pointer> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_status_errors`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_status_infos(): Promise<Pointer> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_status_infos`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_status_warnings(): Promise<Pointer> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_status_warnings`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_version(): Promise<string> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/get_version`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_loaded(): Promise<boolean> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/is_loaded`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load(): Promise<GstPlugin> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/load`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_cache_data(cache_data: GstStructure): Promise<void> {
    const url = new URL(`/Gst/Plugin/${this.ptr}/set_cache_data`, apiConfig.baseUrl);
    url.searchParams.append('cache_data', String(cache_data));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstPadTemplate extends GObjectObject {
  static async new(name_template: string, direction: GstPadDirection, presence: GstPadPresence, caps: GstCaps): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/PadTemplate/new`, apiConfig.baseUrl);
    url.searchParams.append('name_template', String(name_template));
    url.searchParams.append('direction', String(direction));
    url.searchParams.append('presence', String(presence));
    url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_static_pad_template_with_gtype(pad_template: GstStaticPadTemplate, pad_type: Pointer): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/PadTemplate/new_from_static_pad_template_with_gtype`, apiConfig.baseUrl);
    url.searchParams.append('pad_template', String(pad_template));
    url.searchParams.append('pad_type', String(pad_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_with_gtype(name_template: string, direction: GstPadDirection, presence: GstPadPresence, caps: GstCaps, pad_type: Pointer): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/PadTemplate/new_with_gtype`, apiConfig.baseUrl);
    url.searchParams.append('name_template', String(name_template));
    url.searchParams.append('direction', String(direction));
    url.searchParams.append('presence', String(presence));
    url.searchParams.append('caps', String(caps));
    url.searchParams.append('pad_type', String(pad_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/PadTemplate/${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_documentation_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/PadTemplate/${this.ptr}/get_documentation_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pad_created(pad: GstPad): Promise<void> {
    const url = new URL(`/Gst/PadTemplate/${this.ptr}/pad_created`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_documentation_caps(caps: GstCaps): Promise<void> {
    const url = new URL(`/Gst/PadTemplate/${this.ptr}/set_documentation_caps`, apiConfig.baseUrl);
    url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstPad extends GObjectObject {
  static async new(direction: GstPadDirection, name?: string): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/new`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    url.searchParams.append('direction', String(direction));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_static_template(templ: GstStaticPadTemplate, name: string): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/new_from_static_template`, apiConfig.baseUrl);
    url.searchParams.append('templ', String(templ));
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_template(templ: GstPadTemplate, name?: string): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/new_from_template`, apiConfig.baseUrl);
    url.searchParams.append('templ', String(templ));
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPad();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async link_get_name(ret: GstPadLinkReturn): Promise<string> {
    const url = new URL(`/Gst/Pad/link_get_name`, apiConfig.baseUrl);
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async activate_mode(mode: GstPadModeValue, active: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/activate_mode`, apiConfig.baseUrl);
    url.searchParams.append('mode', String(mode));
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_probe(mask: GstPadProbeType, callback: (pad: GstPad, info: GstPadProbeInfo, user_data: Pointer) => GstPadProbeReturn): Promise<number> {
    const url = new URL(`/Gst/Pad/${this.ptr}/add_probe`, apiConfig.baseUrl);
    url.searchParams.append('mask', String(mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.callback !== undefined) {
      callbackDispatcher.set(data.callback.toString(), callback);
    }
    return data.return;
  }
  async can_link(sinkpad: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/can_link`, apiConfig.baseUrl);
    url.searchParams.append('sinkpad', String(sinkpad));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async chain(buffer: GstBuffer): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/chain`, apiConfig.baseUrl);
    url.searchParams.append('buffer', String(buffer));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async chain_list(list: GstBufferList): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/chain_list`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async check_reconfigure(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/check_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_stream_id(parent: GstElement, stream_id?: string): Promise<string> {
    const url = new URL(`/Gst/Pad/${this.ptr}/create_stream_id`, apiConfig.baseUrl);
    url.searchParams.append('parent', String(parent));
    if (stream_id !== undefined) url.searchParams.append('stream_id', String(stream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async event_default(event: GstEvent, parent?: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/event_default`, apiConfig.baseUrl);
    if (parent !== undefined) url.searchParams.append('parent', String(parent));
    url.searchParams.append('event', String(event));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async forward(forward: (pad: GstPad, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/forward`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.forward !== undefined) {
      callbackDispatcher.set(data.forward.toString(), forward);
    }
    return data.return;
  }
  async get_allowed_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_allowed_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_current_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_current_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_direction(): Promise<GstPadDirection> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_direction`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_element_private(): Promise<void> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_element_private`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_last_flow_return(): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_last_flow_return`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_offset(): Promise<number> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pad_template(): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_pad_template`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pad_template_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_pad_template_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_parent_element(): Promise<GstElement> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_parent_element`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_peer(): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_peer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_range(offset: number, size: number): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_range`, apiConfig.baseUrl);
    url.searchParams.append('offset', String(offset));
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_single_internal_link(): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_single_internal_link`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sticky_event(event_type: GstEventTypeValue, idx: number): Promise<GstEvent> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_sticky_event`, apiConfig.baseUrl);
    url.searchParams.append('event_type', String(event_type));
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream(): Promise<GstStream> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_stream`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_id(): Promise<string> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_stream_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_task_state(): Promise<GstTaskState> {
    const url = new URL(`/Gst/Pad/${this.ptr}/get_task_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_current_caps(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/has_current_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_active(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_blocked(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/is_blocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_blocking(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/is_blocking`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_linked(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/is_linked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_internal_links(): Promise<GstIterator> {
    const url = new URL(`/Gst/Pad/${this.ptr}/iterate_internal_links`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_internal_links_default(parent?: GstObject): Promise<GstIterator> {
    const url = new URL(`/Gst/Pad/${this.ptr}/iterate_internal_links_default`, apiConfig.baseUrl);
    if (parent !== undefined) url.searchParams.append('parent', String(parent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link(sinkpad: GstPad): Promise<GstPadLinkReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/link`, apiConfig.baseUrl);
    url.searchParams.append('sinkpad', String(sinkpad));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_full(sinkpad: GstPad, flags: GstPadLinkCheck): Promise<GstPadLinkReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/link_full`, apiConfig.baseUrl);
    url.searchParams.append('sinkpad', String(sinkpad));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_maybe_ghosting(sink: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/link_maybe_ghosting`, apiConfig.baseUrl);
    url.searchParams.append('sink', String(sink));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_maybe_ghosting_full(sink: GstPad, flags: GstPadLinkCheck): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/link_maybe_ghosting_full`, apiConfig.baseUrl);
    url.searchParams.append('sink', String(sink));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async mark_reconfigure(): Promise<void> {
    const url = new URL(`/Gst/Pad/${this.ptr}/mark_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async needs_reconfigure(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/needs_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pause_task(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/pause_task`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/peer_query`, apiConfig.baseUrl);
    url.searchParams.append('query', String(query));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_accept_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/peer_query_accept_caps`, apiConfig.baseUrl);
    url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_caps(filter?: GstCaps): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/${this.ptr}/peer_query_caps`, apiConfig.baseUrl);
    if (filter !== undefined) url.searchParams.append('filter', String(filter));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/peer_query_convert`, apiConfig.baseUrl);
    url.searchParams.append('src_format', String(src_format));
    url.searchParams.append('src_val', String(src_val));
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_duration(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/peer_query_duration`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_position(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/peer_query_position`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async proxy_query_accept_caps(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/proxy_query_accept_caps`, apiConfig.baseUrl);
    url.searchParams.append('query', String(query));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async proxy_query_caps(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/proxy_query_caps`, apiConfig.baseUrl);
    url.searchParams.append('query', String(query));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pull_range(offset: number, size: number): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/pull_range`, apiConfig.baseUrl);
    url.searchParams.append('offset', String(offset));
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push(buffer: GstBuffer): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/push`, apiConfig.baseUrl);
    url.searchParams.append('buffer', String(buffer));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push_event(event: GstEvent): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/push_event`, apiConfig.baseUrl);
    url.searchParams.append('event', String(event));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push_list(list: GstBufferList): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/push_list`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/query`, apiConfig.baseUrl);
    url.searchParams.append('query', String(query));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_accept_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/query_accept_caps`, apiConfig.baseUrl);
    url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_caps(filter?: GstCaps): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/${this.ptr}/query_caps`, apiConfig.baseUrl);
    if (filter !== undefined) url.searchParams.append('filter', String(filter));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/query_convert`, apiConfig.baseUrl);
    url.searchParams.append('src_format', String(src_format));
    url.searchParams.append('src_val', String(src_val));
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_default(query: GstQuery, parent?: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/query_default`, apiConfig.baseUrl);
    if (parent !== undefined) url.searchParams.append('parent', String(parent));
    url.searchParams.append('query', String(query));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_duration(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/query_duration`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_position(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/query_position`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_probe(id: number): Promise<void> {
    const url = new URL(`/Gst/Pad/${this.ptr}/remove_probe`, apiConfig.baseUrl);
    url.searchParams.append('id', String(id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async send_event(event: GstEvent): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/send_event`, apiConfig.baseUrl);
    url.searchParams.append('event', String(event));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_activate_function_full(activate: (pad: GstPad, parent: GstObject) => boolean): Promise<{ activate?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_activate_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.activate !== undefined) {
      callbackDispatcher.set(data.activate.toString(), activate);
    }
    return data;
  }
  async set_activatemode_function_full(activatemode: (pad: GstPad, parent: GstObject, mode: GstPadModeValue, active: boolean) => boolean): Promise<{ activatemode?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_activatemode_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.activatemode !== undefined) {
      callbackDispatcher.set(data.activatemode.toString(), activatemode);
    }
    return data;
  }
  async set_active(active: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_active`, apiConfig.baseUrl);
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_chain_function_full(chain: (pad: GstPad, parent: GstObject, buffer: GstBuffer) => GstFlowReturn): Promise<{ chain?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_chain_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.chain !== undefined) {
      callbackDispatcher.set(data.chain.toString(), chain);
    }
    return data;
  }
  async set_chain_list_function_full(chainlist: (pad: GstPad, parent: GstObject, list: GstBufferList) => GstFlowReturn): Promise<{ chainlist?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_chain_list_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.chainlist !== undefined) {
      callbackDispatcher.set(data.chainlist.toString(), chainlist);
    }
    return data;
  }
  async set_element_private(): Promise<void> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_element_private`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_event_full_function_full(event: (pad: GstPad, parent: GstObject, event: GstEvent) => GstFlowReturn): Promise<{ event?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_event_full_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.event !== undefined) {
      callbackDispatcher.set(data.event.toString(), event);
    }
    return data;
  }
  async set_event_function_full(event: (pad: GstPad, parent: GstObject, event: GstEvent) => boolean): Promise<{ event?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_event_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.event !== undefined) {
      callbackDispatcher.set(data.event.toString(), event);
    }
    return data;
  }
  async set_getrange_function_full(get: (pad: GstPad, parent: GstObject, offset: number, length: number, buffer: GstBuffer) => GstFlowReturn): Promise<{ get?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_getrange_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.get !== undefined) {
      callbackDispatcher.set(data.get.toString(), get);
    }
    return data;
  }
  async set_iterate_internal_links_function_full(iterintlink: (pad: GstPad, parent: GstObject) => GstIterator): Promise<{ iterintlink?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_iterate_internal_links_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.iterintlink !== undefined) {
      callbackDispatcher.set(data.iterintlink.toString(), iterintlink);
    }
    return data;
  }
  async set_link_function_full(link: (pad: GstPad, parent: GstObject, peer: GstPad) => GstPadLinkReturn): Promise<{ link?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_link_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.link !== undefined) {
      callbackDispatcher.set(data.link.toString(), link);
    }
    return data;
  }
  async set_offset(offset: number): Promise<void> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_offset`, apiConfig.baseUrl);
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_query_function_full(query: (pad: GstPad, parent: GstObject, query: GstQuery) => boolean): Promise<{ query?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_query_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.query !== undefined) {
      callbackDispatcher.set(data.query.toString(), query);
    }
    return data;
  }
  async set_unlink_function_full(unlink: (pad: GstPad, parent: GstObject) => void): Promise<{ unlink?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/set_unlink_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.unlink !== undefined) {
      callbackDispatcher.set(data.unlink.toString(), unlink);
    }
    return data;
  }
  async start_task(func: (user_data: Pointer) => void): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/start_task`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async sticky_events_foreach(foreach_func: (pad: GstPad, event: GstEvent, user_data: Pointer) => boolean): Promise<{ foreach_func?: number }> {
    const url = new URL(`/Gst/Pad/${this.ptr}/sticky_events_foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.foreach_func !== undefined) {
      callbackDispatcher.set(data.foreach_func.toString(), foreach_func);
    }
    return data;
  }
  async stop_task(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/stop_task`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async store_sticky_event(event: GstEvent): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/${this.ptr}/store_sticky_event`, apiConfig.baseUrl);
    url.searchParams.append('event', String(event));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unlink(sinkpad: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Pad/${this.ptr}/unlink`, apiConfig.baseUrl);
    url.searchParams.append('sinkpad', String(sinkpad));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async use_fixed_caps(): Promise<void> {
    const url = new URL(`/Gst/Pad/${this.ptr}/use_fixed_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstStream extends GObjectObject {
  static async new(type_: GstStreamTypeValue, flags: GstStreamFlags, stream_id?: string, caps?: GstCaps): Promise<GstStream> {
    const url = new URL(`/Gst/Stream/new`, apiConfig.baseUrl);
    if (stream_id !== undefined) url.searchParams.append('stream_id', String(stream_id));
    if (caps !== undefined) url.searchParams.append('caps', String(caps));
    url.searchParams.append('type', String(type_));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStream();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Stream/${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_flags(): Promise<GstStreamFlags> {
    const url = new URL(`/Gst/Stream/${this.ptr}/get_stream_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_id(): Promise<string> {
    const url = new URL(`/Gst/Stream/${this.ptr}/get_stream_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_type(): Promise<GstStreamTypeValue> {
    const url = new URL(`/Gst/Stream/${this.ptr}/get_stream_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tags(): Promise<GstTagList> {
    const url = new URL(`/Gst/Stream/${this.ptr}/get_tags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_caps(caps?: GstCaps): Promise<void> {
    const url = new URL(`/Gst/Stream/${this.ptr}/set_caps`, apiConfig.baseUrl);
    if (caps !== undefined) url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_flags(flags: GstStreamFlags): Promise<void> {
    const url = new URL(`/Gst/Stream/${this.ptr}/set_stream_flags`, apiConfig.baseUrl);
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_type(stream_type: GstStreamTypeValue): Promise<void> {
    const url = new URL(`/Gst/Stream/${this.ptr}/set_stream_type`, apiConfig.baseUrl);
    url.searchParams.append('stream_type', String(stream_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_tags(tags?: GstTagList): Promise<void> {
    const url = new URL(`/Gst/Stream/${this.ptr}/set_tags`, apiConfig.baseUrl);
    if (tags !== undefined) url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstBus extends GObjectObject {
  static async new(): Promise<GstBus> {
    const url = new URL(`/Gst/Bus/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBus();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_signal_watch(): Promise<void> {
    const url = new URL(`/Gst/Bus/${this.ptr}/add_signal_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_signal_watch_full(priority: number): Promise<void> {
    const url = new URL(`/Gst/Bus/${this.ptr}/add_signal_watch_full`, apiConfig.baseUrl);
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_watch(priority: number, func: (bus: GstBus, message: GstMessage, user_data: Pointer) => boolean): Promise<number> {
    const url = new URL(`/Gst/Bus/${this.ptr}/add_watch`, apiConfig.baseUrl);
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async async_signal_func(message: GstMessage): Promise<boolean> {
    const url = new URL(`/Gst/Bus/${this.ptr}/async_signal_func`, apiConfig.baseUrl);
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_watch(): Promise<GLibSource> {
    const url = new URL(`/Gst/Bus/${this.ptr}/create_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async disable_sync_message_emission(): Promise<void> {
    const url = new URL(`/Gst/Bus/${this.ptr}/disable_sync_message_emission`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async enable_sync_message_emission(): Promise<void> {
    const url = new URL(`/Gst/Bus/${this.ptr}/enable_sync_message_emission`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_pollfd(): Promise<{ fd?: GLibPollFD }> {
    const url = new URL(`/Gst/Bus/${this.ptr}/get_pollfd`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async have_pending(): Promise<boolean> {
    const url = new URL(`/Gst/Bus/${this.ptr}/have_pending`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek(): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/${this.ptr}/peek`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async poll(events: GstMessageTypeValue, timeout: number): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/${this.ptr}/poll`, apiConfig.baseUrl);
    url.searchParams.append('events', String(events));
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pop(): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/${this.ptr}/pop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pop_filtered(types: GstMessageTypeValue): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/${this.ptr}/pop_filtered`, apiConfig.baseUrl);
    url.searchParams.append('types', String(types));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async post(message: GstMessage): Promise<boolean> {
    const url = new URL(`/Gst/Bus/${this.ptr}/post`, apiConfig.baseUrl);
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_signal_watch(): Promise<void> {
    const url = new URL(`/Gst/Bus/${this.ptr}/remove_signal_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_watch(): Promise<boolean> {
    const url = new URL(`/Gst/Bus/${this.ptr}/remove_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flushing(flushing: boolean): Promise<void> {
    const url = new URL(`/Gst/Bus/${this.ptr}/set_flushing`, apiConfig.baseUrl);
    url.searchParams.append('flushing', String(flushing));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_sync_handler(func: (bus: GstBus, message: GstMessage, user_data: Pointer) => GstBusSyncReply): Promise<{ func?: number }> {
    const url = new URL(`/Gst/Bus/${this.ptr}/set_sync_handler`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async sync_signal_handler(message: GstMessage): Promise<GstBusSyncReply> {
    const url = new URL(`/Gst/Bus/${this.ptr}/sync_signal_handler`, apiConfig.baseUrl);
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async timed_pop(timeout: number): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/${this.ptr}/timed_pop`, apiConfig.baseUrl);
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async timed_pop_filtered(timeout: number, types: GstMessageTypeValue): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/${this.ptr}/timed_pop_filtered`, apiConfig.baseUrl);
    url.searchParams.append('timeout', String(timeout));
    url.searchParams.append('types', String(types));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstClock extends GObjectObject {

  async id_compare_func(): Promise<number> {
    const url = new URL(`/Gst/Clock/id_compare_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_get_clock(): Promise<GstClock> {
    const url = new URL(`/Gst/Clock/id_get_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_get_time(): Promise<number> {
    const url = new URL(`/Gst/Clock/id_get_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_ref(): Promise<void> {
    const url = new URL(`/Gst/Clock/id_ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async id_unref(): Promise<void> {
    const url = new URL(`/Gst/Clock/id_unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async id_unschedule(): Promise<void> {
    const url = new URL(`/Gst/Clock/id_unschedule`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async id_uses_clock(clock: GstClock): Promise<boolean> {
    const url = new URL(`/Gst/Clock/id_uses_clock`, apiConfig.baseUrl);
    url.searchParams.append('clock', String(clock));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_wait(): Promise<GstClockReturn> {
    const url = new URL(`/Gst/Clock/id_wait`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_wait_async(func: (clock: GstClock, time: number, id: Pointer, user_data: Pointer) => boolean): Promise<GstClockReturn> {
    const url = new URL(`/Gst/Clock/id_wait_async`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async add_observation(slave: number, master: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/${this.ptr}/add_observation`, apiConfig.baseUrl);
    url.searchParams.append('slave', String(slave));
    url.searchParams.append('master', String(master));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_observation_unapplied(slave: number, master: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/${this.ptr}/add_observation_unapplied`, apiConfig.baseUrl);
    url.searchParams.append('slave', String(slave));
    url.searchParams.append('master', String(master));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async adjust_unlocked(internal: number): Promise<number> {
    const url = new URL(`/Gst/Clock/${this.ptr}/adjust_unlocked`, apiConfig.baseUrl);
    url.searchParams.append('internal', String(internal));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async adjust_with_calibration(internal_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number> {
    const url = new URL(`/Gst/Clock/${this.ptr}/adjust_with_calibration`, apiConfig.baseUrl);
    url.searchParams.append('internal_target', String(internal_target));
    url.searchParams.append('cinternal', String(cinternal));
    url.searchParams.append('cexternal', String(cexternal));
    url.searchParams.append('cnum', String(cnum));
    url.searchParams.append('cdenom', String(cdenom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_calibration(): Promise<{ internal?: number; external?: number; rate_num?: number; rate_denom?: number }> {
    const url = new URL(`/Gst/Clock/${this.ptr}/get_calibration`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async get_internal_time(): Promise<number> {
    const url = new URL(`/Gst/Clock/${this.ptr}/get_internal_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_master(): Promise<GstClock> {
    const url = new URL(`/Gst/Clock/${this.ptr}/get_master`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_resolution(): Promise<number> {
    const url = new URL(`/Gst/Clock/${this.ptr}/get_resolution`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_time(): Promise<number> {
    const url = new URL(`/Gst/Clock/${this.ptr}/get_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_timeout(): Promise<number> {
    const url = new URL(`/Gst/Clock/${this.ptr}/get_timeout`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_synced(): Promise<boolean> {
    const url = new URL(`/Gst/Clock/${this.ptr}/is_synced`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async new_periodic_id(start_time: number, interval: number): Promise<void> {
    const url = new URL(`/Gst/Clock/${this.ptr}/new_periodic_id`, apiConfig.baseUrl);
    url.searchParams.append('start_time', String(start_time));
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async new_single_shot_id(time: number): Promise<void> {
    const url = new URL(`/Gst/Clock/${this.ptr}/new_single_shot_id`, apiConfig.baseUrl);
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async periodic_id_reinit(start_time: number, interval: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/${this.ptr}/periodic_id_reinit`, apiConfig.baseUrl);
    url.searchParams.append('start_time', String(start_time));
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_calibration(internal: number, external: number, rate_num: number, rate_denom: number): Promise<void> {
    const url = new URL(`/Gst/Clock/${this.ptr}/set_calibration`, apiConfig.baseUrl);
    url.searchParams.append('internal', String(internal));
    url.searchParams.append('external', String(external));
    url.searchParams.append('rate_num', String(rate_num));
    url.searchParams.append('rate_denom', String(rate_denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_master(master?: GstClock): Promise<boolean> {
    const url = new URL(`/Gst/Clock/${this.ptr}/set_master`, apiConfig.baseUrl);
    if (master !== undefined) url.searchParams.append('master', String(master));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_resolution(resolution: number): Promise<number> {
    const url = new URL(`/Gst/Clock/${this.ptr}/set_resolution`, apiConfig.baseUrl);
    url.searchParams.append('resolution', String(resolution));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_synced(synced: boolean): Promise<void> {
    const url = new URL(`/Gst/Clock/${this.ptr}/set_synced`, apiConfig.baseUrl);
    url.searchParams.append('synced', String(synced));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_timeout(timeout: number): Promise<void> {
    const url = new URL(`/Gst/Clock/${this.ptr}/set_timeout`, apiConfig.baseUrl);
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async single_shot_id_reinit(time: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/${this.ptr}/single_shot_id_reinit`, apiConfig.baseUrl);
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unadjust_unlocked(external: number): Promise<number> {
    const url = new URL(`/Gst/Clock/${this.ptr}/unadjust_unlocked`, apiConfig.baseUrl);
    url.searchParams.append('external', String(external));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unadjust_with_calibration(external_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number> {
    const url = new URL(`/Gst/Clock/${this.ptr}/unadjust_with_calibration`, apiConfig.baseUrl);
    url.searchParams.append('external_target', String(external_target));
    url.searchParams.append('cinternal', String(cinternal));
    url.searchParams.append('cexternal', String(cexternal));
    url.searchParams.append('cnum', String(cnum));
    url.searchParams.append('cdenom', String(cdenom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async wait_for_sync(timeout: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/${this.ptr}/wait_for_sync`, apiConfig.baseUrl);
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstPluginFeature extends GObjectObject {

  async list_copy(list: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/PluginFeature/list_copy`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_debug(list: Pointer): Promise<void> {
    const url = new URL(`/Gst/PluginFeature/list_debug`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async list_free(list: Pointer): Promise<void> {
    const url = new URL(`/Gst/PluginFeature/list_free`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async rank_compare_func(): Promise<number> {
    const url = new URL(`/Gst/PluginFeature/rank_compare_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async check_version(min_major: number, min_minor: number, min_micro: number): Promise<boolean> {
    const url = new URL(`/Gst/PluginFeature/${this.ptr}/check_version`, apiConfig.baseUrl);
    url.searchParams.append('min_major', String(min_major));
    url.searchParams.append('min_minor', String(min_minor));
    url.searchParams.append('min_micro', String(min_micro));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_plugin(): Promise<GstPlugin> {
    const url = new URL(`/Gst/PluginFeature/${this.ptr}/get_plugin`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_plugin_name(): Promise<string> {
    const url = new URL(`/Gst/PluginFeature/${this.ptr}/get_plugin_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_rank(): Promise<number> {
    const url = new URL(`/Gst/PluginFeature/${this.ptr}/get_rank`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load(): Promise<GstPluginFeature> {
    const url = new URL(`/Gst/PluginFeature/${this.ptr}/load`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_rank(rank: number): Promise<void> {
    const url = new URL(`/Gst/PluginFeature/${this.ptr}/set_rank`, apiConfig.baseUrl);
    url.searchParams.append('rank', String(rank));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstElementFactory extends GObjectObject {

  async find(name: string): Promise<GstElementFactory> {
    const url = new URL(`/Gst/ElementFactory/find`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_filter(list: Pointer, caps: GstCaps, direction: GstPadDirection, subsetonly: boolean): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/list_filter`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    url.searchParams.append('caps', String(caps));
    url.searchParams.append('direction', String(direction));
    url.searchParams.append('subsetonly', String(subsetonly));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_get_elements(type_: number, minrank: GstRank): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/list_get_elements`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    url.searchParams.append('minrank', String(minrank));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async make(factoryname: string, name?: string): Promise<GstElement> {
    const url = new URL(`/Gst/ElementFactory/make`, apiConfig.baseUrl);
    url.searchParams.append('factoryname', String(factoryname));
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async make_with_properties(factoryname: string, n: number, names?: Pointer, values?: Pointer): Promise<GstElement> {
    const url = new URL(`/Gst/ElementFactory/make_with_properties`, apiConfig.baseUrl);
    url.searchParams.append('factoryname', String(factoryname));
    url.searchParams.append('n', String(n));
    if (names !== undefined) url.searchParams.append('names', String(names));
    if (values !== undefined) url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_sink_all_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/can_sink_all_caps`, apiConfig.baseUrl);
    url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_sink_any_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/can_sink_any_caps`, apiConfig.baseUrl);
    url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_src_all_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/can_src_all_caps`, apiConfig.baseUrl);
    url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_src_any_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/can_src_any_caps`, apiConfig.baseUrl);
    url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create(name?: string): Promise<GstElement> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/create`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_with_properties(n: number, names?: Pointer, values?: Pointer): Promise<GstElement> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/create_with_properties`, apiConfig.baseUrl);
    url.searchParams.append('n', String(n));
    if (names !== undefined) url.searchParams.append('names', String(names));
    if (values !== undefined) url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_element_type(): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/get_element_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/get_metadata`, apiConfig.baseUrl);
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata_keys(): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/get_metadata_keys`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_num_pad_templates(): Promise<number> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/get_num_pad_templates`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_skip_documentation(): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/get_skip_documentation`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_static_pad_templates(): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/get_static_pad_templates`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uri_protocols(): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/get_uri_protocols`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uri_type(): Promise<GstURIType> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/get_uri_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_interface(interfacename: string): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/has_interface`, apiConfig.baseUrl);
    url.searchParams.append('interfacename', String(interfacename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_is_type(type_: number): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/${this.ptr}/list_is_type`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstBin extends GObjectObject {
  static async new(name?: string): Promise<GstBin> {
    const url = new URL(`/Gst/Bin/new`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBin();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(element: GstElement): Promise<boolean> {
    const url = new URL(`/Gst/Bin/${this.ptr}/add`, apiConfig.baseUrl);
    url.searchParams.append('element', String(element));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async find_unlinked_pad(direction: GstPadDirection): Promise<GstPad> {
    const url = new URL(`/Gst/Bin/${this.ptr}/find_unlinked_pad`, apiConfig.baseUrl);
    url.searchParams.append('direction', String(direction));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_by_interface(iface: Pointer): Promise<GstElement> {
    const url = new URL(`/Gst/Bin/${this.ptr}/get_by_interface`, apiConfig.baseUrl);
    url.searchParams.append('iface', String(iface));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_by_name(name: string): Promise<GstElement> {
    const url = new URL(`/Gst/Bin/${this.ptr}/get_by_name`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_by_name_recurse_up(name: string): Promise<GstElement> {
    const url = new URL(`/Gst/Bin/${this.ptr}/get_by_name_recurse_up`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_suppressed_flags(): Promise<GstElementFlags> {
    const url = new URL(`/Gst/Bin/${this.ptr}/get_suppressed_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_all_by_element_factory_name(factory_name: string): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/${this.ptr}/iterate_all_by_element_factory_name`, apiConfig.baseUrl);
    url.searchParams.append('factory_name', String(factory_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_all_by_interface(iface: Pointer): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/${this.ptr}/iterate_all_by_interface`, apiConfig.baseUrl);
    url.searchParams.append('iface', String(iface));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_elements(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/${this.ptr}/iterate_elements`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_recurse(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/${this.ptr}/iterate_recurse`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_sinks(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/${this.ptr}/iterate_sinks`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_sorted(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/${this.ptr}/iterate_sorted`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_sources(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/${this.ptr}/iterate_sources`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async recalculate_latency(): Promise<boolean> {
    const url = new URL(`/Gst/Bin/${this.ptr}/recalculate_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove(element: GstElement): Promise<boolean> {
    const url = new URL(`/Gst/Bin/${this.ptr}/remove`, apiConfig.baseUrl);
    url.searchParams.append('element', String(element));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_suppressed_flags(flags: GstElementFlags): Promise<void> {
    const url = new URL(`/Gst/Bin/${this.ptr}/set_suppressed_flags`, apiConfig.baseUrl);
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sync_children_states(): Promise<boolean> {
    const url = new URL(`/Gst/Bin/${this.ptr}/sync_children_states`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstBufferPool extends GObjectObject {
  static async new(): Promise<GstBufferPool> {
    const url = new URL(`/Gst/BufferPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBufferPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async config_add_option(config: GstStructure, option: string): Promise<void> {
    const url = new URL(`/Gst/BufferPool/config_add_option`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    url.searchParams.append('option', String(option));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async config_get_allocator(config: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/config_get_allocator`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_get_option(config: GstStructure, index: number): Promise<string> {
    const url = new URL(`/Gst/BufferPool/config_get_option`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_get_params(config: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/config_get_params`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_has_option(config: GstStructure, option: string): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/config_has_option`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    url.searchParams.append('option', String(option));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_n_options(config: GstStructure): Promise<number> {
    const url = new URL(`/Gst/BufferPool/config_n_options`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_set_allocator(config: GstStructure, allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    const url = new URL(`/Gst/BufferPool/config_set_allocator`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    if (allocator !== undefined) url.searchParams.append('allocator', String(allocator));
    if (params !== undefined) url.searchParams.append('params', String(params));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async config_set_params(config: GstStructure, size: number, min_buffers: number, max_buffers: number, caps?: GstCaps): Promise<void> {
    const url = new URL(`/Gst/BufferPool/config_set_params`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    if (caps !== undefined) url.searchParams.append('caps', String(caps));
    url.searchParams.append('size', String(size));
    url.searchParams.append('min_buffers', String(min_buffers));
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async config_validate_params(config: GstStructure, size: number, min_buffers: number, max_buffers: number, caps?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/config_validate_params`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    if (caps !== undefined) url.searchParams.append('caps', String(caps));
    url.searchParams.append('size', String(size));
    url.searchParams.append('min_buffers', String(min_buffers));
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async acquire_buffer(params?: GstBufferPoolAcquireParams): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/BufferPool/${this.ptr}/acquire_buffer`, apiConfig.baseUrl);
    if (params !== undefined) url.searchParams.append('params', String(params));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_config(): Promise<GstStructure> {
    const url = new URL(`/Gst/BufferPool/${this.ptr}/get_config`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_options(): Promise<Pointer> {
    const url = new URL(`/Gst/BufferPool/${this.ptr}/get_options`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_option(option: string): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/${this.ptr}/has_option`, apiConfig.baseUrl);
    url.searchParams.append('option', String(option));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_active(): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/${this.ptr}/is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async release_buffer(buffer: GstBuffer): Promise<void> {
    const url = new URL(`/Gst/BufferPool/${this.ptr}/release_buffer`, apiConfig.baseUrl);
    url.searchParams.append('buffer', String(buffer));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_active(active: boolean): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/${this.ptr}/set_active`, apiConfig.baseUrl);
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_config(config: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/${this.ptr}/set_config`, apiConfig.baseUrl);
    url.searchParams.append('config', String(config));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flushing(flushing: boolean): Promise<void> {
    const url = new URL(`/Gst/BufferPool/${this.ptr}/set_flushing`, apiConfig.baseUrl);
    url.searchParams.append('flushing', String(flushing));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstControlSource extends GObjectObject {

  async control_source_get_value(timestamp: number): Promise<boolean> {
    const url = new URL(`/Gst/ControlSource/${this.ptr}/control_source_get_value`, apiConfig.baseUrl);
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async control_source_get_value_array(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/ControlSource/${this.ptr}/control_source_get_value_array`, apiConfig.baseUrl);
    url.searchParams.append('timestamp', String(timestamp));
    url.searchParams.append('interval', String(interval));
    url.searchParams.append('n_values', String(n_values));
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstDevice extends GObjectObject {

  async create_element(name?: string): Promise<GstElement> {
    const url = new URL(`/Gst/Device/${this.ptr}/create_element`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Device/${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_device_class(): Promise<string> {
    const url = new URL(`/Gst/Device/${this.ptr}/get_device_class`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_display_name(): Promise<string> {
    const url = new URL(`/Gst/Device/${this.ptr}/get_display_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_properties(): Promise<GstStructure> {
    const url = new URL(`/Gst/Device/${this.ptr}/get_properties`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classes(classes: string): Promise<boolean> {
    const url = new URL(`/Gst/Device/${this.ptr}/has_classes`, apiConfig.baseUrl);
    url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classesv(classes: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Device/${this.ptr}/has_classesv`, apiConfig.baseUrl);
    url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reconfigure_element(element: GstElement): Promise<boolean> {
    const url = new URL(`/Gst/Device/${this.ptr}/reconfigure_element`, apiConfig.baseUrl);
    url.searchParams.append('element', String(element));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstDeviceMonitor extends GObjectObject {
  static async new(): Promise<GstDeviceMonitor> {
    const url = new URL(`/Gst/DeviceMonitor/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDeviceMonitor();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_filter(classes?: string, caps?: GstCaps): Promise<number> {
    const url = new URL(`/Gst/DeviceMonitor/${this.ptr}/add_filter`, apiConfig.baseUrl);
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    if (caps !== undefined) url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`/Gst/DeviceMonitor/${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_devices(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceMonitor/${this.ptr}/get_devices`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_providers(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceMonitor/${this.ptr}/get_providers`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_show_all_devices(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceMonitor/${this.ptr}/get_show_all_devices`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_filter(filter_id: number): Promise<boolean> {
    const url = new URL(`/Gst/DeviceMonitor/${this.ptr}/remove_filter`, apiConfig.baseUrl);
    url.searchParams.append('filter_id', String(filter_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_show_all_devices(show_all: boolean): Promise<void> {
    const url = new URL(`/Gst/DeviceMonitor/${this.ptr}/set_show_all_devices`, apiConfig.baseUrl);
    url.searchParams.append('show_all', String(show_all));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async start(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceMonitor/${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async stop(): Promise<void> {
    const url = new URL(`/Gst/DeviceMonitor/${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstDeviceProvider extends GObjectObject {

  async register(name: string, rank: number, type_: Pointer, plugin?: GstPlugin): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProvider/register`, apiConfig.baseUrl);
    if (plugin !== undefined) url.searchParams.append('plugin', String(plugin));
    url.searchParams.append('name', String(name));
    url.searchParams.append('rank', String(rank));
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_monitor(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/can_monitor`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async device_add(device: GstDevice): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/device_add`, apiConfig.baseUrl);
    url.searchParams.append('device', String(device));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async device_changed(device: GstDevice, changed_device: GstDevice): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/device_changed`, apiConfig.baseUrl);
    url.searchParams.append('device', String(device));
    url.searchParams.append('changed_device', String(changed_device));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async device_remove(device: GstDevice): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/device_remove`, apiConfig.baseUrl);
    url.searchParams.append('device', String(device));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_devices(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/get_devices`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_factory(): Promise<GstDeviceProviderFactory> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/get_factory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_hidden_providers(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/get_hidden_providers`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/get_metadata`, apiConfig.baseUrl);
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async hide_provider(name: string): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/hide_provider`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_started(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/is_started`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async start(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async stop(): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unhide_provider(name: string): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/${this.ptr}/unhide_provider`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstDeviceProviderFactory extends GObjectObject {

  async find(name: string): Promise<GstDeviceProviderFactory> {
    const url = new URL(`/Gst/DeviceProviderFactory/find`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_by_name(factoryname: string): Promise<GstDeviceProvider> {
    const url = new URL(`/Gst/DeviceProviderFactory/get_by_name`, apiConfig.baseUrl);
    url.searchParams.append('factoryname', String(factoryname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_get_device_providers(minrank: GstRank): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProviderFactory/list_get_device_providers`, apiConfig.baseUrl);
    url.searchParams.append('minrank', String(minrank));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get(): Promise<GstDeviceProvider> {
    const url = new URL(`/Gst/DeviceProviderFactory/${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_device_provider_type(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProviderFactory/${this.ptr}/get_device_provider_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`/Gst/DeviceProviderFactory/${this.ptr}/get_metadata`, apiConfig.baseUrl);
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata_keys(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProviderFactory/${this.ptr}/get_metadata_keys`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classes(classes?: string): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProviderFactory/${this.ptr}/has_classes`, apiConfig.baseUrl);
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classesv(classes?: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProviderFactory/${this.ptr}/has_classesv`, apiConfig.baseUrl);
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstDynamicTypeFactory extends GObjectObject {

  async load(factoryname: string): Promise<Pointer> {
    const url = new URL(`/Gst/DynamicTypeFactory/load`, apiConfig.baseUrl);
    url.searchParams.append('factoryname', String(factoryname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstFlagSet {
  ptr!: Pointer;


  async register(flags_type: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/FlagSet/register`, apiConfig.baseUrl);
    url.searchParams.append('flags_type', String(flags_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstProxyPad extends GObjectObject {

  async chain_default(pad: GstPad, buffer: GstBuffer, parent?: GstObject): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/ProxyPad/chain_default`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    if (parent !== undefined) url.searchParams.append('parent', String(parent));
    url.searchParams.append('buffer', String(buffer));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async chain_list_default(pad: GstPad, list: GstBufferList, parent?: GstObject): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/ProxyPad/chain_list_default`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    if (parent !== undefined) url.searchParams.append('parent', String(parent));
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async getrange_default(pad: GstPad, parent: GstObject, offset: number, size: number): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/ProxyPad/getrange_default`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    url.searchParams.append('parent', String(parent));
    url.searchParams.append('offset', String(offset));
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_internal_links_default(pad: GstPad, parent?: GstObject): Promise<GstIterator> {
    const url = new URL(`/Gst/ProxyPad/iterate_internal_links_default`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    if (parent !== undefined) url.searchParams.append('parent', String(parent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_internal(): Promise<GstProxyPad> {
    const url = new URL(`/Gst/ProxyPad/${this.ptr}/get_internal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstGhostPad extends GObjectObject {
  static async new(target: GstPad, name?: string): Promise<GstGhostPad> {
    const url = new URL(`/Gst/GhostPad/new`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    url.searchParams.append('target', String(target));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_template(target: GstPad, templ: GstPadTemplate, name?: string): Promise<GstGhostPad> {
    const url = new URL(`/Gst/GhostPad/new_from_template`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    url.searchParams.append('target', String(target));
    url.searchParams.append('templ', String(templ));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_no_target(dir: GstPadDirection, name?: string): Promise<GstGhostPad> {
    const url = new URL(`/Gst/GhostPad/new_no_target`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    url.searchParams.append('dir', String(dir));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_no_target_from_template(templ: GstPadTemplate, name?: string): Promise<GstGhostPad> {
    const url = new URL(`/Gst/GhostPad/new_no_target_from_template`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    url.searchParams.append('templ', String(templ));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async activate_mode_default(pad: GstPad, mode: GstPadModeValue, active: boolean, parent?: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/GhostPad/activate_mode_default`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    if (parent !== undefined) url.searchParams.append('parent', String(parent));
    url.searchParams.append('mode', String(mode));
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async internal_activate_mode_default(pad: GstPad, mode: GstPadModeValue, active: boolean, parent?: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/GhostPad/internal_activate_mode_default`, apiConfig.baseUrl);
    url.searchParams.append('pad', String(pad));
    if (parent !== undefined) url.searchParams.append('parent', String(parent));
    url.searchParams.append('mode', String(mode));
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async construct(): Promise<boolean> {
    const url = new URL(`/Gst/GhostPad/${this.ptr}/construct`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_target(): Promise<GstPad> {
    const url = new URL(`/Gst/GhostPad/${this.ptr}/get_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_target(newtarget?: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/GhostPad/${this.ptr}/set_target`, apiConfig.baseUrl);
    if (newtarget !== undefined) url.searchParams.append('newtarget', String(newtarget));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstPipeline extends GObjectObject {
  static async new(name?: string): Promise<GstPipeline> {
    const url = new URL(`/Gst/Pipeline/new`, apiConfig.baseUrl);
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPipeline();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async auto_clock(): Promise<void> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/auto_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_auto_flush_bus(): Promise<boolean> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/get_auto_flush_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_configured_latency(): Promise<number> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/get_configured_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_delay(): Promise<number> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/get_delay`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_latency(): Promise<number> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/get_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pipeline_clock(): Promise<GstClock> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/get_pipeline_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_live(): Promise<boolean> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/is_live`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_auto_flush_bus(auto_flush: boolean): Promise<void> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/set_auto_flush_bus`, apiConfig.baseUrl);
    url.searchParams.append('auto_flush', String(auto_flush));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_delay(delay: number): Promise<void> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/set_delay`, apiConfig.baseUrl);
    url.searchParams.append('delay', String(delay));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_latency(latency: number): Promise<void> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/set_latency`, apiConfig.baseUrl);
    url.searchParams.append('latency', String(latency));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async use_clock(clock?: GstClock): Promise<void> {
    const url = new URL(`/Gst/Pipeline/${this.ptr}/use_clock`, apiConfig.baseUrl);
    if (clock !== undefined) url.searchParams.append('clock', String(clock));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstRegistry extends GObjectObject {

  async fork_is_enabled(): Promise<boolean> {
    const url = new URL(`/Gst/Registry/fork_is_enabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fork_set_enabled(enabled: boolean): Promise<void> {
    const url = new URL(`/Gst/Registry/fork_set_enabled`, apiConfig.baseUrl);
    url.searchParams.append('enabled', String(enabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get(): Promise<GstRegistry> {
    const url = new URL(`/Gst/Registry/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_feature(feature: GstPluginFeature): Promise<boolean> {
    const url = new URL(`/Gst/Registry/${this.ptr}/add_feature`, apiConfig.baseUrl);
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_plugin(plugin: GstPlugin): Promise<boolean> {
    const url = new URL(`/Gst/Registry/${this.ptr}/add_plugin`, apiConfig.baseUrl);
    url.searchParams.append('plugin', String(plugin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async check_feature_version(feature_name: string, min_major: number, min_minor: number, min_micro: number): Promise<boolean> {
    const url = new URL(`/Gst/Registry/${this.ptr}/check_feature_version`, apiConfig.baseUrl);
    url.searchParams.append('feature_name', String(feature_name));
    url.searchParams.append('min_major', String(min_major));
    url.searchParams.append('min_minor', String(min_minor));
    url.searchParams.append('min_micro', String(min_micro));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async feature_filter(first: boolean, filter: (feature: GstPluginFeature, user_data: Pointer) => boolean): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/${this.ptr}/feature_filter`, apiConfig.baseUrl);
    url.searchParams.append('first', String(first));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.filter !== undefined) {
      callbackDispatcher.set(data.filter.toString(), filter);
    }
    return data.return;
  }
  async find_feature(name: string, type_: Pointer): Promise<GstPluginFeature> {
    const url = new URL(`/Gst/Registry/${this.ptr}/find_feature`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async find_plugin(name: string): Promise<GstPlugin> {
    const url = new URL(`/Gst/Registry/${this.ptr}/find_plugin`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_feature_list(type_: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/${this.ptr}/get_feature_list`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_feature_list_by_plugin(name: string): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/${this.ptr}/get_feature_list_by_plugin`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_feature_list_cookie(): Promise<number> {
    const url = new URL(`/Gst/Registry/${this.ptr}/get_feature_list_cookie`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_plugin_list(): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/${this.ptr}/get_plugin_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lookup(filename: string): Promise<GstPlugin> {
    const url = new URL(`/Gst/Registry/${this.ptr}/lookup`, apiConfig.baseUrl);
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lookup_feature(name: string): Promise<GstPluginFeature> {
    const url = new URL(`/Gst/Registry/${this.ptr}/lookup_feature`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async plugin_filter(first: boolean, filter: (plugin: GstPlugin, user_data: Pointer) => boolean): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/${this.ptr}/plugin_filter`, apiConfig.baseUrl);
    url.searchParams.append('first', String(first));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.filter !== undefined) {
      callbackDispatcher.set(data.filter.toString(), filter);
    }
    return data.return;
  }
  async remove_feature(feature: GstPluginFeature): Promise<void> {
    const url = new URL(`/Gst/Registry/${this.ptr}/remove_feature`, apiConfig.baseUrl);
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_plugin(plugin: GstPlugin): Promise<void> {
    const url = new URL(`/Gst/Registry/${this.ptr}/remove_plugin`, apiConfig.baseUrl);
    url.searchParams.append('plugin', String(plugin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async scan_path(path: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Registry/${this.ptr}/scan_path`, apiConfig.baseUrl);
    url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstTaskPool extends GObjectObject {
  static async new(): Promise<GstTaskPool> {
    const url = new URL(`/Gst/TaskPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTaskPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async cleanup(): Promise<void> {
    const url = new URL(`/Gst/TaskPool/${this.ptr}/cleanup`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async dispose_handle(): Promise<void> {
    const url = new URL(`/Gst/TaskPool/${this.ptr}/dispose_handle`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async join(): Promise<void> {
    const url = new URL(`/Gst/TaskPool/${this.ptr}/join`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async prepare(): Promise<void> {
    const url = new URL(`/Gst/TaskPool/${this.ptr}/prepare`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push(func: (user_data: Pointer) => void): Promise<{ func?: number }> {
    const url = new URL(`/Gst/TaskPool/${this.ptr}/push`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
}

export class GstSharedTaskPool extends GObjectObject {
  static async new(): Promise<GstSharedTaskPool> {
    const url = new URL(`/Gst/SharedTaskPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstSharedTaskPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_max_threads(): Promise<number> {
    const url = new URL(`/Gst/SharedTaskPool/${this.ptr}/get_max_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_max_threads(max_threads: number): Promise<void> {
    const url = new URL(`/Gst/SharedTaskPool/${this.ptr}/set_max_threads`, apiConfig.baseUrl);
    url.searchParams.append('max_threads', String(max_threads));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstStreamCollection extends GObjectObject {
  static async new(upstream_id?: string): Promise<GstStreamCollection> {
    const url = new URL(`/Gst/StreamCollection/new`, apiConfig.baseUrl);
    if (upstream_id !== undefined) url.searchParams.append('upstream_id', String(upstream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStreamCollection();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_stream(stream: GstStream): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + stream.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/StreamCollection/${this.ptr}/add_stream`, apiConfig.baseUrl);
    url.searchParams.append('stream', String(stream));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (stream && typeof stream === 'object' && 'ptr' in stream) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (stream && typeof stream === 'object' && 'ptr' in stream) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async get_size(): Promise<number> {
    const url = new URL(`/Gst/StreamCollection/${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream(index: number): Promise<GstStream> {
    const url = new URL(`/Gst/StreamCollection/${this.ptr}/get_stream`, apiConfig.baseUrl);
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_upstream_id(): Promise<string> {
    const url = new URL(`/Gst/StreamCollection/${this.ptr}/get_upstream_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstSystemClock extends GObjectObject {

  async obtain(): Promise<GstClock> {
    const url = new URL(`/Gst/SystemClock/obtain`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_default(new_clock?: GstClock): Promise<void> {
    const url = new URL(`/Gst/SystemClock/set_default`, apiConfig.baseUrl);
    if (new_clock !== undefined) url.searchParams.append('new_clock', String(new_clock));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstTask extends GObjectObject {
  static async new(func: (user_data: Pointer) => void): Promise<GstTask> {
    const url = new URL(`/Gst/Task/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    const instance = new GstTask();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async cleanup_all(): Promise<void> {
    const url = new URL(`/Gst/Task/cleanup_all`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_pool(): Promise<GstTaskPool> {
    const url = new URL(`/Gst/Task/${this.ptr}/get_pool`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_state(): Promise<GstTaskState> {
    const url = new URL(`/Gst/Task/${this.ptr}/get_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async join(): Promise<boolean> {
    const url = new URL(`/Gst/Task/${this.ptr}/join`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pause(): Promise<boolean> {
    const url = new URL(`/Gst/Task/${this.ptr}/pause`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async resume(): Promise<boolean> {
    const url = new URL(`/Gst/Task/${this.ptr}/resume`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_enter_callback(enter_func: (task: GstTask, thread: GLibThread, user_data: Pointer) => void): Promise<{ enter_func?: number }> {
    const url = new URL(`/Gst/Task/${this.ptr}/set_enter_callback`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.enter_func !== undefined) {
      callbackDispatcher.set(data.enter_func.toString(), enter_func);
    }
    return data;
  }
  async set_leave_callback(leave_func: (task: GstTask, thread: GLibThread, user_data: Pointer) => void): Promise<{ leave_func?: number }> {
    const url = new URL(`/Gst/Task/${this.ptr}/set_leave_callback`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.leave_func !== undefined) {
      callbackDispatcher.set(data.leave_func.toString(), leave_func);
    }
    return data;
  }
  async set_lock(mutex: GLibRecMutex): Promise<void> {
    const url = new URL(`/Gst/Task/${this.ptr}/set_lock`, apiConfig.baseUrl);
    url.searchParams.append('mutex', String(mutex));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_pool(pool: GstTaskPool): Promise<void> {
    const url = new URL(`/Gst/Task/${this.ptr}/set_pool`, apiConfig.baseUrl);
    url.searchParams.append('pool', String(pool));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_state(state: GstTaskState): Promise<boolean> {
    const url = new URL(`/Gst/Task/${this.ptr}/set_state`, apiConfig.baseUrl);
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async start(): Promise<boolean> {
    const url = new URL(`/Gst/Task/${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async stop(): Promise<boolean> {
    const url = new URL(`/Gst/Task/${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstTracer extends GObjectObject {

  async register(name: string, type_: Pointer, plugin?: GstPlugin): Promise<boolean> {
    const url = new URL(`/Gst/Tracer/register`, apiConfig.baseUrl);
    if (plugin !== undefined) url.searchParams.append('plugin', String(plugin));
    url.searchParams.append('name', String(name));
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstTracerFactory extends GObjectObject {

  async get_list(): Promise<Pointer> {
    const url = new URL(`/Gst/TracerFactory/get_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tracer_type(): Promise<Pointer> {
    const url = new URL(`/Gst/TracerFactory/${this.ptr}/get_tracer_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstTypeFindFactory extends GObjectObject {

  async get_list(): Promise<Pointer> {
    const url = new URL(`/Gst/TypeFindFactory/get_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async call_function(find: GstTypeFind): Promise<void> {
    const url = new URL(`/Gst/TypeFindFactory/${this.ptr}/call_function`, apiConfig.baseUrl);
    url.searchParams.append('find', String(find));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/TypeFindFactory/${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_extensions(): Promise<Pointer> {
    const url = new URL(`/Gst/TypeFindFactory/${this.ptr}/get_extensions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_function(): Promise<boolean> {
    const url = new URL(`/Gst/TypeFindFactory/${this.ptr}/has_function`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstValueArray {
  ptr!: Pointer;


  async append_and_take_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/ValueArray/append_and_take_value`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('append_value', String(append_value));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async append_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueArray/append_value`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('append_value', String(append_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_size(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/ValueArray/get_size`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(value_: GObjectValue, index: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ValueArray/get_value`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async init(value_: GObjectValue, prealloc: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ValueArray/init`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('prealloc', String(prealloc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async prepend_value(value_: GObjectValue, prepend_value: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueArray/prepend_value`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('prepend_value', String(prepend_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstValueList {
  ptr!: Pointer;


  async append_and_take_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/ValueList/append_and_take_value`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('append_value', String(append_value));
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async append_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueList/append_value`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('append_value', String(append_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async concat(value1: GObjectValue, value2: GObjectValue): Promise<{ dest?: GObjectValue }> {
    const url = new URL(`/Gst/ValueList/concat`, apiConfig.baseUrl);
    url.searchParams.append('value1', String(value1));
    url.searchParams.append('value2', String(value2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async get_size(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/ValueList/get_size`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(value_: GObjectValue, index: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ValueList/get_value`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async init(value_: GObjectValue, prealloc: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ValueList/init`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('prealloc', String(prealloc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async merge(value1: GObjectValue, value2: GObjectValue): Promise<{ dest?: GObjectValue }> {
    const url = new URL(`/Gst/ValueList/merge`, apiConfig.baseUrl);
    url.searchParams.append('value1', String(value1));
    url.searchParams.append('value2', String(value2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async prepend_value(value_: GObjectValue, prepend_value: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueList/prepend_value`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('prepend_value', String(prepend_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}


export namespace Gst {
  export async function buffer_get_max_memory(): Promise<number> {
    const url = new URL(`/Gst/buffer_get_max_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function caps_features_from_string(features: string): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/caps_features_from_string`, apiConfig.baseUrl);
    url.searchParams.append('features', String(features));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function caps_from_string(string: string): Promise<GstCaps> {
    const url = new URL(`/Gst/caps_from_string`, apiConfig.baseUrl);
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function core_error_quark(): Promise<number> {
    const url = new URL(`/Gst/core_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_add_log_function(func: (category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, object: GObjectObject, message: GstDebugMessage, user_data: Pointer) => void): Promise<{ func?: number }> {
    const url = new URL(`/Gst/debug_add_log_function`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function debug_add_ring_buffer_logger(max_size_per_thread: number, thread_timeout: number): Promise<void> {
    const url = new URL(`/Gst/debug_add_ring_buffer_logger`, apiConfig.baseUrl);
    url.searchParams.append('max_size_per_thread', String(max_size_per_thread));
    url.searchParams.append('thread_timeout', String(thread_timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_bin_to_dot_data(bin: GstBin, details: GstDebugGraphDetails): Promise<string> {
    const url = new URL(`/Gst/debug_bin_to_dot_data`, apiConfig.baseUrl);
    url.searchParams.append('bin', String(bin));
    url.searchParams.append('details', String(details));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_bin_to_dot_file(bin: GstBin, details: GstDebugGraphDetails, file_name: Pointer): Promise<void> {
    const url = new URL(`/Gst/debug_bin_to_dot_file`, apiConfig.baseUrl);
    url.searchParams.append('bin', String(bin));
    url.searchParams.append('details', String(details));
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_bin_to_dot_file_with_ts(bin: GstBin, details: GstDebugGraphDetails, file_name: Pointer): Promise<void> {
    const url = new URL(`/Gst/debug_bin_to_dot_file_with_ts`, apiConfig.baseUrl);
    url.searchParams.append('bin', String(bin));
    url.searchParams.append('details', String(details));
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_construct_term_color(colorinfo: number): Promise<string> {
    const url = new URL(`/Gst/debug_construct_term_color`, apiConfig.baseUrl);
    url.searchParams.append('colorinfo', String(colorinfo));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_construct_win_color(colorinfo: number): Promise<number> {
    const url = new URL(`/Gst/debug_construct_win_color`, apiConfig.baseUrl);
    url.searchParams.append('colorinfo', String(colorinfo));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_all_categories(): Promise<Pointer> {
    const url = new URL(`/Gst/debug_get_all_categories`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_color_mode(): Promise<GstDebugColorMode> {
    const url = new URL(`/Gst/debug_get_color_mode`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_default_threshold(): Promise<GstDebugLevelValue> {
    const url = new URL(`/Gst/debug_get_default_threshold`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_stack_trace(flags: GstStackTraceFlags): Promise<string> {
    const url = new URL(`/Gst/debug_get_stack_trace`, apiConfig.baseUrl);
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_is_active(): Promise<boolean> {
    const url = new URL(`/Gst/debug_is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_is_colored(): Promise<boolean> {
    const url = new URL(`/Gst/debug_is_colored`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_level_get_name(level: GstDebugLevelValue): Promise<string> {
    const url = new URL(`/Gst/debug_level_get_name`, apiConfig.baseUrl);
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_log_default(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message: GstDebugMessage, object?: GObjectObject): Promise<void> {
    const url = new URL(`/Gst/debug_log_default`, apiConfig.baseUrl);
    url.searchParams.append('category', String(category));
    url.searchParams.append('level', String(level));
    url.searchParams.append('file', String(file));
    url.searchParams.append('function', String(function_));
    url.searchParams.append('line', String(line));
    if (object !== undefined) url.searchParams.append('object', String(object));
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_log_get_line(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message: GstDebugMessage, object?: GObjectObject): Promise<string> {
    const url = new URL(`/Gst/debug_log_get_line`, apiConfig.baseUrl);
    url.searchParams.append('category', String(category));
    url.searchParams.append('level', String(level));
    url.searchParams.append('file', String(file));
    url.searchParams.append('function', String(function_));
    url.searchParams.append('line', String(line));
    if (object !== undefined) url.searchParams.append('object', String(object));
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_log_id_literal(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message_string: string, id?: string): Promise<void> {
    const url = new URL(`/Gst/debug_log_id_literal`, apiConfig.baseUrl);
    url.searchParams.append('category', String(category));
    url.searchParams.append('level', String(level));
    url.searchParams.append('file', String(file));
    url.searchParams.append('function', String(function_));
    url.searchParams.append('line', String(line));
    if (id !== undefined) url.searchParams.append('id', String(id));
    url.searchParams.append('message_string', String(message_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_log_literal(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message_string: string, object?: GObjectObject): Promise<void> {
    const url = new URL(`/Gst/debug_log_literal`, apiConfig.baseUrl);
    url.searchParams.append('category', String(category));
    url.searchParams.append('level', String(level));
    url.searchParams.append('file', String(file));
    url.searchParams.append('function', String(function_));
    url.searchParams.append('line', String(line));
    if (object !== undefined) url.searchParams.append('object', String(object));
    url.searchParams.append('message_string', String(message_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_print_stack_trace(): Promise<void> {
    const url = new URL(`/Gst/debug_print_stack_trace`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_remove_log_function(func: (category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, object: GObjectObject, message: GstDebugMessage, user_data: Pointer) => void): Promise<number> {
    const url = new URL(`/Gst/debug_remove_log_function`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  export async function debug_remove_log_function_by_data(): Promise<number> {
    const url = new URL(`/Gst/debug_remove_log_function_by_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_remove_ring_buffer_logger(): Promise<void> {
    const url = new URL(`/Gst/debug_remove_ring_buffer_logger`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_ring_buffer_logger_get_logs(): Promise<Pointer> {
    const url = new URL(`/Gst/debug_ring_buffer_logger_get_logs`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_set_active(active: boolean): Promise<void> {
    const url = new URL(`/Gst/debug_set_active`, apiConfig.baseUrl);
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_color_mode(mode: GstDebugColorMode): Promise<void> {
    const url = new URL(`/Gst/debug_set_color_mode`, apiConfig.baseUrl);
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_color_mode_from_string(mode: string): Promise<void> {
    const url = new URL(`/Gst/debug_set_color_mode_from_string`, apiConfig.baseUrl);
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_colored(colored: boolean): Promise<void> {
    const url = new URL(`/Gst/debug_set_colored`, apiConfig.baseUrl);
    url.searchParams.append('colored', String(colored));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_default_threshold(level: GstDebugLevelValue): Promise<void> {
    const url = new URL(`/Gst/debug_set_default_threshold`, apiConfig.baseUrl);
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_threshold_for_name(name: string, level: GstDebugLevelValue): Promise<void> {
    const url = new URL(`/Gst/debug_set_threshold_for_name`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_threshold_from_string(list: string, reset: boolean): Promise<void> {
    const url = new URL(`/Gst/debug_set_threshold_from_string`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    url.searchParams.append('reset', String(reset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_unset_threshold_for_name(name: string): Promise<void> {
    const url = new URL(`/Gst/debug_unset_threshold_for_name`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function deinit(): Promise<void> {
    const url = new URL(`/Gst/deinit`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function dynamic_type_register(plugin: GstPlugin, type_: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/dynamic_type_register`, apiConfig.baseUrl);
    url.searchParams.append('plugin', String(plugin));
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function error_get_message(domain: number, code: number): Promise<string> {
    const url = new URL(`/Gst/error_get_message`, apiConfig.baseUrl);
    url.searchParams.append('domain', String(domain));
    url.searchParams.append('code', String(code));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_get_flags(type_: GstEventTypeValue): Promise<GstEventTypeFlags> {
    const url = new URL(`/Gst/event_type_get_flags`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_get_name(type_: GstEventTypeValue): Promise<string> {
    const url = new URL(`/Gst/event_type_get_name`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_to_quark(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`/Gst/event_type_to_quark`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_to_sticky_ordering(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`/Gst/event_type_to_sticky_ordering`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function filename_to_uri(filename: Pointer): Promise<string> {
    const url = new URL(`/Gst/filename_to_uri`, apiConfig.baseUrl);
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flow_get_name(ret: GstFlowReturn): Promise<string> {
    const url = new URL(`/Gst/flow_get_name`, apiConfig.baseUrl);
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flow_to_quark(ret: GstFlowReturn): Promise<number> {
    const url = new URL(`/Gst/flow_to_quark`, apiConfig.baseUrl);
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_get_by_nick(nick: string): Promise<GstFormatValue> {
    const url = new URL(`/Gst/format_get_by_nick`, apiConfig.baseUrl);
    url.searchParams.append('nick', String(nick));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_get_details(format: GstFormatValue): Promise<GstFormatDefinition> {
    const url = new URL(`/Gst/format_get_details`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_get_name(format: GstFormatValue): Promise<string> {
    const url = new URL(`/Gst/format_get_name`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_iterate_definitions(): Promise<GstIterator> {
    const url = new URL(`/Gst/format_iterate_definitions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_register(nick: string, description: string): Promise<GstFormatValue> {
    const url = new URL(`/Gst/format_register`, apiConfig.baseUrl);
    url.searchParams.append('nick', String(nick));
    url.searchParams.append('description', String(description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_to_quark(format: GstFormatValue): Promise<number> {
    const url = new URL(`/Gst/format_to_quark`, apiConfig.baseUrl);
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function formats_contains(formats: Pointer, format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/formats_contains`, apiConfig.baseUrl);
    url.searchParams.append('formats', String(formats));
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_main_executable_path(): Promise<string> {
    const url = new URL(`/Gst/get_main_executable_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function init(argc?: number, argv?: Pointer): Promise<{ argc?: number; argv?: Pointer }> {
    const url = new URL(`/Gst/init`, apiConfig.baseUrl);
    if (argc !== undefined) url.searchParams.append('argc', String(argc));
    if (argv !== undefined) url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function init_check(argc?: number, argv?: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/init_check`, apiConfig.baseUrl);
    if (argc !== undefined) url.searchParams.append('argc', String(argc));
    if (argv !== undefined) url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function is_caps_features(): Promise<boolean> {
    const url = new URL(`/Gst/is_caps_features`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function is_initialized(): Promise<boolean> {
    const url = new URL(`/Gst/is_initialized`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function library_error_quark(): Promise<number> {
    const url = new URL(`/Gst/library_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function message_type_get_name(type_: GstMessageTypeValue): Promise<string> {
    const url = new URL(`/Gst/message_type_get_name`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function message_type_to_quark(type_: GstMessageTypeValue): Promise<number> {
    const url = new URL(`/Gst/message_type_to_quark`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_api_type_get_tags(api: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/meta_api_type_get_tags`, apiConfig.baseUrl);
    url.searchParams.append('api', String(api));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_api_type_has_tag(api: Pointer, tag: number): Promise<boolean> {
    const url = new URL(`/Gst/meta_api_type_has_tag`, apiConfig.baseUrl);
    url.searchParams.append('api', String(api));
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_api_type_register(api: string, tags: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/meta_api_type_register`, apiConfig.baseUrl);
    url.searchParams.append('api', String(api));
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_deserialize(buffer: GstBuffer, data_: number, size: number): Promise<GstMeta> {
    const url = new URL(`/Gst/meta_deserialize`, apiConfig.baseUrl);
    url.searchParams.append('buffer', String(buffer));
    url.searchParams.append('data', String(data_));
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_get_info(impl: string): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/meta_get_info`, apiConfig.baseUrl);
    url.searchParams.append('impl', String(impl));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_register_custom(name: string, tags: Pointer, transform_func: (transbuf: GstBuffer, meta: GstCustomMeta, buffer: GstBuffer, type_: number, data_: Pointer, user_data: Pointer) => boolean): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/meta_register_custom`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.transform_func !== undefined) {
      callbackDispatcher.set(data.transform_func.toString(), transform_func);
    }
    return data.return;
  }
  export async function meta_register_custom_simple(name: string): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/meta_register_custom_simple`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function mini_object_replace(olddata?: GstMiniObject, newdata?: GstMiniObject): Promise<boolean> {
    const url = new URL(`/Gst/mini_object_replace`, apiConfig.baseUrl);
    if (olddata !== undefined) url.searchParams.append('olddata', String(olddata));
    if (newdata !== undefined) url.searchParams.append('newdata', String(newdata));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function mini_object_take(olddata: GstMiniObject, newdata: GstMiniObject): Promise<boolean> {
    const url = new URL(`/Gst/mini_object_take`, apiConfig.baseUrl);
    url.searchParams.append('olddata', String(olddata));
    url.searchParams.append('newdata', String(newdata));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function pad_mode_get_name(mode: GstPadModeValue): Promise<string> {
    const url = new URL(`/Gst/pad_mode_get_name`, apiConfig.baseUrl);
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_spec_array(name: string, nick: string, blurb: string, element_spec: GObjectParamSpec, flags: GObjectParamFlags): Promise<GObjectParamSpec> {
    const url = new URL(`/Gst/param_spec_array`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    url.searchParams.append('nick', String(nick));
    url.searchParams.append('blurb', String(blurb));
    url.searchParams.append('element_spec', String(element_spec));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_spec_fraction(name: string, nick: string, blurb: string, min_num: number, min_denom: number, max_num: number, max_denom: number, default_num: number, default_denom: number, flags: GObjectParamFlags): Promise<GObjectParamSpec> {
    const url = new URL(`/Gst/param_spec_fraction`, apiConfig.baseUrl);
    url.searchParams.append('name', String(name));
    url.searchParams.append('nick', String(nick));
    url.searchParams.append('blurb', String(blurb));
    url.searchParams.append('min_num', String(min_num));
    url.searchParams.append('min_denom', String(min_denom));
    url.searchParams.append('max_num', String(max_num));
    url.searchParams.append('max_denom', String(max_denom));
    url.searchParams.append('default_num', String(default_num));
    url.searchParams.append('default_denom', String(default_denom));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parent_buffer_meta_api_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/parent_buffer_meta_api_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parent_buffer_meta_get_info(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/parent_buffer_meta_get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_bin_from_description(bin_description: string, ghost_unlinked_pads: boolean): Promise<GstBin> {
    const url = new URL(`/Gst/parse_bin_from_description`, apiConfig.baseUrl);
    url.searchParams.append('bin_description', String(bin_description));
    url.searchParams.append('ghost_unlinked_pads', String(ghost_unlinked_pads));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_bin_from_description_full(bin_description: string, ghost_unlinked_pads: boolean, flags: GstParseFlags, context?: GstParseContext): Promise<GstElement> {
    const url = new URL(`/Gst/parse_bin_from_description_full`, apiConfig.baseUrl);
    url.searchParams.append('bin_description', String(bin_description));
    url.searchParams.append('ghost_unlinked_pads', String(ghost_unlinked_pads));
    if (context !== undefined) url.searchParams.append('context', String(context));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_error_quark(): Promise<number> {
    const url = new URL(`/Gst/parse_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_launch(pipeline_description: string): Promise<GstElement> {
    const url = new URL(`/Gst/parse_launch`, apiConfig.baseUrl);
    url.searchParams.append('pipeline_description', String(pipeline_description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_launch_full(pipeline_description: string, flags: GstParseFlags, context?: GstParseContext): Promise<GstElement> {
    const url = new URL(`/Gst/parse_launch_full`, apiConfig.baseUrl);
    url.searchParams.append('pipeline_description', String(pipeline_description));
    if (context !== undefined) url.searchParams.append('context', String(context));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_launchv(argv: Pointer): Promise<GstElement> {
    const url = new URL(`/Gst/parse_launchv`, apiConfig.baseUrl);
    url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_launchv_full(argv: Pointer, flags: GstParseFlags, context?: GstParseContext): Promise<GstElement> {
    const url = new URL(`/Gst/parse_launchv_full`, apiConfig.baseUrl);
    url.searchParams.append('argv', String(argv));
    if (context !== undefined) url.searchParams.append('context', String(context));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function plugin_error_quark(): Promise<number> {
    const url = new URL(`/Gst/plugin_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function preset_get_app_dir(): Promise<Pointer> {
    const url = new URL(`/Gst/preset_get_app_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function preset_set_app_dir(app_dir: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/preset_set_app_dir`, apiConfig.baseUrl);
    url.searchParams.append('app_dir', String(app_dir));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_filter_systems_by_available_decryptors(system_identifiers: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/protection_filter_systems_by_available_decryptors`, apiConfig.baseUrl);
    url.searchParams.append('system_identifiers', String(system_identifiers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_meta_api_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/protection_meta_api_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_meta_get_info(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/protection_meta_get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_select_system(system_identifiers: Pointer): Promise<string> {
    const url = new URL(`/Gst/protection_select_system`, apiConfig.baseUrl);
    url.searchParams.append('system_identifiers', String(system_identifiers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function query_type_get_flags(type_: GstQueryTypeValue): Promise<GstQueryTypeFlags> {
    const url = new URL(`/Gst/query_type_get_flags`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function query_type_get_name(type_: GstQueryTypeValue): Promise<string> {
    const url = new URL(`/Gst/query_type_get_name`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function query_type_to_quark(type_: GstQueryTypeValue): Promise<number> {
    const url = new URL(`/Gst/query_type_to_quark`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function reference_timestamp_meta_api_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/reference_timestamp_meta_api_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function reference_timestamp_meta_get_info(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/reference_timestamp_meta_get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function resource_error_quark(): Promise<number> {
    const url = new URL(`/Gst/resource_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function segtrap_is_enabled(): Promise<boolean> {
    const url = new URL(`/Gst/segtrap_is_enabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function segtrap_set_enabled(enabled: boolean): Promise<void> {
    const url = new URL(`/Gst/segtrap_set_enabled`, apiConfig.baseUrl);
    url.searchParams.append('enabled', String(enabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function state_change_get_name(transition: GstStateChangeValue): Promise<string> {
    const url = new URL(`/Gst/state_change_get_name`, apiConfig.baseUrl);
    url.searchParams.append('transition', String(transition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function static_caps_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/static_caps_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function static_pad_template_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/static_pad_template_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function stream_error_quark(): Promise<number> {
    const url = new URL(`/Gst/stream_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function stream_type_get_name(stype: GstStreamTypeValue): Promise<string> {
    const url = new URL(`/Gst/stream_type_get_name`, apiConfig.baseUrl);
    url.searchParams.append('stype', String(stype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function structure_take(oldstr_ptr?: GstStructure, newstr?: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/structure_take`, apiConfig.baseUrl);
    if (oldstr_ptr !== undefined) url.searchParams.append('oldstr_ptr', String(oldstr_ptr));
    if (newstr !== undefined) url.searchParams.append('newstr', String(newstr));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_exists(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/tag_exists`, apiConfig.baseUrl);
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_description(tag: string): Promise<string> {
    const url = new URL(`/Gst/tag_get_description`, apiConfig.baseUrl);
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_flag(tag: string): Promise<GstTagFlag> {
    const url = new URL(`/Gst/tag_get_flag`, apiConfig.baseUrl);
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_nick(tag: string): Promise<string> {
    const url = new URL(`/Gst/tag_get_nick`, apiConfig.baseUrl);
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_type(tag: string): Promise<Pointer> {
    const url = new URL(`/Gst/tag_get_type`, apiConfig.baseUrl);
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_is_fixed(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/tag_is_fixed`, apiConfig.baseUrl);
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_list_copy_value(list: GstTagList, tag: string): Promise<boolean> {
    const url = new URL(`/Gst/tag_list_copy_value`, apiConfig.baseUrl);
    url.searchParams.append('list', String(list));
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_merge_strings_with_comma(src: GObjectValue): Promise<{ dest?: GObjectValue }> {
    const url = new URL(`/Gst/tag_merge_strings_with_comma`, apiConfig.baseUrl);
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function tag_merge_use_first(src: GObjectValue): Promise<{ dest?: GObjectValue }> {
    const url = new URL(`/Gst/tag_merge_use_first`, apiConfig.baseUrl);
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function toc_entry_type_get_nick(type_: GstTocEntryTypeValue): Promise<string> {
    const url = new URL(`/Gst/toc_entry_type_get_nick`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tracing_get_active_tracers(): Promise<Pointer> {
    const url = new URL(`/Gst/tracing_get_active_tracers`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tracing_register_hook(tracer: GstTracer, detail: string, func: () => void): Promise<{ func?: number }> {
    const url = new URL(`/Gst/tracing_register_hook`, apiConfig.baseUrl);
    url.searchParams.append('tracer', String(tracer));
    url.searchParams.append('detail', String(detail));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function type_find_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/type_find_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_find_register(name: string, rank: number, func: (find: GstTypeFind, user_data: Pointer) => void, plugin?: GstPlugin, extensions?: string, possible_caps?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/type_find_register`, apiConfig.baseUrl);
    if (plugin !== undefined) url.searchParams.append('plugin', String(plugin));
    url.searchParams.append('name', String(name));
    url.searchParams.append('rank', String(rank));
    if (extensions !== undefined) url.searchParams.append('extensions', String(extensions));
    if (possible_caps !== undefined) url.searchParams.append('possible_caps', String(possible_caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  export async function type_is_plugin_api(type_: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/type_is_plugin_api`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_mark_as_plugin_api(type_: Pointer, flags: GstPluginAPIFlags): Promise<void> {
    const url = new URL(`/Gst/type_mark_as_plugin_api`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function update_registry(): Promise<boolean> {
    const url = new URL(`/Gst/update_registry`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_construct(protocol: string, location: string): Promise<string> {
    const url = new URL(`/Gst/uri_construct`, apiConfig.baseUrl);
    url.searchParams.append('protocol', String(protocol));
    url.searchParams.append('location', String(location));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_error_quark(): Promise<number> {
    const url = new URL(`/Gst/uri_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_from_string(uri: string): Promise<GstUri> {
    const url = new URL(`/Gst/uri_from_string`, apiConfig.baseUrl);
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_from_string_escaped(uri: string): Promise<GstUri> {
    const url = new URL(`/Gst/uri_from_string_escaped`, apiConfig.baseUrl);
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_get_location(uri: string): Promise<string> {
    const url = new URL(`/Gst/uri_get_location`, apiConfig.baseUrl);
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_get_protocol(uri: string): Promise<string> {
    const url = new URL(`/Gst/uri_get_protocol`, apiConfig.baseUrl);
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_has_protocol(uri: string, protocol: string): Promise<boolean> {
    const url = new URL(`/Gst/uri_has_protocol`, apiConfig.baseUrl);
    url.searchParams.append('uri', String(uri));
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_is_valid(uri: string): Promise<boolean> {
    const url = new URL(`/Gst/uri_is_valid`, apiConfig.baseUrl);
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_join_strings(base_uri: string, ref_uri: string): Promise<string> {
    const url = new URL(`/Gst/uri_join_strings`, apiConfig.baseUrl);
    url.searchParams.append('base_uri', String(base_uri));
    url.searchParams.append('ref_uri', String(ref_uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_protocol_is_supported(type_: GstURIType, protocol: string): Promise<boolean> {
    const url = new URL(`/Gst/uri_protocol_is_supported`, apiConfig.baseUrl);
    url.searchParams.append('type', String(type_));
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_protocol_is_valid(protocol: string): Promise<boolean> {
    const url = new URL(`/Gst/uri_protocol_is_valid`, apiConfig.baseUrl);
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_array_binary_search(num_elements: number, element_size: number, mode: GstSearchMode, search_func: (a: Pointer, b: Pointer, user_data: Pointer) => number): Promise<{ search_func?: number }> {
    const url = new URL(`/Gst/util_array_binary_search`, apiConfig.baseUrl);
    url.searchParams.append('num_elements', String(num_elements));
    url.searchParams.append('element_size', String(element_size));
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.search_func !== undefined) {
      callbackDispatcher.set(data.search_func.toString(), search_func);
    }
    return data;
  }
  export async function util_ceil_log2(v: number): Promise<number> {
    const url = new URL(`/Gst/util_ceil_log2`, apiConfig.baseUrl);
    url.searchParams.append('v', String(v));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_double_to_fraction(src: number): Promise<{ dest_n?: number; dest_d?: number }> {
    const url = new URL(`/Gst/util_double_to_fraction`, apiConfig.baseUrl);
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function util_dump_buffer(buf: GstBuffer): Promise<void> {
    const url = new URL(`/Gst/util_dump_buffer`, apiConfig.baseUrl);
    url.searchParams.append('buf', String(buf));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_dump_mem(mem: Pointer, size: number): Promise<void> {
    const url = new URL(`/Gst/util_dump_mem`, apiConfig.baseUrl);
    url.searchParams.append('mem', String(mem));
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_filename_compare(a: Pointer, b: Pointer): Promise<number> {
    const url = new URL(`/Gst/util_filename_compare`, apiConfig.baseUrl);
    url.searchParams.append('a', String(a));
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_add(a_n: number, a_d: number, b_n: number, b_d: number): Promise<boolean> {
    const url = new URL(`/Gst/util_fraction_add`, apiConfig.baseUrl);
    url.searchParams.append('a_n', String(a_n));
    url.searchParams.append('a_d', String(a_d));
    url.searchParams.append('b_n', String(b_n));
    url.searchParams.append('b_d', String(b_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_compare(a_n: number, a_d: number, b_n: number, b_d: number): Promise<number> {
    const url = new URL(`/Gst/util_fraction_compare`, apiConfig.baseUrl);
    url.searchParams.append('a_n', String(a_n));
    url.searchParams.append('a_d', String(a_d));
    url.searchParams.append('b_n', String(b_n));
    url.searchParams.append('b_d', String(b_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_multiply(a_n: number, a_d: number, b_n: number, b_d: number): Promise<boolean> {
    const url = new URL(`/Gst/util_fraction_multiply`, apiConfig.baseUrl);
    url.searchParams.append('a_n', String(a_n));
    url.searchParams.append('a_d', String(a_d));
    url.searchParams.append('b_n', String(b_n));
    url.searchParams.append('b_d', String(b_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_to_double(src_n: number, src_d: number): Promise<{ dest?: number }> {
    const url = new URL(`/Gst/util_fraction_to_double`, apiConfig.baseUrl);
    url.searchParams.append('src_n', String(src_n));
    url.searchParams.append('src_d', String(src_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function util_gdouble_to_guint64(value_: number): Promise<number> {
    const url = new URL(`/Gst/util_gdouble_to_guint64`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_get_object_array(object: GObjectObject, name: string): Promise<boolean> {
    const url = new URL(`/Gst/util_get_object_array`, apiConfig.baseUrl);
    url.searchParams.append('object', String(object));
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_get_timestamp(): Promise<number> {
    const url = new URL(`/Gst/util_get_timestamp`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_greatest_common_divisor(a: number, b: number): Promise<number> {
    const url = new URL(`/Gst/util_greatest_common_divisor`, apiConfig.baseUrl);
    url.searchParams.append('a', String(a));
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_greatest_common_divisor_int64(a: number, b: number): Promise<number> {
    const url = new URL(`/Gst/util_greatest_common_divisor_int64`, apiConfig.baseUrl);
    url.searchParams.append('a', String(a));
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_group_id_next(): Promise<number> {
    const url = new URL(`/Gst/util_group_id_next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_guint64_to_gdouble(value_: number): Promise<number> {
    const url = new URL(`/Gst/util_guint64_to_gdouble`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_seqnum_compare(s1: number, s2: number): Promise<number> {
    const url = new URL(`/Gst/util_seqnum_compare`, apiConfig.baseUrl);
    url.searchParams.append('s1', String(s1));
    url.searchParams.append('s2', String(s2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_seqnum_next(): Promise<number> {
    const url = new URL(`/Gst/util_seqnum_next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_set_object_arg(object: GObjectObject, name: string, value_: string): Promise<void> {
    const url = new URL(`/Gst/util_set_object_arg`, apiConfig.baseUrl);
    url.searchParams.append('object', String(object));
    url.searchParams.append('name', String(name));
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_set_object_array(object: GObjectObject, name: string, array: GObjectValueArray): Promise<boolean> {
    const url = new URL(`/Gst/util_set_object_array`, apiConfig.baseUrl);
    url.searchParams.append('object', String(object));
    url.searchParams.append('name', String(name));
    url.searchParams.append('array', String(array));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_set_value_from_string(value_str: string): Promise<{ value_?: GObjectValue }> {
    const url = new URL(`/Gst/util_set_value_from_string`, apiConfig.baseUrl);
    url.searchParams.append('value_str', String(value_str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function util_simplify_fraction(numerator: number, denominator: number, n_terms: number, threshold: number): Promise<void> {
    const url = new URL(`/Gst/util_simplify_fraction`, apiConfig.baseUrl);
    url.searchParams.append('numerator', String(numerator));
    url.searchParams.append('denominator', String(denominator));
    url.searchParams.append('n_terms', String(n_terms));
    url.searchParams.append('threshold', String(threshold));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_uint64_scale(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale`, apiConfig.baseUrl);
    url.searchParams.append('val', String(val));
    url.searchParams.append('num', String(num));
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_ceil(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_ceil`, apiConfig.baseUrl);
    url.searchParams.append('val', String(val));
    url.searchParams.append('num', String(num));
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_int(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_int`, apiConfig.baseUrl);
    url.searchParams.append('val', String(val));
    url.searchParams.append('num', String(num));
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_int_ceil(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_int_ceil`, apiConfig.baseUrl);
    url.searchParams.append('val', String(val));
    url.searchParams.append('num', String(num));
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_int_round(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_int_round`, apiConfig.baseUrl);
    url.searchParams.append('val', String(val));
    url.searchParams.append('num', String(num));
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_round(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_round`, apiConfig.baseUrl);
    url.searchParams.append('val', String(val));
    url.searchParams.append('num', String(num));
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_compare(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_can_compare`, apiConfig.baseUrl);
    url.searchParams.append('value1', String(value1));
    url.searchParams.append('value2', String(value2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_intersect(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_can_intersect`, apiConfig.baseUrl);
    url.searchParams.append('value1', String(value1));
    url.searchParams.append('value2', String(value2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_subtract(minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_can_subtract`, apiConfig.baseUrl);
    url.searchParams.append('minuend', String(minuend));
    url.searchParams.append('subtrahend', String(subtrahend));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_union(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_can_union`, apiConfig.baseUrl);
    url.searchParams.append('value1', String(value1));
    url.searchParams.append('value2', String(value2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_compare(value1: GObjectValue, value2: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_compare`, apiConfig.baseUrl);
    url.searchParams.append('value1', String(value1));
    url.searchParams.append('value2', String(value2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_deserialize(src: string): Promise<boolean> {
    const url = new URL(`/Gst/value_deserialize`, apiConfig.baseUrl);
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_deserialize_with_pspec(src: string, pspec?: GObjectParamSpec): Promise<boolean> {
    const url = new URL(`/Gst/value_deserialize_with_pspec`, apiConfig.baseUrl);
    url.searchParams.append('src', String(src));
    if (pspec !== undefined) url.searchParams.append('pspec', String(pspec));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_fixate(dest: GObjectValue, src: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_fixate`, apiConfig.baseUrl);
    url.searchParams.append('dest', String(dest));
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_fraction_multiply(product: GObjectValue, factor1: GObjectValue, factor2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_fraction_multiply`, apiConfig.baseUrl);
    url.searchParams.append('product', String(product));
    url.searchParams.append('factor1', String(factor1));
    url.searchParams.append('factor2', String(factor2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_fraction_subtract(dest: GObjectValue, minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_fraction_subtract`, apiConfig.baseUrl);
    url.searchParams.append('dest', String(dest));
    url.searchParams.append('minuend', String(minuend));
    url.searchParams.append('subtrahend', String(subtrahend));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_bitmask(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_bitmask`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_caps(value_: GObjectValue): Promise<GstCaps> {
    const url = new URL(`/Gst/value_get_caps`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_caps_features(value_: GObjectValue): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/value_get_caps_features`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_double_range_max(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_double_range_max`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_double_range_min(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_double_range_min`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_flagset_flags(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_flagset_flags`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_flagset_mask(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_flagset_mask`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_denominator(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_fraction_denominator`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_numerator(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_fraction_numerator`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_range_max(value_: GObjectValue): Promise<GObjectValue> {
    const url = new URL(`/Gst/value_get_fraction_range_max`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_range_min(value_: GObjectValue): Promise<GObjectValue> {
    const url = new URL(`/Gst/value_get_fraction_range_min`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int64_range_max(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int64_range_max`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int64_range_min(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int64_range_min`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int64_range_step(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int64_range_step`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int_range_max(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int_range_max`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int_range_min(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int_range_min`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int_range_step(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int_range_step`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_structure(value_: GObjectValue): Promise<GstStructure> {
    const url = new URL(`/Gst/value_get_structure`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_init_and_copy(src: GObjectValue): Promise<{ dest?: GObjectValue }> {
    const url = new URL(`/Gst/value_init_and_copy`, apiConfig.baseUrl);
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function value_intersect(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_intersect`, apiConfig.baseUrl);
    url.searchParams.append('value1', String(value1));
    url.searchParams.append('value2', String(value2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_is_fixed(value_: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_is_fixed`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_is_subset(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_is_subset`, apiConfig.baseUrl);
    url.searchParams.append('value1', String(value1));
    url.searchParams.append('value2', String(value2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_register(table: GstValueTable): Promise<void> {
    const url = new URL(`/Gst/value_register`, apiConfig.baseUrl);
    url.searchParams.append('table', String(table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_serialize(value_: GObjectValue): Promise<string> {
    const url = new URL(`/Gst/value_serialize`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_set_bitmask(value_: GObjectValue, bitmask: number): Promise<void> {
    const url = new URL(`/Gst/value_set_bitmask`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('bitmask', String(bitmask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_caps(value_: GObjectValue, caps: GstCaps): Promise<void> {
    const url = new URL(`/Gst/value_set_caps`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('caps', String(caps));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_caps_features(value_: GObjectValue, features: GstCapsFeatures): Promise<void> {
    const url = new URL(`/Gst/value_set_caps_features`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('features', String(features));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_double_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    const url = new URL(`/Gst/value_set_double_range`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('start', String(start));
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_flagset(value_: GObjectValue, flags: number, mask: number): Promise<void> {
    const url = new URL(`/Gst/value_set_flagset`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('flags', String(flags));
    url.searchParams.append('mask', String(mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_fraction(value_: GObjectValue, numerator: number, denominator: number): Promise<void> {
    const url = new URL(`/Gst/value_set_fraction`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('numerator', String(numerator));
    url.searchParams.append('denominator', String(denominator));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_fraction_range(value_: GObjectValue, start: GObjectValue, end: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/value_set_fraction_range`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('start', String(start));
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_fraction_range_full(value_: GObjectValue, numerator_start: number, denominator_start: number, numerator_end: number, denominator_end: number): Promise<void> {
    const url = new URL(`/Gst/value_set_fraction_range_full`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('numerator_start', String(numerator_start));
    url.searchParams.append('denominator_start', String(denominator_start));
    url.searchParams.append('numerator_end', String(numerator_end));
    url.searchParams.append('denominator_end', String(denominator_end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int64_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    const url = new URL(`/Gst/value_set_int64_range`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('start', String(start));
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int64_range_step(value_: GObjectValue, start: number, end: number, step: number): Promise<void> {
    const url = new URL(`/Gst/value_set_int64_range_step`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('start', String(start));
    url.searchParams.append('end', String(end));
    url.searchParams.append('step', String(step));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    const url = new URL(`/Gst/value_set_int_range`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('start', String(start));
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int_range_step(value_: GObjectValue, start: number, end: number, step: number): Promise<void> {
    const url = new URL(`/Gst/value_set_int_range_step`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('start', String(start));
    url.searchParams.append('end', String(end));
    url.searchParams.append('step', String(step));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_structure(value_: GObjectValue, structure: GstStructure): Promise<void> {
    const url = new URL(`/Gst/value_set_structure`, apiConfig.baseUrl);
    url.searchParams.append('value', String(value_));
    url.searchParams.append('structure', String(structure));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_subtract(minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_subtract`, apiConfig.baseUrl);
    url.searchParams.append('minuend', String(minuend));
    url.searchParams.append('subtrahend', String(subtrahend));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_union(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_union`, apiConfig.baseUrl);
    url.searchParams.append('value1', String(value1));
    url.searchParams.append('value2', String(value2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function version(): Promise<{ major?: number; minor?: number; micro?: number; nano?: number }> {
    const url = new URL(`/Gst/version`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function version_string(): Promise<string> {
    const url = new URL(`/Gst/version_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
