/**
 * Gst REST API
 * Version: 1.0
 * Auto-generated by girest-client-generator
 */

// Base types
export type Pointer = string;

// Configuration for API server location
let apiConfig = {
  host: 'localhost',
  port: 9000,
  get baseUrl(): string {
    return `http://${this.host}:${this.port}`;
  }
};

/**
 * Update the API server configuration
 * @param config New configuration with host and/or port
 */
export function setApiConfig(config: { host?: string; port?: number }): void {
  if (config.host !== undefined) {
    apiConfig.host = config.host;
  }
  if (config.port !== undefined) {
    apiConfig.port = config.port;
  }
  // Reinitialize callback EventSource with new URL
  if (typeof EventSource !== 'undefined' && (config.host !== undefined || config.port !== undefined)) {
    initializeCallbackSource();
  }
}

/**
 * Get the current API server configuration
 */
export function getApiConfig(): { host: string; port: number; baseUrl: string } {
  return {
    host: apiConfig.host,
    port: apiConfig.port,
    baseUrl: apiConfig.baseUrl
  };
}

// FinalizationRegistry for automatic cleanup of GObject instances
const objectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GObject/Object/' + ptr + '/unref')
    .catch(err => console.error('Failed to unref object:', ptr, err));
});

// FinalizationRegistry for automatic cleanup of struct instances
const gstallocationparamsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/AllocationParams/{self}/free')
    .catch(err => console.error('Failed to free GstAllocationParams:', ptr, err));
});
const gobjecttypeinterfaceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GObject/TypeInterface/{self}/free')
    .catch(err => console.error('Failed to free GObjectTypeInterface:', ptr, err));
});
const gobjecttypeclassRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GObject/TypeClass/{self}/free')
    .catch(err => console.error('Failed to free GObjectTypeClass:', ptr, err));
});
const gobjectvalueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GObject/Value/{self}/free')
    .catch(err => console.error('Failed to free GObjectValue:', ptr, err));
});
const glibvariantRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/Variant/{self}/free')
    .catch(err => console.error('Failed to free GLibVariant:', ptr, err));
});
const glibvarianttypeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/VariantType/{self}/free')
    .catch(err => console.error('Failed to free GLibVariantType:', ptr, err));
});
const glibbytesRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/Bytes/{self}/free')
    .catch(err => console.error('Failed to free GLibBytes:', ptr, err));
});
const gobjecttypeinstanceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GObject/TypeInstance/{self}/free')
    .catch(err => console.error('Failed to free GObjectTypeInstance:', ptr, err));
});
const gobjectclosureRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GObject/Closure/{self}/free')
    .catch(err => console.error('Failed to free GObjectClosure:', ptr, err));
});
const gstmemoryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Memory/{self}/free')
    .catch(err => console.error('Failed to free GstMemory:', ptr, err));
});
const gstatomicqueueRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/AtomicQueue/{self}/free')
    .catch(err => console.error('Failed to free GstAtomicQueue:', ptr, err));
});
const gststructureRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Structure/{self}/free')
    .catch(err => console.error('Failed to free GstStructure:', ptr, err));
});
const gobjectvaluearrayRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GObject/ValueArray/{self}/free')
    .catch(err => console.error('Failed to free GObjectValueArray:', ptr, err));
});
const glibdateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/Date/{self}/free')
    .catch(err => console.error('Failed to free GLibDate:', ptr, err));
});
const glibtimevalRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/TimeVal/{self}/free')
    .catch(err => console.error('Failed to free GLibTimeVal:', ptr, err));
});
const gstdatetimeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/DateTime/{self}/free')
    .catch(err => console.error('Failed to free GstDateTime:', ptr, err));
});
const glibdatetimeRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/DateTime/{self}/free')
    .catch(err => console.error('Failed to free GLibDateTime:', ptr, err));
});
const glibtimezoneRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/TimeZone/{self}/free')
    .catch(err => console.error('Failed to free GLibTimeZone:', ptr, err));
});
const gststaticpadtemplateRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/StaticPadTemplate/{self}/free')
    .catch(err => console.error('Failed to free GstStaticPadTemplate:', ptr, err));
});
const gstcapsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Caps/{self}/free')
    .catch(err => console.error('Failed to free GstCaps:', ptr, err));
});
const gstcapsfeaturesRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/CapsFeatures/{self}/free')
    .catch(err => console.error('Failed to free GstCapsFeatures:', ptr, err));
});
const gstpadprobeinfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/PadProbeInfo/{self}/free')
    .catch(err => console.error('Failed to free GstPadProbeInfo:', ptr, err));
});
const gstbufferRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Buffer/{self}/free')
    .catch(err => console.error('Failed to free GstBuffer:', ptr, err));
});
const gstcustommetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/CustomMeta/{self}/free')
    .catch(err => console.error('Failed to free GstCustomMeta:', ptr, err));
});
const gstmetainfoRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/MetaInfo/{self}/free')
    .catch(err => console.error('Failed to free GstMetaInfo:', ptr, err));
});
const gstmetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Meta/{self}/free')
    .catch(err => console.error('Failed to free GstMeta:', ptr, err));
});
const gstparentbuffermetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/ParentBufferMeta/{self}/free')
    .catch(err => console.error('Failed to free GstParentBufferMeta:', ptr, err));
});
const gstprotectionmetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/ProtectionMeta/{self}/free')
    .catch(err => console.error('Failed to free GstProtectionMeta:', ptr, err));
});
const gstreferencetimestampmetaRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/ReferenceTimestampMeta/{self}/free')
    .catch(err => console.error('Failed to free GstReferenceTimestampMeta:', ptr, err));
});
const gstbufferlistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/BufferList/{self}/free')
    .catch(err => console.error('Failed to free GstBufferList:', ptr, err));
});
const gsteventRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Event/{self}/free')
    .catch(err => console.error('Failed to free GstEvent:', ptr, err));
});
const gstiteratorRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Iterator/{self}/free')
    .catch(err => console.error('Failed to free GstIterator:', ptr, err));
});
const gstsegmentRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Segment/{self}/free')
    .catch(err => console.error('Failed to free GstSegment:', ptr, err));
});
const gstmessageRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Message/{self}/free')
    .catch(err => console.error('Failed to free GstMessage:', ptr, err));
});
const gstcontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Context/{self}/free')
    .catch(err => console.error('Failed to free GstContext:', ptr, err));
});
const gsttaglistRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/TagList/{self}/free')
    .catch(err => console.error('Failed to free GstTagList:', ptr, err));
});
const gstsampleRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Sample/{self}/free')
    .catch(err => console.error('Failed to free GstSample:', ptr, err));
});
const gsttocRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Toc/{self}/free')
    .catch(err => console.error('Failed to free GstToc:', ptr, err));
});
const gsttocentryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/TocEntry/{self}/free')
    .catch(err => console.error('Failed to free GstTocEntry:', ptr, err));
});
const gstqueryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Query/{self}/free')
    .catch(err => console.error('Failed to free GstQuery:', ptr, err));
});
const glibsourceRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/Source/{self}/free')
    .catch(err => console.error('Failed to free GLibSource:', ptr, err));
});
const glibmaincontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/MainContext/{self}/free')
    .catch(err => console.error('Failed to free GLibMainContext:', ptr, err));
});
const glibcondRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/Cond/{self}/free')
    .catch(err => console.error('Failed to free GLibCond:', ptr, err));
});
const gstdebugcategoryRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/DebugCategory/{self}/free')
    .catch(err => console.error('Failed to free GstDebugCategory:', ptr, err));
});
const gstdebugmessageRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/DebugMessage/{self}/free')
    .catch(err => console.error('Failed to free GstDebugMessage:', ptr, err));
});
const gstminiobjectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/MiniObject/{self}/free')
    .catch(err => console.error('Failed to free GstMiniObject:', ptr, err));
});
const gstparsecontextRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/ParseContext/{self}/free')
    .catch(err => console.error('Failed to free GstParseContext:', ptr, err));
});
const gstpollfdRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/PollFD/{self}/free')
    .catch(err => console.error('Failed to free GstPollFD:', ptr, err));
});
const gstpollRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Poll/{self}/free')
    .catch(err => console.error('Failed to free GstPoll:', ptr, err));
});
const gstpromiseRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Promise/{self}/free')
    .catch(err => console.error('Failed to free GstPromise:', ptr, err));
});
const gststaticcapsRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/StaticCaps/{self}/free')
    .catch(err => console.error('Failed to free GstStaticCaps:', ptr, err));
});
const glibthreadRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/Thread/{self}/free')
    .catch(err => console.error('Failed to free GLibThread:', ptr, err));
});
const glibrecmutexRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/GLib/RecMutex/{self}/free')
    .catch(err => console.error('Failed to free GLibRecMutex:', ptr, err));
});
const gsttypefindRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/TypeFind/{self}/free')
    .catch(err => console.error('Failed to free GstTypeFind:', ptr, err));
});
const gsturiRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.baseUrl + '/Gst/Uri/{self}/free')
    .catch(err => console.error('Failed to free GstUri:', ptr, err));
});

// Callback dispatcher for handling callbacks from the server
const callbackDispatcher = new Map<string, Function>();

let callbackSource: EventSource | null = null;
let isReinitializing = false;

function initializeCallbackSource(): void {
  // Prevent concurrent reinitialization
  if (isReinitializing) {
    return;
  }
  isReinitializing = true;
  
  // Close existing EventSource if it exists
  if (callbackSource) {
    callbackSource.close();
    callbackSource = null;
  }
  
  // Initialize callback dispatcher with EventSource
  if (typeof EventSource !== 'undefined') {
    callbackSource = new EventSource(apiConfig.baseUrl + '/GIRest/callbacks');
    callbackSource.onmessage = (ev) => {
      try {
        const json = JSON.parse(ev.data);
        const cb = callbackDispatcher.get(json.id.toString());
        if (cb) {
          cb(...Object.values(json.data));
        }
      } catch (error) {
        console.error('Error processing callback:', error);
      }
    };
    callbackSource.onerror = (error) => {
      console.error('Callback EventSource error:', error);
    };
    callbackSource.onopen = () => {
      isReinitializing = false;
    };
  } else {
    isReinitializing = false;
  }
}

// Initialize on module load
initializeCallbackSource();

export type GLibVariantClass = "boolean" | "byte" | "int16" | "uint16" | "int32" | "uint32" | "int64" | "uint64" | "handle" | "double" | "string" | "object_path" | "signature" | "variant" | "maybe" | "array" | "tuple" | "dict_entry";
export type GObjectBindingFlags = "default" | "bidirectional" | "sync_create" | "invert_boolean";
export type GstMemoryFlags = "readonly" | "no_share" | "zero_prefixed" | "zero_padded" | "physically_contiguous" | "not_mappable" | "last";
export interface GstMapInfo {
  ptr: Pointer;
}
export type GstMapFlags = "read" | "write" | "flag_last";
export type GstAllocatorFlags = "custom_alloc" | "no_copy" | "last";
export interface GstAllocatorPrivate {
  ptr: Pointer;
}
export type GstURIType = "unknown" | "sink" | "src";
export type GstPluginDependencyFlags = "none" | "recurse" | "paths_are_default_only" | "file_name_is_suffix" | "file_name_is_prefix" | "paths_are_relative_to_exe";
export type GLibDateMonth = "bad_month" | "january" | "february" | "march" | "april" | "may" | "june" | "july" | "august" | "september" | "october" | "november" | "december";
export type GLibDateWeekday = "bad_weekday" | "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";
export type GLibTimeType = "standard" | "daylight" | "universal";
export type GstSerializeFlags = "none" | "backward_compat" | "strict";
export type GstStateChangeReturn = "failure" | "success" | "async" | "no_preroll";
export type GstState = "void_pending" | "null" | "ready" | "paused" | "playing";
export type GstPadDirection = "unknown" | "src" | "sink";
export type GstPadPresence = "always" | "sometimes" | "request";
export type GstCapsIntersectMode = "zig_zag" | "first";
export type GstPadLinkReturn = "ok" | "wrong_hierarchy" | "was_linked" | "wrong_direction" | "noformat" | "nosched" | "refused";
export namespace GstPadMode {
  export const NONE: 'none' = 'none';
  export const PUSH: 'push' = 'push';
  export const PULL: 'pull' = 'pull';
  export async function get_name(mode: GstPadModeValue): Promise<string> {
    const url = new URL(`/Gst/PadMode/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPadModeValue = "none" | "push" | "pull";
export type GstPadProbeType = "invalid" | "idle" | "block" | "buffer" | "buffer_list" | "event_downstream" | "event_upstream" | "event_flush" | "query_downstream" | "query_upstream" | "push" | "pull" | "blocking" | "data_downstream" | "data_upstream" | "data_both" | "block_downstream" | "block_upstream" | "event_both" | "query_both" | "all_both" | "scheduling";
export interface GstByteArrayInterface {
  ptr: Pointer;
}
export type GstBufferCopyFlags = "none" | "flags" | "timestamps" | "meta" | "memory" | "merge" | "deep";
export type GstBufferFlags = "live" | "decode_only" | "discont" | "resync" | "corrupted" | "marker" | "header" | "gap" | "droppable" | "delta_unit" | "tag_memory" | "sync_after" | "non_droppable" | "last";
export namespace GstFormat {
  export const UNDEFINED: 'undefined' = 'undefined';
  export const DEFAULT: 'default' = 'default';
  export const BYTES: 'bytes' = 'bytes';
  export const TIME: 'time' = 'time';
  export const BUFFERS: 'buffers' = 'buffers';
  export const PERCENT: 'percent' = 'percent';
  export async function get_by_nick(nick: string): Promise<GstFormatValue> {
    const url = new URL(`/Gst/Format/get_by_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_details(format: GstFormatValue): Promise<GstFormatDefinition> {
    const url = new URL(`/Gst/Format/get_details`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_name(format: GstFormatValue): Promise<string> {
    const url = new URL(`/Gst/Format/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function iterate_definitions(): Promise<GstIterator> {
    const url = new URL(`/Gst/Format/iterate_definitions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function register(nick: string, description: string): Promise<GstFormatValue> {
    const url = new URL(`/Gst/Format/register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(format: GstFormatValue): Promise<number> {
    const url = new URL(`/Gst/Format/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstFormatValue = "undefined" | "default" | "bytes" | "time" | "buffers" | "percent";
export interface GstFormatDefinition {
  ptr: Pointer;
}
export type GstIteratorResult = "done" | "ok" | "resync" | "error";
export namespace GstEventType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const FLUSH_START: 'flush_start' = 'flush_start';
  export const FLUSH_STOP: 'flush_stop' = 'flush_stop';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const CAPS: 'caps' = 'caps';
  export const SEGMENT: 'segment' = 'segment';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const TAG: 'tag' = 'tag';
  export const BUFFERSIZE: 'buffersize' = 'buffersize';
  export const SINK_MESSAGE: 'sink_message' = 'sink_message';
  export const STREAM_GROUP_DONE: 'stream_group_done' = 'stream_group_done';
  export const EOS: 'eos' = 'eos';
  export const TOC: 'toc' = 'toc';
  export const PROTECTION: 'protection' = 'protection';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const GAP: 'gap' = 'gap';
  export const INSTANT_RATE_CHANGE: 'instant_rate_change' = 'instant_rate_change';
  export const QOS: 'qos' = 'qos';
  export const SEEK: 'seek' = 'seek';
  export const NAVIGATION: 'navigation' = 'navigation';
  export const LATENCY: 'latency' = 'latency';
  export const STEP: 'step' = 'step';
  export const RECONFIGURE: 'reconfigure' = 'reconfigure';
  export const TOC_SELECT: 'toc_select' = 'toc_select';
  export const SELECT_STREAMS: 'select_streams' = 'select_streams';
  export const INSTANT_RATE_SYNC_TIME: 'instant_rate_sync_time' = 'instant_rate_sync_time';
  export const CUSTOM_UPSTREAM: 'custom_upstream' = 'custom_upstream';
  export const CUSTOM_DOWNSTREAM: 'custom_downstream' = 'custom_downstream';
  export const CUSTOM_DOWNSTREAM_OOB: 'custom_downstream_oob' = 'custom_downstream_oob';
  export const CUSTOM_DOWNSTREAM_STICKY: 'custom_downstream_sticky' = 'custom_downstream_sticky';
  export const CUSTOM_BOTH: 'custom_both' = 'custom_both';
  export const CUSTOM_BOTH_OOB: 'custom_both_oob' = 'custom_both_oob';
  export async function get_flags(type_: GstEventTypeValue): Promise<GstEventTypeFlags> {
    const url = new URL(`/Gst/EventType/get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_name(type_: GstEventTypeValue): Promise<string> {
    const url = new URL(`/Gst/EventType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`/Gst/EventType/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_sticky_ordering(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`/Gst/EventType/to_sticky_ordering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstEventTypeValue = "unknown" | "flush_start" | "flush_stop" | "stream_start" | "caps" | "segment" | "stream_collection" | "tag" | "buffersize" | "sink_message" | "stream_group_done" | "eos" | "toc" | "protection" | "segment_done" | "gap" | "instant_rate_change" | "qos" | "seek" | "navigation" | "latency" | "step" | "reconfigure" | "toc_select" | "select_streams" | "instant_rate_sync_time" | "custom_upstream" | "custom_downstream" | "custom_downstream_oob" | "custom_downstream_sticky" | "custom_both" | "custom_both_oob";
export type GstEventTypeFlags = "upstream" | "downstream" | "serialized" | "sticky" | "sticky_multi";
export type GstSegmentFlags = "none" | "reset" | "trickmode" | "skip" | "segment" | "trickmode_key_units" | "trickmode_forward_predicted" | "trickmode_no_audio";
export type GstQOSType = "overflow" | "underflow" | "throttle";
export type GstSeekFlags = "none" | "flush" | "accurate" | "key_unit" | "segment" | "trickmode" | "skip" | "snap_before" | "snap_after" | "snap_nearest" | "trickmode_key_units" | "trickmode_no_audio" | "trickmode_forward_predicted" | "instant_rate_change";
export type GstSeekType = "none" | "set" | "end";
export type GstClockReturn = "ok" | "early" | "unscheduled" | "busy" | "badtime" | "error" | "unsupported" | "done";
export namespace GstMessageType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const EOS: 'eos' = 'eos';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const INFO: 'info' = 'info';
  export const TAG: 'tag' = 'tag';
  export const BUFFERING: 'buffering' = 'buffering';
  export const STATE_CHANGED: 'state_changed' = 'state_changed';
  export const STATE_DIRTY: 'state_dirty' = 'state_dirty';
  export const STEP_DONE: 'step_done' = 'step_done';
  export const CLOCK_PROVIDE: 'clock_provide' = 'clock_provide';
  export const CLOCK_LOST: 'clock_lost' = 'clock_lost';
  export const NEW_CLOCK: 'new_clock' = 'new_clock';
  export const STRUCTURE_CHANGE: 'structure_change' = 'structure_change';
  export const STREAM_STATUS: 'stream_status' = 'stream_status';
  export const APPLICATION: 'application' = 'application';
  export const ELEMENT: 'element' = 'element';
  export const SEGMENT_START: 'segment_start' = 'segment_start';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const DURATION_CHANGED: 'duration_changed' = 'duration_changed';
  export const LATENCY: 'latency' = 'latency';
  export const ASYNC_START: 'async_start' = 'async_start';
  export const ASYNC_DONE: 'async_done' = 'async_done';
  export const REQUEST_STATE: 'request_state' = 'request_state';
  export const STEP_START: 'step_start' = 'step_start';
  export const QOS: 'qos' = 'qos';
  export const PROGRESS: 'progress' = 'progress';
  export const TOC: 'toc' = 'toc';
  export const RESET_TIME: 'reset_time' = 'reset_time';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const NEED_CONTEXT: 'need_context' = 'need_context';
  export const HAVE_CONTEXT: 'have_context' = 'have_context';
  export const EXTENDED: 'extended' = 'extended';
  export const DEVICE_ADDED: 'device_added' = 'device_added';
  export const DEVICE_REMOVED: 'device_removed' = 'device_removed';
  export const PROPERTY_NOTIFY: 'property_notify' = 'property_notify';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const STREAMS_SELECTED: 'streams_selected' = 'streams_selected';
  export const REDIRECT: 'redirect' = 'redirect';
  export const DEVICE_CHANGED: 'device_changed' = 'device_changed';
  export const INSTANT_RATE_REQUEST: 'instant_rate_request' = 'instant_rate_request';
  export const ANY: 'any' = 'any';
  export async function get_name(type_: GstMessageTypeValue): Promise<string> {
    const url = new URL(`/Gst/MessageType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(type_: GstMessageTypeValue): Promise<number> {
    const url = new URL(`/Gst/MessageType/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstMessageTypeValue = "unknown" | "eos" | "error" | "warning" | "info" | "tag" | "buffering" | "state_changed" | "state_dirty" | "step_done" | "clock_provide" | "clock_lost" | "new_clock" | "structure_change" | "stream_status" | "application" | "element" | "segment_start" | "segment_done" | "duration_changed" | "latency" | "async_start" | "async_done" | "request_state" | "step_start" | "qos" | "progress" | "toc" | "reset_time" | "stream_start" | "need_context" | "have_context" | "extended" | "device_added" | "device_removed" | "property_notify" | "stream_collection" | "streams_selected" | "redirect" | "device_changed" | "instant_rate_request" | "any";
export type GstProgressType = "start" | "continue" | "complete" | "canceled" | "error";
export type GstTagMergeMode = "undefined" | "replace_all" | "replace" | "append" | "prepend" | "keep" | "keep_all" | "count";
export type GstTagScope = "stream" | "global";
export namespace GstStreamType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const AUDIO: 'audio' = 'audio';
  export const VIDEO: 'video' = 'video';
  export const CONTAINER: 'container' = 'container';
  export const TEXT: 'text' = 'text';
  export async function get_name(stype: GstStreamTypeValue): Promise<string> {
    const url = new URL(`/Gst/StreamType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stype', String(stype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStreamTypeValue = "unknown" | "audio" | "video" | "container" | "text";
export type GstStreamFlags = "none" | "sparse" | "select" | "unselect";
export type GstStreamStatusType = "create" | "enter" | "leave" | "destroy" | "start" | "pause" | "stop";
export type GstStructureChangeType = "link" | "unlink";
export type GstTocScope = "global" | "current";
export namespace GstTocEntryType {
  export const ANGLE: 'angle' = 'angle';
  export const VERSION: 'version' = 'version';
  export const EDITION: 'edition' = 'edition';
  export const INVALID: 'invalid' = 'invalid';
  export const TITLE: 'title' = 'title';
  export const TRACK: 'track' = 'track';
  export const CHAPTER: 'chapter' = 'chapter';
  export async function get_nick(type_: GstTocEntryTypeValue): Promise<string> {
    const url = new URL(`/Gst/TocEntryType/get_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstTocEntryTypeValue = "angle" | "version" | "edition" | "invalid" | "title" | "track" | "chapter";
export type GstTocLoopType = "none" | "forward" | "reverse" | "ping_pong";
export type GstBufferingMode = "stream" | "download" | "timeshift" | "live";
export type GstGapFlags = "data";
export namespace GstQueryType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const POSITION: 'position' = 'position';
  export const DURATION: 'duration' = 'duration';
  export const LATENCY: 'latency' = 'latency';
  export const JITTER: 'jitter' = 'jitter';
  export const RATE: 'rate' = 'rate';
  export const SEEKING: 'seeking' = 'seeking';
  export const SEGMENT: 'segment' = 'segment';
  export const CONVERT: 'convert' = 'convert';
  export const FORMATS: 'formats' = 'formats';
  export const BUFFERING: 'buffering' = 'buffering';
  export const CUSTOM: 'custom' = 'custom';
  export const URI: 'uri' = 'uri';
  export const ALLOCATION: 'allocation' = 'allocation';
  export const SCHEDULING: 'scheduling' = 'scheduling';
  export const ACCEPT_CAPS: 'accept_caps' = 'accept_caps';
  export const CAPS: 'caps' = 'caps';
  export const DRAIN: 'drain' = 'drain';
  export const CONTEXT: 'context' = 'context';
  export const BITRATE: 'bitrate' = 'bitrate';
  export const SELECTABLE: 'selectable' = 'selectable';
  export async function get_flags(type_: GstQueryTypeValue): Promise<GstQueryTypeFlags> {
    const url = new URL(`/Gst/QueryType/get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_name(type_: GstQueryTypeValue): Promise<string> {
    const url = new URL(`/Gst/QueryType/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function to_quark(type_: GstQueryTypeValue): Promise<number> {
    const url = new URL(`/Gst/QueryType/to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstQueryTypeValue = "unknown" | "position" | "duration" | "latency" | "jitter" | "rate" | "seeking" | "segment" | "convert" | "formats" | "buffering" | "custom" | "uri" | "allocation" | "scheduling" | "accept_caps" | "caps" | "drain" | "context" | "bitrate" | "selectable";
export type GstQueryTypeFlags = "upstream" | "downstream" | "serialized";
export interface GstBufferPoolAcquireParams {
  ptr: Pointer;
}
export type GstFlowReturn = "custom_success_2" | "custom_success_1" | "custom_success" | "ok" | "not_linked" | "flushing" | "eos" | "not_negotiated" | "error" | "not_supported" | "custom_error" | "custom_error_1" | "custom_error_2";
export type GstSchedulingFlags = "seekable" | "sequential" | "bandwidth_limited";
export type GstPadProbeReturn = "drop" | "ok" | "remove" | "pass" | "handled";
export type GstTaskState = "started" | "stopped" | "paused";
export type GstPadLinkCheck = "nothing" | "hierarchy" | "template_caps" | "caps" | "no_reconfigure" | "default";
export namespace GstStateChange {
  export const NULL_TO_READY: 'null_to_ready' = 'null_to_ready';
  export const READY_TO_PAUSED: 'ready_to_paused' = 'ready_to_paused';
  export const PAUSED_TO_PLAYING: 'paused_to_playing' = 'paused_to_playing';
  export const PLAYING_TO_PAUSED: 'playing_to_paused' = 'playing_to_paused';
  export const PAUSED_TO_READY: 'paused_to_ready' = 'paused_to_ready';
  export const READY_TO_NULL: 'ready_to_null' = 'ready_to_null';
  export const NULL_TO_NULL: 'null_to_null' = 'null_to_null';
  export const READY_TO_READY: 'ready_to_ready' = 'ready_to_ready';
  export const PAUSED_TO_PAUSED: 'paused_to_paused' = 'paused_to_paused';
  export const PLAYING_TO_PLAYING: 'playing_to_playing' = 'playing_to_playing';
  export async function get_name(transition: GstStateChangeValue): Promise<string> {
    const url = new URL(`/Gst/StateChange/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('transition', String(transition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStateChangeValue = "null_to_ready" | "ready_to_paused" | "paused_to_playing" | "playing_to_paused" | "paused_to_ready" | "ready_to_null" | "null_to_null" | "ready_to_ready" | "paused_to_paused" | "playing_to_playing";
export interface GLibSourceFuncs {
  ptr: Pointer;
}
export interface GLibPollFD {
  ptr: Pointer;
}
export type GLibIOCondition = "in" | "out" | "pri" | "err" | "hup" | "nval";
export type GLibMainContextFlags = "none" | "ownerless_polling";
export interface GLibSourceCallbackFuncs {
  ptr: Pointer;
}
export type GstBusSyncReply = "drop" | "pass" | "async";
export type GstRank = "none" | "marginal" | "secondary" | "primary";
export type GstElementFlags = "locked_state" | "sink" | "source" | "provide_clock" | "require_clock" | "indexable" | "last";
export type GstBinFlags = "no_resync" | "streams_aware" | "last";
export interface GstBinPrivate {
  ptr: Pointer;
}
export type GstBufferPoolAcquireFlags = "none" | "key_unit" | "dontwait" | "discont" | "last";
export interface GstBufferPoolPrivate {
  ptr: Pointer;
}
export type GstBusFlags = "flushing" | "flag_last";
export interface GstBusPrivate {
  ptr: Pointer;
}
export type GstCapsFlags = "any";
export interface GstClockEntry {
  ptr: Pointer;
}
export type GstClockEntryType = "single" | "periodic";
export type GstClockFlags = "can_do_single_sync" | "can_do_single_async" | "can_do_periodic_sync" | "can_do_periodic_async" | "can_set_resolution" | "can_set_master" | "needs_startup_sync" | "last";
export interface GstClockPrivate {
  ptr: Pointer;
}
export type GstClockType = "realtime" | "monotonic" | "other" | "tai";
export interface GstControlBindingPrivate {
  ptr: Pointer;
}
export namespace GstCoreError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const STATE_CHANGE: 'state_change' = 'state_change';
  export const PAD: 'pad' = 'pad';
  export const THREAD: 'thread' = 'thread';
  export const NEGOTIATION: 'negotiation' = 'negotiation';
  export const EVENT: 'event' = 'event';
  export const SEEK: 'seek' = 'seek';
  export const CAPS: 'caps' = 'caps';
  export const TAG: 'tag' = 'tag';
  export const MISSING_PLUGIN: 'missing_plugin' = 'missing_plugin';
  export const CLOCK: 'clock' = 'clock';
  export const DISABLED: 'disabled' = 'disabled';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/CoreError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstCoreErrorValue = "failed" | "too_lazy" | "not_implemented" | "state_change" | "pad" | "thread" | "negotiation" | "event" | "seek" | "caps" | "tag" | "missing_plugin" | "clock" | "disabled" | "num_errors";
export namespace GstDebugLevel {
  export const NONE: 'none' = 'none';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const FIXME: 'fixme' = 'fixme';
  export const INFO: 'info' = 'info';
  export const DEBUG: 'debug' = 'debug';
  export const LOG: 'log' = 'log';
  export const TRACE: 'trace' = 'trace';
  export const MEMDUMP: 'memdump' = 'memdump';
  export const COUNT: 'count' = 'count';
  export async function get_name(level: GstDebugLevelValue): Promise<string> {
    const url = new URL(`/Gst/DebugLevel/get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstDebugLevelValue = "none" | "error" | "warning" | "fixme" | "info" | "debug" | "log" | "trace" | "memdump" | "count";
export type GstDebugColorFlags = "fg_black" | "fg_red" | "fg_green" | "fg_yellow" | "fg_blue" | "fg_magenta" | "fg_cyan" | "fg_white" | "bg_black" | "bg_red" | "bg_green" | "bg_yellow" | "bg_blue" | "bg_magenta" | "bg_cyan" | "bg_white" | "bold" | "underline";
export type GstDebugColorMode = "off" | "on" | "unix";
export type GstDebugGraphDetails = "media_type" | "caps_details" | "non_default_params" | "states" | "full_params" | "all" | "verbose";
export interface GstDeviceMonitorPrivate {
  ptr: Pointer;
}
export interface GstDevicePrivate {
  ptr: Pointer;
}
export interface GstDeviceProviderPrivate {
  ptr: Pointer;
}
export interface GstGhostPadPrivate {
  ptr: Pointer;
}
export type GstIteratorItem = "skip" | "pass" | "end";
export namespace GstLibraryError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const INIT: 'init' = 'init';
  export const SHUTDOWN: 'shutdown' = 'shutdown';
  export const SETTINGS: 'settings' = 'settings';
  export const ENCODE: 'encode' = 'encode';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/LibraryError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstLibraryErrorValue = "failed" | "too_lazy" | "init" | "shutdown" | "settings" | "encode" | "num_errors";
export type GstLockFlags = "read" | "write" | "exclusive" | "last";
export type GstMetaFlags = "none" | "readonly" | "pooled" | "locked" | "last";
export interface GstMetaTransformCopy {
  ptr: Pointer;
}
export type GstMiniObjectFlags = "lockable" | "lock_readonly" | "may_be_leaked" | "last";
export type GstObjectFlags = "may_be_leaked" | "constructed" | "last";
export type GstPadFlags = "blocked" | "flushing" | "eos" | "blocking" | "need_parent" | "need_reconfigure" | "pending_events" | "fixed_caps" | "proxy_caps" | "proxy_allocation" | "proxy_scheduling" | "accept_intersect" | "accept_template" | "last";
export interface GstPadPrivate {
  ptr: Pointer;
}
export type GstPadTemplateFlags = "last";
export interface GstParamSpecArray {
  ptr: Pointer;
}
export interface GstParamSpecFraction {
  ptr: Pointer;
}
export namespace GstParseError {
  export const SYNTAX: 'syntax' = 'syntax';
  export const NO_SUCH_ELEMENT: 'no_such_element' = 'no_such_element';
  export const NO_SUCH_PROPERTY: 'no_such_property' = 'no_such_property';
  export const LINK: 'link' = 'link';
  export const COULD_NOT_SET_PROPERTY: 'could_not_set_property' = 'could_not_set_property';
  export const EMPTY_BIN: 'empty_bin' = 'empty_bin';
  export const EMPTY: 'empty' = 'empty';
  export const DELAYED_LINK: 'delayed_link' = 'delayed_link';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/ParseError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstParseErrorValue = "syntax" | "no_such_element" | "no_such_property" | "link" | "could_not_set_property" | "empty_bin" | "empty" | "delayed_link";
export type GstParseFlags = "none" | "fatal_errors" | "no_single_element_bins" | "place_in_bin";
export type GstPipelineFlags = "fixed_clock" | "last";
export interface GstPipelinePrivate {
  ptr: Pointer;
}
export type GstPluginAPIFlags = "members";
export interface GstPluginDesc {
  ptr: Pointer;
}
export namespace GstPluginError {
  export const MODULE: 'module' = 'module';
  export const DEPENDENCIES: 'dependencies' = 'dependencies';
  export const NAME_MISMATCH: 'name_mismatch' = 'name_mismatch';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/PluginError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstPluginErrorValue = "module" | "dependencies" | "name_mismatch";
export type GstPluginFlags = "cached" | "blacklisted";
export type GstPromiseResult = "pending" | "interrupted" | "replied" | "expired";
export interface GstProxyPadPrivate {
  ptr: Pointer;
}
export interface GstRegistryPrivate {
  ptr: Pointer;
}
export namespace GstResourceError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_FOUND: 'not_found' = 'not_found';
  export const BUSY: 'busy' = 'busy';
  export const OPEN_READ: 'open_read' = 'open_read';
  export const OPEN_WRITE: 'open_write' = 'open_write';
  export const OPEN_READ_WRITE: 'open_read_write' = 'open_read_write';
  export const CLOSE: 'close' = 'close';
  export const READ: 'read' = 'read';
  export const WRITE: 'write' = 'write';
  export const SEEK: 'seek' = 'seek';
  export const SYNC: 'sync' = 'sync';
  export const SETTINGS: 'settings' = 'settings';
  export const NO_SPACE_LEFT: 'no_space_left' = 'no_space_left';
  export const NOT_AUTHORIZED: 'not_authorized' = 'not_authorized';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/ResourceError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstResourceErrorValue = "failed" | "too_lazy" | "not_found" | "busy" | "open_read" | "open_write" | "open_read_write" | "close" | "read" | "write" | "seek" | "sync" | "settings" | "no_space_left" | "not_authorized" | "num_errors";
export type GstSearchMode = "exact" | "before" | "after";
export interface GstSharedTaskPoolPrivate {
  ptr: Pointer;
}
export type GstStackTraceFlags = "none" | "full";
export interface GstStreamCollectionPrivate {
  ptr: Pointer;
}
export namespace GstStreamError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const TYPE_NOT_FOUND: 'type_not_found' = 'type_not_found';
  export const WRONG_TYPE: 'wrong_type' = 'wrong_type';
  export const CODEC_NOT_FOUND: 'codec_not_found' = 'codec_not_found';
  export const DECODE: 'decode' = 'decode';
  export const ENCODE: 'encode' = 'encode';
  export const DEMUX: 'demux' = 'demux';
  export const MUX: 'mux' = 'mux';
  export const FORMAT: 'format' = 'format';
  export const DECRYPT: 'decrypt' = 'decrypt';
  export const DECRYPT_NOKEY: 'decrypt_nokey' = 'decrypt_nokey';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/StreamError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstStreamErrorValue = "failed" | "too_lazy" | "not_implemented" | "type_not_found" | "wrong_type" | "codec_not_found" | "decode" | "encode" | "demux" | "mux" | "format" | "decrypt" | "decrypt_nokey" | "num_errors";
export interface GstStreamPrivate {
  ptr: Pointer;
}
export interface GstSystemClockPrivate {
  ptr: Pointer;
}
export type GstTagFlag = "undefined" | "meta" | "encoded" | "decoded" | "count";
export interface GstTaskPrivate {
  ptr: Pointer;
}
export interface GstTimedValue {
  ptr: Pointer;
}
export interface GstTracerPrivate {
  ptr: Pointer;
}
export type GstTracerValueFlags = "none" | "optional" | "aggregated";
export type GstTracerValueScope = "process" | "thread" | "element" | "pad";
export type GstTypeFindProbability = "none" | "minimum" | "possible" | "likely" | "nearly_certain" | "maximum";
export namespace GstURIError {
  export const UNSUPPORTED_PROTOCOL: 'unsupported_protocol' = 'unsupported_protocol';
  export const BAD_URI: 'bad_uri' = 'bad_uri';
  export const BAD_STATE: 'bad_state' = 'bad_state';
  export const BAD_REFERENCE: 'bad_reference' = 'bad_reference';
  export async function quark(): Promise<number> {
    const url = new URL(`/Gst/URIError/quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
export type GstURIErrorValue = "unsupported_protocol" | "bad_uri" | "bad_state" | "bad_reference";
export interface GstValueTable {
  ptr: Pointer;
}
export type GObjectParamFlags = "readable" | "writable" | "readwrite" | "construct" | "construct_only" | "lax_validation" | "static_name" | "private" | "static_nick" | "static_blurb" | "explicit_notify" | "deprecated";

export class GLibBytes {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibbytesRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibbytesRegistry.unregister(this);
    const url = new URL(`/GLib/Bytes/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(size: number, data_?: Pointer): Promise<GLibBytes> {
    const url = new URL(`/GLib/Bytes/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibBytes();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_take(size: number, data_?: Pointer): Promise<GLibBytes> {
    const url = new URL(`/GLib/Bytes/new_take`, apiConfig.baseUrl);
    // Primitive parameter
    if (data_ !== undefined) url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibBytes();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async compare(bytes2: GLibBytes): Promise<number> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes2 && typeof bytes2 === 'object' && 'ptr' in bytes2) {
      url.searchParams.append('bytes2', 'ptr,' + bytes2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async equal(bytes2: GLibBytes): Promise<boolean> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes2 && typeof bytes2 === 'object' && 'ptr' in bytes2) {
      url.searchParams.append('bytes2', 'ptr,' + bytes2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_data(): Promise<Pointer> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/get_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_region(element_size: number, offset: number, n_elements: number): Promise<void> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/get_region`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('element_size', String(element_size));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('n_elements', String(n_elements));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_size(): Promise<number> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async hash(): Promise<number> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async new_from_bytes(offset: number, length: number): Promise<GLibBytes> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/new_from_bytes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ref(): Promise<GLibBytes> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref_to_array(): Promise<Pointer> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/unref_to_array`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unref_to_data(): Promise<Pointer> {
    const url = new URL(`/GLib/Bytes/ptr,${this.ptr}/unref_to_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GLibCond {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibcondRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibcondRegistry.unregister(this);
    const url = new URL(`/GLib/Cond/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibCond> {
    const url = new URL(`/GLib/Cond/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibCond();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async broadcast(): Promise<void> {
    const url = new URL(`/GLib/Cond/ptr,${this.ptr}/broadcast`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async clear(): Promise<void> {
    const url = new URL(`/GLib/Cond/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async init(): Promise<void> {
    const url = new URL(`/GLib/Cond/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async signal(): Promise<void> {
    const url = new URL(`/GLib/Cond/ptr,${this.ptr}/signal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait(mutex: Pointer): Promise<void> {
    const url = new URL(`/GLib/Cond/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mutex', String(mutex));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait_until(mutex: Pointer, end_time: number): Promise<boolean> {
    const url = new URL(`/GLib/Cond/ptr,${this.ptr}/wait_until`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mutex', String(mutex));
    // Primitive parameter
    url.searchParams.append('end_time', String(end_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GLibDate {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibdateRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibdateRegistry.unregister(this);
    const url = new URL(`/GLib/Date/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibDate> {
    const url = new URL(`/GLib/Date/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_dmy(day: number, month: GLibDateMonth, year: number): Promise<GLibDate> {
    const url = new URL(`/GLib/Date/new_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_julian(julian_day: number): Promise<GLibDate> {
    const url = new URL(`/GLib/Date/new_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_day', String(julian_day));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDate();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_days(n_days: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/add_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_days', String(n_days));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_months(n_months: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/add_months`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_months', String(n_months));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_years(n_years: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/add_years`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_years', String(n_years));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async clamp(min_date: GLibDate, max_date: GLibDate): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/clamp`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (min_date && typeof min_date === 'object' && 'ptr' in min_date) {
      url.searchParams.append('min_date', 'ptr,' + min_date.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (max_date && typeof max_date === 'object' && 'ptr' in max_date) {
      url.searchParams.append('max_date', 'ptr,' + max_date.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async clear(n_dates: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_dates', String(n_dates));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async compare(rhs: GLibDate): Promise<number> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (rhs && typeof rhs === 'object' && 'ptr' in rhs) {
      url.searchParams.append('rhs', 'ptr,' + rhs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GLibDate> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDate(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async days_between(date2: GLibDate): Promise<number> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/days_between`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (date2 && typeof date2 === 'object' && 'ptr' in date2) {
      url.searchParams.append('date2', 'ptr,' + date2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day(): Promise<number> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/get_day`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day_of_year(): Promise<number> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/get_day_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_iso8601_week_of_year(): Promise<number> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/get_iso8601_week_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_julian(): Promise<number> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/get_julian`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_monday_week_of_year(): Promise<number> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/get_monday_week_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_month(): Promise<GLibDateMonth> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/get_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sunday_week_of_year(): Promise<number> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/get_sunday_week_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_weekday(): Promise<GLibDateWeekday> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/get_weekday`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_year(): Promise<number> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/get_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_first_of_month(): Promise<boolean> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/is_first_of_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_last_of_month(): Promise<boolean> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/is_last_of_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async order(date2: GLibDate): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/order`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (date2 && typeof date2 === 'object' && 'ptr' in date2) {
      url.searchParams.append('date2', 'ptr,' + date2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_day(day: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/set_day`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_dmy(day: number, month: GLibDateMonth, y: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/set_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('y', String(y));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_julian(julian_date: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/set_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_date', String(julian_date));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_month(month: GLibDateMonth): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/set_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_parse(str: string): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/set_parse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_time(time_: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/set_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time_', String(time_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_time_t(timet: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/set_time_t`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timet', String(timet));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_time_val(timeval: GLibTimeVal): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/set_time_val`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (timeval && typeof timeval === 'object' && 'ptr' in timeval) {
      url.searchParams.append('timeval', 'ptr,' + timeval.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_year(year: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/set_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async subtract_days(n_days: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/subtract_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_days', String(n_days));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async subtract_months(n_months: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/subtract_months`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_months', String(n_months));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async subtract_years(n_years: number): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/subtract_years`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_years', String(n_years));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async to_struct_tm(): Promise<void> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/to_struct_tm`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async valid(): Promise<boolean> {
    const url = new URL(`/GLib/Date/ptr,${this.ptr}/valid`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_days_in_month(month: GLibDateMonth, year: number): Promise<number> {
    const url = new URL(`/GLib/Date/get_days_in_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_monday_weeks_in_year(year: number): Promise<number> {
    const url = new URL(`/GLib/Date/get_monday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sunday_weeks_in_year(year: number): Promise<number> {
    const url = new URL(`/GLib/Date/get_sunday_weeks_in_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_leap_year(year: number): Promise<boolean> {
    const url = new URL(`/GLib/Date/is_leap_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async strftime(s: string, slen: number, format: string, date: GLibDate): Promise<number> {
    const url = new URL(`/GLib/Date/strftime`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s', String(s));
    // Primitive parameter
    url.searchParams.append('slen', String(slen));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Object with explode=false: serialize as comma-separated
    if (date && typeof date === 'object' && 'ptr' in date) {
      url.searchParams.append('date', 'ptr,' + date.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async valid_day(day: number): Promise<boolean> {
    const url = new URL(`/GLib/Date/valid_day`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async valid_dmy(day: number, month: GLibDateMonth, year: number): Promise<boolean> {
    const url = new URL(`/GLib/Date/valid_dmy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async valid_julian(julian_date: number): Promise<boolean> {
    const url = new URL(`/GLib/Date/valid_julian`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('julian_date', String(julian_date));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async valid_month(month: GLibDateMonth): Promise<boolean> {
    const url = new URL(`/GLib/Date/valid_month`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('month', String(month));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async valid_weekday(weekday: GLibDateWeekday): Promise<boolean> {
    const url = new URL(`/GLib/Date/valid_weekday`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('weekday', String(weekday));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async valid_year(year: number): Promise<boolean> {
    const url = new URL(`/GLib/Date/valid_year`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GLibDateTime {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibdatetimeRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibdatetimeRegistry.unregister(this);
    const url = new URL(`/GLib/DateTime/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(tz: GLibTimeZone, year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tz && typeof tz === 'object' && 'ptr' in tz) {
      url.searchParams.append('tz', 'ptr,' + tz.ptr);
    }
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_iso8601(text: string, default_tz?: GLibTimeZone): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_from_iso8601`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Object with explode=false: serialize as comma-separated
    if (default_tz !== undefined && typeof default_tz === 'object' && 'ptr' in default_tz) {
      url.searchParams.append('default_tz', 'ptr,' + default_tz.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_timeval_local(tv: GLibTimeVal): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_from_timeval_local`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tv && typeof tv === 'object' && 'ptr' in tv) {
      url.searchParams.append('tv', 'ptr,' + tv.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_timeval_utc(tv: GLibTimeVal): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_from_timeval_utc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tv && typeof tv === 'object' && 'ptr' in tv) {
      url.searchParams.append('tv', 'ptr,' + tv.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_local(t: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_from_unix_local`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('t', String(t));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_local_usec(usecs: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_from_unix_local_usec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_utc(t: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_from_unix_utc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('t', String(t));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_utc_usec(usecs: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_from_unix_utc_usec`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_local(year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_local`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now(tz: GLibTimeZone): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_now`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tz && typeof tz === 'object' && 'ptr' in tz) {
      url.searchParams.append('tz', 'ptr,' + tz.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now_local(): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_now_local`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now_utc(): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_now_utc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_utc(year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/new_utc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(timespan: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timespan', String(timespan));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_days(days: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/add_days`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('days', String(days));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_full(years: number, months: number, days: number, hours: number, minutes: number, seconds: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/add_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('years', String(years));
    // Primitive parameter
    url.searchParams.append('months', String(months));
    // Primitive parameter
    url.searchParams.append('days', String(days));
    // Primitive parameter
    url.searchParams.append('hours', String(hours));
    // Primitive parameter
    url.searchParams.append('minutes', String(minutes));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_hours(hours: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/add_hours`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('hours', String(hours));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_minutes(minutes: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/add_minutes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('minutes', String(minutes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_months(months: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/add_months`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('months', String(months));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_seconds(seconds: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/add_seconds`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_weeks(weeks: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/add_weeks`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('weeks', String(weeks));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_years(years: number): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/add_years`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('years', String(years));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async compare(dt2: GLibDateTime): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dt2 && typeof dt2 === 'object' && 'ptr' in dt2) {
      url.searchParams.append('dt2', 'ptr,' + dt2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async difference(begin: GLibDateTime): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/difference`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (begin && typeof begin === 'object' && 'ptr' in begin) {
      url.searchParams.append('begin', 'ptr,' + begin.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async equal(dt2: GLibDateTime): Promise<boolean> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dt2 && typeof dt2 === 'object' && 'ptr' in dt2) {
      url.searchParams.append('dt2', 'ptr,' + dt2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async format(format: string): Promise<string> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/format`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async format_iso8601(): Promise<string> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/format_iso8601`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day_of_month(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_day_of_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day_of_week(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_day_of_week`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_day_of_year(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_day_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_hour(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_hour`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_microsecond(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_microsecond`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_minute(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_minute`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_month(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_second(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_second`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_seconds(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_seconds`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_timezone(): Promise<GLibTimeZone> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_timezone`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTimeZone(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_timezone_abbreviation(): Promise<string> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_timezone_abbreviation`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_utc_offset(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_utc_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_week_numbering_year(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_week_numbering_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_week_of_year(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_week_of_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_year(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_ymd(): Promise<{ year?: number; month?: number; day?: number }> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/get_ymd`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async hash(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_daylight_savings(): Promise<boolean> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/is_daylight_savings`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_local(): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/to_local`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_timeval(tv: GLibTimeVal): Promise<boolean> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/to_timeval`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tv && typeof tv === 'object' && 'ptr' in tv) {
      url.searchParams.append('tv', 'ptr,' + tv.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_timezone(tz: GLibTimeZone): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/to_timezone`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tz && typeof tz === 'object' && 'ptr' in tz) {
      url.searchParams.append('tz', 'ptr,' + tz.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_unix(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/to_unix`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_unix_usec(): Promise<number> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/to_unix_usec`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_utc(): Promise<GLibDateTime> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/to_utc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`/GLib/DateTime/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GLibMainContext {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibmaincontextRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibmaincontextRegistry.unregister(this);
    const url = new URL(`/GLib/MainContext/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibMainContext> {
    const url = new URL(`/GLib/MainContext/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibMainContext();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_with_flags(flags: GLibMainContextFlags): Promise<GLibMainContext> {
    const url = new URL(`/GLib/MainContext/new_with_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibMainContext();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async acquire(): Promise<boolean> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/acquire`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_poll(fd: GLibPollFD, priority: number): Promise<void> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/add_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async check(max_priority: number, fds: Pointer, n_fds: number): Promise<boolean> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/check`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_priority', String(max_priority));
    // Primitive parameter
    url.searchParams.append('fds', String(fds));
    // Primitive parameter
    url.searchParams.append('n_fds', String(n_fds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dispatch(): Promise<void> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/dispatch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async find_source_by_funcs_user_data(funcs: GLibSourceFuncs): Promise<GLibSource> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/find_source_by_funcs_user_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async find_source_by_id(source_id: number): Promise<GLibSource> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/find_source_by_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_id', String(source_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async find_source_by_user_data(): Promise<GLibSource> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/find_source_by_user_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async invoke_full(priority: number, function_: (user_data: Pointer) => boolean): Promise<{ function_?: number }> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/invoke_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.function !== undefined) {
      callbackDispatcher.set(data.function.toString(), function_);
    }
    return data;
  }
  async is_owner(): Promise<boolean> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/is_owner`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iteration(may_block: boolean): Promise<boolean> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/iteration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('may_block', String(may_block));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pending(): Promise<boolean> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/pending`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pop_thread_default(): Promise<void> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/pop_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async prepare(): Promise<boolean> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/prepare`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push_thread_default(): Promise<void> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/push_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async query(max_priority: number, n_fds: number): Promise<number> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/query`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_priority', String(max_priority));
    // Primitive parameter
    url.searchParams.append('n_fds', String(n_fds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibMainContext> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async release(): Promise<void> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/release`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_poll(fd: GLibPollFD): Promise<void> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/remove_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait(cond: GLibCond, mutex: Pointer): Promise<boolean> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (cond && typeof cond === 'object' && 'ptr' in cond) {
      url.searchParams.append('cond', 'ptr,' + cond.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mutex', String(mutex));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async wakeup(): Promise<void> {
    const url = new URL(`/GLib/MainContext/ptr,${this.ptr}/wakeup`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async default(): Promise<GLibMainContext> {
    const url = new URL(`/GLib/MainContext/default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_thread_default(): Promise<GLibMainContext> {
    const url = new URL(`/GLib/MainContext/get_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ref_thread_default(): Promise<GLibMainContext> {
    const url = new URL(`/GLib/MainContext/ref_thread_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GLibRecMutex {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibrecmutexRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibrecmutexRegistry.unregister(this);
    const url = new URL(`/GLib/RecMutex/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibRecMutex> {
    const url = new URL(`/GLib/RecMutex/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibRecMutex();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clear(): Promise<void> {
    const url = new URL(`/GLib/RecMutex/ptr,${this.ptr}/clear`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async init(): Promise<void> {
    const url = new URL(`/GLib/RecMutex/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async lock(): Promise<void> {
    const url = new URL(`/GLib/RecMutex/ptr,${this.ptr}/lock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async trylock(): Promise<boolean> {
    const url = new URL(`/GLib/RecMutex/ptr,${this.ptr}/trylock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unlock(): Promise<void> {
    const url = new URL(`/GLib/RecMutex/ptr,${this.ptr}/unlock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GLibSource {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibsourceRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibsourceRegistry.unregister(this);
    const url = new URL(`/GLib/Source/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(source_funcs: GLibSourceFuncs, struct_size: number): Promise<GLibSource> {
    const url = new URL(`/GLib/Source/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (source_funcs && typeof source_funcs === 'object' && 'ptr' in source_funcs) {
      url.searchParams.append('source_funcs', 'ptr,' + source_funcs.ptr);
    }
    // Primitive parameter
    url.searchParams.append('struct_size', String(struct_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibSource();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_child_source(child_source: GLibSource): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/add_child_source`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_source && typeof child_source === 'object' && 'ptr' in child_source) {
      url.searchParams.append('child_source', 'ptr,' + child_source.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_poll(fd: GLibPollFD): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/add_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_unix_fd(fd: number, events: GLibIOCondition): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/add_unix_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fd', String(fd));
    // Primitive parameter
    url.searchParams.append('events', String(events));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async attach(context?: GLibMainContext): Promise<number> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/attach`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async destroy(): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/destroy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_can_recurse(): Promise<boolean> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/get_can_recurse`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_context(): Promise<GLibMainContext> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/get_context`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibMainContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_current_time(timeval: GLibTimeVal): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/get_current_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (timeval && typeof timeval === 'object' && 'ptr' in timeval) {
      url.searchParams.append('timeval', 'ptr,' + timeval.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_id(): Promise<number> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/get_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_priority(): Promise<number> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/get_priority`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_ready_time(): Promise<number> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/get_ready_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_time(): Promise<number> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/get_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_destroyed(): Promise<boolean> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/is_destroyed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async modify_unix_fd(new_events: GLibIOCondition): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/modify_unix_fd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('new_events', String(new_events));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async query_unix_fd(): Promise<GLibIOCondition> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/query_unix_fd`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibSource> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove_child_source(child_source: GLibSource): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/remove_child_source`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_source && typeof child_source === 'object' && 'ptr' in child_source) {
      url.searchParams.append('child_source', 'ptr,' + child_source.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_poll(fd: GLibPollFD): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/remove_poll`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_unix_fd(): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/remove_unix_fd`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_callback(func: (user_data: Pointer) => boolean): Promise<{ func?: number }> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/set_callback`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async set_callback_indirect(callback_funcs: GLibSourceCallbackFuncs): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/set_callback_indirect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (callback_funcs && typeof callback_funcs === 'object' && 'ptr' in callback_funcs) {
      url.searchParams.append('callback_funcs', 'ptr,' + callback_funcs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_can_recurse(can_recurse: boolean): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/set_can_recurse`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('can_recurse', String(can_recurse));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_funcs(funcs: GLibSourceFuncs): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/set_funcs`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_name(name: string): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_priority(priority: number): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/set_priority`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_ready_time(ready_time: number): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/set_ready_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ready_time', String(ready_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_static_name(name: string): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/set_static_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`/GLib/Source/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove(tag: number): Promise<boolean> {
    const url = new URL(`/GLib/Source/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_by_funcs_user_data(funcs: GLibSourceFuncs): Promise<boolean> {
    const url = new URL(`/GLib/Source/remove_by_funcs_user_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (funcs && typeof funcs === 'object' && 'ptr' in funcs) {
      url.searchParams.append('funcs', 'ptr,' + funcs.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_by_user_data(): Promise<boolean> {
    const url = new URL(`/GLib/Source/remove_by_user_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_name_by_id(tag: number, name: string): Promise<void> {
    const url = new URL(`/GLib/Source/set_name_by_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GLibThread {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibthreadRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibthreadRegistry.unregister(this);
    const url = new URL(`/GLib/Thread/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(func: (data_: Pointer) => void, name?: string): Promise<GLibThread> {
    const url = new URL(`/GLib/Thread/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    const instance = new GLibThread();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async try_new(func: (data_: Pointer) => void, name?: string): Promise<GLibThread> {
    const url = new URL(`/GLib/Thread/try_new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    const instance = new GLibThread();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async join(): Promise<void> {
    const url = new URL(`/GLib/Thread/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GLibThread> {
    const url = new URL(`/GLib/Thread/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibThread(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`/GLib/Thread/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async error_quark(): Promise<number> {
    const url = new URL(`/GLib/Thread/error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async exit(): Promise<void> {
    const url = new URL(`/GLib/Thread/exit`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async self(): Promise<GLibThread> {
    const url = new URL(`/GLib/Thread/self`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibThread(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async yield(): Promise<void> {
    const url = new URL(`/GLib/Thread/yield`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GLibTimeVal {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtimevalRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtimevalRegistry.unregister(this);
    const url = new URL(`/GLib/TimeVal/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GLibTimeVal> {
    const url = new URL(`/GLib/TimeVal/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeVal();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(microseconds: number): Promise<void> {
    const url = new URL(`/GLib/TimeVal/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('microseconds', String(microseconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async to_iso8601(): Promise<string> {
    const url = new URL(`/GLib/TimeVal/ptr,${this.ptr}/to_iso8601`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async from_iso8601(iso_date: string, time_: GLibTimeVal): Promise<boolean> {
    const url = new URL(`/GLib/TimeVal/from_iso8601`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iso_date', String(iso_date));
    // Object with explode=false: serialize as comma-separated
    if (time_ && typeof time_ === 'object' && 'ptr' in time_) {
      url.searchParams.append('time_', 'ptr,' + time_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GLibTimeZone {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibtimezoneRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibtimezoneRegistry.unregister(this);
    const url = new URL(`/GLib/TimeZone/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(identifier?: string): Promise<GLibTimeZone> {
    const url = new URL(`/GLib/TimeZone/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (identifier !== undefined) url.searchParams.append('identifier', String(identifier));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_identifier(identifier?: string): Promise<GLibTimeZone> {
    const url = new URL(`/GLib/TimeZone/new_identifier`, apiConfig.baseUrl);
    // Primitive parameter
    if (identifier !== undefined) url.searchParams.append('identifier', String(identifier));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_local(): Promise<GLibTimeZone> {
    const url = new URL(`/GLib/TimeZone/new_local`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_offset(seconds: number): Promise<GLibTimeZone> {
    const url = new URL(`/GLib/TimeZone/new_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_utc(): Promise<GLibTimeZone> {
    const url = new URL(`/GLib/TimeZone/new_utc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibTimeZone();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async adjust_time(type_: GLibTimeType, time_: number): Promise<number> {
    const url = new URL(`/GLib/TimeZone/ptr,${this.ptr}/adjust_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('time_', String(time_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async find_interval(type_: GLibTimeType, time_: number): Promise<number> {
    const url = new URL(`/GLib/TimeZone/ptr,${this.ptr}/find_interval`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('time_', String(time_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_abbreviation(interval: number): Promise<string> {
    const url = new URL(`/GLib/TimeZone/ptr,${this.ptr}/get_abbreviation`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_identifier(): Promise<string> {
    const url = new URL(`/GLib/TimeZone/ptr,${this.ptr}/get_identifier`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_offset(interval: number): Promise<number> {
    const url = new URL(`/GLib/TimeZone/ptr,${this.ptr}/get_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_dst(interval: number): Promise<boolean> {
    const url = new URL(`/GLib/TimeZone/ptr,${this.ptr}/is_dst`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibTimeZone> {
    const url = new URL(`/GLib/TimeZone/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibTimeZone(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`/GLib/TimeZone/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GLibVariant {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibvariantRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibvariantRegistry.unregister(this);
    const url = new URL(`/GLib/Variant/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_array(n_children: number, child_type?: GLibVariantType, children?: Pointer): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_type !== undefined && typeof child_type === 'object' && 'ptr' in child_type) {
      url.searchParams.append('child_type', 'ptr,' + child_type.ptr);
    }
    // Primitive parameter
    if (children !== undefined) url.searchParams.append('children', String(children));
    // Primitive parameter
    url.searchParams.append('n_children', String(n_children));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_boolean(value_: boolean): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_byte(value_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_byte`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_bytestring(string: Pointer): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_bytestring`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_bytestring_array(strv: Pointer, length: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_bytestring_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_dict_entry(key: GLibVariant, value_: GLibVariant): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_dict_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (key && typeof key === 'object' && 'ptr' in key) {
      url.searchParams.append('key', 'ptr,' + key.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_double(value_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_fixed_array(element_type: GLibVariantType, n_elements: number, element_size: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_fixed_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element_type && typeof element_type === 'object' && 'ptr' in element_type) {
      url.searchParams.append('element_type', 'ptr,' + element_type.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_elements', String(n_elements));
    // Primitive parameter
    url.searchParams.append('element_size', String(element_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_bytes(type_: GLibVariantType, bytes: GLibBytes, trusted: boolean): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_from_bytes`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (bytes && typeof bytes === 'object' && 'ptr' in bytes) {
      url.searchParams.append('bytes', 'ptr,' + bytes.ptr);
    }
    // Primitive parameter
    url.searchParams.append('trusted', String(trusted));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_data(type_: GLibVariantType, data_: Pointer, size: number, trusted: boolean, notify: (data_: Pointer) => void): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_from_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('trusted', String(trusted));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.notify !== undefined) {
      callbackDispatcher.set(data.notify.toString(), notify);
    }
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_handle(value_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_handle`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_int16(value_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_int16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_int32(value_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_int32`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_int64(value_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_maybe(child_type?: GLibVariantType, child?: GLibVariant): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_maybe`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (child_type !== undefined && typeof child_type === 'object' && 'ptr' in child_type) {
      url.searchParams.append('child_type', 'ptr,' + child_type.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (child !== undefined && typeof child === 'object' && 'ptr' in child) {
      url.searchParams.append('child', 'ptr,' + child.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_object_path(object_path: string): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_object_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('object_path', String(object_path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_objv(strv: Pointer, length: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_objv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_signature(signature: string): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_signature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('signature', String(signature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_string(string: string): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_strv(strv: Pointer, length: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_strv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('strv', String(strv));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_tuple(children: Pointer, n_children: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_tuple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('children', String(children));
    // Primitive parameter
    url.searchParams.append('n_children', String(n_children));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_uint16(value_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_uint16`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_uint32(value_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_uint32`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_uint64(value_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_variant(value_: GLibVariant): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/new_variant`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariant();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async byteswap(): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/byteswap`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async check_format_string(format_string: string, copy_only: boolean): Promise<boolean> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/check_format_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format_string', String(format_string));
    // Primitive parameter
    url.searchParams.append('copy_only', String(copy_only));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async classify(): Promise<GLibVariantClass> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/classify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async compare(two: GLibVariant): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (two && typeof two === 'object' && 'ptr' in two) {
      url.searchParams.append('two', 'ptr,' + two.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_bytestring(): Promise<Pointer> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/dup_bytestring`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_bytestring_array(): Promise<Pointer> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/dup_bytestring_array`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_objv(): Promise<Pointer> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/dup_objv`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_string(): Promise<string> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/dup_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_strv(): Promise<Pointer> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/dup_strv`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async equal(two: GLibVariant): Promise<boolean> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (two && typeof two === 'object' && 'ptr' in two) {
      url.searchParams.append('two', 'ptr,' + two.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boolean(): Promise<boolean> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_byte(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_byte`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bytestring(): Promise<Pointer> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_bytestring`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bytestring_array(): Promise<Pointer> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_bytestring_array`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_child_value(index_: number): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_child_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_data(): Promise<void> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_data_as_bytes(): Promise<GLibBytes> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_data_as_bytes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibBytes(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_double(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_handle(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_handle`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int16(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_int16`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int32(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_int32`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_maybe(): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_maybe`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_normal_form(): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_normal_form`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_objv(): Promise<Pointer> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_objv`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_size(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string(): Promise<string> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_strv(): Promise<Pointer> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_strv`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_type(): Promise<GLibVariantType> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_type_string(): Promise<string> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_type_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint16(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_uint16`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint32(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_uint32`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_variant(): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/get_variant`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async hash(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_container(): Promise<boolean> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/is_container`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_floating(): Promise<boolean> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/is_floating`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_normal_form(): Promise<boolean> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/is_normal_form`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_of_type(type_: GLibVariantType): Promise<boolean> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/is_of_type`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lookup_value(key: string, expected_type?: GLibVariantType): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/lookup_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    // Object with explode=false: serialize as comma-separated
    if (expected_type !== undefined && typeof expected_type === 'object' && 'ptr' in expected_type) {
      url.searchParams.append('expected_type', 'ptr,' + expected_type.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async n_children(): Promise<number> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/n_children`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async print(type_annotate: boolean): Promise<string> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/print`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_annotate', String(type_annotate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ref_sink(): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/ref_sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async store(): Promise<void> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/store`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async take_ref(): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/take_ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`/GLib/Variant/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_object_path(string: string): Promise<boolean> {
    const url = new URL(`/GLib/Variant/is_object_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_signature(string: string): Promise<boolean> {
    const url = new URL(`/GLib/Variant/is_signature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse(text: string, type_?: GLibVariantType, limit?: string, endptr?: string): Promise<GLibVariant> {
    const url = new URL(`/GLib/Variant/parse`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type_ !== undefined && typeof type_ === 'object' && 'ptr' in type_) {
      url.searchParams.append('type', 'ptr,' + type_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('text', String(text));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    // Primitive parameter
    if (endptr !== undefined) url.searchParams.append('endptr', String(endptr));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async parse_error_print_context(error_: Pointer, source_str: string): Promise<string> {
    const url = new URL(`/GLib/Variant/parse_error_print_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('source_str', String(source_str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_error_quark(): Promise<number> {
    const url = new URL(`/GLib/Variant/parse_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parser_get_error_quark(): Promise<number> {
    const url = new URL(`/GLib/Variant/parser_get_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GLibVariantType {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      glibvarianttypeRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    glibvarianttypeRegistry.unregister(this);
    const url = new URL(`/GLib/VariantType/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(type_string: string): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_array(element: GLibVariantType): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/new_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_dict_entry(key: GLibVariantType, value_: GLibVariantType): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/new_dict_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (key && typeof key === 'object' && 'ptr' in key) {
      url.searchParams.append('key', 'ptr,' + key.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_maybe(element: GLibVariantType): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/new_maybe`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_tuple(items: Pointer, length: number): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/new_tuple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('items', String(items));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GLibVariantType();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async dup_string(): Promise<string> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/dup_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async element(): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/element`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async equal(type2: GLibVariantType): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (type2 && typeof type2 === 'object' && 'ptr' in type2) {
      url.searchParams.append('type2', 'ptr,' + type2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async first(): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/first`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_string_length(): Promise<number> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/get_string_length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async hash(): Promise<number> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/hash`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_array(): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/is_array`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_basic(): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/is_basic`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_container(): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/is_container`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_definite(): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/is_definite`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_dict_entry(): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/is_dict_entry`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_maybe(): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/is_maybe`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subtype_of(supertype: GLibVariantType): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/is_subtype_of`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (supertype && typeof supertype === 'object' && 'ptr' in supertype) {
      url.searchParams.append('supertype', 'ptr,' + supertype.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_tuple(): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/is_tuple`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_variant(): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/is_variant`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async key(): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/key`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async n_items(): Promise<number> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/n_items`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async next(): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async value(): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/ptr,${this.ptr}/value`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async checked_(type_string: string): Promise<GLibVariantType> {
    const url = new URL(`/GLib/VariantType/checked_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariantType(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async string_get_depth_(type_string: string): Promise<number> {
    const url = new URL(`/GLib/VariantType/string_get_depth_`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async string_is_valid(type_string: string): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/string_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type_string', String(type_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async string_scan(string: string, limit?: string): Promise<boolean> {
    const url = new URL(`/GLib/VariantType/string_scan`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    // Primitive parameter
    if (limit !== undefined) url.searchParams.append('limit', String(limit));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GObjectObject {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      objectRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  unref(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    objectRegistry.unregister(this);
    return fetch(apiConfig.baseUrl + '/GObject/Object/' + this.ptr + '/unref')
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
  static async newv(object_type: Pointer, n_parameters: number, parameters: Pointer): Promise<GObjectObject> {
    const url = new URL(`/GObject/Object/newv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('object_type', String(object_type));
    // Primitive parameter
    url.searchParams.append('n_parameters', String(n_parameters));
    // Primitive parameter
    url.searchParams.append('parameters', String(parameters));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectObject();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async compat_control(what: number): Promise<number> {
    const url = new URL(`/GObject/Object/compat_control`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('what', String(what));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async interface_find_property(g_iface: GObjectTypeInterface, property_name: string): Promise<GObjectParamSpec> {
    const url = new URL(`/GObject/Object/interface_find_property`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async interface_install_property(g_iface: GObjectTypeInterface, pspec: GObjectParamSpec): Promise<void> {
    const url = new URL(`/GObject/Object/interface_install_property`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async interface_list_properties(g_iface: GObjectTypeInterface): Promise<Pointer> {
    const url = new URL(`/GObject/Object/interface_list_properties`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (g_iface && typeof g_iface === 'object' && 'ptr' in g_iface) {
      url.searchParams.append('g_iface', 'ptr,' + g_iface.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async bind_property(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlags): Promise<GObjectBinding> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/bind_property`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectBinding(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async bind_property_full(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlags, transform_to: GObjectClosure, transform_from: GObjectClosure): Promise<GObjectBinding> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/bind_property_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('source_property', String(source_property));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Primitive parameter
    url.searchParams.append('target_property', String(target_property));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Object with explode=false: serialize as comma-separated
    if (transform_to && typeof transform_to === 'object' && 'ptr' in transform_to) {
      url.searchParams.append('transform_to', 'ptr,' + transform_to.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (transform_from && typeof transform_from === 'object' && 'ptr' in transform_from) {
      url.searchParams.append('transform_from', 'ptr,' + transform_from.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectBinding(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async force_floating(): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/force_floating`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async freeze_notify(): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/freeze_notify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_data(key: string): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/get_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_property(property_name: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/get_property`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async getv(n_properties: number, names: Pointer, values: Pointer): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/getv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_properties', String(n_properties));
    // Primitive parameter
    url.searchParams.append('names', String(names));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_floating(): Promise<boolean> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/is_floating`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async notify(property_name: string): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/notify`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async notify_by_pspec(pspec: GObjectParamSpec): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/notify_by_pspec`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ref_sink(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/ref_sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async run_dispose(): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/run_dispose`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_data(key: string): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/set_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_property(property_name: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/set_property`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_data(key: string): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/steal_data`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async thaw_notify(): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/thaw_notify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async watch_closure(closure: GObjectClosure): Promise<void> {
    const url = new URL(`/GObject/Object/ptr,${this.ptr}/watch_closure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (closure && typeof closure === 'object' && 'ptr' in closure) {
      url.searchParams.append('closure', 'ptr,' + closure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GObjectBinding extends GObjectObject {

  async dup_source(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Binding/ptr,${this.ptr}/dup_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async dup_target(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Binding/ptr,${this.ptr}/dup_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_flags(): Promise<GObjectBindingFlags> {
    const url = new URL(`/GObject/Binding/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_source(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Binding/ptr,${this.ptr}/get_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_source_property(): Promise<string> {
    const url = new URL(`/GObject/Binding/ptr,${this.ptr}/get_source_property`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_target(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Binding/ptr,${this.ptr}/get_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_target_property(): Promise<string> {
    const url = new URL(`/GObject/Binding/ptr,${this.ptr}/get_target_property`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unbind(): Promise<void> {
    const url = new URL(`/GObject/Binding/ptr,${this.ptr}/unbind`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GObjectClosure {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjectclosureRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjectclosureRegistry.unregister(this);
    const url = new URL(`/GObject/Closure/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
  static async new_object(sizeof_closure: number, object: GObjectObject): Promise<GObjectClosure> {
    const url = new URL(`/GObject/Closure/new_object`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('sizeof_closure', String(sizeof_closure));
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectClosure();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_simple(sizeof_closure: number): Promise<GObjectClosure> {
    const url = new URL(`/GObject/Closure/new_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('sizeof_closure', String(sizeof_closure));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectClosure();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async invalidate(): Promise<void> {
    const url = new URL(`/GObject/Closure/ptr,${this.ptr}/invalidate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async invoke(return_value: GObjectValue, n_param_values: number, param_values: Pointer): Promise<void> {
    const url = new URL(`/GObject/Closure/ptr,${this.ptr}/invoke`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (return_value && typeof return_value === 'object' && 'ptr' in return_value) {
      url.searchParams.append('return_value', 'ptr,' + return_value.ptr);
    }
    // Primitive parameter
    url.searchParams.append('n_param_values', String(n_param_values));
    // Primitive parameter
    url.searchParams.append('param_values', String(param_values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<GObjectClosure> {
    const url = new URL(`/GObject/Closure/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectClosure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async sink(): Promise<void> {
    const url = new URL(`/GObject/Closure/ptr,${this.ptr}/sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`/GObject/Closure/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GObjectInitiallyUnowned extends GObjectObject {


}

export class GObjectParamSpec {

  async is_valid_name(name: string): Promise<boolean> {
    const url = new URL(`/GObject/ParamSpec/is_valid_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_blurb(): Promise<string> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/get_blurb`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_default_value(): Promise<GObjectValue> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/get_default_value`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name_quark(): Promise<number> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/get_name_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_nick(): Promise<string> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/get_nick`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_redirect_target(): Promise<GObjectParamSpec> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/get_redirect_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/set_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sink(): Promise<void> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/sink`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_qdata(quark: number): Promise<void> {
    const url = new URL(`/GObject/ParamSpec/ptr,${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GObjectTypeClass {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjecttypeclassRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjecttypeclassRegistry.unregister(this);
    const url = new URL(`/GObject/TypeClass/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
  static async new(): Promise<GObjectTypeClass> {
    const url = new URL(`/GObject/TypeClass/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectTypeClass();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_private(private_size: number): Promise<void> {
    const url = new URL(`/GObject/TypeClass/ptr,${this.ptr}/add_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_size', String(private_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_private(private_type: Pointer): Promise<void> {
    const url = new URL(`/GObject/TypeClass/ptr,${this.ptr}/get_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_type', String(private_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async peek_parent(): Promise<GObjectTypeClass> {
    const url = new URL(`/GObject/TypeClass/ptr,${this.ptr}/peek_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`/GObject/TypeClass/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async adjust_private_offset(private_size_or_offset: number): Promise<void> {
    const url = new URL(`/GObject/TypeClass/adjust_private_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_size_or_offset', String(private_size_or_offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async peek(type_: Pointer): Promise<GObjectTypeClass> {
    const url = new URL(`/GObject/TypeClass/peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async peek_static(type_: Pointer): Promise<GObjectTypeClass> {
    const url = new URL(`/GObject/TypeClass/peek_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async ref(type_: Pointer): Promise<GObjectTypeClass> {
    const url = new URL(`/GObject/TypeClass/ref`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeClass(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GObjectTypeInstance {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjecttypeinstanceRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjecttypeinstanceRegistry.unregister(this);
    const url = new URL(`/GObject/TypeInstance/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
  static async new(): Promise<GObjectTypeInstance> {
    const url = new URL(`/GObject/TypeInstance/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectTypeInstance();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_private(private_type: Pointer): Promise<void> {
    const url = new URL(`/GObject/TypeInstance/ptr,${this.ptr}/get_private`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('private_type', String(private_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GObjectTypeInterface {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjecttypeinterfaceRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjecttypeinterfaceRegistry.unregister(this);
    const url = new URL(`/GObject/TypeInterface/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
  static async new(): Promise<GObjectTypeInterface> {
    const url = new URL(`/GObject/TypeInterface/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectTypeInterface();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async peek_parent(): Promise<GObjectTypeInterface> {
    const url = new URL(`/GObject/TypeInterface/ptr,${this.ptr}/peek_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeInterface(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_prerequisite(interface_type: Pointer, prerequisite_type: Pointer): Promise<void> {
    const url = new URL(`/GObject/TypeInterface/add_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    // Primitive parameter
    url.searchParams.append('prerequisite_type', String(prerequisite_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_plugin(instance_type: Pointer, interface_type: Pointer): Promise<Pointer> {
    const url = new URL(`/GObject/TypeInterface/get_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('instance_type', String(instance_type));
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async instantiatable_prerequisite(interface_type: Pointer): Promise<Pointer> {
    const url = new URL(`/GObject/TypeInterface/instantiatable_prerequisite`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek(instance_class: GObjectTypeClass, iface_type: Pointer): Promise<GObjectTypeInterface> {
    const url = new URL(`/GObject/TypeInterface/peek`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance_class && typeof instance_class === 'object' && 'ptr' in instance_class) {
      url.searchParams.append('instance_class', 'ptr,' + instance_class.ptr);
    }
    // Primitive parameter
    url.searchParams.append('iface_type', String(iface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectTypeInterface(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prerequisites(interface_type: Pointer): Promise<Pointer> {
    const url = new URL(`/GObject/TypeInterface/prerequisites`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interface_type', String(interface_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GObjectValue {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjectvalueRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjectvalueRegistry.unregister(this);
    const url = new URL(`/GObject/Value/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
  static async new(): Promise<GObjectValue> {
    const url = new URL(`/GObject/Value/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectValue();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(dest_value: GObjectValue): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest_value && typeof dest_value === 'object' && 'ptr' in dest_value) {
      url.searchParams.append('dest_value', 'ptr,' + dest_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async dup_object(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/dup_object`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async dup_string(): Promise<string> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/dup_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async dup_variant(): Promise<GLibVariant> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/dup_variant`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async fits_pointer(): Promise<boolean> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/fits_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boolean(): Promise<boolean> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boxed(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_boxed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_char(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_char`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_enum(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_enum`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_flags(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_float(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_float`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_gtype(): Promise<Pointer> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_gtype`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_int`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_long(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_long`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_object(): Promise<GObjectObject> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_object`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_param(): Promise<GObjectParamSpec> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_param`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_pointer(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_schar(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_schar`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string(): Promise<string> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uchar(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_uchar`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_uint`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_ulong(): Promise<number> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_ulong`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_variant(): Promise<GLibVariant> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/get_variant`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibVariant(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async init(g_type: Pointer): Promise<GObjectValue> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('g_type', String(g_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async init_from_instance(instance: GObjectTypeInstance): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/init_from_instance`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (instance && typeof instance === 'object' && 'ptr' in instance) {
      url.searchParams.append('instance', 'ptr,' + instance.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async peek_pointer(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/peek_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async reset(): Promise<GObjectValue> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/reset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_boolean(v_boolean: boolean): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_boolean', String(v_boolean));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_boxed(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_boxed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_boxed_take_ownership(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_boxed_take_ownership`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_char(v_char: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_char`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_char', String(v_char));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_double(v_double: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_double', String(v_double));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_enum(v_enum: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_enum', String(v_enum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_flags(v_flags: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_flags', String(v_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_float(v_float: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_float`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_float', String(v_float));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_gtype(v_gtype: Pointer): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_gtype`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_gtype', String(v_gtype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_instance(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_instance`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_int(v_int: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_int', String(v_int));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_int64(v_int64: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_int64', String(v_int64));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_interned_string(v_string?: string): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_interned_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_long(v_long: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_long`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_long', String(v_long));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_object(v_object?: GObjectObject): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_object`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (v_object !== undefined && typeof v_object === 'object' && 'ptr' in v_object) {
      url.searchParams.append('v_object', 'ptr,' + v_object.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_param(param?: GObjectParamSpec): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_param`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (param !== undefined && typeof param === 'object' && 'ptr' in param) {
      url.searchParams.append('param', 'ptr,' + param.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_pointer(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_pointer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_schar(v_char: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_schar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_char', String(v_char));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_static_boxed(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_static_boxed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_static_string(v_string?: string): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_static_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_string(v_string?: string): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_string_take_ownership(v_string?: string): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_string_take_ownership`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uchar(v_uchar: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_uchar`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_uchar', String(v_uchar));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uint(v_uint: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_uint', String(v_uint));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uint64(v_uint64: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_uint64', String(v_uint64));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_ulong(v_ulong: number): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_ulong`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v_ulong', String(v_ulong));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_variant(variant?: GLibVariant): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/set_variant`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (variant !== undefined && typeof variant === 'object' && 'ptr' in variant) {
      url.searchParams.append('variant', 'ptr,' + variant.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async steal_string(): Promise<string> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/steal_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async take_boxed(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/take_boxed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async take_string(v_string?: string): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/take_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (v_string !== undefined) url.searchParams.append('v_string', String(v_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async take_variant(variant?: GLibVariant): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/take_variant`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (variant !== undefined && typeof variant === 'object' && 'ptr' in variant) {
      url.searchParams.append('variant', 'ptr,' + variant.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async transform(dest_value: GObjectValue): Promise<boolean> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/transform`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest_value && typeof dest_value === 'object' && 'ptr' in dest_value) {
      url.searchParams.append('dest_value', 'ptr,' + dest_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unset(): Promise<void> {
    const url = new URL(`/GObject/Value/ptr,${this.ptr}/unset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async type_compatible(src_type: Pointer, dest_type: Pointer): Promise<boolean> {
    const url = new URL(`/GObject/Value/type_compatible`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async type_transformable(src_type: Pointer, dest_type: Pointer): Promise<boolean> {
    const url = new URL(`/GObject/Value/type_transformable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_type', String(src_type));
    // Primitive parameter
    url.searchParams.append('dest_type', String(dest_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GObjectValueArray {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gobjectvaluearrayRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gobjectvaluearrayRegistry.unregister(this);
    const url = new URL(`/GObject/ValueArray/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
  static async new(n_prealloced: number): Promise<GObjectValueArray> {
    const url = new URL(`/GObject/ValueArray/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_prealloced', String(n_prealloced));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GObjectValueArray();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append(value_?: GObjectValue): Promise<GObjectValueArray> {
    const url = new URL(`/GObject/ValueArray/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ !== undefined && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy(): Promise<GObjectValueArray> {
    const url = new URL(`/GObject/ValueArray/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_nth(index_: number): Promise<GObjectValue> {
    const url = new URL(`/GObject/ValueArray/ptr,${this.ptr}/get_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert(index_: number, value_?: GObjectValue): Promise<GObjectValueArray> {
    const url = new URL(`/GObject/ValueArray/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    // Object with explode=false: serialize as comma-separated
    if (value_ !== undefined && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend(value_?: GObjectValue): Promise<GObjectValueArray> {
    const url = new URL(`/GObject/ValueArray/ptr,${this.ptr}/prepend`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ !== undefined && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove(index_: number): Promise<GObjectValueArray> {
    const url = new URL(`/GObject/ValueArray/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index_', String(index_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async sort(compare_func: (a: Pointer, b: Pointer, user_data: Pointer) => number): Promise<GObjectValueArray> {
    const url = new URL(`/GObject/ValueArray/ptr,${this.ptr}/sort`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.compare_func !== undefined) {
      callbackDispatcher.set(data.compare_func.toString(), compare_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValueArray(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstAllocationParams {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstallocationparamsRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstallocationparamsRegistry.unregister(this);
    const url = new URL(`/Gst/AllocationParams/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstAllocationParams> {
    const url = new URL(`/Gst/AllocationParams/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstAllocationParams();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GstAllocationParams> {
    const url = new URL(`/Gst/AllocationParams/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstAllocationParams(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async init(): Promise<void> {
    const url = new URL(`/Gst/AllocationParams/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstObject extends GObjectInitiallyUnowned {

  async check_uniqueness(list: Pointer, name: string): Promise<boolean> {
    const url = new URL(`/Gst/Object/check_uniqueness`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async default_deep_notify(object: GObjectObject, orig: GstObject, pspec: GObjectParamSpec, excluded_props?: Pointer): Promise<void> {
    const url = new URL(`/Gst/Object/default_deep_notify`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (orig && typeof orig === 'object' && 'ptr' in orig) {
      url.searchParams.append('orig', 'ptr,' + orig.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (pspec && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    // Primitive parameter
    if (excluded_props !== undefined) url.searchParams.append('excluded_props', String(excluded_props));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace(oldobj?: GstObject, newobj?: GstObject): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + oldobj.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Object/replace`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (oldobj !== undefined && typeof oldobj === 'object' && 'ptr' in oldobj) {
      url.searchParams.append('oldobj', 'ptr,' + oldobj.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newobj !== undefined && typeof newobj === 'object' && 'ptr' in newobj) {
      url.searchParams.append('newobj', 'ptr,' + newobj.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + oldobj.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (oldobj && typeof oldobj === 'object' && 'ptr' in oldobj) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + oldobj.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async add_control_binding(binding: GstControlBinding): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/add_control_binding`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (binding && typeof binding === 'object' && 'ptr' in binding) {
      url.searchParams.append('binding', 'ptr,' + binding.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async default_error(error_: Pointer, debug?: string): Promise<void> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/default_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_control_binding(property_name: string): Promise<GstControlBinding> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/get_control_binding`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstControlBinding(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_control_rate(): Promise<number> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/get_control_rate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_g_value_array(property_name: string, timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/get_g_value_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_parent(): Promise<GstObject> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/get_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_path_string(): Promise<string> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/get_path_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(property_name: string, timestamp: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_active_control_bindings(): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/has_active_control_bindings`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_ancestor(ancestor: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/has_ancestor`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ancestor && typeof ancestor === 'object' && 'ptr' in ancestor) {
      url.searchParams.append('ancestor', 'ptr,' + ancestor.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_as_ancestor(ancestor: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/has_as_ancestor`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ancestor && typeof ancestor === 'object' && 'ptr' in ancestor) {
      url.searchParams.append('ancestor', 'ptr,' + ancestor.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_as_parent(parent: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/has_as_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GstObject> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstObject(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove_control_binding(binding: GstControlBinding): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/remove_control_binding`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (binding && typeof binding === 'object' && 'ptr' in binding) {
      url.searchParams.append('binding', 'ptr,' + binding.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_control_binding_disabled(property_name: string, disabled: boolean): Promise<void> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/set_control_binding_disabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('disabled', String(disabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_control_bindings_disabled(disabled: boolean): Promise<void> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/set_control_bindings_disabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('disabled', String(disabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_control_rate(control_rate: number): Promise<void> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/set_control_rate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('control_rate', String(control_rate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_name(name?: string): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_parent(parent: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/set_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async suggest_next_sync(): Promise<number> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/suggest_next_sync`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async sync_values(timestamp: number): Promise<boolean> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/sync_values`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unparent(): Promise<void> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/unparent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`/Gst/Object/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstAllocator extends GstObject {

  async find(name?: string): Promise<GstAllocator> {
    const url = new URL(`/Gst/Allocator/find`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstAllocator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async register(name: string, allocator: GstAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + allocator.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Allocator/register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async alloc(size: number, params?: GstAllocationParams): Promise<GstMemory> {
    const url = new URL(`/Gst/Allocator/ptr,${this.ptr}/alloc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async free(memory: GstMemory): Promise<void> {
    const url = new URL(`/Gst/Allocator/ptr,${this.ptr}/free`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (memory && typeof memory === 'object' && 'ptr' in memory) {
      url.searchParams.append('memory', 'ptr,' + memory.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_default(): Promise<void> {
    const url = new URL(`/Gst/Allocator/ptr,${this.ptr}/set_default`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstAtomicQueue {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstatomicqueueRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstatomicqueueRegistry.unregister(this);
    const url = new URL(`/Gst/AtomicQueue/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(initial_size: number): Promise<GstAtomicQueue> {
    const url = new URL(`/Gst/AtomicQueue/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('initial_size', String(initial_size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstAtomicQueue();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async length(): Promise<number> {
    const url = new URL(`/Gst/AtomicQueue/ptr,${this.ptr}/length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek(): Promise<void> {
    const url = new URL(`/Gst/AtomicQueue/ptr,${this.ptr}/peek`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async pop(): Promise<void> {
    const url = new URL(`/Gst/AtomicQueue/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push(): Promise<void> {
    const url = new URL(`/Gst/AtomicQueue/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async ref(): Promise<void> {
    const url = new URL(`/Gst/AtomicQueue/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unref(): Promise<void> {
    const url = new URL(`/Gst/AtomicQueue/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstElement extends GstObject {

  async make_from_uri(type_: GstURIType, uri: string, elementname?: string): Promise<GstElement> {
    const url = new URL(`/Gst/Element/make_from_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    if (elementname !== undefined) url.searchParams.append('elementname', String(elementname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async register(name: string, rank: number, type_: Pointer, plugin?: GstPlugin): Promise<boolean> {
    const url = new URL(`/Gst/Element/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async state_change_return_get_name(state_ret: GstStateChangeReturn): Promise<string> {
    const url = new URL(`/Gst/Element/state_change_return_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state_ret', String(state_ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async state_get_name(state: GstState): Promise<string> {
    const url = new URL(`/Gst/Element/state_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async type_set_skip_documentation(type_: Pointer): Promise<void> {
    const url = new URL(`/Gst/Element/type_set_skip_documentation`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async abort_state(): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/abort_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_pad(pad: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/add_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_property_deep_notify_watch(include_value: boolean, property_name?: string): Promise<number> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/add_property_deep_notify_watch`, apiConfig.baseUrl);
    // Primitive parameter
    if (property_name !== undefined) url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('include_value', String(include_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_property_notify_watch(include_value: boolean, property_name?: string): Promise<number> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/add_property_notify_watch`, apiConfig.baseUrl);
    // Primitive parameter
    if (property_name !== undefined) url.searchParams.append('property_name', String(property_name));
    // Primitive parameter
    url.searchParams.append('include_value', String(include_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async call_async(func: (element: GstElement, user_data: Pointer) => void): Promise<{ func?: number }> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/call_async`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async change_state(transition: GstStateChangeValue): Promise<GstStateChangeReturn> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/change_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('transition', String(transition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async continue_state(ret: GstStateChangeReturn): Promise<GstStateChangeReturn> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/continue_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_all_pads(): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/create_all_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async decorate_stream_id(stream_id: string): Promise<string> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/decorate_stream_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stream_id', String(stream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async foreach_pad(func: (element: GstElement, pad: GstPad, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/foreach_pad`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async foreach_sink_pad(func: (element: GstElement, pad: GstPad, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/foreach_sink_pad`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async foreach_src_pad(func: (element: GstElement, pad: GstPad, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/foreach_src_pad`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get_base_time(): Promise<number> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_base_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBus(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_clock(): Promise<GstClock> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstClock(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_compatible_pad(pad: GstPad, caps?: GstCaps): Promise<GstPad> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_compatible_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_compatible_pad_template(compattempl: GstPadTemplate): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_compatible_pad_template`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (compattempl && typeof compattempl === 'object' && 'ptr' in compattempl) {
      url.searchParams.append('compattempl', 'ptr,' + compattempl.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPadTemplate(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_context(context_type: string): Promise<GstContext> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_context_unlocked(context_type: string): Promise<GstContext> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_context_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_contexts(): Promise<Pointer> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_contexts`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_current_clock_time(): Promise<number> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_current_clock_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_current_running_time(): Promise<number> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_current_running_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_factory(): Promise<GstElementFactory> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_factory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElementFactory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pad_template(name: string): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_pad_template`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPadTemplate(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_pad_template_list(): Promise<Pointer> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_pad_template_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_request_pad(name: string): Promise<GstPad> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_request_pad`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_start_time(): Promise<number> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_start_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_state(state: GstState, pending: GstState, timeout: number): Promise<GstStateChangeReturn> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    // Primitive parameter
    url.searchParams.append('pending', String(pending));
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_static_pad(name: string): Promise<GstPad> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/get_static_pad`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_locked_state(): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/is_locked_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_pads(): Promise<GstIterator> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/iterate_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_sink_pads(): Promise<GstIterator> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/iterate_sink_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_src_pads(): Promise<GstIterator> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/iterate_src_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async link(dest: GstElement): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_filtered(dest: GstElement, filter?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/link_filtered`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_pads(dest: GstElement, srcpadname?: string, destpadname?: string): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/link_pads`, apiConfig.baseUrl);
    // Primitive parameter
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_pads_filtered(dest: GstElement, srcpadname?: string, destpadname?: string, filter?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/link_pads_filtered`, apiConfig.baseUrl);
    // Primitive parameter
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_pads_full(dest: GstElement, flags: GstPadLinkCheck, srcpadname?: string, destpadname?: string): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/link_pads_full`, apiConfig.baseUrl);
    // Primitive parameter
    if (srcpadname !== undefined) url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    if (destpadname !== undefined) url.searchParams.append('destpadname', String(destpadname));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lost_state(): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/lost_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async message_full(type_: GstMessageTypeValue, domain: number, code: number, file: string, function_: string, line: number, text?: string, debug?: string): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/message_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    if (text !== undefined) url.searchParams.append('text', String(text));
    // Primitive parameter
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async message_full_with_details(type_: GstMessageTypeValue, domain: number, code: number, file: string, function_: string, line: number, structure: GstStructure, text?: string, debug?: string): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/message_full_with_details`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    if (text !== undefined) url.searchParams.append('text', String(text));
    // Primitive parameter
    if (debug !== undefined) url.searchParams.append('debug', String(debug));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async no_more_pads(): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/no_more_pads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async post_message(message: GstMessage): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/post_message`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async provide_clock(): Promise<GstClock> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/provide_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstClock(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async query(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/query`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/query_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_val', String(src_val));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_duration(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/query_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_position(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/query_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async release_request_pad(pad: GstPad): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/release_request_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_pad(pad: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/remove_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_property_notify_watch(watch_id: number): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/remove_property_notify_watch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('watch_id', String(watch_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async request_pad(templ: GstPadTemplate, name?: string, caps?: GstCaps): Promise<GstPad> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/request_pad`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async request_pad_simple(name: string): Promise<GstPad> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/request_pad_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async seek(rate: number, format: GstFormatValue, flags: GstSeekFlags, start_type: GstSeekType, start: number, stop_type: GstSeekType, stop: number): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async seek_simple(format: GstFormatValue, seek_flags: GstSeekFlags, seek_pos: number): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/seek_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('seek_flags', String(seek_flags));
    // Primitive parameter
    url.searchParams.append('seek_pos', String(seek_pos));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async send_event(event: GstEvent): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/send_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_base_time(time: number): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/set_base_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_bus(bus?: GstBus): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/set_bus`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bus !== undefined && typeof bus === 'object' && 'ptr' in bus) {
      url.searchParams.append('bus', 'ptr,' + bus.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_clock(clock?: GstClock): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/set_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock !== undefined && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_context(context: GstContext): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/set_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_locked_state(locked_state: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/set_locked_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('locked_state', String(locked_state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_start_time(time: number): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/set_start_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_state(state: GstState): Promise<GstStateChangeReturn> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/set_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async sync_state_with_parent(): Promise<boolean> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/sync_state_with_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unlink(dest: GstElement): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/unlink`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unlink_pads(srcpadname: string, dest: GstElement, destpadname: string): Promise<void> {
    const url = new URL(`/Gst/Element/ptr,${this.ptr}/unlink_pads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('srcpadname', String(srcpadname));
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    url.searchParams.append('destpadname', String(destpadname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstBin extends GstElement {
  static async new(name?: string): Promise<GstBin> {
    const url = new URL(`/Gst/Bin/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBin();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(element: GstElement): Promise<boolean> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async find_unlinked_pad(direction: GstPadDirection): Promise<GstPad> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/find_unlinked_pad`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_by_interface(iface: Pointer): Promise<GstElement> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/get_by_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iface', String(iface));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_by_name(name: string): Promise<GstElement> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/get_by_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_by_name_recurse_up(name: string): Promise<GstElement> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/get_by_name_recurse_up`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_suppressed_flags(): Promise<GstElementFlags> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/get_suppressed_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_all_by_element_factory_name(factory_name: string): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/iterate_all_by_element_factory_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factory_name', String(factory_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_all_by_interface(iface: Pointer): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/iterate_all_by_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('iface', String(iface));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_elements(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/iterate_elements`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_recurse(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/iterate_recurse`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_sinks(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/iterate_sinks`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_sorted(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/iterate_sorted`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_sources(): Promise<GstIterator> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/iterate_sources`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async recalculate_latency(): Promise<boolean> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/recalculate_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove(element: GstElement): Promise<boolean> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_suppressed_flags(flags: GstElementFlags): Promise<void> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/set_suppressed_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sync_children_states(): Promise<boolean> {
    const url = new URL(`/Gst/Bin/ptr,${this.ptr}/sync_children_states`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstBuffer {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstbufferRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstbufferRegistry.unregister(this);
    const url = new URL(`/Gst/Buffer/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_allocate(size: number, allocator?: GstAllocator, params?: GstAllocationParams): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/new_allocate`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_memdup(data_: Pointer, size: number): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/new_memdup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_wrapped(data_: Pointer, size: number): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/new_wrapped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_wrapped_bytes(bytes: GLibBytes): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/new_wrapped_bytes`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bytes && typeof bytes === 'object' && 'ptr' in bytes) {
      url.searchParams.append('bytes', 'ptr,' + bytes.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_wrapped_full(flags: GstMemoryFlags, data_: Pointer, maxsize: number, offset: number, size: number, notify: (data_: Pointer) => void): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/new_wrapped_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.notify !== undefined) {
      callbackDispatcher.set(data.notify.toString(), notify);
    }
    const instance = new GstBuffer();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_custom_meta(name: string): Promise<GstCustomMeta> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/add_custom_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCustomMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_meta(info: GstMetaInfo): Promise<GstMeta> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/add_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_parent_buffer_meta(ref: GstBuffer): Promise<GstParentBufferMeta> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/add_parent_buffer_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ref && typeof ref === 'object' && 'ptr' in ref) {
      url.searchParams.append('ref', 'ptr,' + ref.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstParentBufferMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_protection_meta(info: GstStructure): Promise<GstProtectionMeta> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/add_protection_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstProtectionMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_reference_timestamp_meta(reference: GstCaps, timestamp: number, duration: number): Promise<GstReferenceTimestampMeta> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/add_reference_timestamp_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (reference && typeof reference === 'object' && 'ptr' in reference) {
      url.searchParams.append('reference', 'ptr,' + reference.ptr);
    }
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstReferenceTimestampMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async append(buf2: GstBuffer): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buf2 && typeof buf2 === 'object' && 'ptr' in buf2) {
      url.searchParams.append('buf2', 'ptr,' + buf2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async append_memory(mem: GstMemory): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/append_memory`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async append_region(buf2: GstBuffer, offset: number, size: number): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/append_region`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buf2 && typeof buf2 === 'object' && 'ptr' in buf2) {
      url.searchParams.append('buf2', 'ptr,' + buf2.ptr);
    }
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy_deep(): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/copy_deep`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy_into(src: GstBuffer, flags: GstBufferCopyFlags, offset: number, size: number): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/copy_into`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy_region(flags: GstBufferCopyFlags, offset: number, size: number): Promise<GstBuffer> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/copy_region`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async extract(offset: number): Promise<number> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/extract`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async extract_dup(offset: number, size: number): Promise<{ dest?: Pointer; dest_size?: number }> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/extract_dup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async fill(offset: number, src: Pointer, size: number): Promise<number> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/fill`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async find_memory(offset: number, size: number): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/find_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async foreach_meta(func: (buffer: GstBuffer, meta: GstMeta, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/foreach_meta`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get_all_memory(): Promise<GstMemory> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_all_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_custom_meta(name: string): Promise<GstCustomMeta> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_custom_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCustomMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_flags(): Promise<GstBufferFlags> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_memory(idx: number): Promise<GstMemory> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_memory_range(idx: number, length: number): Promise<GstMemory> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_memory_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_meta(api: Pointer): Promise<GstMeta> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_n_meta(api_type: Pointer): Promise<number> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_n_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api_type', String(api_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_reference_timestamp_meta(reference?: GstCaps): Promise<GstReferenceTimestampMeta> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_reference_timestamp_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (reference !== undefined && typeof reference === 'object' && 'ptr' in reference) {
      url.searchParams.append('reference', 'ptr,' + reference.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstReferenceTimestampMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_size(): Promise<number> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sizes(): Promise<number> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_sizes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sizes_range(idx: number, length: number): Promise<number> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/get_sizes_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_flags(flags: GstBufferFlags): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/has_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async insert_memory(idx: number, mem: GstMemory): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/insert_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_all_memory_writable(): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/is_all_memory_writable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_memory_range_writable(idx: number, length: number): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/is_memory_range_writable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async map(info: GstMapInfo, flags: GstMapFlags): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/map`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async map_range(idx: number, length: number, info: GstMapInfo, flags: GstMapFlags): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/map_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async memcmp(offset: number, mem: Pointer, size: number): Promise<number> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/memcmp`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async memset(offset: number, val: number, size: number): Promise<number> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/memset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async n_memory(): Promise<number> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/n_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek_memory(idx: number): Promise<GstMemory> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/peek_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend_memory(mem: GstMemory): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/prepend_memory`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_all_memory(): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/remove_all_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_memory(idx: number): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/remove_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_memory_range(idx: number, length: number): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/remove_memory_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_meta(meta: GstMeta): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/remove_meta`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (meta && typeof meta === 'object' && 'ptr' in meta) {
      url.searchParams.append('meta', 'ptr,' + meta.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async replace_all_memory(mem: GstMemory): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/replace_all_memory`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace_memory(idx: number, mem: GstMemory): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/replace_memory`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace_memory_range(idx: number, length: number, mem: GstMemory): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/replace_memory_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Object with explode=false: serialize as comma-separated
    if (mem && typeof mem === 'object' && 'ptr' in mem) {
      url.searchParams.append('mem', 'ptr,' + mem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async resize(offset: number, size: number): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/resize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async resize_range(idx: number, length: number, offset: number, size: number): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/resize_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flags(flags: GstBufferFlags): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/set_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_size(size: number): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/set_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unmap(info: GstMapInfo): Promise<void> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/unmap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unset_flags(flags: GstBufferFlags): Promise<boolean> {
    const url = new URL(`/Gst/Buffer/ptr,${this.ptr}/unset_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_max_memory(): Promise<number> {
    const url = new URL(`/Gst/Buffer/get_max_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstBufferList {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstbufferlistRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstbufferlistRegistry.unregister(this);
    const url = new URL(`/Gst/BufferList/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstBufferList> {
    const url = new URL(`/Gst/BufferList/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBufferList();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_sized(size: number): Promise<GstBufferList> {
    const url = new URL(`/Gst/BufferList/new_sized`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBufferList();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async calculate_size(): Promise<number> {
    const url = new URL(`/Gst/BufferList/ptr,${this.ptr}/calculate_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy_deep(): Promise<GstBufferList> {
    const url = new URL(`/Gst/BufferList/ptr,${this.ptr}/copy_deep`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBufferList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async foreach(func: (buffer: GstBuffer, idx: number, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/BufferList/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get(idx: number): Promise<GstBuffer> {
    const url = new URL(`/Gst/BufferList/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_writable(idx: number): Promise<GstBuffer> {
    const url = new URL(`/Gst/BufferList/ptr,${this.ptr}/get_writable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert(idx: number, buffer: GstBuffer): Promise<void> {
    const url = new URL(`/Gst/BufferList/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async length(): Promise<number> {
    const url = new URL(`/Gst/BufferList/ptr,${this.ptr}/length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove(idx: number, length: number): Promise<void> {
    const url = new URL(`/Gst/BufferList/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    // Primitive parameter
    url.searchParams.append('length', String(length));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstBufferPool extends GstObject {
  static async new(): Promise<GstBufferPool> {
    const url = new URL(`/Gst/BufferPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBufferPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async config_add_option(config: GstStructure, option: string): Promise<void> {
    const url = new URL(`/Gst/BufferPool/config_add_option`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Primitive parameter
    url.searchParams.append('option', String(option));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async config_get_allocator(config: GstStructure, params: GstAllocationParams, allocator?: GstAllocator): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/config_get_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_get_option(config: GstStructure, index: number): Promise<string> {
    const url = new URL(`/Gst/BufferPool/config_get_option`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_get_params(config: GstStructure, caps?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/config_get_params`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_has_option(config: GstStructure, option: string): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/config_has_option`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Primitive parameter
    url.searchParams.append('option', String(option));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_n_options(config: GstStructure): Promise<number> {
    const url = new URL(`/Gst/BufferPool/config_n_options`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async config_set_allocator(config: GstStructure, allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    const url = new URL(`/Gst/BufferPool/config_set_allocator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async config_set_params(config: GstStructure, size: number, min_buffers: number, max_buffers: number, caps?: GstCaps): Promise<void> {
    const url = new URL(`/Gst/BufferPool/config_set_params`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async config_validate_params(config: GstStructure, size: number, min_buffers: number, max_buffers: number, caps?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/config_validate_params`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async acquire_buffer(buffer?: GstBuffer, params?: GstBufferPoolAcquireParams): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/BufferPool/ptr,${this.ptr}/acquire_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer !== undefined && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_config(): Promise<GstStructure> {
    const url = new URL(`/Gst/BufferPool/ptr,${this.ptr}/get_config`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_options(): Promise<Pointer> {
    const url = new URL(`/Gst/BufferPool/ptr,${this.ptr}/get_options`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_option(option: string): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/ptr,${this.ptr}/has_option`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('option', String(option));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_active(): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/ptr,${this.ptr}/is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async release_buffer(buffer: GstBuffer): Promise<void> {
    const url = new URL(`/Gst/BufferPool/ptr,${this.ptr}/release_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_active(active: boolean): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/ptr,${this.ptr}/set_active`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_config(config: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/BufferPool/ptr,${this.ptr}/set_config`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (config && typeof config === 'object' && 'ptr' in config) {
      url.searchParams.append('config', 'ptr,' + config.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flushing(flushing: boolean): Promise<void> {
    const url = new URL(`/Gst/BufferPool/ptr,${this.ptr}/set_flushing`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flushing', String(flushing));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstBus extends GstObject {
  static async new(): Promise<GstBus> {
    const url = new URL(`/Gst/Bus/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstBus();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_signal_watch(): Promise<void> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/add_signal_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_signal_watch_full(priority: number): Promise<void> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/add_signal_watch_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_watch(priority: number, func: (bus: GstBus, message: GstMessage, user_data: Pointer) => boolean): Promise<number> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/add_watch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('priority', String(priority));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async async_signal_func(message: GstMessage): Promise<boolean> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/async_signal_func`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_watch(): Promise<GLibSource> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/create_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibSource(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async disable_sync_message_emission(): Promise<void> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/disable_sync_message_emission`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async enable_sync_message_emission(): Promise<void> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/enable_sync_message_emission`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_pollfd(fd: GLibPollFD): Promise<void> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/get_pollfd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async have_pending(): Promise<boolean> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/have_pending`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek(): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/peek`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async poll(events: GstMessageTypeValue, timeout: number): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/poll`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('events', String(events));
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async pop(): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/pop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async pop_filtered(types: GstMessageTypeValue): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/pop_filtered`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('types', String(types));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async post(message: GstMessage): Promise<boolean> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/post`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_signal_watch(): Promise<void> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/remove_signal_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_watch(): Promise<boolean> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/remove_watch`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flushing(flushing: boolean): Promise<void> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/set_flushing`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flushing', String(flushing));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_sync_handler(func: (bus: GstBus, message: GstMessage, user_data: Pointer) => GstBusSyncReply): Promise<{ func?: number }> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/set_sync_handler`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async sync_signal_handler(message: GstMessage): Promise<GstBusSyncReply> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/sync_signal_handler`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async timed_pop(timeout: number): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/timed_pop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async timed_pop_filtered(timeout: number, types: GstMessageTypeValue): Promise<GstMessage> {
    const url = new URL(`/Gst/Bus/ptr,${this.ptr}/timed_pop_filtered`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    // Primitive parameter
    url.searchParams.append('types', String(types));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMessage(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstCaps {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstcapsRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstcapsRegistry.unregister(this);
    const url = new URL(`/Gst/Caps/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_any(): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/new_any`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCaps();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_empty(): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/new_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCaps();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_empty_simple(media_type: string): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/new_empty_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('media_type', String(media_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCaps();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append(caps2: GstCaps): Promise<void> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/append`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async append_structure(structure: GstStructure): Promise<void> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/append_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async append_structure_full(structure: GstStructure, features?: GstCapsFeatures): Promise<void> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/append_structure_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async can_intersect(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/can_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy_nth(nth: number): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/copy_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nth', String(nth));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async filter_and_map_in_place(func: (features: GstCapsFeatures, structure: GstStructure, user_data: Pointer) => boolean): Promise<{ func?: number }> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/filter_and_map_in_place`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async fixate(): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/fixate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async foreach(func: (features: GstCapsFeatures, structure: GstStructure, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get_features(index: number): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/get_features`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_size(): Promise<number> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_structure(index: number): Promise<GstStructure> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async intersect(caps2: GstCaps): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async intersect_full(caps2: GstCaps, mode: GstCapsIntersectMode): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/intersect_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_always_compatible(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_always_compatible`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_any(): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_any`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_empty(): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_equal(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_equal_fixed(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_equal_fixed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_fixed(): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_fixed`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_strictly_equal(caps2: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_strictly_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subset(superset: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_subset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (superset && typeof superset === 'object' && 'ptr' in superset) {
      url.searchParams.append('superset', 'ptr,' + superset.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subset_structure(structure: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_subset_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subset_structure_full(structure: GstStructure, features?: GstCapsFeatures): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/is_subset_structure_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async map_in_place(func: (features: GstCapsFeatures, structure: GstStructure, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/map_in_place`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async merge(caps2: GstCaps): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/merge`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps2 && typeof caps2 === 'object' && 'ptr' in caps2) {
      url.searchParams.append('caps2', 'ptr,' + caps2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async merge_structure(structure: GstStructure): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/merge_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async merge_structure_full(structure: GstStructure, features?: GstCapsFeatures): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/merge_structure_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async normalize(): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/normalize`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async remove_structure(idx: number): Promise<void> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/remove_structure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async serialize(flags: GstSerializeFlags): Promise<string> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/serialize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_features(index: number, features?: GstCapsFeatures): Promise<void> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/set_features`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_features_simple(features?: GstCapsFeatures): Promise<void> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/set_features_simple`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (features !== undefined && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_value(field: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async simplify(): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/simplify`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async steal_structure(index: number): Promise<GstStructure> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/steal_structure`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async subtract(subtrahend: GstCaps): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_string(): Promise<string> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async truncate(): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/ptr,${this.ptr}/truncate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async from_string(string: string): Promise<GstCaps> {
    const url = new URL(`/Gst/Caps/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstCapsFeatures {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstcapsfeaturesRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstcapsfeaturesRegistry.unregister(this);
    const url = new URL(`/Gst/CapsFeatures/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_any(): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/CapsFeatures/new_any`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCapsFeatures();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_empty(): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/CapsFeatures/new_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCapsFeatures();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_single(feature: string): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/CapsFeatures/new_single`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCapsFeatures();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add(feature: string): Promise<void> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_id(feature: number): Promise<void> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/add_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async contains(feature: string): Promise<boolean> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async contains_id(feature: number): Promise<boolean> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/contains_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_nth(i: number): Promise<string> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/get_nth`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('i', String(i));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_nth_id(i: number): Promise<number> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/get_nth_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('i', String(i));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_size(): Promise<number> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_any(): Promise<boolean> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/is_any`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_equal(features2: GstCapsFeatures): Promise<boolean> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (features2 && typeof features2 === 'object' && 'ptr' in features2) {
      url.searchParams.append('features2', 'ptr,' + features2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove(feature: string): Promise<void> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/remove`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_id(feature: number): Promise<void> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/remove_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature', String(feature));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_parent_refcount(refcount: number): Promise<boolean> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/set_parent_refcount`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('refcount', String(refcount));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_string(): Promise<string> {
    const url = new URL(`/Gst/CapsFeatures/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async from_string(features: string): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/CapsFeatures/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('features', String(features));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstClock extends GstObject {

  async id_compare_func(): Promise<number> {
    const url = new URL(`/Gst/Clock/id_compare_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_get_clock(): Promise<GstClock> {
    const url = new URL(`/Gst/Clock/id_get_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstClock(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async id_get_time(): Promise<number> {
    const url = new URL(`/Gst/Clock/id_get_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_ref(): Promise<void> {
    const url = new URL(`/Gst/Clock/id_ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async id_unref(): Promise<void> {
    const url = new URL(`/Gst/Clock/id_unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async id_unschedule(): Promise<void> {
    const url = new URL(`/Gst/Clock/id_unschedule`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async id_uses_clock(clock: GstClock): Promise<boolean> {
    const url = new URL(`/Gst/Clock/id_uses_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_wait(): Promise<GstClockReturn> {
    const url = new URL(`/Gst/Clock/id_wait`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_wait_async(func: (clock: GstClock, time: number, id: Pointer, user_data: Pointer) => boolean): Promise<GstClockReturn> {
    const url = new URL(`/Gst/Clock/id_wait_async`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async add_observation(slave: number, master: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/add_observation`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('slave', String(slave));
    // Primitive parameter
    url.searchParams.append('master', String(master));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_observation_unapplied(slave: number, master: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/add_observation_unapplied`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('slave', String(slave));
    // Primitive parameter
    url.searchParams.append('master', String(master));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async adjust_unlocked(internal: number): Promise<number> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/adjust_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('internal', String(internal));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async adjust_with_calibration(internal_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/adjust_with_calibration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('internal_target', String(internal_target));
    // Primitive parameter
    url.searchParams.append('cinternal', String(cinternal));
    // Primitive parameter
    url.searchParams.append('cexternal', String(cexternal));
    // Primitive parameter
    url.searchParams.append('cnum', String(cnum));
    // Primitive parameter
    url.searchParams.append('cdenom', String(cdenom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_calibration(): Promise<{ internal?: number; external?: number; rate_num?: number; rate_denom?: number }> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/get_calibration`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async get_internal_time(): Promise<number> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/get_internal_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_master(): Promise<GstClock> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/get_master`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstClock(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_resolution(): Promise<number> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/get_resolution`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_time(): Promise<number> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/get_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_timeout(): Promise<number> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/get_timeout`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_synced(): Promise<boolean> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/is_synced`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async new_periodic_id(start_time: number, interval: number): Promise<void> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/new_periodic_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start_time', String(start_time));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async new_single_shot_id(time: number): Promise<void> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/new_single_shot_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async periodic_id_reinit(start_time: number, interval: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/periodic_id_reinit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start_time', String(start_time));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_calibration(internal: number, external: number, rate_num: number, rate_denom: number): Promise<void> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/set_calibration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('internal', String(internal));
    // Primitive parameter
    url.searchParams.append('external', String(external));
    // Primitive parameter
    url.searchParams.append('rate_num', String(rate_num));
    // Primitive parameter
    url.searchParams.append('rate_denom', String(rate_denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_master(master?: GstClock): Promise<boolean> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/set_master`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (master !== undefined && typeof master === 'object' && 'ptr' in master) {
      url.searchParams.append('master', 'ptr,' + master.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_resolution(resolution: number): Promise<number> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/set_resolution`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('resolution', String(resolution));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_synced(synced: boolean): Promise<void> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/set_synced`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('synced', String(synced));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_timeout(timeout: number): Promise<void> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/set_timeout`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async single_shot_id_reinit(time: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/single_shot_id_reinit`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('time', String(time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unadjust_unlocked(external: number): Promise<number> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/unadjust_unlocked`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('external', String(external));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unadjust_with_calibration(external_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/unadjust_with_calibration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('external_target', String(external_target));
    // Primitive parameter
    url.searchParams.append('cinternal', String(cinternal));
    // Primitive parameter
    url.searchParams.append('cexternal', String(cexternal));
    // Primitive parameter
    url.searchParams.append('cnum', String(cnum));
    // Primitive parameter
    url.searchParams.append('cdenom', String(cdenom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async wait_for_sync(timeout: number): Promise<boolean> {
    const url = new URL(`/Gst/Clock/ptr,${this.ptr}/wait_for_sync`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstContext {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstcontextRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstcontextRegistry.unregister(this);
    const url = new URL(`/Gst/Context/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(context_type: string, persistent: boolean): Promise<GstContext> {
    const url = new URL(`/Gst/Context/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    // Primitive parameter
    url.searchParams.append('persistent', String(persistent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstContext();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_context_type(): Promise<string> {
    const url = new URL(`/Gst/Context/ptr,${this.ptr}/get_context_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_structure(): Promise<GstStructure> {
    const url = new URL(`/Gst/Context/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_context_type(context_type: string): Promise<boolean> {
    const url = new URL(`/Gst/Context/ptr,${this.ptr}/has_context_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_persistent(): Promise<boolean> {
    const url = new URL(`/Gst/Context/ptr,${this.ptr}/is_persistent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async writable_structure(): Promise<GstStructure> {
    const url = new URL(`/Gst/Context/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstControlBinding extends GstObject {

  async get_g_value_array(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/ControlBinding/ptr,${this.ptr}/get_g_value_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(timestamp: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ControlBinding/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_disabled(): Promise<boolean> {
    const url = new URL(`/Gst/ControlBinding/ptr,${this.ptr}/is_disabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_disabled(disabled: boolean): Promise<void> {
    const url = new URL(`/Gst/ControlBinding/ptr,${this.ptr}/set_disabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('disabled', String(disabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async sync_values(object: GstObject, timestamp: number, last_sync: number): Promise<boolean> {
    const url = new URL(`/Gst/ControlBinding/ptr,${this.ptr}/sync_values`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('last_sync', String(last_sync));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstControlSource extends GstObject {

  async control_source_get_value(timestamp: number): Promise<boolean> {
    const url = new URL(`/Gst/ControlSource/ptr,${this.ptr}/control_source_get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async control_source_get_value_array(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/ControlSource/ptr,${this.ptr}/control_source_get_value_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    // Primitive parameter
    url.searchParams.append('n_values', String(n_values));
    // Primitive parameter
    url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstCustomMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstcustommetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstcustommetaRegistry.unregister(this);
    const url = new URL(`/Gst/CustomMeta/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstCustomMeta> {
    const url = new URL(`/Gst/CustomMeta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstCustomMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_structure(): Promise<GstStructure> {
    const url = new URL(`/Gst/CustomMeta/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_name(name: string): Promise<boolean> {
    const url = new URL(`/Gst/CustomMeta/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstDateTime {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstdatetimeRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstdatetimeRegistry.unregister(this);
    const url = new URL(`/Gst/DateTime/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(tzoffset: number, year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tzoffset', String(tzoffset));
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_g_date_time(dt?: GLibDateTime): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_from_g_date_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dt !== undefined && typeof dt === 'object' && 'ptr' in dt) {
      url.searchParams.append('dt', 'ptr,' + dt.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_iso8601_string(string: string): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_from_iso8601_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_epoch_local_time(secs: number): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_from_unix_epoch_local_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('secs', String(secs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_epoch_local_time_usecs(usecs: number): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_from_unix_epoch_local_time_usecs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_epoch_utc(secs: number): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_from_unix_epoch_utc`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('secs', String(secs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_unix_epoch_utc_usecs(usecs: number): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_from_unix_epoch_utc_usecs`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('usecs', String(usecs));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_local_time(year: number, month: number, day: number, hour: number, minute: number, seconds: number): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_local_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    // Primitive parameter
    url.searchParams.append('hour', String(hour));
    // Primitive parameter
    url.searchParams.append('minute', String(minute));
    // Primitive parameter
    url.searchParams.append('seconds', String(seconds));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now_local_time(): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_now_local_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_now_utc(): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_now_utc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_y(year: number): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_y`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_ym(year: number, month: number): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_ym`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_ymd(year: number, month: number, day: number): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/new_ymd`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('year', String(year));
    // Primitive parameter
    url.searchParams.append('month', String(month));
    // Primitive parameter
    url.searchParams.append('day', String(day));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDateTime();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_day(): Promise<number> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/get_day`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_hour(): Promise<number> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/get_hour`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_microsecond(): Promise<number> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/get_microsecond`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_minute(): Promise<number> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/get_minute`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_month(): Promise<number> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/get_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_second(): Promise<number> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/get_second`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_time_zone_offset(): Promise<number> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/get_time_zone_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_year(): Promise<number> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/get_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_day(): Promise<boolean> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/has_day`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_month(): Promise<boolean> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/has_month`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_second(): Promise<boolean> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/has_second`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_time(): Promise<boolean> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/has_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_year(): Promise<boolean> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/has_year`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async ref(): Promise<GstDateTime> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/ref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_g_date_time(): Promise<GLibDateTime> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/to_g_date_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GLibDateTime(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async to_iso8601_string(): Promise<string> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/to_iso8601_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unref(): Promise<void> {
    const url = new URL(`/Gst/DateTime/ptr,${this.ptr}/unref`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstDebugCategory {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstdebugcategoryRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstdebugcategoryRegistry.unregister(this);
    const url = new URL(`/Gst/DebugCategory/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstDebugCategory> {
    const url = new URL(`/Gst/DebugCategory/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDebugCategory();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_color(): Promise<number> {
    const url = new URL(`/Gst/DebugCategory/ptr,${this.ptr}/get_color`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_description(): Promise<string> {
    const url = new URL(`/Gst/DebugCategory/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`/Gst/DebugCategory/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_threshold(): Promise<GstDebugLevelValue> {
    const url = new URL(`/Gst/DebugCategory/ptr,${this.ptr}/get_threshold`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reset_threshold(): Promise<void> {
    const url = new URL(`/Gst/DebugCategory/ptr,${this.ptr}/reset_threshold`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_threshold(level: GstDebugLevelValue): Promise<void> {
    const url = new URL(`/Gst/DebugCategory/ptr,${this.ptr}/set_threshold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstDebugMessage {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstdebugmessageRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstdebugmessageRegistry.unregister(this);
    const url = new URL(`/Gst/DebugMessage/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstDebugMessage> {
    const url = new URL(`/Gst/DebugMessage/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDebugMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get(): Promise<string> {
    const url = new URL(`/Gst/DebugMessage/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_id(): Promise<string> {
    const url = new URL(`/Gst/DebugMessage/ptr,${this.ptr}/get_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstDevice extends GstObject {

  async create_element(name?: string): Promise<GstElement> {
    const url = new URL(`/Gst/Device/ptr,${this.ptr}/create_element`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Device/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_device_class(): Promise<string> {
    const url = new URL(`/Gst/Device/ptr,${this.ptr}/get_device_class`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_display_name(): Promise<string> {
    const url = new URL(`/Gst/Device/ptr,${this.ptr}/get_display_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_properties(): Promise<GstStructure> {
    const url = new URL(`/Gst/Device/ptr,${this.ptr}/get_properties`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_classes(classes: string): Promise<boolean> {
    const url = new URL(`/Gst/Device/ptr,${this.ptr}/has_classes`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classesv(classes: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Device/ptr,${this.ptr}/has_classesv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async reconfigure_element(element: GstElement): Promise<boolean> {
    const url = new URL(`/Gst/Device/ptr,${this.ptr}/reconfigure_element`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (element && typeof element === 'object' && 'ptr' in element) {
      url.searchParams.append('element', 'ptr,' + element.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstDeviceMonitor extends GstObject {
  static async new(): Promise<GstDeviceMonitor> {
    const url = new URL(`/Gst/DeviceMonitor/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstDeviceMonitor();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_filter(classes?: string, caps?: GstCaps): Promise<number> {
    const url = new URL(`/Gst/DeviceMonitor/ptr,${this.ptr}/add_filter`, apiConfig.baseUrl);
    // Primitive parameter
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`/Gst/DeviceMonitor/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBus(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_devices(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceMonitor/ptr,${this.ptr}/get_devices`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_providers(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceMonitor/ptr,${this.ptr}/get_providers`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_show_all_devices(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceMonitor/ptr,${this.ptr}/get_show_all_devices`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_filter(filter_id: number): Promise<boolean> {
    const url = new URL(`/Gst/DeviceMonitor/ptr,${this.ptr}/remove_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filter_id', String(filter_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_show_all_devices(show_all: boolean): Promise<void> {
    const url = new URL(`/Gst/DeviceMonitor/ptr,${this.ptr}/set_show_all_devices`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('show_all', String(show_all));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async start(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceMonitor/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async stop(): Promise<void> {
    const url = new URL(`/Gst/DeviceMonitor/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstDeviceProvider extends GstObject {

  async register(name: string, rank: number, type_: Pointer, plugin?: GstPlugin): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProvider/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_monitor(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/can_monitor`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async device_add(device: GstDevice): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/device_add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async device_changed(device: GstDevice, changed_device: GstDevice): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/device_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      url.searchParams.append('changed_device', 'ptr,' + changed_device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async device_remove(device: GstDevice): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/device_remove`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBus(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_devices(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/get_devices`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_factory(): Promise<GstDeviceProviderFactory> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/get_factory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstDeviceProviderFactory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_hidden_providers(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/get_hidden_providers`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async hide_provider(name: string): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/hide_provider`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_started(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/is_started`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async start(): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async stop(): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unhide_provider(name: string): Promise<void> {
    const url = new URL(`/Gst/DeviceProvider/ptr,${this.ptr}/unhide_provider`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstPluginFeature extends GstObject {

  async list_copy(list: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/PluginFeature/list_copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_debug(list: Pointer): Promise<void> {
    const url = new URL(`/Gst/PluginFeature/list_debug`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async list_free(list: Pointer): Promise<void> {
    const url = new URL(`/Gst/PluginFeature/list_free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async rank_compare_func(): Promise<number> {
    const url = new URL(`/Gst/PluginFeature/rank_compare_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async check_version(min_major: number, min_minor: number, min_micro: number): Promise<boolean> {
    const url = new URL(`/Gst/PluginFeature/ptr,${this.ptr}/check_version`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('min_major', String(min_major));
    // Primitive parameter
    url.searchParams.append('min_minor', String(min_minor));
    // Primitive parameter
    url.searchParams.append('min_micro', String(min_micro));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_plugin(): Promise<GstPlugin> {
    const url = new URL(`/Gst/PluginFeature/ptr,${this.ptr}/get_plugin`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPlugin(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_plugin_name(): Promise<string> {
    const url = new URL(`/Gst/PluginFeature/ptr,${this.ptr}/get_plugin_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_rank(): Promise<number> {
    const url = new URL(`/Gst/PluginFeature/ptr,${this.ptr}/get_rank`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load(): Promise<GstPluginFeature> {
    const url = new URL(`/Gst/PluginFeature/ptr,${this.ptr}/load`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPluginFeature(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_rank(rank: number): Promise<void> {
    const url = new URL(`/Gst/PluginFeature/ptr,${this.ptr}/set_rank`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstDeviceProviderFactory extends GstPluginFeature {

  async find(name: string): Promise<GstDeviceProviderFactory> {
    const url = new URL(`/Gst/DeviceProviderFactory/find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstDeviceProviderFactory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_by_name(factoryname: string): Promise<GstDeviceProvider> {
    const url = new URL(`/Gst/DeviceProviderFactory/get_by_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstDeviceProvider(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async list_get_device_providers(minrank: GstRank): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProviderFactory/list_get_device_providers`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('minrank', String(minrank));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get(): Promise<GstDeviceProvider> {
    const url = new URL(`/Gst/DeviceProviderFactory/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstDeviceProvider(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_device_provider_type(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProviderFactory/ptr,${this.ptr}/get_device_provider_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`/Gst/DeviceProviderFactory/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata_keys(): Promise<Pointer> {
    const url = new URL(`/Gst/DeviceProviderFactory/ptr,${this.ptr}/get_metadata_keys`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classes(classes?: string): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProviderFactory/ptr,${this.ptr}/has_classes`, apiConfig.baseUrl);
    // Primitive parameter
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_classesv(classes?: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/DeviceProviderFactory/ptr,${this.ptr}/has_classesv`, apiConfig.baseUrl);
    // Primitive parameter
    if (classes !== undefined) url.searchParams.append('classes', String(classes));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstDynamicTypeFactory extends GstPluginFeature {

  async load(factoryname: string): Promise<Pointer> {
    const url = new URL(`/Gst/DynamicTypeFactory/load`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstElementFactory extends GstPluginFeature {

  async find(name: string): Promise<GstElementFactory> {
    const url = new URL(`/Gst/ElementFactory/find`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElementFactory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async list_filter(list: Pointer, caps: GstCaps, direction: GstPadDirection, subsetonly: boolean): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/list_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    // Primitive parameter
    url.searchParams.append('subsetonly', String(subsetonly));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_get_elements(type_: number, minrank: GstRank): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/list_get_elements`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('minrank', String(minrank));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async make(factoryname: string, name?: string): Promise<GstElement> {
    const url = new URL(`/Gst/ElementFactory/make`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async make_with_properties(factoryname: string, n: number, names?: Pointer, values?: Pointer): Promise<GstElement> {
    const url = new URL(`/Gst/ElementFactory/make_with_properties`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('factoryname', String(factoryname));
    // Primitive parameter
    url.searchParams.append('n', String(n));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    if (values !== undefined) url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async can_sink_all_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/can_sink_all_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_sink_any_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/can_sink_any_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_src_all_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/can_src_all_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async can_src_any_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/can_src_any_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create(name?: string): Promise<GstElement> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/create`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async create_with_properties(n: number, names?: Pointer, values?: Pointer): Promise<GstElement> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/create_with_properties`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n', String(n));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    if (values !== undefined) url.searchParams.append('values', String(values));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_element_type(): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/get_element_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata(key: string): Promise<string> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/get_metadata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('key', String(key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_metadata_keys(): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/get_metadata_keys`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_num_pad_templates(): Promise<number> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/get_num_pad_templates`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_skip_documentation(): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/get_skip_documentation`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_static_pad_templates(): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/get_static_pad_templates`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uri_protocols(): Promise<Pointer> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/get_uri_protocols`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uri_type(): Promise<GstURIType> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/get_uri_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_interface(interfacename: string): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/has_interface`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interfacename', String(interfacename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async list_is_type(type_: number): Promise<boolean> {
    const url = new URL(`/Gst/ElementFactory/ptr,${this.ptr}/list_is_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstEvent {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsteventRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsteventRegistry.unregister(this);
    const url = new URL(`/Gst/Event/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_buffer_size(format: GstFormatValue, minsize: number, maxsize: number, async_: boolean): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_buffer_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('minsize', String(minsize));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('async', String(async_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_caps(caps: GstCaps): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_custom(type_: GstEventTypeValue, structure: GstStructure): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_eos(): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_eos`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_flush_start(): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_flush_start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_flush_stop(reset_time: boolean): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_flush_stop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('reset_time', String(reset_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_gap(timestamp: number, duration: number): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_gap`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_instant_rate_change(rate_multiplier: number, new_flags: GstSegmentFlags): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_instant_rate_change`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate_multiplier', String(rate_multiplier));
    // Primitive parameter
    url.searchParams.append('new_flags', String(new_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_instant_rate_sync_time(rate_multiplier: number, running_time: number, upstream_running_time: number): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_instant_rate_sync_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate_multiplier', String(rate_multiplier));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    // Primitive parameter
    url.searchParams.append('upstream_running_time', String(upstream_running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_latency(latency: number): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_latency`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('latency', String(latency));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_navigation(structure: GstStructure): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_navigation`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_protection(system_id: string, data_: GstBuffer, origin: string): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_protection`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('system_id', String(system_id));
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('origin', String(origin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_qos(type_: GstQOSType, proportion: number, diff: number, timestamp: number): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_qos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('proportion', String(proportion));
    // Primitive parameter
    url.searchParams.append('diff', String(diff));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_reconfigure(): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_seek(rate: number, format: GstFormatValue, flags: GstSeekFlags, start_type: GstSeekType, start: number, stop_type: GstSeekType, stop: number): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment(segment: GstSegment): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment_done(format: GstFormatValue, position: number): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_segment_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_select_streams(streams: Pointer): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_select_streams`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('streams', String(streams));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_sink_message(name: string, msg: GstMessage): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_sink_message`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (msg && typeof msg === 'object' && 'ptr' in msg) {
      url.searchParams.append('msg', 'ptr,' + msg.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_step(format: GstFormatValue, amount: number, rate: number, flush: boolean, intermediate: boolean): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_step`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('amount', String(amount));
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    // Primitive parameter
    url.searchParams.append('intermediate', String(intermediate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_collection(collection: GstStreamCollection): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_group_done(group_id: number): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_stream_group_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_id', String(group_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_start(stream_id: string): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_stream_start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stream_id', String(stream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_tag(taglist: GstTagList): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (taglist && typeof taglist === 'object' && 'ptr' in taglist) {
      url.searchParams.append('taglist', 'ptr,' + taglist.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_toc(toc: GstToc, updated: boolean): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    // Primitive parameter
    url.searchParams.append('updated', String(updated));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_toc_select(uid: string): Promise<GstEvent> {
    const url = new URL(`/Gst/Event/new_toc_select`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uid', String(uid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstEvent();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy_segment(segment: GstSegment): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/copy_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_running_time_offset(): Promise<number> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/get_running_time_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_seqnum(): Promise<number> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/get_seqnum`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_structure(): Promise<GstStructure> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_name(name: string): Promise<boolean> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_name_id(name: number): Promise<boolean> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/has_name_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_buffer_size(format: GstFormatValue): Promise<{ minsize?: number; maxsize?: number; async_?: boolean }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_buffer_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_caps(caps: GstCaps): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_flush_stop(): Promise<{ reset_time?: boolean }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_flush_stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_gap(): Promise<{ timestamp?: number; duration?: number }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_gap`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_gap_flags(flags: GstGapFlags): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_gap_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_group_id(): Promise<boolean> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_group_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_instant_rate_change(new_flags: GstSegmentFlags): Promise<{ rate_multiplier?: number }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_instant_rate_change`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('new_flags', String(new_flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_instant_rate_sync_time(): Promise<{ rate_multiplier?: number; running_time?: number; upstream_running_time?: number }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_instant_rate_sync_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_latency(): Promise<{ latency?: number }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_protection(data_: GstBuffer): Promise<{ system_id?: string; origin?: string }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_protection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_qos(type_: GstQOSType): Promise<{ proportion?: number; diff?: number; timestamp?: number }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_qos`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_seek(format: GstFormatValue, flags: GstSeekFlags, start_type: GstSeekType, stop_type: GstSeekType): Promise<{ rate?: number; start?: number; stop?: number }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_seek_trickmode_interval(): Promise<{ interval?: number }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_seek_trickmode_interval`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_segment(segment: GstSegment): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_segment_done(format: GstFormatValue): Promise<{ position?: number }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_segment_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_select_streams(): Promise<{ streams?: Pointer }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_select_streams`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_sink_message(msg: GstMessage): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_sink_message`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (msg && typeof msg === 'object' && 'ptr' in msg) {
      url.searchParams.append('msg', 'ptr,' + msg.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_step(format: GstFormatValue): Promise<{ amount?: number; rate?: number; flush?: boolean; intermediate?: boolean }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_step`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_stream(stream: GstStream): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + stream.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_stream`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (stream && typeof stream === 'object' && 'ptr' in stream) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (stream && typeof stream === 'object' && 'ptr' in stream) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_stream_collection(collection: GstStreamCollection): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + collection.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (collection && typeof collection === 'object' && 'ptr' in collection) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_stream_flags(flags: GstStreamFlags): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_stream_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_stream_group_done(): Promise<{ group_id?: number }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_stream_group_done`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_stream_start(): Promise<{ stream_id?: string }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_stream_start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_tag(taglist: GstTagList): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (taglist && typeof taglist === 'object' && 'ptr' in taglist) {
      url.searchParams.append('taglist', 'ptr,' + taglist.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_toc(toc: GstToc): Promise<{ updated?: boolean }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_toc_select(): Promise<{ uid?: string }> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/parse_toc_select`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async set_gap_flags(flags: GstGapFlags): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/set_gap_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_group_id(group_id: number): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/set_group_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_id', String(group_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_running_time_offset(offset: number): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/set_running_time_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_seek_trickmode_interval(interval: number): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/set_seek_trickmode_interval`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('interval', String(interval));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_seqnum(seqnum: number): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/set_seqnum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seqnum', String(seqnum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream(stream: GstStream): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/set_stream`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_flags(flags: GstStreamFlags): Promise<void> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/set_stream_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async writable_structure(): Promise<GstStructure> {
    const url = new URL(`/Gst/Event/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstFlagSet {
  ptr!: Pointer;


  async register(flags_type: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/FlagSet/register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstPad extends GstObject {
  static async new(direction: GstPadDirection, name?: string): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_static_template(templ: GstStaticPadTemplate, name: string): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/new_from_static_template`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_template(templ: GstPadTemplate, name?: string): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/new_from_template`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPad();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async link_get_name(ret: GstPadLinkReturn): Promise<string> {
    const url = new URL(`/Gst/Pad/link_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async activate_mode(mode: GstPadModeValue, active: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/activate_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_probe(mask: GstPadProbeType, callback: (pad: GstPad, info: GstPadProbeInfo, user_data: Pointer) => GstPadProbeReturn): Promise<number> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/add_probe`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.callback !== undefined) {
      callbackDispatcher.set(data.callback.toString(), callback);
    }
    return data.return;
  }
  async can_link(sinkpad: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/can_link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async chain(buffer: GstBuffer): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/chain`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async chain_list(list: GstBufferList): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/chain_list`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async check_reconfigure(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/check_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async create_stream_id(parent: GstElement, stream_id?: string): Promise<string> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/create_stream_id`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    if (stream_id !== undefined) url.searchParams.append('stream_id', String(stream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async event_default(event: GstEvent, parent?: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/event_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async forward(forward: (pad: GstPad, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/forward`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.forward !== undefined) {
      callbackDispatcher.set(data.forward.toString(), forward);
    }
    return data.return;
  }
  async get_allowed_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_allowed_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_current_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_current_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_direction(): Promise<GstPadDirection> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_direction`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_element_private(): Promise<void> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_element_private`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_last_flow_return(): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_last_flow_return`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_offset(): Promise<number> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_offset`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pad_template(): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_pad_template`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPadTemplate(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_pad_template_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_pad_template_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_parent_element(): Promise<GstElement> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_parent_element`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_peer(): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_peer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_range(offset: number, size: number, buffer: GstBuffer): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_single_internal_link(): Promise<GstPad> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_single_internal_link`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_sticky_event(event_type: GstEventTypeValue, idx: number): Promise<GstEvent> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_sticky_event`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('event_type', String(event_type));
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstEvent(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_stream(): Promise<GstStream> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_stream`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStream(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_stream_id(): Promise<string> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_stream_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_task_state(): Promise<GstTaskState> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/get_task_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_current_caps(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/has_current_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_active(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_blocked(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/is_blocked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_blocking(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/is_blocking`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_linked(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/is_linked`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_internal_links(): Promise<GstIterator> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/iterate_internal_links`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async iterate_internal_links_default(parent?: GstObject): Promise<GstIterator> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/iterate_internal_links_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async link(sinkpad: GstPad): Promise<GstPadLinkReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/link`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_full(sinkpad: GstPad, flags: GstPadLinkCheck): Promise<GstPadLinkReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/link_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_maybe_ghosting(sink: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/link_maybe_ghosting`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sink && typeof sink === 'object' && 'ptr' in sink) {
      url.searchParams.append('sink', 'ptr,' + sink.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async link_maybe_ghosting_full(sink: GstPad, flags: GstPadLinkCheck): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/link_maybe_ghosting_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sink && typeof sink === 'object' && 'ptr' in sink) {
      url.searchParams.append('sink', 'ptr,' + sink.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async mark_reconfigure(): Promise<void> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/mark_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async needs_reconfigure(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/needs_reconfigure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pause_task(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/pause_task`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/peer_query`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_accept_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/peer_query_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_caps(filter?: GstCaps): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/peer_query_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async peer_query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/peer_query_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_val', String(src_val));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_duration(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/peer_query_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peer_query_position(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/peer_query_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async proxy_query_accept_caps(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/proxy_query_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async proxy_query_caps(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/proxy_query_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pull_range(offset: number, size: number, buffer: GstBuffer): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/pull_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push(buffer: GstBuffer): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push_event(event: GstEvent): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/push_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push_list(list: GstBufferList): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/push_list`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query(query: GstQuery): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/query`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_accept_caps(caps: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/query_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_caps(filter?: GstCaps): Promise<GstCaps> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/query_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter !== undefined && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async query_convert(src_format: GstFormatValue, src_val: number, dest_format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/query_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_val', String(src_val));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_default(query: GstQuery, parent?: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/query_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (query && typeof query === 'object' && 'ptr' in query) {
      url.searchParams.append('query', 'ptr,' + query.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_duration(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/query_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_position(format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/query_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_probe(id: number): Promise<void> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/remove_probe`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('id', String(id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async send_event(event: GstEvent): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/send_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_activate_function_full(activate: (pad: GstPad, parent: GstObject) => boolean): Promise<{ activate?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_activate_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.activate !== undefined) {
      callbackDispatcher.set(data.activate.toString(), activate);
    }
    return data;
  }
  async set_activatemode_function_full(activatemode: (pad: GstPad, parent: GstObject, mode: GstPadModeValue, active: boolean) => boolean): Promise<{ activatemode?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_activatemode_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.activatemode !== undefined) {
      callbackDispatcher.set(data.activatemode.toString(), activatemode);
    }
    return data;
  }
  async set_active(active: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_active`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_chain_function_full(chain: (pad: GstPad, parent: GstObject, buffer: GstBuffer) => GstFlowReturn): Promise<{ chain?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_chain_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.chain !== undefined) {
      callbackDispatcher.set(data.chain.toString(), chain);
    }
    return data;
  }
  async set_chain_list_function_full(chainlist: (pad: GstPad, parent: GstObject, list: GstBufferList) => GstFlowReturn): Promise<{ chainlist?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_chain_list_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.chainlist !== undefined) {
      callbackDispatcher.set(data.chainlist.toString(), chainlist);
    }
    return data;
  }
  async set_element_private(): Promise<void> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_element_private`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_event_full_function_full(event: (pad: GstPad, parent: GstObject, event: GstEvent) => GstFlowReturn): Promise<{ event?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_event_full_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.event !== undefined) {
      callbackDispatcher.set(data.event.toString(), event);
    }
    return data;
  }
  async set_event_function_full(event: (pad: GstPad, parent: GstObject, event: GstEvent) => boolean): Promise<{ event?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_event_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.event !== undefined) {
      callbackDispatcher.set(data.event.toString(), event);
    }
    return data;
  }
  async set_getrange_function_full(get: (pad: GstPad, parent: GstObject, offset: number, length: number, buffer: GstBuffer) => GstFlowReturn): Promise<{ get?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_getrange_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.get !== undefined) {
      callbackDispatcher.set(data.get.toString(), get);
    }
    return data;
  }
  async set_iterate_internal_links_function_full(iterintlink: (pad: GstPad, parent: GstObject) => GstIterator): Promise<{ iterintlink?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_iterate_internal_links_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.iterintlink !== undefined) {
      callbackDispatcher.set(data.iterintlink.toString(), iterintlink);
    }
    return data;
  }
  async set_link_function_full(link: (pad: GstPad, parent: GstObject, peer: GstPad) => GstPadLinkReturn): Promise<{ link?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_link_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.link !== undefined) {
      callbackDispatcher.set(data.link.toString(), link);
    }
    return data;
  }
  async set_offset(offset: number): Promise<void> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_offset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_query_function_full(query: (pad: GstPad, parent: GstObject, query: GstQuery) => boolean): Promise<{ query?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_query_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.query !== undefined) {
      callbackDispatcher.set(data.query.toString(), query);
    }
    return data;
  }
  async set_unlink_function_full(unlink: (pad: GstPad, parent: GstObject) => void): Promise<{ unlink?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/set_unlink_function_full`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.unlink !== undefined) {
      callbackDispatcher.set(data.unlink.toString(), unlink);
    }
    return data;
  }
  async start_task(func: (user_data: Pointer) => void): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/start_task`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async sticky_events_foreach(foreach_func: (pad: GstPad, event: GstEvent, user_data: Pointer) => boolean): Promise<{ foreach_func?: number }> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/sticky_events_foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.foreach_func !== undefined) {
      callbackDispatcher.set(data.foreach_func.toString(), foreach_func);
    }
    return data;
  }
  async stop_task(): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/stop_task`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async store_sticky_event(event: GstEvent): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/store_sticky_event`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (event && typeof event === 'object' && 'ptr' in event) {
      url.searchParams.append('event', 'ptr,' + event.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async unlink(sinkpad: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/unlink`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (sinkpad && typeof sinkpad === 'object' && 'ptr' in sinkpad) {
      url.searchParams.append('sinkpad', 'ptr,' + sinkpad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async use_fixed_caps(): Promise<void> {
    const url = new URL(`/Gst/Pad/ptr,${this.ptr}/use_fixed_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstProxyPad extends GstPad {

  async chain_default(pad: GstPad, buffer: GstBuffer, parent?: GstObject): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/ProxyPad/chain_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async chain_list_default(pad: GstPad, list: GstBufferList, parent?: GstObject): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/ProxyPad/chain_list_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async getrange_default(pad: GstPad, parent: GstObject, offset: number, size: number, buffer: GstBuffer): Promise<GstFlowReturn> {
    const url = new URL(`/Gst/ProxyPad/getrange_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async iterate_internal_links_default(pad: GstPad, parent?: GstObject): Promise<GstIterator> {
    const url = new URL(`/Gst/ProxyPad/iterate_internal_links_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_internal(): Promise<GstProxyPad> {
    const url = new URL(`/Gst/ProxyPad/ptr,${this.ptr}/get_internal`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstProxyPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstGhostPad extends GstProxyPad {
  static async new(target: GstPad, name?: string): Promise<GstGhostPad> {
    const url = new URL(`/Gst/GhostPad/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_template(target: GstPad, templ: GstPadTemplate, name?: string): Promise<GstGhostPad> {
    const url = new URL(`/Gst/GhostPad/new_from_template`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (target && typeof target === 'object' && 'ptr' in target) {
      url.searchParams.append('target', 'ptr,' + target.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_no_target(dir: GstPadDirection, name?: string): Promise<GstGhostPad> {
    const url = new URL(`/Gst/GhostPad/new_no_target`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('dir', String(dir));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_no_target_from_template(templ: GstPadTemplate, name?: string): Promise<GstGhostPad> {
    const url = new URL(`/Gst/GhostPad/new_no_target_from_template`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (templ && typeof templ === 'object' && 'ptr' in templ) {
      url.searchParams.append('templ', 'ptr,' + templ.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstGhostPad();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async activate_mode_default(pad: GstPad, mode: GstPadModeValue, active: boolean, parent?: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/GhostPad/activate_mode_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async internal_activate_mode_default(pad: GstPad, mode: GstPadModeValue, active: boolean, parent?: GstObject): Promise<boolean> {
    const url = new URL(`/Gst/GhostPad/internal_activate_mode_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (parent !== undefined && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async construct(): Promise<boolean> {
    const url = new URL(`/Gst/GhostPad/ptr,${this.ptr}/construct`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_target(): Promise<GstPad> {
    const url = new URL(`/Gst/GhostPad/ptr,${this.ptr}/get_target`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPad(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_target(newtarget?: GstPad): Promise<boolean> {
    const url = new URL(`/Gst/GhostPad/ptr,${this.ptr}/set_target`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (newtarget !== undefined && typeof newtarget === 'object' && 'ptr' in newtarget) {
      url.searchParams.append('newtarget', 'ptr,' + newtarget.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstIterator {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstiteratorRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstiteratorRegistry.unregister(this);
    const url = new URL(`/Gst/Iterator/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_single(type_: Pointer, object: GObjectValue): Promise<GstIterator> {
    const url = new URL(`/Gst/Iterator/new_single`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstIterator();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GstIterator> {
    const url = new URL(`/Gst/Iterator/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async filter(user_data: GObjectValue, func: (a: Pointer, b: Pointer) => number): Promise<GstIterator> {
    const url = new URL(`/Gst/Iterator/ptr,${this.ptr}/filter`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (user_data && typeof user_data === 'object' && 'ptr' in user_data) {
      url.searchParams.append('user_data', 'ptr,' + user_data.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async find_custom(elem: GObjectValue, func: (a: Pointer, b: Pointer) => number): Promise<boolean> {
    const url = new URL(`/Gst/Iterator/ptr,${this.ptr}/find_custom`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (elem && typeof elem === 'object' && 'ptr' in elem) {
      url.searchParams.append('elem', 'ptr,' + elem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async fold(ret: GObjectValue, func: (item: GObjectValue, ret: GObjectValue, user_data: Pointer) => boolean): Promise<GstIteratorResult> {
    const url = new URL(`/Gst/Iterator/ptr,${this.ptr}/fold`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ret && typeof ret === 'object' && 'ptr' in ret) {
      url.searchParams.append('ret', 'ptr,' + ret.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async foreach(func: (item: GObjectValue, user_data: Pointer) => void): Promise<GstIteratorResult> {
    const url = new URL(`/Gst/Iterator/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async next(elem: GObjectValue): Promise<GstIteratorResult> {
    const url = new URL(`/Gst/Iterator/ptr,${this.ptr}/next`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (elem && typeof elem === 'object' && 'ptr' in elem) {
      url.searchParams.append('elem', 'ptr,' + elem.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async push(other: GstIterator): Promise<void> {
    const url = new URL(`/Gst/Iterator/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (other && typeof other === 'object' && 'ptr' in other) {
      url.searchParams.append('other', 'ptr,' + other.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async resync(): Promise<void> {
    const url = new URL(`/Gst/Iterator/ptr,${this.ptr}/resync`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstMemory {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstmemoryRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstmemoryRegistry.unregister(this);
    const url = new URL(`/Gst/Memory/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_wrapped(flags: GstMemoryFlags, data_: Pointer, maxsize: number, offset: number, size: number, notify: (data_: Pointer) => void): Promise<GstMemory> {
    const url = new URL(`/Gst/Memory/new_wrapped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.notify !== undefined) {
      callbackDispatcher.set(data.notify.toString(), notify);
    }
    const instance = new GstMemory();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(offset: number, size: number): Promise<GstMemory> {
    const url = new URL(`/Gst/Memory/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_sizes(): Promise<number> {
    const url = new URL(`/Gst/Memory/ptr,${this.ptr}/get_sizes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_span(mem2: GstMemory): Promise<boolean> {
    const url = new URL(`/Gst/Memory/ptr,${this.ptr}/is_span`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mem2 && typeof mem2 === 'object' && 'ptr' in mem2) {
      url.searchParams.append('mem2', 'ptr,' + mem2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_type(mem_type: string): Promise<boolean> {
    const url = new URL(`/Gst/Memory/ptr,${this.ptr}/is_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem_type', String(mem_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async make_mapped(info: GstMapInfo, flags: GstMapFlags): Promise<GstMemory> {
    const url = new URL(`/Gst/Memory/ptr,${this.ptr}/make_mapped`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async map(info: GstMapInfo, flags: GstMapFlags): Promise<boolean> {
    const url = new URL(`/Gst/Memory/ptr,${this.ptr}/map`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async resize(offset: number, size: number): Promise<void> {
    const url = new URL(`/Gst/Memory/ptr,${this.ptr}/resize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async share(offset: number, size: number): Promise<GstMemory> {
    const url = new URL(`/Gst/Memory/ptr,${this.ptr}/share`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMemory(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async unmap(info: GstMapInfo): Promise<void> {
    const url = new URL(`/Gst/Memory/ptr,${this.ptr}/unmap`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstMessage {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstmessageRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstmessageRegistry.unregister(this);
    const url = new URL(`/Gst/Message/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_application(structure: GstStructure, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_application`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_async_done(running_time: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_async_done`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_async_start(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_async_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_buffering(percent: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_buffering`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('percent', String(percent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_clock_lost(clock: GstClock, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_clock_lost`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_clock_provide(clock: GstClock, ready: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_clock_provide`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    // Primitive parameter
    url.searchParams.append('ready', String(ready));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_custom(type_: GstMessageTypeValue, src?: GstObject, structure?: GstStructure): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_device_added(device: GstDevice, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_device_added`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_device_changed(device: GstDevice, changed_device: GstDevice, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_device_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      url.searchParams.append('changed_device', 'ptr,' + changed_device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_device_removed(device: GstDevice, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_device_removed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_duration_changed(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_duration_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_element(structure: GstStructure, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_element`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_eos(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_eos`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_error(error_: Pointer, debug: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_error`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_error_with_details(error_: Pointer, debug: string, src?: GstObject, details?: GstStructure): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_error_with_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    // Object with explode=false: serialize as comma-separated
    if (details !== undefined && typeof details === 'object' && 'ptr' in details) {
      url.searchParams.append('details', 'ptr,' + details.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_have_context(context: GstContext, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_have_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (context && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_info(error_: Pointer, debug: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_info`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_info_with_details(error_: Pointer, debug: string, src?: GstObject, details?: GstStructure): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_info_with_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    // Object with explode=false: serialize as comma-separated
    if (details !== undefined && typeof details === 'object' && 'ptr' in details) {
      url.searchParams.append('details', 'ptr,' + details.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_instant_rate_request(rate_multiplier: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_instant_rate_request`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('rate_multiplier', String(rate_multiplier));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_latency(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_latency`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_need_context(context_type: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_need_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_new_clock(clock: GstClock, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_new_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_progress(type_: GstProgressType, code: string, text: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_progress`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    // Primitive parameter
    url.searchParams.append('text', String(text));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_property_notify(src: GstObject, property_name: string, val?: GObjectValue): Promise<GstMessage> {
    // Increment ref for parameters with full transfer ownership
    if (val && typeof val === 'object' && 'ptr' in val) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + val.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Message/new_property_notify`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('property_name', String(property_name));
    // Object with explode=false: serialize as comma-separated
    if (val !== undefined && typeof val === 'object' && 'ptr' in val) {
      url.searchParams.append('val', 'ptr,' + val.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (val && typeof val === 'object' && 'ptr' in val) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + val.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      const instance = new GstMessage();
      Object.assign(instance, data.return || data);
      return instance;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (val && typeof val === 'object' && 'ptr' in val) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + val.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  static async new_qos(live: boolean, running_time: number, stream_time: number, timestamp: number, duration: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_qos`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('live', String(live));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    // Primitive parameter
    url.searchParams.append('stream_time', String(stream_time));
    // Primitive parameter
    url.searchParams.append('timestamp', String(timestamp));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_redirect(location: string, src?: GstObject, tag_list?: GstTagList, entry_struct?: GstStructure): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_redirect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Object with explode=false: serialize as comma-separated
    if (tag_list !== undefined && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (entry_struct !== undefined && typeof entry_struct === 'object' && 'ptr' in entry_struct) {
      url.searchParams.append('entry_struct', 'ptr,' + entry_struct.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_request_state(state: GstState, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_request_state`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_reset_time(running_time: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_reset_time`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment_done(format: GstFormatValue, position: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_segment_done`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment_start(format: GstFormatValue, position: number, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_segment_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_state_changed(oldstate: GstState, newstate: GstState, pending: GstState, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_state_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('oldstate', String(oldstate));
    // Primitive parameter
    url.searchParams.append('newstate', String(newstate));
    // Primitive parameter
    url.searchParams.append('pending', String(pending));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_state_dirty(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_state_dirty`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_step_done(format: GstFormatValue, amount: number, rate: number, flush: boolean, intermediate: boolean, duration: number, eos: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_step_done`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('amount', String(amount));
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    // Primitive parameter
    url.searchParams.append('intermediate', String(intermediate));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    // Primitive parameter
    url.searchParams.append('eos', String(eos));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_step_start(active: boolean, format: GstFormatValue, amount: number, rate: number, flush: boolean, intermediate: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_step_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('amount', String(amount));
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('flush', String(flush));
    // Primitive parameter
    url.searchParams.append('intermediate', String(intermediate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_collection(collection: GstStreamCollection, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_start(src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_stream_start`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_stream_status(type_: GstStreamStatusType, owner: GstElement, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_stream_status`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_streams_selected(collection: GstStreamCollection, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_streams_selected`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_structure_change(type_: GstStructureChangeType, owner: GstElement, busy: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_structure_change`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    // Primitive parameter
    url.searchParams.append('busy', String(busy));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_tag(tag_list: GstTagList, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (tag_list && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_toc(toc: GstToc, updated: boolean, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    // Primitive parameter
    url.searchParams.append('updated', String(updated));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_warning(error_: Pointer, debug: string, src?: GstObject): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_warning`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_warning_with_details(error_: Pointer, debug: string, src?: GstObject, details?: GstStructure): Promise<GstMessage> {
    const url = new URL(`/Gst/Message/new_warning_with_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (src !== undefined && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    // Primitive parameter
    url.searchParams.append('error', String(error_));
    // Primitive parameter
    url.searchParams.append('debug', String(debug));
    // Object with explode=false: serialize as comma-separated
    if (details !== undefined && typeof details === 'object' && 'ptr' in details) {
      url.searchParams.append('details', 'ptr,' + details.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMessage();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_redirect_entry(location: string, tag_list?: GstTagList, entry_struct?: GstStructure): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/add_redirect_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('location', String(location));
    // Object with explode=false: serialize as comma-separated
    if (tag_list !== undefined && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (entry_struct !== undefined && typeof entry_struct === 'object' && 'ptr' in entry_struct) {
      url.searchParams.append('entry_struct', 'ptr,' + entry_struct.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_num_redirect_entries(): Promise<number> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/get_num_redirect_entries`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_seqnum(): Promise<number> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/get_seqnum`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_status_object(): Promise<GObjectValue> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/get_stream_status_object`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_structure(): Promise<GstStructure> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_name(name: string): Promise<boolean> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_async_done(): Promise<{ running_time?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_async_done`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering(): Promise<{ percent?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_buffering`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering_stats(mode: GstBufferingMode): Promise<{ avg_in?: number; avg_out?: number; buffering_left?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_clock_lost(clock: GstClock): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_clock_lost`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_clock_provide(clock: GstClock): Promise<{ ready?: boolean }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_clock_provide`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_context_type(): Promise<boolean> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_context_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_device_added(device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (device && typeof device === 'object' && 'ptr' in device) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + device.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_device_added`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (device && typeof device === 'object' && 'ptr' in device) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_device_changed(device: GstDevice, changed_device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (device && typeof device === 'object' && 'ptr' in device) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + device.ptr + '/ref').catch(() => {});
    }
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + changed_device.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_device_changed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
      url.searchParams.append('changed_device', 'ptr,' + changed_device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + changed_device.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (device && typeof device === 'object' && 'ptr' in device) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
      }
      if (changed_device && typeof changed_device === 'object' && 'ptr' in changed_device) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + changed_device.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_device_removed(device: GstDevice): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (device && typeof device === 'object' && 'ptr' in device) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + device.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_device_removed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (device && typeof device === 'object' && 'ptr' in device) {
      url.searchParams.append('device', 'ptr,' + device.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (device && typeof device === 'object' && 'ptr' in device) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (device && typeof device === 'object' && 'ptr' in device) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + device.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_error(): Promise<{ gerror?: Pointer; debug?: string }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_error`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_error_details(structure?: GstStructure): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_error_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_group_id(): Promise<boolean> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_group_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_have_context(context: GstContext): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_have_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_info(): Promise<{ gerror?: Pointer; debug?: string }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_info_details(structure?: GstStructure): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_info_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_instant_rate_request(): Promise<{ rate_multiplier?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_instant_rate_request`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_new_clock(clock: GstClock): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_new_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_progress(type_: GstProgressType): Promise<{ code?: string; text?: string }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_progress`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_property_notify(object: GstObject, property_value?: GObjectValue): Promise<{ property_name?: string }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_property_notify`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (property_value !== undefined && typeof property_value === 'object' && 'ptr' in property_value) {
      url.searchParams.append('property_value', 'ptr,' + property_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_qos(): Promise<{ live?: boolean; running_time?: number; stream_time?: number; timestamp?: number; duration?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_qos`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_qos_stats(format: GstFormatValue): Promise<{ processed?: number; dropped?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_qos_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_qos_values(): Promise<{ jitter?: number; proportion?: number; quality?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_qos_values`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_redirect_entry(entry_index: number, tag_list?: GstTagList, entry_struct?: GstStructure): Promise<{ location?: string }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_redirect_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('entry_index', String(entry_index));
    // Object with explode=false: serialize as comma-separated
    if (tag_list !== undefined && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (entry_struct !== undefined && typeof entry_struct === 'object' && 'ptr' in entry_struct) {
      url.searchParams.append('entry_struct', 'ptr,' + entry_struct.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_request_state(state: GstState): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_request_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_reset_time(): Promise<{ running_time?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_reset_time`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_segment_done(format: GstFormatValue): Promise<{ position?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_segment_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_segment_start(format: GstFormatValue): Promise<{ position?: number }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_segment_start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_state_changed(oldstate: GstState, newstate: GstState, pending: GstState): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_state_changed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('oldstate', String(oldstate));
    // Primitive parameter
    url.searchParams.append('newstate', String(newstate));
    // Primitive parameter
    url.searchParams.append('pending', String(pending));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_step_done(format: GstFormatValue): Promise<{ amount?: number; rate?: number; flush?: boolean; intermediate?: boolean; duration?: number; eos?: boolean }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_step_done`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_step_start(format: GstFormatValue): Promise<{ active?: boolean; amount?: number; rate?: number; flush?: boolean; intermediate?: boolean }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_step_start`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_stream_collection(collection: GstStreamCollection): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + collection.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_stream_collection`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (collection && typeof collection === 'object' && 'ptr' in collection) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_stream_status(type_: GstStreamStatusType, owner: GstElement): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_stream_status`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_streams_selected(collection: GstStreamCollection): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + collection.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_streams_selected`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (collection && typeof collection === 'object' && 'ptr' in collection) {
      url.searchParams.append('collection', 'ptr,' + collection.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (collection && typeof collection === 'object' && 'ptr' in collection) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (collection && typeof collection === 'object' && 'ptr' in collection) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + collection.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_structure_change(type_: GstStructureChangeType, owner: GstElement): Promise<{ busy?: boolean }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_structure_change`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (owner && typeof owner === 'object' && 'ptr' in owner) {
      url.searchParams.append('owner', 'ptr,' + owner.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_tag(tag_list: GstTagList): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_tag`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tag_list && typeof tag_list === 'object' && 'ptr' in tag_list) {
      url.searchParams.append('tag_list', 'ptr,' + tag_list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_toc(toc: GstToc): Promise<{ updated?: boolean }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_toc`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (toc && typeof toc === 'object' && 'ptr' in toc) {
      url.searchParams.append('toc', 'ptr,' + toc.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_warning(): Promise<{ gerror?: Pointer; debug?: string }> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_warning`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_warning_details(structure?: GstStructure): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/parse_warning_details`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffering_stats(mode: GstBufferingMode, avg_in: number, avg_out: number, buffering_left: number): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/set_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('avg_in', String(avg_in));
    // Primitive parameter
    url.searchParams.append('avg_out', String(avg_out));
    // Primitive parameter
    url.searchParams.append('buffering_left', String(buffering_left));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_group_id(group_id: number): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/set_group_id`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('group_id', String(group_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_qos_stats(format: GstFormatValue, processed: number, dropped: number): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/set_qos_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('processed', String(processed));
    // Primitive parameter
    url.searchParams.append('dropped', String(dropped));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_qos_values(jitter: number, proportion: number, quality: number): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/set_qos_values`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('jitter', String(jitter));
    // Primitive parameter
    url.searchParams.append('proportion', String(proportion));
    // Primitive parameter
    url.searchParams.append('quality', String(quality));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_seqnum(seqnum: number): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/set_seqnum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('seqnum', String(seqnum));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_status_object(object: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/set_stream_status_object`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async streams_selected_add(stream: GstStream): Promise<void> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/streams_selected_add`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async streams_selected_get_size(): Promise<number> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/streams_selected_get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async streams_selected_get_stream(idx: number): Promise<GstStream> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/streams_selected_get_stream`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('idx', String(idx));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStream(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async writable_structure(): Promise<GstStructure> {
    const url = new URL(`/Gst/Message/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstmetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstmetaRegistry.unregister(this);
    const url = new URL(`/Gst/Meta/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstMeta> {
    const url = new URL(`/Gst/Meta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async compare_seqnum(meta2: GstMeta): Promise<number> {
    const url = new URL(`/Gst/Meta/ptr,${this.ptr}/compare_seqnum`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (meta2 && typeof meta2 === 'object' && 'ptr' in meta2) {
      url.searchParams.append('meta2', 'ptr,' + meta2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_seqnum(): Promise<number> {
    const url = new URL(`/Gst/Meta/ptr,${this.ptr}/get_seqnum`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async serialize(data_: GstByteArrayInterface): Promise<boolean> {
    const url = new URL(`/Gst/Meta/ptr,${this.ptr}/serialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (data_ && typeof data_ === 'object' && 'ptr' in data_) {
      url.searchParams.append('data', 'ptr,' + data_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async serialize_simple(data_: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Meta/ptr,${this.ptr}/serialize_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async api_type_get_tags(api: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/Meta/api_type_get_tags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async api_type_has_tag(api: Pointer, tag: number): Promise<boolean> {
    const url = new URL(`/Gst/Meta/api_type_has_tag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async api_type_register(api: string, tags: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/Meta/api_type_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async deserialize(buffer: GstBuffer, data_: number, size: number): Promise<GstMeta> {
    const url = new URL(`/Gst/Meta/deserialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_info(impl: string): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/Meta/get_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('impl', String(impl));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async register_custom(name: string, tags: Pointer, transform_func: (transbuf: GstBuffer, meta: GstCustomMeta, buffer: GstBuffer, type_: number, data_: Pointer, user_data: Pointer) => boolean): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/Meta/register_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.transform_func !== undefined) {
      callbackDispatcher.set(data.transform_func.toString(), transform_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async register_custom_simple(name: string): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/Meta/register_custom_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstMetaInfo {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstmetainfoRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstmetainfoRegistry.unregister(this);
    const url = new URL(`/Gst/MetaInfo/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/MetaInfo/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMetaInfo();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async is_custom(): Promise<boolean> {
    const url = new URL(`/Gst/MetaInfo/ptr,${this.ptr}/is_custom`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async register(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/MetaInfo/ptr,${this.ptr}/register`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstMiniObject {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstminiobjectRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstminiobjectRegistry.unregister(this);
    const url = new URL(`/Gst/MiniObject/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstMiniObject> {
    const url = new URL(`/Gst/MiniObject/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstMiniObject();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_parent(parent: GstMiniObject): Promise<void> {
    const url = new URL(`/Gst/MiniObject/ptr,${this.ptr}/add_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_qdata(quark: number): Promise<void> {
    const url = new URL(`/Gst/MiniObject/ptr,${this.ptr}/get_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_writable(): Promise<boolean> {
    const url = new URL(`/Gst/MiniObject/ptr,${this.ptr}/is_writable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lock(flags: GstLockFlags): Promise<boolean> {
    const url = new URL(`/Gst/MiniObject/ptr,${this.ptr}/lock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_parent(parent: GstMiniObject): Promise<void> {
    const url = new URL(`/Gst/MiniObject/ptr,${this.ptr}/remove_parent`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (parent && typeof parent === 'object' && 'ptr' in parent) {
      url.searchParams.append('parent', 'ptr,' + parent.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_qdata(quark: number, destroy: (data_: Pointer) => void): Promise<{ destroy?: number }> {
    const url = new URL(`/Gst/MiniObject/ptr,${this.ptr}/set_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.destroy !== undefined) {
      callbackDispatcher.set(data.destroy.toString(), destroy);
    }
    return data;
  }
  async steal_qdata(quark: number): Promise<void> {
    const url = new URL(`/Gst/MiniObject/ptr,${this.ptr}/steal_qdata`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async unlock(flags: GstLockFlags): Promise<void> {
    const url = new URL(`/Gst/MiniObject/ptr,${this.ptr}/unlock`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async replace(olddata?: GstMiniObject, newdata?: GstMiniObject): Promise<boolean> {
    const url = new URL(`/Gst/MiniObject/replace`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata !== undefined && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata !== undefined && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async take(olddata: GstMiniObject, newdata: GstMiniObject): Promise<boolean> {
    const url = new URL(`/Gst/MiniObject/take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstPadProbeInfo {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstpadprobeinfoRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstpadprobeinfoRegistry.unregister(this);
    const url = new URL(`/Gst/PadProbeInfo/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstPadProbeInfo> {
    const url = new URL(`/Gst/PadProbeInfo/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadProbeInfo();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_buffer(): Promise<GstBuffer> {
    const url = new URL(`/Gst/PadProbeInfo/ptr,${this.ptr}/get_buffer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_buffer_list(): Promise<GstBufferList> {
    const url = new URL(`/Gst/PadProbeInfo/ptr,${this.ptr}/get_buffer_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBufferList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_event(): Promise<GstEvent> {
    const url = new URL(`/Gst/PadProbeInfo/ptr,${this.ptr}/get_event`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstEvent(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_query(): Promise<GstQuery> {
    const url = new URL(`/Gst/PadProbeInfo/ptr,${this.ptr}/get_query`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstQuery(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstPadTemplate extends GstObject {
  static async new(name_template: string, direction: GstPadDirection, presence: GstPadPresence, caps: GstCaps): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/PadTemplate/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name_template', String(name_template));
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    // Primitive parameter
    url.searchParams.append('presence', String(presence));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_static_pad_template_with_gtype(pad_template: GstStaticPadTemplate, pad_type: Pointer): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/PadTemplate/new_from_static_pad_template_with_gtype`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad_template && typeof pad_template === 'object' && 'ptr' in pad_template) {
      url.searchParams.append('pad_template', 'ptr,' + pad_template.ptr);
    }
    // Primitive parameter
    url.searchParams.append('pad_type', String(pad_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_with_gtype(name_template: string, direction: GstPadDirection, presence: GstPadPresence, caps: GstCaps, pad_type: Pointer): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/PadTemplate/new_with_gtype`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name_template', String(name_template));
    // Primitive parameter
    url.searchParams.append('direction', String(direction));
    // Primitive parameter
    url.searchParams.append('presence', String(presence));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('pad_type', String(pad_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/PadTemplate/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_documentation_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/PadTemplate/ptr,${this.ptr}/get_documentation_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async pad_created(pad: GstPad): Promise<void> {
    const url = new URL(`/Gst/PadTemplate/ptr,${this.ptr}/pad_created`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pad && typeof pad === 'object' && 'ptr' in pad) {
      url.searchParams.append('pad', 'ptr,' + pad.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_documentation_caps(caps: GstCaps): Promise<void> {
    const url = new URL(`/Gst/PadTemplate/ptr,${this.ptr}/set_documentation_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstParentBufferMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstparentbuffermetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstparentbuffermetaRegistry.unregister(this);
    const url = new URL(`/Gst/ParentBufferMeta/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstParentBufferMeta> {
    const url = new URL(`/Gst/ParentBufferMeta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstParentBufferMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_info(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/ParentBufferMeta/get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstParseContext {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstparsecontextRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstparsecontextRegistry.unregister(this);
    const url = new URL(`/Gst/ParseContext/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstParseContext> {
    const url = new URL(`/Gst/ParseContext/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstParseContext();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async copy(): Promise<GstParseContext> {
    const url = new URL(`/Gst/ParseContext/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstParseContext(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_missing_elements(): Promise<Pointer> {
    const url = new URL(`/Gst/ParseContext/ptr,${this.ptr}/get_missing_elements`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstPipeline extends GstBin {
  static async new(name?: string): Promise<GstPipeline> {
    const url = new URL(`/Gst/Pipeline/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (name !== undefined) url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPipeline();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async auto_clock(): Promise<void> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/auto_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_auto_flush_bus(): Promise<boolean> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/get_auto_flush_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_bus(): Promise<GstBus> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/get_bus`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBus(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_configured_latency(): Promise<number> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/get_configured_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_delay(): Promise<number> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/get_delay`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_latency(): Promise<number> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/get_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pipeline_clock(): Promise<GstClock> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/get_pipeline_clock`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstClock(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_live(): Promise<boolean> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/is_live`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_auto_flush_bus(auto_flush: boolean): Promise<void> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/set_auto_flush_bus`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('auto_flush', String(auto_flush));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_delay(delay: number): Promise<void> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/set_delay`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('delay', String(delay));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_latency(latency: number): Promise<void> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/set_latency`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('latency', String(latency));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async use_clock(clock?: GstClock): Promise<void> {
    const url = new URL(`/Gst/Pipeline/ptr,${this.ptr}/use_clock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (clock !== undefined && typeof clock === 'object' && 'ptr' in clock) {
      url.searchParams.append('clock', 'ptr,' + clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstPlugin extends GstObject {

  async list_free(list: Pointer): Promise<void> {
    const url = new URL(`/Gst/Plugin/list_free`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async load_by_name(name: string): Promise<GstPlugin> {
    const url = new URL(`/Gst/Plugin/load_by_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPlugin(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async load_file(filename: Pointer): Promise<GstPlugin> {
    const url = new URL(`/Gst/Plugin/load_file`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPlugin(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async register_static(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package_: string, origin: string, init_func: (plugin: GstPlugin) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Plugin/register_static`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('major_version', String(major_version));
    // Primitive parameter
    url.searchParams.append('minor_version', String(minor_version));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    // Primitive parameter
    url.searchParams.append('version', String(version));
    // Primitive parameter
    url.searchParams.append('license', String(license));
    // Primitive parameter
    url.searchParams.append('source', String(source));
    // Primitive parameter
    url.searchParams.append('package', String(package_));
    // Primitive parameter
    url.searchParams.append('origin', String(origin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.init_func !== undefined) {
      callbackDispatcher.set(data.init_func.toString(), init_func);
    }
    return data.return;
  }
  async register_static_full(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package_: string, origin: string, init_full_func: (plugin: GstPlugin, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Plugin/register_static_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('major_version', String(major_version));
    // Primitive parameter
    url.searchParams.append('minor_version', String(minor_version));
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    // Primitive parameter
    url.searchParams.append('version', String(version));
    // Primitive parameter
    url.searchParams.append('license', String(license));
    // Primitive parameter
    url.searchParams.append('source', String(source));
    // Primitive parameter
    url.searchParams.append('package', String(package_));
    // Primitive parameter
    url.searchParams.append('origin', String(origin));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.init_full_func !== undefined) {
      callbackDispatcher.set(data.init_full_func.toString(), init_full_func);
    }
    return data.return;
  }
  async add_dependency(flags: GstPluginDependencyFlags, env_vars?: Pointer, paths?: Pointer, names?: Pointer): Promise<void> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/add_dependency`, apiConfig.baseUrl);
    // Primitive parameter
    if (env_vars !== undefined) url.searchParams.append('env_vars', String(env_vars));
    // Primitive parameter
    if (paths !== undefined) url.searchParams.append('paths', String(paths));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_dependency_simple(flags: GstPluginDependencyFlags, env_vars?: string, paths?: string, names?: string): Promise<void> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/add_dependency_simple`, apiConfig.baseUrl);
    // Primitive parameter
    if (env_vars !== undefined) url.searchParams.append('env_vars', String(env_vars));
    // Primitive parameter
    if (paths !== undefined) url.searchParams.append('paths', String(paths));
    // Primitive parameter
    if (names !== undefined) url.searchParams.append('names', String(names));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_status_error(message: string): Promise<void> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/add_status_error`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_status_info(message: string): Promise<void> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/add_status_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_status_warning(message: string): Promise<void> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/add_status_warning`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('message', String(message));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_cache_data(): Promise<GstStructure> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_cache_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_description(): Promise<string> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_description`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_filename(): Promise<Pointer> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_filename`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_license(): Promise<string> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_license`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name(): Promise<string> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_origin(): Promise<string> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_origin`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_package(): Promise<string> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_package`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_release_date_string(): Promise<string> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_release_date_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_source(): Promise<string> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_source`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_status_errors(): Promise<Pointer> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_status_errors`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_status_infos(): Promise<Pointer> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_status_infos`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_status_warnings(): Promise<Pointer> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_status_warnings`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_version(): Promise<string> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/get_version`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_loaded(): Promise<boolean> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/is_loaded`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async load(): Promise<GstPlugin> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/load`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPlugin(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_cache_data(cache_data: GstStructure): Promise<void> {
    const url = new URL(`/Gst/Plugin/ptr,${this.ptr}/set_cache_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (cache_data && typeof cache_data === 'object' && 'ptr' in cache_data) {
      url.searchParams.append('cache_data', 'ptr,' + cache_data.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstPoll {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstpollRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstpollRegistry.unregister(this);
    const url = new URL(`/Gst/Poll/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstPoll> {
    const url = new URL(`/Gst/Poll/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPoll();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_fd(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/add_fd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_can_read(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/fd_can_read`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_can_write(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/fd_can_write`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_ctl_pri(fd: GstPollFD, active: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/fd_ctl_pri`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_ctl_read(fd: GstPollFD, active: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/fd_ctl_read`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_ctl_write(fd: GstPollFD, active: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/fd_ctl_write`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_has_closed(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/fd_has_closed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_has_error(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/fd_has_error`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_has_pri(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/fd_has_pri`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fd_ignored(fd: GstPollFD): Promise<void> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/fd_ignored`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_read_gpollfd(fd: GLibPollFD): Promise<void> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/get_read_gpollfd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async read_control(): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/read_control`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_fd(fd: GstPollFD): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/remove_fd`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (fd && typeof fd === 'object' && 'ptr' in fd) {
      url.searchParams.append('fd', 'ptr,' + fd.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async restart(): Promise<void> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/restart`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_controllable(controllable: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/set_controllable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('controllable', String(controllable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_flushing(flushing: boolean): Promise<void> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/set_flushing`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flushing', String(flushing));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait(timeout: number): Promise<number> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('timeout', String(timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async write_control(): Promise<boolean> {
    const url = new URL(`/Gst/Poll/ptr,${this.ptr}/write_control`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstPollFD {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstpollfdRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstpollfdRegistry.unregister(this);
    const url = new URL(`/Gst/PollFD/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstPollFD> {
    const url = new URL(`/Gst/PollFD/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPollFD();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async init(): Promise<void> {
    const url = new URL(`/Gst/PollFD/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstPromise {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstpromiseRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstpromiseRegistry.unregister(this);
    const url = new URL(`/Gst/Promise/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstPromise> {
    const url = new URL(`/Gst/Promise/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstPromise();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_with_change_func(func: (promise: GstPromise, user_data: Pointer) => void): Promise<GstPromise> {
    const url = new URL(`/Gst/Promise/new_with_change_func`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    const instance = new GstPromise();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async expire(): Promise<void> {
    const url = new URL(`/Gst/Promise/ptr,${this.ptr}/expire`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_reply(): Promise<GstStructure> {
    const url = new URL(`/Gst/Promise/ptr,${this.ptr}/get_reply`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async interrupt(): Promise<void> {
    const url = new URL(`/Gst/Promise/ptr,${this.ptr}/interrupt`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async reply(s?: GstStructure): Promise<void> {
    const url = new URL(`/Gst/Promise/ptr,${this.ptr}/reply`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (s !== undefined && typeof s === 'object' && 'ptr' in s) {
      url.searchParams.append('s', 'ptr,' + s.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async wait(): Promise<GstPromiseResult> {
    const url = new URL(`/Gst/Promise/ptr,${this.ptr}/wait`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstProtectionMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstprotectionmetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstprotectionmetaRegistry.unregister(this);
    const url = new URL(`/Gst/ProtectionMeta/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstProtectionMeta> {
    const url = new URL(`/Gst/ProtectionMeta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstProtectionMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_info(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/ProtectionMeta/get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstQuery {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstqueryRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstqueryRegistry.unregister(this);
    const url = new URL(`/Gst/Query/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_accept_caps(caps: GstCaps): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_allocation(need_pool: boolean, caps?: GstCaps): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_allocation`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('need_pool', String(need_pool));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_bitrate(): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_bitrate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_buffering(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_buffering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_caps(filter: GstCaps): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_context(context_type: string): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_context`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('context_type', String(context_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_convert(src_format: GstFormatValue, value_: number, dest_format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_custom(type_: GstQueryTypeValue, structure?: GstStructure): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Object with explode=false: serialize as comma-separated
    if (structure !== undefined && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_drain(): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_drain`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_duration(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_formats(): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_formats`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_latency(): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_position(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_scheduling(): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_scheduling`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_seeking(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_seeking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_segment(format: GstFormatValue): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_segment`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_selectable(): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_selectable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_uri(): Promise<GstQuery> {
    const url = new URL(`/Gst/Query/new_uri`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstQuery();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_allocation_meta(api: Pointer, params?: GstStructure): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/add_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_allocation_param(allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/add_allocation_param`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_allocation_pool(size: number, min_buffers: number, max_buffers: number, pool?: GstBufferPool): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/add_allocation_pool`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pool !== undefined && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async add_buffering_range(start: number, stop: number): Promise<boolean> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/add_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_scheduling_mode(mode: GstPadModeValue): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/add_scheduling_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async find_allocation_meta(api: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/find_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_allocation_metas(): Promise<number> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/get_n_allocation_metas`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_allocation_params(): Promise<number> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/get_n_allocation_params`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_allocation_pools(): Promise<number> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/get_n_allocation_pools`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_buffering_ranges(): Promise<number> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/get_n_buffering_ranges`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_n_scheduling_modes(): Promise<number> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/get_n_scheduling_modes`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_structure(): Promise<GstStructure> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/get_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_scheduling_mode(mode: GstPadModeValue): Promise<boolean> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/has_scheduling_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_scheduling_mode_with_flags(mode: GstPadModeValue, flags: GstSchedulingFlags): Promise<boolean> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/has_scheduling_mode_with_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_accept_caps(caps: GstCaps): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_accept_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_accept_caps_result(): Promise<{ result_?: boolean }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_accept_caps_result`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_allocation(caps?: GstCaps): Promise<{ need_pool?: boolean }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_allocation`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_bitrate(): Promise<{ nominal_bitrate?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_bitrate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering_percent(): Promise<{ busy?: boolean; percent?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_buffering_percent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering_range(format: GstFormatValue): Promise<{ start?: number; stop?: number; estimated_total?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_buffering_stats(mode: GstBufferingMode): Promise<{ avg_in?: number; avg_out?: number; buffering_left?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_caps(filter: GstCaps): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (filter && typeof filter === 'object' && 'ptr' in filter) {
      url.searchParams.append('filter', 'ptr,' + filter.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_caps_result(caps?: GstCaps): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_caps_result`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_context(context?: GstContext): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_context_type(): Promise<boolean> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_context_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_convert(src_format: GstFormatValue, dest_format: GstFormatValue): Promise<{ src_value?: number; dest_value?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_duration(format: GstFormatValue): Promise<{ duration?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_latency(): Promise<{ live?: boolean; min_latency?: number; max_latency?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_latency`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_n_formats(): Promise<{ n_formats?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_n_formats`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_nth_allocation_meta(index: number, params: GstStructure): Promise<Pointer> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_nth_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (params && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_nth_allocation_param(index: number, params: GstAllocationParams, allocator?: GstAllocator): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + allocator.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_nth_allocation_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (allocator && typeof allocator === 'object' && 'ptr' in allocator) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + allocator.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_nth_allocation_pool(index: number, pool?: GstBufferPool): Promise<{ size?: number; min_buffers?: number; max_buffers?: number }> {
    // Increment ref for parameters with full transfer ownership
    if (pool && typeof pool === 'object' && 'ptr' in pool) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + pool.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_nth_allocation_pool`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (pool !== undefined && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (pool && typeof pool === 'object' && 'ptr' in pool) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + pool.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (pool && typeof pool === 'object' && 'ptr' in pool) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + pool.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async parse_nth_buffering_range(index: number): Promise<boolean> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_nth_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_nth_format(nth: number, format: GstFormatValue): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_nth_format`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nth', String(nth));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async parse_nth_scheduling_mode(index: number): Promise<GstPadModeValue> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_nth_scheduling_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async parse_position(format: GstFormatValue): Promise<{ cur?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_scheduling(flags: GstSchedulingFlags): Promise<{ minsize?: number; maxsize?: number; align?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_scheduling`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_seeking(format: GstFormatValue): Promise<{ seekable?: boolean; segment_start?: number; segment_end?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_seeking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_segment(format: GstFormatValue): Promise<{ rate?: number; start_value?: number; stop_value?: number }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_segment`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_selectable(): Promise<{ selectable?: boolean }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_selectable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_uri(): Promise<{ uri?: string }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_uri`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_uri_redirection(): Promise<{ uri?: string }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_uri_redirection`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async parse_uri_redirection_permanent(): Promise<{ permanent?: boolean }> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/parse_uri_redirection_permanent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  async remove_nth_allocation_meta(index: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/remove_nth_allocation_meta`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_nth_allocation_param(index: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/remove_nth_allocation_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_nth_allocation_pool(index: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/remove_nth_allocation_pool`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_accept_caps_result(result_: boolean): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_accept_caps_result`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('result', String(result_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_bitrate(nominal_bitrate: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_bitrate`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nominal_bitrate', String(nominal_bitrate));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffering_percent(busy: boolean, percent: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_buffering_percent`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('busy', String(busy));
    // Primitive parameter
    url.searchParams.append('percent', String(percent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffering_range(format: GstFormatValue, start: number, stop: number, estimated_total: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_buffering_range`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    // Primitive parameter
    url.searchParams.append('estimated_total', String(estimated_total));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffering_stats(mode: GstBufferingMode, avg_in: number, avg_out: number, buffering_left: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_buffering_stats`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('avg_in', String(avg_in));
    // Primitive parameter
    url.searchParams.append('avg_out', String(avg_out));
    // Primitive parameter
    url.searchParams.append('buffering_left', String(buffering_left));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_caps_result(caps?: GstCaps): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_caps_result`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_context(context?: GstContext): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_context`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_convert(src_format: GstFormatValue, src_value: number, dest_format: GstFormatValue, dest_value: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_convert`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_format', String(src_format));
    // Primitive parameter
    url.searchParams.append('src_value', String(src_value));
    // Primitive parameter
    url.searchParams.append('dest_format', String(dest_format));
    // Primitive parameter
    url.searchParams.append('dest_value', String(dest_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_duration(format: GstFormatValue, duration: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_duration`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('duration', String(duration));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_formatsv(n_formats: number, formats: Pointer): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_formatsv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('n_formats', String(n_formats));
    // Primitive parameter
    url.searchParams.append('formats', String(formats));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_latency(live: boolean, min_latency: number, max_latency: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_latency`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('live', String(live));
    // Primitive parameter
    url.searchParams.append('min_latency', String(min_latency));
    // Primitive parameter
    url.searchParams.append('max_latency', String(max_latency));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_nth_allocation_param(index: number, allocator?: GstAllocator, params?: GstAllocationParams): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_nth_allocation_param`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (allocator !== undefined && typeof allocator === 'object' && 'ptr' in allocator) {
      url.searchParams.append('allocator', 'ptr,' + allocator.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (params !== undefined && typeof params === 'object' && 'ptr' in params) {
      url.searchParams.append('params', 'ptr,' + params.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_nth_allocation_pool(index: number, size: number, min_buffers: number, max_buffers: number, pool?: GstBufferPool): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_nth_allocation_pool`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (pool !== undefined && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    // Primitive parameter
    url.searchParams.append('size', String(size));
    // Primitive parameter
    url.searchParams.append('min_buffers', String(min_buffers));
    // Primitive parameter
    url.searchParams.append('max_buffers', String(max_buffers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_position(format: GstFormatValue, cur: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('cur', String(cur));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_scheduling(flags: GstSchedulingFlags, minsize: number, maxsize: number, align: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_scheduling`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('minsize', String(minsize));
    // Primitive parameter
    url.searchParams.append('maxsize', String(maxsize));
    // Primitive parameter
    url.searchParams.append('align', String(align));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_seeking(format: GstFormatValue, seekable: boolean, segment_start: number, segment_end: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_seeking`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('seekable', String(seekable));
    // Primitive parameter
    url.searchParams.append('segment_start', String(segment_start));
    // Primitive parameter
    url.searchParams.append('segment_end', String(segment_end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_segment(rate: number, format: GstFormatValue, start_value: number, stop_value: number): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_segment`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('start_value', String(start_value));
    // Primitive parameter
    url.searchParams.append('stop_value', String(stop_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_selectable(selectable: boolean): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_selectable`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('selectable', String(selectable));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uri(uri?: string): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_uri`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uri_redirection(uri?: string): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_uri_redirection`, apiConfig.baseUrl);
    // Primitive parameter
    if (uri !== undefined) url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_uri_redirection_permanent(permanent: boolean): Promise<void> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/set_uri_redirection_permanent`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('permanent', String(permanent));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async writable_structure(): Promise<GstStructure> {
    const url = new URL(`/Gst/Query/ptr,${this.ptr}/writable_structure`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstReferenceTimestampMeta {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstreferencetimestampmetaRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstreferencetimestampmetaRegistry.unregister(this);
    const url = new URL(`/Gst/ReferenceTimestampMeta/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstReferenceTimestampMeta> {
    const url = new URL(`/Gst/ReferenceTimestampMeta/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstReferenceTimestampMeta();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_info(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/ReferenceTimestampMeta/get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstRegistry extends GstObject {

  async fork_is_enabled(): Promise<boolean> {
    const url = new URL(`/Gst/Registry/fork_is_enabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fork_set_enabled(enabled: boolean): Promise<void> {
    const url = new URL(`/Gst/Registry/fork_set_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('enabled', String(enabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get(): Promise<GstRegistry> {
    const url = new URL(`/Gst/Registry/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstRegistry(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async add_feature(feature: GstPluginFeature): Promise<boolean> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/add_feature`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (feature && typeof feature === 'object' && 'ptr' in feature) {
      url.searchParams.append('feature', 'ptr,' + feature.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async add_plugin(plugin: GstPlugin): Promise<boolean> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/add_plugin`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async check_feature_version(feature_name: string, min_major: number, min_minor: number, min_micro: number): Promise<boolean> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/check_feature_version`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('feature_name', String(feature_name));
    // Primitive parameter
    url.searchParams.append('min_major', String(min_major));
    // Primitive parameter
    url.searchParams.append('min_minor', String(min_minor));
    // Primitive parameter
    url.searchParams.append('min_micro', String(min_micro));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async feature_filter(first: boolean, filter: (feature: GstPluginFeature, user_data: Pointer) => boolean): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/feature_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('first', String(first));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.filter !== undefined) {
      callbackDispatcher.set(data.filter.toString(), filter);
    }
    return data.return;
  }
  async find_feature(name: string, type_: Pointer): Promise<GstPluginFeature> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/find_feature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPluginFeature(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async find_plugin(name: string): Promise<GstPlugin> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/find_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPlugin(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_feature_list(type_: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/get_feature_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_feature_list_by_plugin(name: string): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/get_feature_list_by_plugin`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_feature_list_cookie(): Promise<number> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/get_feature_list_cookie`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_plugin_list(): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/get_plugin_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async lookup(filename: string): Promise<GstPlugin> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/lookup`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPlugin(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async lookup_feature(name: string): Promise<GstPluginFeature> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/lookup_feature`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPluginFeature(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async plugin_filter(first: boolean, filter: (plugin: GstPlugin, user_data: Pointer) => boolean): Promise<Pointer> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/plugin_filter`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('first', String(first));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.filter !== undefined) {
      callbackDispatcher.set(data.filter.toString(), filter);
    }
    return data.return;
  }
  async remove_feature(feature: GstPluginFeature): Promise<void> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/remove_feature`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (feature && typeof feature === 'object' && 'ptr' in feature) {
      url.searchParams.append('feature', 'ptr,' + feature.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_plugin(plugin: GstPlugin): Promise<void> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/remove_plugin`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async scan_path(path: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Registry/ptr,${this.ptr}/scan_path`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstSample {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstsampleRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstsampleRegistry.unregister(this);
    const url = new URL(`/Gst/Sample/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(buffer?: GstBuffer, caps?: GstCaps, segment?: GstSegment, info?: GstStructure): Promise<GstSample> {
    const url = new URL(`/Gst/Sample/new`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer !== undefined && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (segment !== undefined && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (info !== undefined && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstSample();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_buffer(): Promise<GstBuffer> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/get_buffer`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBuffer(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_buffer_list(): Promise<GstBufferList> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/get_buffer_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBufferList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_info(): Promise<GstStructure> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_segment(): Promise<GstSegment> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/get_segment`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstSegment(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_buffer(buffer: GstBuffer): Promise<void> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/set_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_buffer_list(buffer_list: GstBufferList): Promise<void> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/set_buffer_list`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer_list && typeof buffer_list === 'object' && 'ptr' in buffer_list) {
      url.searchParams.append('buffer_list', 'ptr,' + buffer_list.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_caps(caps: GstCaps): Promise<void> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/set_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_info(info: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/set_info`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (info && typeof info === 'object' && 'ptr' in info) {
      url.searchParams.append('info', 'ptr,' + info.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_segment(segment: GstSegment): Promise<void> {
    const url = new URL(`/Gst/Sample/ptr,${this.ptr}/set_segment`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (segment && typeof segment === 'object' && 'ptr' in segment) {
      url.searchParams.append('segment', 'ptr,' + segment.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstSegment {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gstsegmentRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gstsegmentRegistry.unregister(this);
    const url = new URL(`/Gst/Segment/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstSegment> {
    const url = new URL(`/Gst/Segment/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstSegment();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async clip(format: GstFormatValue, start: number, stop: number): Promise<boolean> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/clip`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GstSegment> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstSegment(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async copy_into(dest: GstSegment): Promise<void> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/copy_into`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async do_seek(rate: number, format: GstFormatValue, flags: GstSeekFlags, start_type: GstSeekType, start: number, stop_type: GstSeekType, stop: number): Promise<boolean> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/do_seek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('rate', String(rate));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('start_type', String(start_type));
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop_type', String(stop_type));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async init(format: GstFormatValue): Promise<void> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/init`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_equal(s1: GstSegment): Promise<boolean> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (s1 && typeof s1 === 'object' && 'ptr' in s1) {
      url.searchParams.append('s1', 'ptr,' + s1.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async offset_running_time(format: GstFormatValue, offset: number): Promise<boolean> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/offset_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async position_from_running_time(format: GstFormatValue, running_time: number): Promise<number> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/position_from_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async position_from_running_time_full(format: GstFormatValue, running_time: number): Promise<number> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/position_from_running_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async position_from_stream_time(format: GstFormatValue, stream_time: number): Promise<number> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/position_from_stream_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('stream_time', String(stream_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async position_from_stream_time_full(format: GstFormatValue, stream_time: number): Promise<number> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/position_from_stream_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('stream_time', String(stream_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_running_time(format: GstFormatValue, running_time: number): Promise<boolean> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/set_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_position(format: GstFormatValue, running_time: number): Promise<number> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/to_position`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('running_time', String(running_time));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_running_time(format: GstFormatValue, position: number): Promise<number> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/to_running_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_running_time_full(format: GstFormatValue, position: number): Promise<number> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/to_running_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_stream_time(format: GstFormatValue, position: number): Promise<number> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/to_stream_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_stream_time_full(format: GstFormatValue, position: number): Promise<number> {
    const url = new URL(`/Gst/Segment/ptr,${this.ptr}/to_stream_time_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    // Primitive parameter
    url.searchParams.append('position', String(position));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstTaskPool extends GstObject {
  static async new(): Promise<GstTaskPool> {
    const url = new URL(`/Gst/TaskPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTaskPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async cleanup(): Promise<void> {
    const url = new URL(`/Gst/TaskPool/ptr,${this.ptr}/cleanup`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async dispose_handle(): Promise<void> {
    const url = new URL(`/Gst/TaskPool/ptr,${this.ptr}/dispose_handle`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async join(): Promise<void> {
    const url = new URL(`/Gst/TaskPool/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async prepare(): Promise<void> {
    const url = new URL(`/Gst/TaskPool/ptr,${this.ptr}/prepare`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async push(func: (user_data: Pointer) => void): Promise<{ func?: number }> {
    const url = new URL(`/Gst/TaskPool/ptr,${this.ptr}/push`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
}

export class GstSharedTaskPool extends GstTaskPool {
  static async new(): Promise<GstSharedTaskPool> {
    const url = new URL(`/Gst/SharedTaskPool/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstSharedTaskPool();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_max_threads(): Promise<number> {
    const url = new URL(`/Gst/SharedTaskPool/ptr,${this.ptr}/get_max_threads`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_max_threads(max_threads: number): Promise<void> {
    const url = new URL(`/Gst/SharedTaskPool/ptr,${this.ptr}/set_max_threads`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_threads', String(max_threads));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstStaticCaps {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gststaticcapsRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gststaticcapsRegistry.unregister(this);
    const url = new URL(`/Gst/StaticCaps/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstStaticCaps> {
    const url = new URL(`/Gst/StaticCaps/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStaticCaps();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async cleanup(): Promise<void> {
    const url = new URL(`/Gst/StaticCaps/ptr,${this.ptr}/cleanup`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get(): Promise<GstCaps> {
    const url = new URL(`/Gst/StaticCaps/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstStaticPadTemplate {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gststaticpadtemplateRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gststaticpadtemplateRegistry.unregister(this);
    const url = new URL(`/Gst/StaticPadTemplate/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstStaticPadTemplate> {
    const url = new URL(`/Gst/StaticPadTemplate/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStaticPadTemplate();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get(): Promise<GstPadTemplate> {
    const url = new URL(`/Gst/StaticPadTemplate/ptr,${this.ptr}/get`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstPadTemplate(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/StaticPadTemplate/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
}

export class GstStream extends GstObject {
  static async new(type_: GstStreamTypeValue, flags: GstStreamFlags, stream_id?: string, caps?: GstCaps): Promise<GstStream> {
    const url = new URL(`/Gst/Stream/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (stream_id !== undefined) url.searchParams.append('stream_id', String(stream_id));
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStream();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/Stream/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_stream_flags(): Promise<GstStreamFlags> {
    const url = new URL(`/Gst/Stream/ptr,${this.ptr}/get_stream_flags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_id(): Promise<string> {
    const url = new URL(`/Gst/Stream/ptr,${this.ptr}/get_stream_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream_type(): Promise<GstStreamTypeValue> {
    const url = new URL(`/Gst/Stream/ptr,${this.ptr}/get_stream_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tags(): Promise<GstTagList> {
    const url = new URL(`/Gst/Stream/ptr,${this.ptr}/get_tags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_caps(caps?: GstCaps): Promise<void> {
    const url = new URL(`/Gst/Stream/ptr,${this.ptr}/set_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (caps !== undefined && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_flags(flags: GstStreamFlags): Promise<void> {
    const url = new URL(`/Gst/Stream/ptr,${this.ptr}/set_stream_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_stream_type(stream_type: GstStreamTypeValue): Promise<void> {
    const url = new URL(`/Gst/Stream/ptr,${this.ptr}/set_stream_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stream_type', String(stream_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_tags(tags?: GstTagList): Promise<void> {
    const url = new URL(`/Gst/Stream/ptr,${this.ptr}/set_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstStreamCollection extends GstObject {
  static async new(upstream_id?: string): Promise<GstStreamCollection> {
    const url = new URL(`/Gst/StreamCollection/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (upstream_id !== undefined) url.searchParams.append('upstream_id', String(upstream_id));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStreamCollection();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_stream(stream: GstStream): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + stream.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/StreamCollection/ptr,${this.ptr}/add_stream`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (stream && typeof stream === 'object' && 'ptr' in stream) {
      url.searchParams.append('stream', 'ptr,' + stream.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (stream && typeof stream === 'object' && 'ptr' in stream) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (stream && typeof stream === 'object' && 'ptr' in stream) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + stream.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async get_size(): Promise<number> {
    const url = new URL(`/Gst/StreamCollection/ptr,${this.ptr}/get_size`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_stream(index: number): Promise<GstStream> {
    const url = new URL(`/Gst/StreamCollection/ptr,${this.ptr}/get_stream`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStream(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_upstream_id(): Promise<string> {
    const url = new URL(`/Gst/StreamCollection/ptr,${this.ptr}/get_upstream_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstStructure {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gststructureRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gststructureRegistry.unregister(this);
    const url = new URL(`/Gst/Structure/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async from_string(string: string): Promise<GstStructure> {
    const url = new URL(`/Gst/Structure/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStructure();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_empty(name: string): Promise<GstStructure> {
    const url = new URL(`/Gst/Structure/new_empty`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStructure();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_string(string: string): Promise<GstStructure> {
    const url = new URL(`/Gst/Structure/new_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStructure();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_id_empty(quark: number): Promise<GstStructure> {
    const url = new URL(`/Gst/Structure/new_id_empty`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('quark', String(quark));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstStructure();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async can_intersect(struct2: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/can_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (struct2 && typeof struct2 === 'object' && 'ptr' in struct2) {
      url.searchParams.append('struct2', 'ptr,' + struct2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy(): Promise<GstStructure> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async filter_and_map_in_place(func: (field_id: number, value_: GObjectValue, user_data: Pointer) => boolean): Promise<{ func?: number }> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/filter_and_map_in_place`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async fixate(): Promise<void> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/fixate`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async fixate_field(field_name: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/fixate_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_boolean(field_name: string, target: boolean): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/fixate_field_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_nearest_double(field_name: string, target: number): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/fixate_field_nearest_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_nearest_fraction(field_name: string, target_numerator: number, target_denominator: number): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/fixate_field_nearest_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target_numerator', String(target_numerator));
    // Primitive parameter
    url.searchParams.append('target_denominator', String(target_denominator));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_nearest_int(field_name: string, target: number): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/fixate_field_nearest_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async fixate_field_string(field_name: string, target: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/fixate_field_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field_name', String(field_name));
    // Primitive parameter
    url.searchParams.append('target', String(target));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async foreach(func: (field_id: number, value_: GObjectValue, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async get_array(fieldname: string, array: GObjectValueArray): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (array && typeof array === 'object' && 'ptr' in array) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + array.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (array && typeof array === 'object' && 'ptr' in array) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + array.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (array && typeof array === 'object' && 'ptr' in array) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + array.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async get_boolean(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_clock_time(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_clock_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date(fieldname: string, value_: GLibDate): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_date`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date_time(fieldname: string, value_: GstDateTime): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_enum(fieldname: string, enumtype: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_enum`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Primitive parameter
    url.searchParams.append('enumtype', String(enumtype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_field_type(fieldname: string): Promise<Pointer> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_field_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_flags(fieldname: string, flags_type: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Primitive parameter
    url.searchParams.append('flags_type', String(flags_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_flagset(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_flagset`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_fraction(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_list(fieldname: string, array: GObjectValueArray): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (array && typeof array === 'object' && 'ptr' in array) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + array.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (array && typeof array === 'object' && 'ptr' in array) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + array.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (array && typeof array === 'object' && 'ptr' in array) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + array.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async get_name(): Promise<string> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_name`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_name_id(): Promise<number> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_name_id`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string(fieldname: string): Promise<string> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(fieldname: string): Promise<GObjectValue> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async has_field(fieldname: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/has_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_field_typed(fieldname: string, type_: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/has_field_typed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_name(name: string): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/has_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_get_value(field: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/id_get_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async id_has_field(field: number): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/id_has_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_has_field_typed(field: number, type_: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/id_has_field_typed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async id_set_value(field: number, value_: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/id_set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async id_take_value(field: number, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + value_.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/id_take_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('field', String(field));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + value_.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + value_.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async intersect(struct2: GstStructure): Promise<GstStructure> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (struct2 && typeof struct2 === 'object' && 'ptr' in struct2) {
      url.searchParams.append('struct2', 'ptr,' + struct2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async is_equal(structure2: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (structure2 && typeof structure2 === 'object' && 'ptr' in structure2) {
      url.searchParams.append('structure2', 'ptr,' + structure2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_subset(superset: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/is_subset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (superset && typeof superset === 'object' && 'ptr' in superset) {
      url.searchParams.append('superset', 'ptr,' + superset.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async map_in_place(func: (field_id: number, value_: GObjectValue, user_data: Pointer) => boolean): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/map_in_place`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  async n_fields(): Promise<number> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/n_fields`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async nth_field_name(index: number): Promise<string> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/nth_field_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_all_fields(): Promise<void> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/remove_all_fields`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async remove_field(fieldname: string): Promise<void> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/remove_field`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async serialize(flags: GstSerializeFlags): Promise<string> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/serialize`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async serialize_full(flags: GstSerializeFlags): Promise<string> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/serialize_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_array(fieldname: string, array: GObjectValueArray): Promise<void> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/set_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_list(fieldname: string, array: GObjectValueArray): Promise<void> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/set_list`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_name(name: string): Promise<void> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/set_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_parent_refcount(refcount: number): Promise<boolean> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/set_parent_refcount`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('refcount', String(refcount));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_value(fieldname: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/set_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async take_value(fieldname: string, value_: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + value_.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/take_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('fieldname', String(fieldname));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + value_.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + value_.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async to_string(): Promise<string> {
    const url = new URL(`/Gst/Structure/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async take(oldstr_ptr?: GstStructure, newstr?: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/Structure/take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (oldstr_ptr !== undefined && typeof oldstr_ptr === 'object' && 'ptr' in oldstr_ptr) {
      url.searchParams.append('oldstr_ptr', 'ptr,' + oldstr_ptr.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newstr !== undefined && typeof newstr === 'object' && 'ptr' in newstr) {
      url.searchParams.append('newstr', 'ptr,' + newstr.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstSystemClock extends GstClock {

  async obtain(): Promise<GstClock> {
    const url = new URL(`/Gst/SystemClock/obtain`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstClock(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async set_default(new_clock?: GstClock): Promise<void> {
    const url = new URL(`/Gst/SystemClock/set_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (new_clock !== undefined && typeof new_clock === 'object' && 'ptr' in new_clock) {
      url.searchParams.append('new_clock', 'ptr,' + new_clock.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstTagList {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsttaglistRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsttaglistRegistry.unregister(this);
    const url = new URL(`/Gst/TagList/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new_empty(): Promise<GstTagList> {
    const url = new URL(`/Gst/TagList/new_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTagList();
    Object.assign(instance, data.return || data);
    return instance;
  }
  static async new_from_string(str: string): Promise<GstTagList> {
    const url = new URL(`/Gst/TagList/new_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('str', String(str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTagList();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async add_value(mode: GstTagMergeMode, tag: string, value_: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/add_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async copy(): Promise<GstTagList> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/copy`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async foreach(func: (list: GstTagList, tag: string, user_data: Pointer) => void): Promise<{ func?: number }> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/foreach`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  async get_boolean(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_boolean`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_boolean_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_boolean_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date(tag: string, value_: GLibDate): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_date`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date_index(tag: string, index: number, value_: GLibDate): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_date_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date_time(tag: string, value_: GstDateTime): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_date_time`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_date_time_index(tag: string, index: number, value_: GstDateTime): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_date_time_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_double_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_double_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_float(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_float`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_float_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_float_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int64_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_int64_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_int_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_int_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pointer(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_pointer`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_pointer_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_pointer_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sample(tag: string, sample: GstSample): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_sample`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Object with explode=false: serialize as comma-separated
    if (sample && typeof sample === 'object' && 'ptr' in sample) {
      url.searchParams.append('sample', 'ptr,' + sample.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sample_index(tag: string, index: number, sample: GstSample): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_sample_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    // Object with explode=false: serialize as comma-separated
    if (sample && typeof sample === 'object' && 'ptr' in sample) {
      url.searchParams.append('sample', 'ptr,' + sample.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_scope(): Promise<GstTagScope> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_scope`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_string_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_string_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tag_size(tag: string): Promise<number> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_tag_size`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_uint`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_uint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint64_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_uint64_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_uint_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_uint_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value_index(tag: string, index: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/get_value_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async insert(from: GstTagList, mode: GstTagMergeMode): Promise<void> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/insert`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (from && typeof from === 'object' && 'ptr' in from) {
      url.searchParams.append('from', 'ptr,' + from.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async is_empty(): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/is_empty`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_equal(list2: GstTagList): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/is_equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list2 && typeof list2 === 'object' && 'ptr' in list2) {
      url.searchParams.append('list2', 'ptr,' + list2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async merge(mode: GstTagMergeMode, list2?: GstTagList): Promise<GstTagList> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/merge`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (list2 !== undefined && typeof list2 === 'object' && 'ptr' in list2) {
      url.searchParams.append('list2', 'ptr,' + list2.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async n_tags(): Promise<number> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/n_tags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async nth_tag_name(index: number): Promise<string> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/nth_tag_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek_string_index(tag: string, index: number): Promise<boolean> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/peek_string_index`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_tag(tag: string): Promise<void> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/remove_tag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_scope(scope: GstTagScope): Promise<void> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/set_scope`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope', String(scope));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async to_string(): Promise<string> {
    const url = new URL(`/Gst/TagList/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async copy_value(dest: GObjectValue, list: GstTagList, tag: string): Promise<boolean> {
    const url = new URL(`/Gst/TagList/copy_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstTask extends GstObject {
  static async new(func: (user_data: Pointer) => void): Promise<GstTask> {
    const url = new URL(`/Gst/Task/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    const instance = new GstTask();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async cleanup_all(): Promise<void> {
    const url = new URL(`/Gst/Task/cleanup_all`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_pool(): Promise<GstTaskPool> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/get_pool`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTaskPool(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_state(): Promise<GstTaskState> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/get_state`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async join(): Promise<boolean> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async pause(): Promise<boolean> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/pause`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async resume(): Promise<boolean> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/resume`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_enter_callback(enter_func: (task: GstTask, thread: GLibThread, user_data: Pointer) => void): Promise<{ enter_func?: number }> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/set_enter_callback`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.enter_func !== undefined) {
      callbackDispatcher.set(data.enter_func.toString(), enter_func);
    }
    return data;
  }
  async set_leave_callback(leave_func: (task: GstTask, thread: GLibThread, user_data: Pointer) => void): Promise<{ leave_func?: number }> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/set_leave_callback`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.leave_func !== undefined) {
      callbackDispatcher.set(data.leave_func.toString(), leave_func);
    }
    return data;
  }
  async set_lock(mutex: GLibRecMutex): Promise<void> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/set_lock`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (mutex && typeof mutex === 'object' && 'ptr' in mutex) {
      url.searchParams.append('mutex', 'ptr,' + mutex.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_pool(pool: GstTaskPool): Promise<void> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/set_pool`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (pool && typeof pool === 'object' && 'ptr' in pool) {
      url.searchParams.append('pool', 'ptr,' + pool.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_state(state: GstTaskState): Promise<boolean> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/set_state`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('state', String(state));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async start(): Promise<boolean> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/start`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async stop(): Promise<boolean> {
    const url = new URL(`/Gst/Task/ptr,${this.ptr}/stop`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstToc {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsttocRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsttocRegistry.unregister(this);
    const url = new URL(`/Gst/Toc/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(scope: GstTocScope): Promise<GstToc> {
    const url = new URL(`/Gst/Toc/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scope', String(scope));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstToc();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append_entry(entry: GstTocEntry): Promise<void> {
    const url = new URL(`/Gst/Toc/ptr,${this.ptr}/append_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (entry && typeof entry === 'object' && 'ptr' in entry) {
      url.searchParams.append('entry', 'ptr,' + entry.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async dump(): Promise<void> {
    const url = new URL(`/Gst/Toc/ptr,${this.ptr}/dump`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async find_entry(uid: string): Promise<GstTocEntry> {
    const url = new URL(`/Gst/Toc/ptr,${this.ptr}/find_entry`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uid', String(uid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTocEntry(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_entries(): Promise<Pointer> {
    const url = new URL(`/Gst/Toc/ptr,${this.ptr}/get_entries`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_scope(): Promise<GstTocScope> {
    const url = new URL(`/Gst/Toc/ptr,${this.ptr}/get_scope`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tags(): Promise<GstTagList> {
    const url = new URL(`/Gst/Toc/ptr,${this.ptr}/get_tags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async merge_tags(mode: GstTagMergeMode, tags?: GstTagList): Promise<void> {
    const url = new URL(`/Gst/Toc/ptr,${this.ptr}/merge_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_tags(tags?: GstTagList): Promise<void> {
    const url = new URL(`/Gst/Toc/ptr,${this.ptr}/set_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstTocEntry {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsttocentryRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsttocentryRegistry.unregister(this);
    const url = new URL(`/Gst/TocEntry/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(type_: GstTocEntryTypeValue, uid: string): Promise<GstTocEntry> {
    const url = new URL(`/Gst/TocEntry/new`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('uid', String(uid));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTocEntry();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append_sub_entry(subentry: GstTocEntry): Promise<void> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/append_sub_entry`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (subentry && typeof subentry === 'object' && 'ptr' in subentry) {
      url.searchParams.append('subentry', 'ptr,' + subentry.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_entry_type(): Promise<GstTocEntryTypeValue> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/get_entry_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_loop(loop_type: GstTocLoopType): Promise<boolean> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/get_loop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('loop_type', String(loop_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_parent(): Promise<GstTocEntry> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/get_parent`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTocEntry(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_start_stop_times(): Promise<boolean> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/get_start_stop_times`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_sub_entries(): Promise<Pointer> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/get_sub_entries`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tags(): Promise<GstTagList> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/get_tags`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstTagList(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_toc(): Promise<GstToc> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/get_toc`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstToc(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_uid(): Promise<string> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/get_uid`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_alternative(): Promise<boolean> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/is_alternative`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_sequence(): Promise<boolean> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/is_sequence`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async merge_tags(mode: GstTagMergeMode, tags?: GstTagList): Promise<void> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/merge_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_loop(loop_type: GstTocLoopType, repeat_count: number): Promise<void> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/set_loop`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('loop_type', String(loop_type));
    // Primitive parameter
    url.searchParams.append('repeat_count', String(repeat_count));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_start_stop_times(start: number, stop: number): Promise<void> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/set_start_stop_times`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('stop', String(stop));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async set_tags(tags?: GstTagList): Promise<void> {
    const url = new URL(`/Gst/TocEntry/ptr,${this.ptr}/set_tags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tags !== undefined && typeof tags === 'object' && 'ptr' in tags) {
      url.searchParams.append('tags', 'ptr,' + tags.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstTracer extends GstObject {

  async register(name: string, type_: Pointer, plugin?: GstPlugin): Promise<boolean> {
    const url = new URL(`/Gst/Tracer/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstTracerFactory extends GstPluginFeature {

  async get_list(): Promise<Pointer> {
    const url = new URL(`/Gst/TracerFactory/get_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_tracer_type(): Promise<Pointer> {
    const url = new URL(`/Gst/TracerFactory/ptr,${this.ptr}/get_tracer_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstTypeFind {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsttypefindRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsttypefindRegistry.unregister(this);
    const url = new URL(`/Gst/TypeFind/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(): Promise<GstTypeFind> {
    const url = new URL(`/Gst/TypeFind/new`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstTypeFind();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async get_length(): Promise<number> {
    const url = new URL(`/Gst/TypeFind/ptr,${this.ptr}/get_length`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async peek(offset: number, size: number): Promise<number> {
    const url = new URL(`/Gst/TypeFind/ptr,${this.ptr}/peek`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('offset', String(offset));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async suggest(probability: number, caps: GstCaps): Promise<void> {
    const url = new URL(`/Gst/TypeFind/ptr,${this.ptr}/suggest`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('probability', String(probability));
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async suggest_empty_simple(probability: number, media_type: string): Promise<void> {
    const url = new URL(`/Gst/TypeFind/ptr,${this.ptr}/suggest_empty_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('probability', String(probability));
    // Primitive parameter
    url.searchParams.append('media_type', String(media_type));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async register(name: string, rank: number, func: (find: GstTypeFind, user_data: Pointer) => void, plugin?: GstPlugin, extensions?: string, possible_caps?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/TypeFind/register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    if (extensions !== undefined) url.searchParams.append('extensions', String(extensions));
    // Object with explode=false: serialize as comma-separated
    if (possible_caps !== undefined && typeof possible_caps === 'object' && 'ptr' in possible_caps) {
      url.searchParams.append('possible_caps', 'ptr,' + possible_caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
}

export class GstTypeFindFactory extends GstPluginFeature {

  async get_list(): Promise<Pointer> {
    const url = new URL(`/Gst/TypeFindFactory/get_list`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async call_function(find: GstTypeFind): Promise<void> {
    const url = new URL(`/Gst/TypeFindFactory/ptr,${this.ptr}/call_function`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (find && typeof find === 'object' && 'ptr' in find) {
      url.searchParams.append('find', 'ptr,' + find.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_caps(): Promise<GstCaps> {
    const url = new URL(`/Gst/TypeFindFactory/ptr,${this.ptr}/get_caps`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_extensions(): Promise<Pointer> {
    const url = new URL(`/Gst/TypeFindFactory/ptr,${this.ptr}/get_extensions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_function(): Promise<boolean> {
    const url = new URL(`/Gst/TypeFindFactory/ptr,${this.ptr}/has_function`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstUri {
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      gsturiRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  free(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    gsturiRegistry.unregister(this);
    const url = new URL(`/Gst/Uri/{self}/free`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }

  static async new(port: number, scheme?: string, userinfo?: string, host?: string, path?: string, query?: string, fragment?: string): Promise<GstUri> {
    const url = new URL(`/Gst/Uri/new`, apiConfig.baseUrl);
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    const instance = new GstUri();
    Object.assign(instance, data.return || data);
    return instance;
  }

  async append_path(relative_path?: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/append_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (relative_path !== undefined) url.searchParams.append('relative_path', String(relative_path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async append_path_segment(path_segment?: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/append_path_segment`, apiConfig.baseUrl);
    // Primitive parameter
    if (path_segment !== undefined) url.searchParams.append('path_segment', String(path_segment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async equal(second: GstUri): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/equal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (second && typeof second === 'object' && 'ptr' in second) {
      url.searchParams.append('second', 'ptr,' + second.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async from_string_with_base(uri: string): Promise<GstUri> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/from_string_with_base`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_fragment(): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_fragment`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_host(): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_host`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_media_fragment_table(): Promise<Pointer> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_media_fragment_table`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_path(): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_path_segments(): Promise<Pointer> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_path_segments`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_path_string(): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_path_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_port(): Promise<number> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_port`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_keys(): Promise<Pointer> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_query_keys`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_string(): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_query_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_string_ordered(keys?: Pointer): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_query_string_ordered`, apiConfig.baseUrl);
    // Primitive parameter
    if (keys !== undefined) url.searchParams.append('keys', String(keys));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_table(): Promise<Pointer> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_query_table`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_query_value(query_key: string): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_query_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_scheme(): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_scheme`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_userinfo(): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/get_userinfo`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_normalized(): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/is_normalized`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_writable(): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/is_writable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async join(ref_uri?: GstUri): Promise<GstUri> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/join`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (ref_uri !== undefined && typeof ref_uri === 'object' && 'ptr' in ref_uri) {
      url.searchParams.append('ref_uri', 'ptr,' + ref_uri.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async make_writable(): Promise<GstUri> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/make_writable`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async new_with_base(port: number, scheme?: string, userinfo?: string, host?: string, path?: string, query?: string, fragment?: string): Promise<GstUri> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/new_with_base`, apiConfig.baseUrl);
    // Primitive parameter
    if (scheme !== undefined) url.searchParams.append('scheme', String(scheme));
    // Primitive parameter
    if (userinfo !== undefined) url.searchParams.append('userinfo', String(userinfo));
    // Primitive parameter
    if (host !== undefined) url.searchParams.append('host', String(host));
    // Primitive parameter
    url.searchParams.append('port', String(port));
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async normalize(): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/normalize`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async query_has_key(query_key: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/query_has_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async remove_query_key(query_key: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/remove_query_key`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_fragment(fragment?: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_fragment`, apiConfig.baseUrl);
    // Primitive parameter
    if (fragment !== undefined) url.searchParams.append('fragment', String(fragment));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_host(host: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_host`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('host', String(host));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_path(path?: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_path`, apiConfig.baseUrl);
    // Primitive parameter
    if (path !== undefined) url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_path_segments(path_segments?: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_path_segments`, apiConfig.baseUrl);
    // Primitive parameter
    if (path_segments !== undefined) url.searchParams.append('path_segments', String(path_segments));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_path_string(path: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_path_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('path', String(path));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_port(port: number): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_port`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('port', String(port));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_query_string(query?: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_query_string`, apiConfig.baseUrl);
    // Primitive parameter
    if (query !== undefined) url.searchParams.append('query', String(query));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_query_table(query_table?: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_query_table`, apiConfig.baseUrl);
    // Primitive parameter
    if (query_table !== undefined) url.searchParams.append('query_table', String(query_table));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_query_value(query_key: string, query_value?: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_query_value`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('query_key', String(query_key));
    // Primitive parameter
    if (query_value !== undefined) url.searchParams.append('query_value', String(query_value));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_scheme(scheme: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_scheme`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('scheme', String(scheme));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async set_userinfo(userinfo: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/set_userinfo`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('userinfo', String(userinfo));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_string(): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/to_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async to_string_with_keys(keys?: Pointer): Promise<string> {
    const url = new URL(`/Gst/Uri/ptr,${this.ptr}/to_string_with_keys`, apiConfig.baseUrl);
    // Primitive parameter
    if (keys !== undefined) url.searchParams.append('keys', String(keys));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async construct(protocol: string, location: string): Promise<string> {
    const url = new URL(`/Gst/Uri/construct`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    // Primitive parameter
    url.searchParams.append('location', String(location));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async from_string(uri: string): Promise<GstUri> {
    const url = new URL(`/Gst/Uri/from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async from_string_escaped(uri: string): Promise<GstUri> {
    const url = new URL(`/Gst/Uri/from_string_escaped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async get_location(uri: string): Promise<string> {
    const url = new URL(`/Gst/Uri/get_location`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_protocol(uri: string): Promise<string> {
    const url = new URL(`/Gst/Uri/get_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async has_protocol(uri: string, protocol: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/has_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async is_valid(uri: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async join_strings(base_uri: string, ref_uri: string): Promise<string> {
    const url = new URL(`/Gst/Uri/join_strings`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('base_uri', String(base_uri));
    // Primitive parameter
    url.searchParams.append('ref_uri', String(ref_uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async protocol_is_supported(type_: GstURIType, protocol: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/protocol_is_supported`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async protocol_is_valid(protocol: string): Promise<boolean> {
    const url = new URL(`/Gst/Uri/protocol_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}

export class GstValueArray {
  ptr!: Pointer;


  async append_and_take_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/ValueArray/append_and_take_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async append_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueArray/append_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_size(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/ValueArray/get_size`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(value_: GObjectValue, index: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ValueArray/get_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async init(value_: GObjectValue, prealloc: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ValueArray/init`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('prealloc', String(prealloc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async prepend_value(value_: GObjectValue, prepend_value: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueArray/prepend_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (prepend_value && typeof prepend_value === 'object' && 'ptr' in prepend_value) {
      url.searchParams.append('prepend_value', 'ptr,' + prepend_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}

export class GstValueList {
  ptr!: Pointer;


  async append_and_take_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    // Increment ref for parameters with full transfer ownership
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/ValueList/append_and_take_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + append_value.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  async append_value(value_: GObjectValue, append_value: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueList/append_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (append_value && typeof append_value === 'object' && 'ptr' in append_value) {
      url.searchParams.append('append_value', 'ptr,' + append_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async concat(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueList/concat`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async get_size(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/ValueList/get_size`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  async get_value(value_: GObjectValue, index: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ValueList/get_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('index', String(index));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async init(value_: GObjectValue, prealloc: number): Promise<GObjectValue> {
    const url = new URL(`/Gst/ValueList/init`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('prealloc', String(prealloc));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  async merge(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueList/merge`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  async prepend_value(value_: GObjectValue, prepend_value: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/ValueList/prepend_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (prepend_value && typeof prepend_value === 'object' && 'ptr' in prepend_value) {
      url.searchParams.append('prepend_value', 'ptr,' + prepend_value.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
}


export namespace Gst {
  export async function buffer_get_max_memory(): Promise<number> {
    const url = new URL(`/Gst/buffer_get_max_memory`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function caps_features_from_string(features: string): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/caps_features_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('features', String(features));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function caps_from_string(string: string): Promise<GstCaps> {
    const url = new URL(`/Gst/caps_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('string', String(string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function core_error_quark(): Promise<number> {
    const url = new URL(`/Gst/core_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_add_log_function(func: (category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, object: GObjectObject, message: GstDebugMessage, user_data: Pointer) => void): Promise<{ func?: number }> {
    const url = new URL(`/Gst/debug_add_log_function`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function debug_add_ring_buffer_logger(max_size_per_thread: number, thread_timeout: number): Promise<void> {
    const url = new URL(`/Gst/debug_add_ring_buffer_logger`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('max_size_per_thread', String(max_size_per_thread));
    // Primitive parameter
    url.searchParams.append('thread_timeout', String(thread_timeout));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_bin_to_dot_data(bin: GstBin, details: GstDebugGraphDetails): Promise<string> {
    const url = new URL(`/Gst/debug_bin_to_dot_data`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bin && typeof bin === 'object' && 'ptr' in bin) {
      url.searchParams.append('bin', 'ptr,' + bin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('details', String(details));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_bin_to_dot_file(bin: GstBin, details: GstDebugGraphDetails, file_name: Pointer): Promise<void> {
    const url = new URL(`/Gst/debug_bin_to_dot_file`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bin && typeof bin === 'object' && 'ptr' in bin) {
      url.searchParams.append('bin', 'ptr,' + bin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('details', String(details));
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_bin_to_dot_file_with_ts(bin: GstBin, details: GstDebugGraphDetails, file_name: Pointer): Promise<void> {
    const url = new URL(`/Gst/debug_bin_to_dot_file_with_ts`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (bin && typeof bin === 'object' && 'ptr' in bin) {
      url.searchParams.append('bin', 'ptr,' + bin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('details', String(details));
    // Primitive parameter
    url.searchParams.append('file_name', String(file_name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_construct_term_color(colorinfo: number): Promise<string> {
    const url = new URL(`/Gst/debug_construct_term_color`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('colorinfo', String(colorinfo));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_construct_win_color(colorinfo: number): Promise<number> {
    const url = new URL(`/Gst/debug_construct_win_color`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('colorinfo', String(colorinfo));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_all_categories(): Promise<Pointer> {
    const url = new URL(`/Gst/debug_get_all_categories`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_color_mode(): Promise<GstDebugColorMode> {
    const url = new URL(`/Gst/debug_get_color_mode`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_default_threshold(): Promise<GstDebugLevelValue> {
    const url = new URL(`/Gst/debug_get_default_threshold`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_get_stack_trace(flags: GstStackTraceFlags): Promise<string> {
    const url = new URL(`/Gst/debug_get_stack_trace`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_is_active(): Promise<boolean> {
    const url = new URL(`/Gst/debug_is_active`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_is_colored(): Promise<boolean> {
    const url = new URL(`/Gst/debug_is_colored`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_level_get_name(level: GstDebugLevelValue): Promise<string> {
    const url = new URL(`/Gst/debug_level_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_log_default(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message: GstDebugMessage, object?: GObjectObject): Promise<void> {
    const url = new URL(`/Gst/debug_log_default`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (object !== undefined && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_log_get_line(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message: GstDebugMessage, object?: GObjectObject): Promise<string> {
    const url = new URL(`/Gst/debug_log_get_line`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (object !== undefined && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (message && typeof message === 'object' && 'ptr' in message) {
      url.searchParams.append('message', 'ptr,' + message.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_log_id_literal(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message_string: string, id?: string): Promise<void> {
    const url = new URL(`/Gst/debug_log_id_literal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Primitive parameter
    if (id !== undefined) url.searchParams.append('id', String(id));
    // Primitive parameter
    url.searchParams.append('message_string', String(message_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_log_literal(category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, message_string: string, object?: GObjectObject): Promise<void> {
    const url = new URL(`/Gst/debug_log_literal`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (category && typeof category === 'object' && 'ptr' in category) {
      url.searchParams.append('category', 'ptr,' + category.ptr);
    }
    // Primitive parameter
    url.searchParams.append('level', String(level));
    // Primitive parameter
    url.searchParams.append('file', String(file));
    // Primitive parameter
    url.searchParams.append('function', String(function_));
    // Primitive parameter
    url.searchParams.append('line', String(line));
    // Object with explode=false: serialize as comma-separated
    if (object !== undefined && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('message_string', String(message_string));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_print_stack_trace(): Promise<void> {
    const url = new URL(`/Gst/debug_print_stack_trace`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_remove_log_function(func: (category: GstDebugCategory, level: GstDebugLevelValue, file: string, function_: string, line: number, object: GObjectObject, message: GstDebugMessage, user_data: Pointer) => void): Promise<number> {
    const url = new URL(`/Gst/debug_remove_log_function`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  export async function debug_remove_log_function_by_data(): Promise<number> {
    const url = new URL(`/Gst/debug_remove_log_function_by_data`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_remove_ring_buffer_logger(): Promise<void> {
    const url = new URL(`/Gst/debug_remove_ring_buffer_logger`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_ring_buffer_logger_get_logs(): Promise<Pointer> {
    const url = new URL(`/Gst/debug_ring_buffer_logger_get_logs`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function debug_set_active(active: boolean): Promise<void> {
    const url = new URL(`/Gst/debug_set_active`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('active', String(active));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_color_mode(mode: GstDebugColorMode): Promise<void> {
    const url = new URL(`/Gst/debug_set_color_mode`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_color_mode_from_string(mode: string): Promise<void> {
    const url = new URL(`/Gst/debug_set_color_mode_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_colored(colored: boolean): Promise<void> {
    const url = new URL(`/Gst/debug_set_colored`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('colored', String(colored));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_default_threshold(level: GstDebugLevelValue): Promise<void> {
    const url = new URL(`/Gst/debug_set_default_threshold`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_threshold_for_name(name: string, level: GstDebugLevelValue): Promise<void> {
    const url = new URL(`/Gst/debug_set_threshold_for_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('level', String(level));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_set_threshold_from_string(list: string, reset: boolean): Promise<void> {
    const url = new URL(`/Gst/debug_set_threshold_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('list', String(list));
    // Primitive parameter
    url.searchParams.append('reset', String(reset));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function debug_unset_threshold_for_name(name: string): Promise<void> {
    const url = new URL(`/Gst/debug_unset_threshold_for_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function deinit(): Promise<void> {
    const url = new URL(`/Gst/deinit`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function dynamic_type_register(plugin: GstPlugin, type_: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/dynamic_type_register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function error_get_message(domain: number, code: number): Promise<string> {
    const url = new URL(`/Gst/error_get_message`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('domain', String(domain));
    // Primitive parameter
    url.searchParams.append('code', String(code));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_get_flags(type_: GstEventTypeValue): Promise<GstEventTypeFlags> {
    const url = new URL(`/Gst/event_type_get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_get_name(type_: GstEventTypeValue): Promise<string> {
    const url = new URL(`/Gst/event_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_to_quark(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`/Gst/event_type_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function event_type_to_sticky_ordering(type_: GstEventTypeValue): Promise<number> {
    const url = new URL(`/Gst/event_type_to_sticky_ordering`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function filename_to_uri(filename: Pointer): Promise<string> {
    const url = new URL(`/Gst/filename_to_uri`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('filename', String(filename));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flow_get_name(ret: GstFlowReturn): Promise<string> {
    const url = new URL(`/Gst/flow_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function flow_to_quark(ret: GstFlowReturn): Promise<number> {
    const url = new URL(`/Gst/flow_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('ret', String(ret));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_get_by_nick(nick: string): Promise<GstFormatValue> {
    const url = new URL(`/Gst/format_get_by_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_get_details(format: GstFormatValue): Promise<GstFormatDefinition> {
    const url = new URL(`/Gst/format_get_details`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_get_name(format: GstFormatValue): Promise<string> {
    const url = new URL(`/Gst/format_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_iterate_definitions(): Promise<GstIterator> {
    const url = new URL(`/Gst/format_iterate_definitions`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstIterator(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function format_register(nick: string, description: string): Promise<GstFormatValue> {
    const url = new URL(`/Gst/format_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('description', String(description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function format_to_quark(format: GstFormatValue): Promise<number> {
    const url = new URL(`/Gst/format_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function formats_contains(formats: Pointer, format: GstFormatValue): Promise<boolean> {
    const url = new URL(`/Gst/formats_contains`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('formats', String(formats));
    // Primitive parameter
    url.searchParams.append('format', String(format));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function get_main_executable_path(): Promise<string> {
    const url = new URL(`/Gst/get_main_executable_path`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function init(argc?: number, argv?: Pointer): Promise<{ argc?: number; argv?: Pointer }> {
    const url = new URL(`/Gst/init`, apiConfig.baseUrl);
    // Primitive parameter
    if (argc !== undefined) url.searchParams.append('argc', String(argc));
    // Primitive parameter
    if (argv !== undefined) url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function init_check(argc?: number, argv?: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/init_check`, apiConfig.baseUrl);
    // Primitive parameter
    if (argc !== undefined) url.searchParams.append('argc', String(argc));
    // Primitive parameter
    if (argv !== undefined) url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function is_caps_features(): Promise<boolean> {
    const url = new URL(`/Gst/is_caps_features`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function is_initialized(): Promise<boolean> {
    const url = new URL(`/Gst/is_initialized`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function library_error_quark(): Promise<number> {
    const url = new URL(`/Gst/library_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function message_type_get_name(type_: GstMessageTypeValue): Promise<string> {
    const url = new URL(`/Gst/message_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function message_type_to_quark(type_: GstMessageTypeValue): Promise<number> {
    const url = new URL(`/Gst/message_type_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_api_type_get_tags(api: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/meta_api_type_get_tags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_api_type_has_tag(api: Pointer, tag: number): Promise<boolean> {
    const url = new URL(`/Gst/meta_api_type_has_tag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_api_type_register(api: string, tags: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/meta_api_type_register`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('api', String(api));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function meta_deserialize(buffer: GstBuffer, data_: number, size: number): Promise<GstMeta> {
    const url = new URL(`/Gst/meta_deserialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buffer && typeof buffer === 'object' && 'ptr' in buffer) {
      url.searchParams.append('buffer', 'ptr,' + buffer.ptr);
    }
    // Primitive parameter
    url.searchParams.append('data', String(data_));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMeta(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function meta_get_info(impl: string): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/meta_get_info`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('impl', String(impl));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function meta_register_custom(name: string, tags: Pointer, transform_func: (transbuf: GstBuffer, meta: GstCustomMeta, buffer: GstBuffer, type_: number, data_: Pointer, user_data: Pointer) => boolean): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/meta_register_custom`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('tags', String(tags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.transform_func !== undefined) {
      callbackDispatcher.set(data.transform_func.toString(), transform_func);
    }
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function meta_register_custom_simple(name: string): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/meta_register_custom_simple`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function mini_object_replace(olddata?: GstMiniObject, newdata?: GstMiniObject): Promise<boolean> {
    const url = new URL(`/Gst/mini_object_replace`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata !== undefined && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata !== undefined && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function mini_object_take(olddata: GstMiniObject, newdata: GstMiniObject): Promise<boolean> {
    const url = new URL(`/Gst/mini_object_take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (olddata && typeof olddata === 'object' && 'ptr' in olddata) {
      url.searchParams.append('olddata', 'ptr,' + olddata.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newdata && typeof newdata === 'object' && 'ptr' in newdata) {
      url.searchParams.append('newdata', 'ptr,' + newdata.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function pad_mode_get_name(mode: GstPadModeValue): Promise<string> {
    const url = new URL(`/Gst/pad_mode_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function param_spec_array(name: string, nick: string, blurb: string, element_spec: GObjectParamSpec, flags: GObjectParamFlags): Promise<GObjectParamSpec> {
    const url = new URL(`/Gst/param_spec_array`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('blurb', String(blurb));
    // Object with explode=false: serialize as comma-separated
    if (element_spec && typeof element_spec === 'object' && 'ptr' in element_spec) {
      url.searchParams.append('element_spec', 'ptr,' + element_spec.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function param_spec_fraction(name: string, nick: string, blurb: string, min_num: number, min_denom: number, max_num: number, max_denom: number, default_num: number, default_denom: number, flags: GObjectParamFlags): Promise<GObjectParamSpec> {
    const url = new URL(`/Gst/param_spec_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('nick', String(nick));
    // Primitive parameter
    url.searchParams.append('blurb', String(blurb));
    // Primitive parameter
    url.searchParams.append('min_num', String(min_num));
    // Primitive parameter
    url.searchParams.append('min_denom', String(min_denom));
    // Primitive parameter
    url.searchParams.append('max_num', String(max_num));
    // Primitive parameter
    url.searchParams.append('max_denom', String(max_denom));
    // Primitive parameter
    url.searchParams.append('default_num', String(default_num));
    // Primitive parameter
    url.searchParams.append('default_denom', String(default_denom));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectParamSpec(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function parent_buffer_meta_api_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/parent_buffer_meta_api_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parent_buffer_meta_get_info(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/parent_buffer_meta_get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function parse_bin_from_description(bin_description: string, ghost_unlinked_pads: boolean): Promise<GstBin> {
    const url = new URL(`/Gst/parse_bin_from_description`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('bin_description', String(bin_description));
    // Primitive parameter
    url.searchParams.append('ghost_unlinked_pads', String(ghost_unlinked_pads));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstBin(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function parse_bin_from_description_full(bin_description: string, ghost_unlinked_pads: boolean, flags: GstParseFlags, context?: GstParseContext): Promise<GstElement> {
    const url = new URL(`/Gst/parse_bin_from_description_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('bin_description', String(bin_description));
    // Primitive parameter
    url.searchParams.append('ghost_unlinked_pads', String(ghost_unlinked_pads));
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function parse_error_quark(): Promise<number> {
    const url = new URL(`/Gst/parse_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function parse_launch(pipeline_description: string): Promise<GstElement> {
    const url = new URL(`/Gst/parse_launch`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pipeline_description', String(pipeline_description));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function parse_launch_full(pipeline_description: string, flags: GstParseFlags, context?: GstParseContext): Promise<GstElement> {
    const url = new URL(`/Gst/parse_launch_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('pipeline_description', String(pipeline_description));
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function parse_launchv(argv: Pointer): Promise<GstElement> {
    const url = new URL(`/Gst/parse_launchv`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function parse_launchv_full(argv: Pointer, flags: GstParseFlags, context?: GstParseContext): Promise<GstElement> {
    const url = new URL(`/Gst/parse_launchv_full`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('argv', String(argv));
    // Object with explode=false: serialize as comma-separated
    if (context !== undefined && typeof context === 'object' && 'ptr' in context) {
      url.searchParams.append('context', 'ptr,' + context.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstElement(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function plugin_error_quark(): Promise<number> {
    const url = new URL(`/Gst/plugin_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function preset_get_app_dir(): Promise<Pointer> {
    const url = new URL(`/Gst/preset_get_app_dir`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function preset_set_app_dir(app_dir: Pointer): Promise<boolean> {
    const url = new URL(`/Gst/preset_set_app_dir`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('app_dir', String(app_dir));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_filter_systems_by_available_decryptors(system_identifiers: Pointer): Promise<Pointer> {
    const url = new URL(`/Gst/protection_filter_systems_by_available_decryptors`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('system_identifiers', String(system_identifiers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_meta_api_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/protection_meta_api_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function protection_meta_get_info(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/protection_meta_get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function protection_select_system(system_identifiers: Pointer): Promise<string> {
    const url = new URL(`/Gst/protection_select_system`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('system_identifiers', String(system_identifiers));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function query_type_get_flags(type_: GstQueryTypeValue): Promise<GstQueryTypeFlags> {
    const url = new URL(`/Gst/query_type_get_flags`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function query_type_get_name(type_: GstQueryTypeValue): Promise<string> {
    const url = new URL(`/Gst/query_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function query_type_to_quark(type_: GstQueryTypeValue): Promise<number> {
    const url = new URL(`/Gst/query_type_to_quark`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function reference_timestamp_meta_api_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/reference_timestamp_meta_api_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function reference_timestamp_meta_get_info(): Promise<GstMetaInfo> {
    const url = new URL(`/Gst/reference_timestamp_meta_get_info`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstMetaInfo(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function resource_error_quark(): Promise<number> {
    const url = new URL(`/Gst/resource_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function segtrap_is_enabled(): Promise<boolean> {
    const url = new URL(`/Gst/segtrap_is_enabled`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function segtrap_set_enabled(enabled: boolean): Promise<void> {
    const url = new URL(`/Gst/segtrap_set_enabled`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('enabled', String(enabled));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function state_change_get_name(transition: GstStateChangeValue): Promise<string> {
    const url = new URL(`/Gst/state_change_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('transition', String(transition));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function static_caps_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/static_caps_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function static_pad_template_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/static_pad_template_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function stream_error_quark(): Promise<number> {
    const url = new URL(`/Gst/stream_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function stream_type_get_name(stype: GstStreamTypeValue): Promise<string> {
    const url = new URL(`/Gst/stream_type_get_name`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('stype', String(stype));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function structure_take(oldstr_ptr?: GstStructure, newstr?: GstStructure): Promise<boolean> {
    const url = new URL(`/Gst/structure_take`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (oldstr_ptr !== undefined && typeof oldstr_ptr === 'object' && 'ptr' in oldstr_ptr) {
      url.searchParams.append('oldstr_ptr', 'ptr,' + oldstr_ptr.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (newstr !== undefined && typeof newstr === 'object' && 'ptr' in newstr) {
      url.searchParams.append('newstr', 'ptr,' + newstr.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_exists(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/tag_exists`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_description(tag: string): Promise<string> {
    const url = new URL(`/Gst/tag_get_description`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_flag(tag: string): Promise<GstTagFlag> {
    const url = new URL(`/Gst/tag_get_flag`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_nick(tag: string): Promise<string> {
    const url = new URL(`/Gst/tag_get_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_get_type(tag: string): Promise<Pointer> {
    const url = new URL(`/Gst/tag_get_type`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_is_fixed(tag: string): Promise<boolean> {
    const url = new URL(`/Gst/tag_is_fixed`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_list_copy_value(dest: GObjectValue, list: GstTagList, tag: string): Promise<boolean> {
    const url = new URL(`/Gst/tag_list_copy_value`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (list && typeof list === 'object' && 'ptr' in list) {
      url.searchParams.append('list', 'ptr,' + list.ptr);
    }
    // Primitive parameter
    url.searchParams.append('tag', String(tag));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tag_merge_strings_with_comma(dest: GObjectValue, src: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/tag_merge_strings_with_comma`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function tag_merge_use_first(dest: GObjectValue, src: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/tag_merge_use_first`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function toc_entry_type_get_nick(type_: GstTocEntryTypeValue): Promise<string> {
    const url = new URL(`/Gst/toc_entry_type_get_nick`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tracing_get_active_tracers(): Promise<Pointer> {
    const url = new URL(`/Gst/tracing_get_active_tracers`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function tracing_register_hook(tracer: GstTracer, detail: string, func: () => void): Promise<{ func?: number }> {
    const url = new URL(`/Gst/tracing_register_hook`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (tracer && typeof tracer === 'object' && 'ptr' in tracer) {
      url.searchParams.append('tracer', 'ptr,' + tracer.ptr);
    }
    // Primitive parameter
    url.searchParams.append('detail', String(detail));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data;
  }
  export async function type_find_get_type(): Promise<Pointer> {
    const url = new URL(`/Gst/type_find_get_type`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_find_register(name: string, rank: number, func: (find: GstTypeFind, user_data: Pointer) => void, plugin?: GstPlugin, extensions?: string, possible_caps?: GstCaps): Promise<boolean> {
    const url = new URL(`/Gst/type_find_register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (plugin !== undefined && typeof plugin === 'object' && 'ptr' in plugin) {
      url.searchParams.append('plugin', 'ptr,' + plugin.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('rank', String(rank));
    // Primitive parameter
    if (extensions !== undefined) url.searchParams.append('extensions', String(extensions));
    // Object with explode=false: serialize as comma-separated
    if (possible_caps !== undefined && typeof possible_caps === 'object' && 'ptr' in possible_caps) {
      url.searchParams.append('possible_caps', 'ptr,' + possible_caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.func !== undefined) {
      callbackDispatcher.set(data.func.toString(), func);
    }
    return data.return;
  }
  export async function type_is_plugin_api(type_: Pointer, flags: GstPluginAPIFlags): Promise<boolean> {
    const url = new URL(`/Gst/type_is_plugin_api`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function type_mark_as_plugin_api(type_: Pointer, flags: GstPluginAPIFlags): Promise<void> {
    const url = new URL(`/Gst/type_mark_as_plugin_api`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function update_registry(): Promise<boolean> {
    const url = new URL(`/Gst/update_registry`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_construct(protocol: string, location: string): Promise<string> {
    const url = new URL(`/Gst/uri_construct`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    // Primitive parameter
    url.searchParams.append('location', String(location));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_error_quark(): Promise<number> {
    const url = new URL(`/Gst/uri_error_quark`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_from_string(uri: string): Promise<GstUri> {
    const url = new URL(`/Gst/uri_from_string`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function uri_from_string_escaped(uri: string): Promise<GstUri> {
    const url = new URL(`/Gst/uri_from_string_escaped`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstUri(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function uri_get_location(uri: string): Promise<string> {
    const url = new URL(`/Gst/uri_get_location`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_get_protocol(uri: string): Promise<string> {
    const url = new URL(`/Gst/uri_get_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_has_protocol(uri: string, protocol: string): Promise<boolean> {
    const url = new URL(`/Gst/uri_has_protocol`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_is_valid(uri: string): Promise<boolean> {
    const url = new URL(`/Gst/uri_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('uri', String(uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_join_strings(base_uri: string, ref_uri: string): Promise<string> {
    const url = new URL(`/Gst/uri_join_strings`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('base_uri', String(base_uri));
    // Primitive parameter
    url.searchParams.append('ref_uri', String(ref_uri));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_protocol_is_supported(type_: GstURIType, protocol: string): Promise<boolean> {
    const url = new URL(`/Gst/uri_protocol_is_supported`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('type', String(type_));
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function uri_protocol_is_valid(protocol: string): Promise<boolean> {
    const url = new URL(`/Gst/uri_protocol_is_valid`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('protocol', String(protocol));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_array_binary_search(num_elements: number, element_size: number, mode: GstSearchMode, search_func: (a: Pointer, b: Pointer, user_data: Pointer) => number): Promise<{ search_func?: number }> {
    const url = new URL(`/Gst/util_array_binary_search`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('num_elements', String(num_elements));
    // Primitive parameter
    url.searchParams.append('element_size', String(element_size));
    // Primitive parameter
    url.searchParams.append('mode', String(mode));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Register callbacks
    if (data.search_func !== undefined) {
      callbackDispatcher.set(data.search_func.toString(), search_func);
    }
    return data;
  }
  export async function util_ceil_log2(v: number): Promise<number> {
    const url = new URL(`/Gst/util_ceil_log2`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('v', String(v));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_double_to_fraction(src: number): Promise<{ dest_n?: number; dest_d?: number }> {
    const url = new URL(`/Gst/util_double_to_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function util_dump_buffer(buf: GstBuffer): Promise<void> {
    const url = new URL(`/Gst/util_dump_buffer`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (buf && typeof buf === 'object' && 'ptr' in buf) {
      url.searchParams.append('buf', 'ptr,' + buf.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_dump_mem(mem: Pointer, size: number): Promise<void> {
    const url = new URL(`/Gst/util_dump_mem`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('mem', String(mem));
    // Primitive parameter
    url.searchParams.append('size', String(size));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_filename_compare(a: Pointer, b: Pointer): Promise<number> {
    const url = new URL(`/Gst/util_filename_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_add(a_n: number, a_d: number, b_n: number, b_d: number): Promise<boolean> {
    const url = new URL(`/Gst/util_fraction_add`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a_n', String(a_n));
    // Primitive parameter
    url.searchParams.append('a_d', String(a_d));
    // Primitive parameter
    url.searchParams.append('b_n', String(b_n));
    // Primitive parameter
    url.searchParams.append('b_d', String(b_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_compare(a_n: number, a_d: number, b_n: number, b_d: number): Promise<number> {
    const url = new URL(`/Gst/util_fraction_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a_n', String(a_n));
    // Primitive parameter
    url.searchParams.append('a_d', String(a_d));
    // Primitive parameter
    url.searchParams.append('b_n', String(b_n));
    // Primitive parameter
    url.searchParams.append('b_d', String(b_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_multiply(a_n: number, a_d: number, b_n: number, b_d: number): Promise<boolean> {
    const url = new URL(`/Gst/util_fraction_multiply`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a_n', String(a_n));
    // Primitive parameter
    url.searchParams.append('a_d', String(a_d));
    // Primitive parameter
    url.searchParams.append('b_n', String(b_n));
    // Primitive parameter
    url.searchParams.append('b_d', String(b_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_fraction_to_double(src_n: number, src_d: number): Promise<{ dest?: number }> {
    const url = new URL(`/Gst/util_fraction_to_double`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('src_n', String(src_n));
    // Primitive parameter
    url.searchParams.append('src_d', String(src_d));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function util_gdouble_to_guint64(value_: number): Promise<number> {
    const url = new URL(`/Gst/util_gdouble_to_guint64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_get_object_array(object: GObjectObject, name: string, array: GObjectValueArray): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (array && typeof array === 'object' && 'ptr' in array) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + array.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/util_get_object_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (array && typeof array === 'object' && 'ptr' in array) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + array.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (array && typeof array === 'object' && 'ptr' in array) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + array.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  export async function util_get_timestamp(): Promise<number> {
    const url = new URL(`/Gst/util_get_timestamp`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_greatest_common_divisor(a: number, b: number): Promise<number> {
    const url = new URL(`/Gst/util_greatest_common_divisor`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_greatest_common_divisor_int64(a: number, b: number): Promise<number> {
    const url = new URL(`/Gst/util_greatest_common_divisor_int64`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('a', String(a));
    // Primitive parameter
    url.searchParams.append('b', String(b));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_group_id_next(): Promise<number> {
    const url = new URL(`/Gst/util_group_id_next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_guint64_to_gdouble(value_: number): Promise<number> {
    const url = new URL(`/Gst/util_guint64_to_gdouble`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_seqnum_compare(s1: number, s2: number): Promise<number> {
    const url = new URL(`/Gst/util_seqnum_compare`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('s1', String(s1));
    // Primitive parameter
    url.searchParams.append('s2', String(s2));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_seqnum_next(): Promise<number> {
    const url = new URL(`/Gst/util_seqnum_next`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_set_object_arg(object: GObjectObject, name: string, value_: string): Promise<void> {
    const url = new URL(`/Gst/util_set_object_arg`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Primitive parameter
    url.searchParams.append('value', String(value_));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_set_object_array(object: GObjectObject, name: string, array: GObjectValueArray): Promise<boolean> {
    const url = new URL(`/Gst/util_set_object_array`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (object && typeof object === 'object' && 'ptr' in object) {
      url.searchParams.append('object', 'ptr,' + object.ptr);
    }
    // Primitive parameter
    url.searchParams.append('name', String(name));
    // Object with explode=false: serialize as comma-separated
    if (array && typeof array === 'object' && 'ptr' in array) {
      url.searchParams.append('array', 'ptr,' + array.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_set_value_from_string(value_: GObjectValue, value_str: string): Promise<void> {
    const url = new URL(`/Gst/util_set_value_from_string`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('value_str', String(value_str));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_simplify_fraction(numerator: number, denominator: number, n_terms: number, threshold: number): Promise<void> {
    const url = new URL(`/Gst/util_simplify_fraction`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('numerator', String(numerator));
    // Primitive parameter
    url.searchParams.append('denominator', String(denominator));
    // Primitive parameter
    url.searchParams.append('n_terms', String(n_terms));
    // Primitive parameter
    url.searchParams.append('threshold', String(threshold));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function util_uint64_scale(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_ceil(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_ceil`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_int(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_int`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_int_ceil(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_int_ceil`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_int_round(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_int_round`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function util_uint64_scale_round(val: number, num: number, denom: number): Promise<number> {
    const url = new URL(`/Gst/util_uint64_scale_round`, apiConfig.baseUrl);
    // Primitive parameter
    url.searchParams.append('val', String(val));
    // Primitive parameter
    url.searchParams.append('num', String(num));
    // Primitive parameter
    url.searchParams.append('denom', String(denom));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_compare(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_can_compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_intersect(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_can_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_subtract(minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_can_subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (minuend && typeof minuend === 'object' && 'ptr' in minuend) {
      url.searchParams.append('minuend', 'ptr,' + minuend.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_can_union(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_can_union`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_compare(value1: GObjectValue, value2: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_compare`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_deserialize(dest: GObjectValue, src: string): Promise<boolean> {
    const url = new URL(`/Gst/value_deserialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    url.searchParams.append('src', String(src));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_deserialize_with_pspec(dest: GObjectValue, src: string, pspec?: GObjectParamSpec): Promise<boolean> {
    const url = new URL(`/Gst/value_deserialize_with_pspec`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Primitive parameter
    url.searchParams.append('src', String(src));
    // Object with explode=false: serialize as comma-separated
    if (pspec !== undefined && typeof pspec === 'object' && 'ptr' in pspec) {
      url.searchParams.append('pspec', 'ptr,' + pspec.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_fixate(dest: GObjectValue, src: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_fixate`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_fraction_multiply(product: GObjectValue, factor1: GObjectValue, factor2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_fraction_multiply`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (product && typeof product === 'object' && 'ptr' in product) {
      url.searchParams.append('product', 'ptr,' + product.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (factor1 && typeof factor1 === 'object' && 'ptr' in factor1) {
      url.searchParams.append('factor1', 'ptr,' + factor1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (factor2 && typeof factor2 === 'object' && 'ptr' in factor2) {
      url.searchParams.append('factor2', 'ptr,' + factor2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_fraction_subtract(dest: GObjectValue, minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_fraction_subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (minuend && typeof minuend === 'object' && 'ptr' in minuend) {
      url.searchParams.append('minuend', 'ptr,' + minuend.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_bitmask(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_bitmask`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_caps(value_: GObjectValue): Promise<GstCaps> {
    const url = new URL(`/Gst/value_get_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCaps(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_get_caps_features(value_: GObjectValue): Promise<GstCapsFeatures> {
    const url = new URL(`/Gst/value_get_caps_features`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstCapsFeatures(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_get_double_range_max(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_double_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_double_range_min(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_double_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_flagset_flags(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_flagset_flags`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_flagset_mask(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_flagset_mask`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_denominator(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_fraction_denominator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_numerator(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_fraction_numerator`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_fraction_range_max(value_: GObjectValue): Promise<GObjectValue> {
    const url = new URL(`/Gst/value_get_fraction_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_get_fraction_range_min(value_: GObjectValue): Promise<GObjectValue> {
    const url = new URL(`/Gst/value_get_fraction_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GObjectValue(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_get_int64_range_max(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int64_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int64_range_min(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int64_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int64_range_step(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int64_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int_range_max(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int_range_max`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int_range_min(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int_range_min`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_int_range_step(value_: GObjectValue): Promise<number> {
    const url = new URL(`/Gst/value_get_int_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_get_structure(value_: GObjectValue): Promise<GstStructure> {
    const url = new URL(`/Gst/value_get_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    // Return value is an object/struct, instantiate it from the ptr
    if (data.return && typeof data.return === 'object' && 'ptr' in data.return) {
      const instance = new GstStructure(data.return.ptr);
      return instance;
    }
    return data.return;
  }
  export async function value_init_and_copy(dest: GObjectValue, src: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/value_init_and_copy`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (src && typeof src === 'object' && 'ptr' in src) {
      url.searchParams.append('src', 'ptr,' + src.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_intersect(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    // Increment ref for parameters with full transfer ownership
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      await fetch(apiConfig.baseUrl + '/GObject/Object/' + dest.ptr + '/ref').catch(() => {});
    }
    const url = new URL(`/Gst/value_intersect`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
        if (dest && typeof dest === 'object' && 'ptr' in dest) {
          await fetch(apiConfig.baseUrl + '/GObject/Object/' + dest.ptr + '/unref').catch(() => {});
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.return;
    } catch (error) {
      // If there's an error, unref the objects we ref'd
      if (dest && typeof dest === 'object' && 'ptr' in dest) {
        await fetch(apiConfig.baseUrl + '/GObject/Object/' + dest.ptr + '/unref').catch(() => {});
      }
      throw error;
    }
  }
  export async function value_is_fixed(value_: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_is_fixed`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_is_subset(value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_is_subset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_register(table: GstValueTable): Promise<void> {
    const url = new URL(`/Gst/value_register`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (table && typeof table === 'object' && 'ptr' in table) {
      url.searchParams.append('table', 'ptr,' + table.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_serialize(value_: GObjectValue): Promise<string> {
    const url = new URL(`/Gst/value_serialize`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_set_bitmask(value_: GObjectValue, bitmask: number): Promise<void> {
    const url = new URL(`/Gst/value_set_bitmask`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('bitmask', String(bitmask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_caps(value_: GObjectValue, caps: GstCaps): Promise<void> {
    const url = new URL(`/Gst/value_set_caps`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (caps && typeof caps === 'object' && 'ptr' in caps) {
      url.searchParams.append('caps', 'ptr,' + caps.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_caps_features(value_: GObjectValue, features: GstCapsFeatures): Promise<void> {
    const url = new URL(`/Gst/value_set_caps_features`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (features && typeof features === 'object' && 'ptr' in features) {
      url.searchParams.append('features', 'ptr,' + features.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_double_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    const url = new URL(`/Gst/value_set_double_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_flagset(value_: GObjectValue, flags: number, mask: number): Promise<void> {
    const url = new URL(`/Gst/value_set_flagset`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('flags', String(flags));
    // Primitive parameter
    url.searchParams.append('mask', String(mask));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_fraction(value_: GObjectValue, numerator: number, denominator: number): Promise<void> {
    const url = new URL(`/Gst/value_set_fraction`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('numerator', String(numerator));
    // Primitive parameter
    url.searchParams.append('denominator', String(denominator));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_fraction_range(value_: GObjectValue, start: GObjectValue, end: GObjectValue): Promise<void> {
    const url = new URL(`/Gst/value_set_fraction_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (start && typeof start === 'object' && 'ptr' in start) {
      url.searchParams.append('start', 'ptr,' + start.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (end && typeof end === 'object' && 'ptr' in end) {
      url.searchParams.append('end', 'ptr,' + end.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_fraction_range_full(value_: GObjectValue, numerator_start: number, denominator_start: number, numerator_end: number, denominator_end: number): Promise<void> {
    const url = new URL(`/Gst/value_set_fraction_range_full`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('numerator_start', String(numerator_start));
    // Primitive parameter
    url.searchParams.append('denominator_start', String(denominator_start));
    // Primitive parameter
    url.searchParams.append('numerator_end', String(numerator_end));
    // Primitive parameter
    url.searchParams.append('denominator_end', String(denominator_end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int64_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    const url = new URL(`/Gst/value_set_int64_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int64_range_step(value_: GObjectValue, start: number, end: number, step: number): Promise<void> {
    const url = new URL(`/Gst/value_set_int64_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    // Primitive parameter
    url.searchParams.append('step', String(step));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int_range(value_: GObjectValue, start: number, end: number): Promise<void> {
    const url = new URL(`/Gst/value_set_int_range`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_int_range_step(value_: GObjectValue, start: number, end: number, step: number): Promise<void> {
    const url = new URL(`/Gst/value_set_int_range_step`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Primitive parameter
    url.searchParams.append('start', String(start));
    // Primitive parameter
    url.searchParams.append('end', String(end));
    // Primitive parameter
    url.searchParams.append('step', String(step));
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_set_structure(value_: GObjectValue, structure: GstStructure): Promise<void> {
    const url = new URL(`/Gst/value_set_structure`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (value_ && typeof value_ === 'object' && 'ptr' in value_) {
      url.searchParams.append('value', 'ptr,' + value_.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (structure && typeof structure === 'object' && 'ptr' in structure) {
      url.searchParams.append('structure', 'ptr,' + structure.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  }
  export async function value_subtract(dest: GObjectValue, minuend: GObjectValue, subtrahend: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_subtract`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (minuend && typeof minuend === 'object' && 'ptr' in minuend) {
      url.searchParams.append('minuend', 'ptr,' + minuend.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (subtrahend && typeof subtrahend === 'object' && 'ptr' in subtrahend) {
      url.searchParams.append('subtrahend', 'ptr,' + subtrahend.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function value_union(dest: GObjectValue, value1: GObjectValue, value2: GObjectValue): Promise<boolean> {
    const url = new URL(`/Gst/value_union`, apiConfig.baseUrl);
    // Object with explode=false: serialize as comma-separated
    if (dest && typeof dest === 'object' && 'ptr' in dest) {
      url.searchParams.append('dest', 'ptr,' + dest.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value1 && typeof value1 === 'object' && 'ptr' in value1) {
      url.searchParams.append('value1', 'ptr,' + value1.ptr);
    }
    // Object with explode=false: serialize as comma-separated
    if (value2 && typeof value2 === 'object' && 'ptr' in value2) {
      url.searchParams.append('value2', 'ptr,' + value2.ptr);
    }
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
  export async function version(): Promise<{ major?: number; minor?: number; micro?: number; nano?: number }> {
    const url = new URL(`/Gst/version`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data;
  }
  export async function version_string(): Promise<string> {
    const url = new URL(`/Gst/version_string`, apiConfig.baseUrl);
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.return;
  }
}
