{# Method template #}
{% set required_params = [] %}
{% set optional_params = [] %}
{% set callback_params = [] %}
{% set callback_url_params = [] %}
{% set header_params_list = [] %}

{# Process query parameters - skip callback URL params in non-SSE mode as they're handled separately #}
{% for param in method.query_params %}
  {% if param.is_callback_url %}
    {# Non-SSE mode: callback URL parameter - we'll handle this separately #}
    {% set _ = callback_url_params.append(param) %}
  {% else %}
    {% set ts_type = param.type.lang_type %}
    {% if param.required %}
      {% set _ = required_params.append(param.valid_name + ": " + ts_type) %}
    {% else %}
      {% set _ = optional_params.append(param.valid_name + "?: " + ts_type) %}
    {% endif %}
  {% endif %}
{% endfor %}

{# For SSE mode: Add callback function parameters from return parameters that are callbacks #}
{% if method.uses_sse_callbacks %}
  {% for return_param in method.return_obj.return_params %}
    {% if return_param.is_callback %}
      {% set _ = callback_params.append(return_param.valid_name + ": " + return_param.callback.name) %}
    {% endif %}
  {% endfor %}
{% endif %}

{# For non-SSE mode: Add callback function parameters for each callback_url param #}
{% if not method.uses_sse_callbacks %}
  {% for cb_url_param in callback_url_params %}
    {# The callback function parameter name is derived from the URL param name #}
    {# e.g., func_url -> func #}
    {% set cb_func_name = cb_url_param.name.replace('_url', '') %}
    {# Find the callback schema reference #}
    {% set cb_ref = cb_url_param.schema_section.get('x-gi-callback', '') %}
    {% set cb_schema_name = cb_ref.split('/')[-1] if cb_ref else 'Function' %}
    {% set _ = callback_params.append(cb_func_name + ": " + cb_schema_name) %}
  {% endfor %}
  
  {# Add header parameters for non-SSE mode (sessionId, callbackSecret) #}
  {% for header_param in method.header_params %}
    {% set _ = header_params_list.append(header_param) %}
    {% if header_param.required %}
      {% set _ = required_params.append(header_param.valid_name.replace('-', '_') + ": string") %}
    {% else %}
      {% set _ = optional_params.append(header_param.valid_name.replace('-', '_') + "?: string") %}
    {% endif %}
  {% endfor %}
{% endif %}

{% set all_params = required_params + callback_params + optional_params %}
{% set params_string = all_params | join(", ") %}

{# Generate method return signature based on return_params #}
{% set method_return_signature = 'void' %}
{% if method.return_obj.return_params %}
  {% if method.return_obj.return_params|length == 1 %}
    {% set return_param = method.return_obj.return_params[0] %}
    {# In SSE mode, callback params are in the return; skip them for the TS return type #}
    {% if not (method.uses_sse_callbacks and return_param.is_callback) %}
      {% set method_return_signature = return_param.type.lang_type %}
      {% if return_param.can_be_null %}
        {% set method_return_signature = method_return_signature + " | null" %}
      {% endif %}
    {% endif %}
  {% else %}
    {% set return_type_parts = [] %}
    {% for return_param in method.return_obj.return_params %}
      {# In SSE mode, skip callback params from the return type #}
      {% if not (method.uses_sse_callbacks and return_param.is_callback) %}
        {% set type_str = return_param.type.lang_type %}
        {% if return_param.can_be_null %}
          {% set type_str = type_str + " | null" %}
        {% endif %}
        {% set _ = return_type_parts.append(return_param.name + ": " + type_str) %}
      {% endif %}
    {% endfor %}
    {% if return_type_parts|length > 0 %}
      {% set method_return_signature = "{" + return_type_parts | join(", ") + "}" %}
    {% endif %}
  {% endif %}
{% endif %}

{% set ns = namespace(method_path = method.path) %}
{% for param in method.path_params %}
  {% set placeholder = "{" + param.valid_name + "}" %}
  {% if param.type.is_ref and param.type.ref_schema.info_type in ['object','struct'] %}
    {% set ns.method_path = ns.method_path.replace(placeholder, "ptr,${this.ptr}") %}
  {% else %}
    {% set ns.method_path = ns.method_path.replace(placeholder, "${" + param.valid_name + "}") %}
  {% endif %}
{% endfor %}


{% block signature %} 
{% if method.is_namespace_function or (method.parent.info_type in ['enum','flags'] and method.parent.methods|length > 0) %}
  export async function {{ method.valid_name }}({{ params_string }}): Promise<{{ method_return_signature }}> {
{% elif method.is_static %}
  static async {{ method.valid_name }}({{ params_string }}): Promise<{{ method_return_signature }}> {
{% else %}
  async {{ method.valid_name }}({{ params_string }}): Promise<{{ method_return_signature }}> {
{% endif %}
{% endblock %}
{% block body %}
    // Increment ref for parameters with full transfer ownership
{% for param in method.params %}
{% include 'param_precondition.ts.j2' %}
{% endfor %}
    const url = new URL(`${apiConfig.normalizedBasePath}{{ ns.method_path }}`, apiConfig.baseUrl);
{% for param in method.query_params %}
  {% if not param.is_callback_url %}
{% include 'param.ts.j2' %}
  {% endif %}
{% endfor %}
{% if not method.uses_sse_callbacks %}
{# Non-SSE mode: Use callback handler interface #}
{% for cb_url_param in callback_url_params %}
    {% set cb_func_name = cb_url_param.name.replace('_url', '') %}
    // Non-SSE mode: Register callback using the callback handler
    let {{ cb_func_name }}_callbackInfo: { callbackUrl: string; callbackId: string } | undefined;
    if (typeof {{ cb_func_name }} !== 'undefined') {
      const handler = getCallbackHandler();
      if (!handler) {
        throw new Error('Callback handler not configured. Call setCallbackHandler() first.');
      }
      
      // Register the callback and get URL + ID
      {{ cb_func_name }}_callbackInfo = handler.registerCallback({{ cb_func_name }}, {
        methodName: '{{ method.name }}',
        paramName: '{{ cb_func_name }}'
      });
      
      // Pass the callback URL to the server
      url.searchParams.append('{{ cb_url_param.name }}', {{ cb_func_name }}_callbackInfo.callbackUrl);
    }
{% endfor %}
{% endif %}
    try {
{% if not method.uses_sse_callbacks and header_params_list|length > 0 %}
      // Non-SSE mode: Add headers for callback authentication
      const headers: Record<string, string> = {};
{% for header_param in header_params_list %}
      {% set header_var_name = header_param.valid_name.replace('-', '_') %}
      if ({{ header_var_name }}) {
        headers['{{ header_param.name }}'] = {{ header_var_name }};
      }
{% endfor %}
      const response = await fetch(url.toString(), { headers });
{% else %}
      const response = await fetch(url.toString());
{% endif %}
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
{% for param in method.params %}
{% include 'param_postcondition.ts.j2' %}
{% endfor %}
        throw new Error(`HTTP error! status: ${response.status}`);
      }
{% if not method.return_obj.is_void or method.callback_params %}
      const data = await response.json();
{% if method.uses_sse_callbacks and method.callback_params %}
      // SSE mode: Register callbacks with dispatcher
{% for cb in method.callback_params %}
      if (data.{{ cb.name }} !== undefined) {
        callbackDispatcher.set(data.{{ cb.name }}.toString(), {
          converter: convert{{ cb.callback.name }}Args,
          userFunction: {{ cb.valid_name }}
        });
      }
{% endfor %}
{% endif %}
{% if not method.return_obj.is_void %}
  {{ method.return_obj.generate() }}
{% else %}
      return data;
{% endif %}
{% endif %}
    } catch (error) {
      // If there's an error, unref the objects we ref'd
{% for param in method.query_params %}
{% include 'param_postcondition.ts.j2' %}
{% endfor %}
      throw error;
    }
  }
{% endblock %}
