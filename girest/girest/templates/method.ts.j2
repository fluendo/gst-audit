{# Method template #}
{% if is_namespace_function %}
  export async function {{ name }}({{ params }}): Promise<{{ return_type }}> {
{% elif is_static %}
  static async {{ name }}({{ params }}): Promise<{{ return_type }}> {
{% else %}
  async {{ name }}({{ params }}): Promise<{{ return_type }}> {
{% endif %}
    // Increment ref for parameters with full transfer ownership
{% for param in query_params %}
{% include 'param_precondition.ts.j2' %}
{% endfor %}
    const url = new URL(`${apiConfig.normalizedBasePath}{{ path }}`, apiConfig.baseUrl);
{% for param in query_params %}
{% include 'param.ts.j2' %}
{% endfor %}
    try {
      const response = await fetch(url.toString());
      if (!response.ok) {
        // If the call fails, unref the objects we ref'd
{% for param in query_params %}
{% include 'param_postcondition.ts.j2' %}
{% endfor %}
        throw new Error(`HTTP error! status: ${response.status}`);
      }
{% if return_type != 'void' or callback_params %}
      const data = await response.json();
{% if callback_params %}
      // Register callbacks
{% for cb in callback_params %}
      if (data.{{ cb.api_name if cb.api_name else cb.name }} !== undefined) {
        callbackDispatcher.set(data.{{ cb.api_name if cb.api_name else cb.name }}.toString(), {{ cb.name }});
      }
{% endfor %}
{% endif %}
{% if is_constructor %}
      const instance = new {{ class_name }}();
      Object.assign(instance, data.return || data);
      return instance;
{% elif has_return %}
{% include 'return.ts.j2' %}
{% else %}
      return data;
{% endif %}
{% endif %}
    } catch (error) {
      // If there's an error, unref the objects we ref'd
{% for param in query_params %}
{% include 'param_postcondition.ts.j2' %}
{% endfor %}
      throw error;
    }
  }
