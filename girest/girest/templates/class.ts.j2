{# Class template #}
{% if is_enum %}
export namespace {{ name }} {
{% for method in methods %}
{{ method }}
{% endfor %}
}
{% else %}
export class {{ name }}{% if extends_gobject and parent_class %} extends {{ parent_class }}{% endif %} {
{% if name == 'GObjectObject' %}
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      objectRegistry.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  unref(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    objectRegistry.unregister(this);
    return fetch(apiConfig.baseUrl + '/GObject/Object/' + this.ptr + '/unref')
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
{% elif has_destructor %}
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
      {{ destructor_registry }}.register(this, ptr);
    }
  }
  
  // Manual cleanup method
  {{ destructor_method_name }}(): Promise<void> {
    if (!this.ptr) return Promise.resolve();
    {{ destructor_registry }}.unregister(this);
    const url = new URL(`{{ destructor_path }}`, apiConfig.baseUrl);
    return fetch(url.toString())
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      });
  }
{% elif extends_gobject and not parent_class %}
  ptr!: string;
  
  constructor(ptr?: string) {
    if (ptr) {
      this.ptr = ptr;
    }
  }
{% else %}
{% for prop in properties %}
  {{ prop.name }}{{ prop.assertion }}: {{ prop.type }};
{% endfor %}
{% endif %}
{% if properties and (constructors or methods) %}

{% endif %}
{{ constructors | join('\n') }}
{% if constructors and methods %}

{% endif %}
{{ methods | join('\n') }}
}
{% endif %}
