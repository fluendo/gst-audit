/**
 * {{ title }}
 * Version: {{ version }}
 * Auto-generated by girest-client-generator
 * Mode: {{ 'SSE' if sse_mode else 'Non-SSE (URL-based callbacks)' }}
 */

// Configuration for API server location
let apiConfig = {
  host: '{{ host }}',
  port: {{ port }},
  basePath: '{{ base_path }}',
  get baseUrl(): string {
    return `http://${this.host}:${this.port}`;
  },
  get normalizedBasePath(): string {
    return this.basePath && !this.basePath.startsWith('/') ? `/${this.basePath}` : this.basePath;
  },
  get fullBaseUrl(): string {
    return `http://${this.host}:${this.port}${this.normalizedBasePath}`;
  },
};

/**
 * Update the API server configuration
 * @param config New configuration with host, port, and/or basePath
 */
export function setApiConfig(config: { host?: string; port?: number; basePath?: string }): void {
  if (config.host !== undefined) {
    apiConfig.host = config.host;
  }
  if (config.port !== undefined) {
    apiConfig.port = config.port;
  }
  if (config.basePath !== undefined) {
    apiConfig.basePath = config.basePath;
  }

{% if sse_mode %}
  // Reinitialize callback EventSource with new URL
  if (typeof EventSource !== 'undefined' && (config.host !== undefined || config.port !== undefined || config.basePath !== undefined)) {
    initializeCallbackSource();
  }
{% endif %}
}

/**
 * Get the current API server configuration
 */
export function getApiConfig(): { host: string; port: number; basePath: string; baseUrl: string } {
  return {
    host: apiConfig.host,
    port: apiConfig.port,
    basePath: apiConfig.basePath,
    baseUrl: apiConfig.baseUrl
  };
}

// FinalizationRegistry for automatic cleanup of GObject instances
const objectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Object/ptr,' + ptr + '/unref')
    .catch(err => console.error('Failed to unref object:', ptr, err));
});

{% if sse_mode %}
// SSE Mode: Callback dispatcher for handling callbacks from the server via EventSource
interface CallbackEntry {
  converter: (data: any) => any[];
  userFunction: Function;
}
const callbackDispatcher = new Map<string, CallbackEntry>();

let callbackSource: EventSource | null = null;
let isReinitializing = false;

function initializeCallbackSource(): void {
  // Prevent concurrent reinitialization
  if (isReinitializing) {
    return;
  }
  isReinitializing = true;
  
  // Close existing EventSource if it exists
  if (callbackSource) {
    callbackSource.close();
    callbackSource = null;
  }
  
  // Initialize callback dispatcher with EventSource
  if (typeof EventSource !== 'undefined') {
    callbackSource = new EventSource(apiConfig.fullBaseUrl + '/GIRest/callbacks');
    callbackSource.onmessage = (ev) => {
      try {
        const json = JSON.parse(ev.data);
        const callbackEntry = callbackDispatcher.get(json.id.toString());
        if (callbackEntry) {
          const convertedArgs = callbackEntry.converter(json.data);
          callbackEntry.userFunction(...convertedArgs);
        }
      } catch (error) {
        console.error('Error processing callback:', error);
      }
    };
    callbackSource.onerror = (error) => {
      console.error('Callback EventSource error:', error);
    };
    callbackSource.onopen = () => {
      isReinitializing = false;
    };
  } else {
    isReinitializing = false;
  }
}
{% else %}
// Non-SSE Mode: URL-based callbacks
// The client must implement ICallbackHandler to receive and process callbacks

/**
 * Interface for callback handling in non-SSE mode.
 * Implementations should handle callback registration and invocation.
 */
export interface ICallbackHandler {
  /**
   * Register a callback function and return metadata for the server.
   * 
   * @param callbackFunc The callback function to register
   * @param metadata Additional metadata (method name, parameter name, etc.)
   * @returns An object containing:
   *   - callbackUrl: The URL where callbacks should be POSTed
   *   - callbackId: A unique identifier for this callback registration
   */
  registerCallback(
    callbackFunc: Function,
    metadata: { methodName: string; paramName: string }
  ): { callbackUrl: string; callbackId: string };

  /**
   * Unregister a callback.
   * 
   * @param callbackId The callback ID to unregister
   */
  unregisterCallback(callbackId: string): void;
}

let callbackHandler: ICallbackHandler | null = null;

/**
 * Set the callback handler for non-SSE mode.
 * This handler is responsible for managing callback registrations and invocations.
 * 
 * @param handler An implementation of ICallbackHandler
 */
export function setCallbackHandler(handler: ICallbackHandler): void {
  callbackHandler = handler;
}

/**
 * Get the current callback handler.
 */
export function getCallbackHandler(): ICallbackHandler | null {
  return callbackHandler;
}
{% endif %}

// Define the core interfaces for objects and structs memory management
interface ObjectLikeInstance {
  ref(): Promise<void>;
  unref(): Promise<void>;
}

interface StructLikeInstance {
  free(): Promise<void>;
  copy(): Promise<void>;
}

// Combined interface for objects that might need various cleanup
interface ManagedResource extends Partial<ObjectLikeInstance>, Partial<StructLikeInstance> {}

type transferType = 'none' | 'container' | 'full';

{% for schema in schemas.values() %}
  {{ schema.generate() }}
{% endfor %}