/**
 * {{ title }}
 * Version: {{ version }}
 * Auto-generated by girest-client-generator
 */

// Base types
export type Pointer = string;

// Configuration for API server location
let apiConfig = {
  host: '{{ host }}',
  port: {{ port }},
  basePath: '{{ base_path }}',
  get baseUrl(): string {
    return `http://${this.host}:${this.port}`;
  },
  get normalizedBasePath(): string {
    return this.basePath && !this.basePath.startsWith('/') ? `/${this.basePath}` : this.basePath;
  },
  get fullBaseUrl(): string {
    return `http://${this.host}:${this.port}${this.normalizedBasePath}`;
  },
};

/**
 * Update the API server configuration
 * @param config New configuration with host, port, and/or basePath
 */
export function setApiConfig(config: { host?: string; port?: number; basePath?: string }): void {
  if (config.host !== undefined) {
    apiConfig.host = config.host;
  }
  if (config.port !== undefined) {
    apiConfig.port = config.port;
  }
  if (config.basePath !== undefined) {
    apiConfig.basePath = config.basePath;
  }

  // Reinitialize callback EventSource with new URL
  if (typeof EventSource !== 'undefined' && (config.host !== undefined || config.port !== undefined || config.basePath !== undefined)) {
    initializeCallbackSource();
  }
}

/**
 * Get the current API server configuration
 */
export function getApiConfig(): { host: string; port: number; basePath: string; baseUrl: string } {
  return {
    host: apiConfig.host,
    port: apiConfig.port,
    basePath: apiConfig.basePath,
    baseUrl: apiConfig.baseUrl
  };
}

// FinalizationRegistry for automatic cleanup of GObject instances
const objectRegistry = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '/GObject/Object/ptr,' + ptr + '/unref')
    .catch(err => console.error('Failed to unref object:', ptr, err));
});
{% if struct_registries %}

// FinalizationRegistry for automatic cleanup of struct instances
{% for registry in struct_registries %}
const {{ registry.name }} = new FinalizationRegistry((ptr: string) => {
  fetch(apiConfig.fullBaseUrl + '{{ registry.path }}')
    .catch(err => console.error('Failed to free {{ registry.class_name }}:', ptr, err));
});
{% endfor %}
{% endif %}

// Callback dispatcher for handling callbacks from the server
const callbackDispatcher = new Map<string, Function>();

let callbackSource: EventSource | null = null;
let isReinitializing = false;

function initializeCallbackSource(): void {
  // Prevent concurrent reinitialization
  if (isReinitializing) {
    return;
  }
  isReinitializing = true;
  
  // Close existing EventSource if it exists
  if (callbackSource) {
    callbackSource.close();
    callbackSource = null;
  }
  
  // Initialize callback dispatcher with EventSource
  if (typeof EventSource !== 'undefined') {
    callbackSource = new EventSource(apiConfig.fullBaseUrl + '/GIRest/callbacks');
    callbackSource.onmessage = (ev) => {
      try {
        const json = JSON.parse(ev.data);
        const cb = callbackDispatcher.get(json.id.toString());
        if (cb) {
          cb(...Object.values(json.data));
        }
      } catch (error) {
        console.error('Error processing callback:', error);
      }
    };
    callbackSource.onerror = (error) => {
      console.error('Callback EventSource error:', error);
    };
    callbackSource.onopen = () => {
      isReinitializing = false;
    };
  } else {
    isReinitializing = false;
  }
}

{% if interfaces %}

{{ interfaces | join('\n') }}
{% endif %}
{% if classes %}

{{ classes | join('\n') }}
{% endif %}
{% if standalone_namespace %}

{{ standalone_namespace }}
{% endif %}
