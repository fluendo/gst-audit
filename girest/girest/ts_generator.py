"""
TypeScript bindings generator for GIRest OpenAPI schemas.

This module converts OpenAPI schemas generated by GIRest into TypeScript
bindings with proper class structure, inheritance, and type definitions.
"""
import json
from typing import Dict, List, Set, Optional, Any


class TypeScriptGenerator:
    """Generates TypeScript bindings from OpenAPI schema."""
    
    def __init__(self, openapi_schema: Dict[str, Any]):
        """
        Initialize the generator with an OpenAPI schema.
        
        Args:
            openapi_schema: The OpenAPI schema dictionary from GIRest
        """
        self.schema = openapi_schema
        self.components = openapi_schema.get("components", {})
        self.schemas = self.components.get("schemas", {})
        self.paths = openapi_schema.get("paths", {})
        self.generated_types: Set[str] = set()
        self.class_methods: Dict[str, List[Dict]] = {}  # class_name -> [methods]
        
        # Parse operations and organize by tag (class)
        self._parse_operations()
    
    def _parse_operations(self):
        """Parse all operations and organize them by tag (class name)."""
        for path, operations in self.paths.items():
            for method, operation in operations.items():
                if method.lower() not in ["get", "post", "put", "delete", "patch"]:
                    continue
                
                tags = operation.get("tags", [])
                if tags:
                    # Use the first tag as the class name
                    class_name = tags[0]
                    if class_name not in self.class_methods:
                        self.class_methods[class_name] = []
                    
                    self.class_methods[class_name].append({
                        "path": path,
                        "http_method": method,
                        "operation": operation,
                        "operation_id": operation.get("operationId", "")
                    })
    
    def _openapi_type_to_ts(self, schema: Dict[str, Any], nullable: bool = False) -> str:
        """
        Convert an OpenAPI schema type to TypeScript type.
        
        Args:
            schema: The OpenAPI schema definition
            nullable: Whether the type can be null
            
        Returns:
            TypeScript type string
        """
        if not schema:
            return "any"
        
        # Handle $ref
        if "$ref" in schema:
            ref_path = schema["$ref"]
            if ref_path.startswith("#/components/schemas/"):
                type_name = ref_path.split("/")[-1]
                return type_name + (" | null" if nullable else "")
        
        # Handle allOf (inheritance)
        if "allOf" in schema:
            # For now, we'll handle this in schema generation
            # Return the type name if it's already defined
            return "any"
        
        # Handle oneOf (union types)
        if "oneOf" in schema:
            types = [self._openapi_type_to_ts(s) for s in schema["oneOf"]]
            union = " | ".join(types)
            return f"({union})" + (" | null" if nullable else "")
        
        schema_type = schema.get("type")
        
        if schema_type == "string":
            enum_values = schema.get("enum")
            if enum_values:
                # Return enum as string literal union
                literals = " | ".join([f'"{v}"' for v in enum_values])
                return literals + (" | null" if nullable else "")
            return "string" + (" | null" if nullable else "")
        
        elif schema_type == "integer" or schema_type == "number":
            return "number" + (" | null" if nullable else "")
        
        elif schema_type == "boolean":
            return "boolean" + (" | null" if nullable else "")
        
        elif schema_type == "array":
            items = schema.get("items", {})
            item_type = self._openapi_type_to_ts(items)
            return f"{item_type}[]" + (" | null" if nullable else "")
        
        elif schema_type == "object":
            properties = schema.get("properties", {})
            if properties:
                # For inline objects, generate a type
                prop_types = []
                required = schema.get("required", [])
                for prop_name, prop_schema in properties.items():
                    is_required = prop_name in required
                    prop_type = self._openapi_type_to_ts(prop_schema)
                    optional_marker = "" if is_required else "?"
                    prop_types.append(f"{prop_name}{optional_marker}: {prop_type}")
                return "{ " + "; ".join(prop_types) + " }" + (" | null" if nullable else "")
            return "object" + (" | null" if nullable else "")
        
        return "any" + (" | null" if nullable else "")
    
    def _generate_interface(self, name: str, schema: Dict[str, Any]) -> str:
        """
        Generate a TypeScript interface for a schema.
        
        Args:
            name: The interface name
            schema: The OpenAPI schema
            
        Returns:
            TypeScript interface definition
        """
        lines = []
        
        # Handle enums - generate as type alias with string literals
        if "enum" in schema and schema.get("type") == "string":
            enum_values = schema["enum"]
            literals = " | ".join([f'"{v}"' for v in enum_values])
            return f"export type {name} = {literals};"
        
        # Handle allOf (inheritance)
        if "allOf" in schema:
            all_of = schema["allOf"]
            # First element is typically the parent reference
            parent_refs = []
            own_props = {}
            
            for item in all_of:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        parent_refs.append(parent_name)
                elif "type" in item and item["type"] == "object":
                    # This contains the properties for this class
                    own_props = item.get("properties", {})
            
            if parent_refs:
                extends_clause = " extends " + ", ".join(parent_refs)
                lines.append(f"export interface {name}{extends_clause} {{")
            else:
                lines.append(f"export interface {name} {{")
            
            # Add properties from this level
            required = schema.get("required", [])
            for prop_name, prop_schema in own_props.items():
                is_required = prop_name in required
                prop_type = self._openapi_type_to_ts(prop_schema)
                optional_marker = "" if is_required else "?"
                lines.append(f"  {prop_name}{optional_marker}: {prop_type};")
        
        else:
            # Regular object
            lines.append(f"export interface {name} {{")
            properties = schema.get("properties", {})
            required = schema.get("required", [])
            
            for prop_name, prop_schema in properties.items():
                is_required = prop_name in required
                prop_type = self._openapi_type_to_ts(prop_schema)
                optional_marker = "" if is_required else "?"
                lines.append(f"  {prop_name}{optional_marker}: {prop_type};")
        
        lines.append("}")
        
        return "\n".join(lines)
    
    def _generate_class_method(self, method_info: Dict[str, Any]) -> str:
        """
        Generate a TypeScript class method from an operation.
        
        Args:
            method_info: Dictionary containing operation information
            
        Returns:
            TypeScript method definition
        """
        operation = method_info["operation"]
        path = method_info["path"]
        
        # Extract method name from path (last segment)
        method_name = path.split("/")[-1].replace("{", "").replace("}", "")
        
        # Build parameter list
        params = operation.get("parameters", [])
        method_params = []
        
        for param in params:
            param_name = param.get("name", "")
            param_schema = param.get("schema", {})
            param_required = param.get("required", False)
            
            # Skip 'self' parameter as it's implicit in methods
            if param_name == "self":
                continue
            
            param_type = self._openapi_type_to_ts(param_schema)
            optional_marker = "" if param_required else "?"
            method_params.append(f"{param_name}{optional_marker}: {param_type}")
        
        # Determine return type from responses
        return_type = "void"
        responses = operation.get("responses", {})
        
        if "200" in responses:
            content = responses["200"].get("content", {})
            app_json = content.get("application/json", {})
            schema = app_json.get("schema", {})
            
            if schema:
                # The response is an object with properties
                props = schema.get("properties", {})
                if "return" in props:
                    return_type = self._openapi_type_to_ts(props["return"])
                elif props:
                    # Return the entire response object
                    return_type = self._openapi_type_to_ts(schema)
                else:
                    return_type = "void"
        
        params_str = ", ".join(method_params)
        return f"  {method_name}({params_str}): Promise<{return_type}>;"
    
    def _generate_class(self, class_name: str) -> str:
        """
        Generate a TypeScript class with methods from operations.
        
        Args:
            class_name: The class name (from tag)
            
        Returns:
            TypeScript class definition
        """
        lines = []
        
        # Check if there's a corresponding schema for this class
        schema = self.schemas.get(class_name)
        
        if schema:
            # Generate as a class that implements the interface
            lines.append(f"export class {class_name} {{")
            
            # Add properties from the interface
            properties = schema.get("properties", {})
            required = schema.get("required", [])
            
            # Handle allOf for inheritance
            if "allOf" in schema:
                all_of = schema["allOf"]
                for item in all_of:
                    if "type" in item and item["type"] == "object":
                        properties = item.get("properties", {})
                        break
            
            for prop_name, prop_schema in properties.items():
                is_required = prop_name in required
                prop_type = self._openapi_type_to_ts(prop_schema)
                # Use definite assignment assertion for required properties
                assertion = "!" if is_required else "?"
                lines.append(f"  {prop_name}{assertion}: {prop_type};")
            
            lines.append("")
        else:
            lines.append(f"export class {class_name} {{")
        
        # Add methods
        if class_name in self.class_methods:
            for method_info in self.class_methods[class_name]:
                method_def = self._generate_class_method(method_info)
                lines.append(method_def)
        
        lines.append("}")
        
        return "\n".join(lines)
    
    def generate(self) -> str:
        """
        Generate complete TypeScript bindings.
        
        Returns:
            TypeScript code as a string
        """
        output = []
        
        # Header comment
        title = self.schema.get("info", {}).get("title", "API")
        version = self.schema.get("info", {}).get("version", "1.0")
        
        output.append("/**")
        output.append(f" * {title}")
        output.append(f" * Version: {version}")
        output.append(" * Auto-generated by girest-ts")
        output.append(" */")
        output.append("")
        
        # Generate interfaces for all schemas
        for schema_name, schema_def in self.schemas.items():
            interface_def = self._generate_interface(schema_name, schema_def)
            output.append(interface_def)
            output.append("")
        
        # Generate classes for schemas that have methods
        for class_name in self.class_methods.keys():
            class_def = self._generate_class(class_name)
            output.append(class_def)
            output.append("")
        
        return "\n".join(output)
