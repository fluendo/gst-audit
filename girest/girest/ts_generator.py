"""
TypeScript bindings generator for GIRest OpenAPI schemas.

This module converts OpenAPI schemas generated by GIRest into TypeScript
bindings with proper class structure, inheritance, and type definitions.
"""
import json
from typing import Dict, List, Set, Optional, Any


class TypeScriptGenerator:
    """Generates TypeScript bindings from OpenAPI schema."""
    
    def __init__(self, openapi_schema: Dict[str, Any], base_url: Optional[str] = None):
        """
        Initialize the generator with an OpenAPI schema.
        
        Args:
            openapi_schema: The OpenAPI schema dictionary from GIRest
            base_url: Optional base URL for REST API calls (e.g., 'http://localhost:8000')
        """
        self.schema = openapi_schema
        self.components = openapi_schema.get("components", {})
        self.schemas = self.components.get("schemas", {})
        self.paths = openapi_schema.get("paths", {})
        self.generated_types: Set[str] = set()
        self.class_methods: Dict[str, List[Dict]] = {}  # class_name -> [methods]
        self.base_url = base_url
        self.enum_schemas: Set[str] = set()  # Track which schemas are enums
        self.class_constructors: Dict[str, List[Dict]] = {}  # class_name -> [constructor methods]
        
        # Identify enum schemas first
        self._identify_enum_schemas()
        
        # Parse operations and organize by tag (class)
        self._parse_operations()
    
    def _identify_enum_schemas(self):
        """Identify which schemas are enums."""
        for schema_name, schema_def in self.schemas.items():
            if "enum" in schema_def and schema_def.get("type") == "string":
                self.enum_schemas.add(schema_name)
    
    def _parse_operations(self):
        """Parse all operations and organize them by tag (class name)."""
        for path, operations in self.paths.items():
            for method, operation in operations.items():
                if method.lower() not in ["get", "post", "put", "delete", "patch"]:
                    continue
                
                tags = operation.get("tags", [])
                if tags:
                    # Use the first tag as the class name
                    class_name = tags[0]
                    
                    method_info = {
                        "path": path,
                        "http_method": method,
                        "operation": operation,
                        "operation_id": operation.get("operationId", "")
                    }
                    
                    # Check if this is a constructor method
                    is_constructor = operation.get("x-gi-constructor", False)
                    
                    if is_constructor:
                        # Add to constructors
                        if class_name not in self.class_constructors:
                            self.class_constructors[class_name] = []
                        self.class_constructors[class_name].append(method_info)
                    else:
                        # Add to regular methods
                        if class_name not in self.class_methods:
                            self.class_methods[class_name] = []
                        self.class_methods[class_name].append(method_info)
    
    def _openapi_type_to_ts(self, schema: Dict[str, Any], nullable: bool = False) -> str:
        """
        Convert an OpenAPI schema type to TypeScript type.
        
        Args:
            schema: The OpenAPI schema definition
            nullable: Whether the type can be null
            
        Returns:
            TypeScript type string
        """
        if not schema:
            return "any"
        
        # Handle $ref
        if "$ref" in schema:
            ref_path = schema["$ref"]
            if ref_path.startswith("#/components/schemas/"):
                type_name = ref_path.split("/")[-1]
                return type_name + (" | null" if nullable else "")
        
        # Handle allOf (inheritance)
        if "allOf" in schema:
            # For now, we'll handle this in schema generation
            # Return the type name if it's already defined
            return "any"
        
        # Handle oneOf (union types)
        if "oneOf" in schema:
            types = [self._openapi_type_to_ts(s) for s in schema["oneOf"]]
            union = " | ".join(types)
            return f"({union})" + (" | null" if nullable else "")
        
        schema_type = schema.get("type")
        
        if schema_type == "string":
            enum_values = schema.get("enum")
            if enum_values:
                # Return enum as string literal union
                literals = " | ".join([f'"{v}"' for v in enum_values])
                return literals + (" | null" if nullable else "")
            return "string" + (" | null" if nullable else "")
        
        elif schema_type == "integer" or schema_type == "number":
            return "number" + (" | null" if nullable else "")
        
        elif schema_type == "boolean":
            return "boolean" + (" | null" if nullable else "")
        
        elif schema_type == "array":
            items = schema.get("items", {})
            item_type = self._openapi_type_to_ts(items)
            return f"{item_type}[]" + (" | null" if nullable else "")
        
        elif schema_type == "object":
            properties = schema.get("properties", {})
            if properties:
                # For inline objects, generate a type
                prop_types = []
                required = schema.get("required", [])
                for prop_name, prop_schema in properties.items():
                    is_required = prop_name in required
                    prop_type = self._openapi_type_to_ts(prop_schema)
                    optional_marker = "" if is_required else "?"
                    prop_types.append(f"{prop_name}{optional_marker}: {prop_type}")
                return "{ " + "; ".join(prop_types) + " }" + (" | null" if nullable else "")
            return "object" + (" | null" if nullable else "")
        
        return "any" + (" | null" if nullable else "")
    
    def _generate_interface(self, name: str, schema: Dict[str, Any]) -> str:
        """
        Generate a TypeScript interface for a schema.
        
        Args:
            name: The interface name
            schema: The OpenAPI schema
            
        Returns:
            TypeScript interface definition
        """
        lines = []
        
        # Handle enums
        if "enum" in schema and schema.get("type") == "string":
            enum_values = schema["enum"]
            
            # Check if this enum has methods (will be generated as namespace later)
            has_methods = name in self.class_methods
            
            if has_methods:
                # For enums with methods, generate as namespace with const values
                # Methods will be added later in _generate_class
                lines.append(f"export namespace {name} {{")
                for value in enum_values:
                    # Convert enum value to uppercase constant name
                    const_name = value.upper().replace("-", "_").replace(".", "_")
                    lines.append(f"  export const {const_name}: '{value}' = '{value}';")
                lines.append("}")
                # Also generate a type alias for the enum values
                literals = " | ".join([f'"{v}"' for v in enum_values])
                lines.append(f"export type {name}Value = {literals};")
                return "\n".join(lines)
            else:
                # Generate as simple type alias for enums without methods
                literals = " | ".join([f'"{v}"' for v in enum_values])
                return f"export type {name} = {literals};"
        
        # Handle allOf (inheritance)
        if "allOf" in schema:
            all_of = schema["allOf"]
            # First element is typically the parent reference
            parent_refs = []
            own_props = {}
            
            for item in all_of:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        parent_refs.append(parent_name)
                elif "type" in item and item["type"] == "object":
                    # This contains the properties for this class
                    own_props = item.get("properties", {})
            
            if parent_refs:
                extends_clause = " extends " + ", ".join(parent_refs)
                lines.append(f"export interface {name}{extends_clause} {{")
            else:
                lines.append(f"export interface {name} {{")
            
            # Add properties from this level
            required = schema.get("required", [])
            for prop_name, prop_schema in own_props.items():
                is_required = prop_name in required
                prop_type = self._openapi_type_to_ts(prop_schema)
                optional_marker = "" if is_required else "?"
                lines.append(f"  {prop_name}{optional_marker}: {prop_type};")
        
        else:
            # Regular object
            lines.append(f"export interface {name} {{")
            properties = schema.get("properties", {})
            required = schema.get("required", [])
            
            for prop_name, prop_schema in properties.items():
                is_required = prop_name in required
                prop_type = self._openapi_type_to_ts(prop_schema)
                optional_marker = "" if is_required else "?"
                lines.append(f"  {prop_name}{optional_marker}: {prop_type};")
        
        lines.append("}")
        
        return "\n".join(lines)
    
    def _generate_constructor(self, method_info: Dict[str, Any], class_name: str) -> str:
        """
        Generate a TypeScript constructor from a constructor method.
        
        Args:
            method_info: Dictionary containing operation information
            class_name: The class name for this constructor
            
        Returns:
            TypeScript constructor definition
        """
        operation = method_info["operation"]
        path = method_info["path"]
        
        # Build parameter list
        params = operation.get("parameters", [])
        constructor_params = []
        query_params = []
        path_params = []
        
        for param in params:
            param_name = param.get("name", "")
            param_schema = param.get("schema", {})
            param_required = param.get("required", False)
            param_in = param.get("in", "query")
            
            # Skip 'self' parameter in constructors
            if param_name == "self":
                continue
            
            param_type = self._openapi_type_to_ts(param_schema)
            optional_marker = "" if param_required else "?"
            constructor_params.append(f"{param_name}{optional_marker}: {param_type}")
            
            if param_in == "path":
                path_params.append((param_name, param_schema))
            elif param_in == "query":
                query_params.append((param_name, param_schema, param_required))
        
        # Determine return type - constructors return an instance of the class
        return_type = class_name
        
        params_str = ", ".join(constructor_params)
        
        # Generate constructor implementation if base_url is provided
        if self.base_url:
            lines = []
            lines.append(f"  constructor({params_str}) {{")
            
            # Build the URL
            url_path = path
            # Replace path parameters
            for param_name, param_schema in path_params:
                url_path = url_path.replace(f"{{{param_name}}}", f"${{{param_name}}}")
            
            lines.append(f"    const url = new URL(`{url_path}`, '{self.base_url}');")
            
            # Add query parameters
            if query_params:
                for param_name, param_schema, required in query_params:
                    if required:
                        lines.append(f"    url.searchParams.append('{param_name}', String({param_name}));")
                    else:
                        lines.append(f"    if ({param_name} !== undefined) url.searchParams.append('{param_name}', String({param_name}));")
            
            # Make the fetch call
            lines.append(f"    const response = await fetch(url.toString());")
            lines.append(f"    if (!response.ok) throw new Error(`HTTP error! status: ${{response.status}}`);")
            lines.append(f"    const data = await response.json();")
            lines.append(f"    // Initialize object from returned data")
            lines.append(f"    Object.assign(this, data.return || data);")
            lines.append(f"  }}")
            return "\n".join(lines)
        else:
            # Generate abstract constructor signature without implementation
            # Note: TypeScript doesn't support async constructors, so we'll use a static factory method
            return None  # Will be handled as static factory method
    
    def _generate_static_factory(self, method_info: Dict[str, Any], class_name: str) -> str:
        """
        Generate a static factory method for constructor methods.
        
        Args:
            method_info: Dictionary containing operation information
            class_name: The class name for this method
            
        Returns:
            TypeScript static factory method definition
        """
        operation = method_info["operation"]
        path = method_info["path"]
        
        # Extract method name from path (last segment)
        method_name = path.split("/")[-1].replace("{", "").replace("}", "")
        
        # Build parameter list
        params = operation.get("parameters", [])
        method_params = []
        query_params = []
        path_params = []
        
        for param in params:
            param_name = param.get("name", "")
            param_schema = param.get("schema", {})
            param_required = param.get("required", False)
            param_in = param.get("in", "query")
            
            # Skip 'self' parameter
            if param_name == "self":
                continue
            
            param_type = self._openapi_type_to_ts(param_schema)
            optional_marker = "" if param_required else "?"
            method_params.append(f"{param_name}{optional_marker}: {param_type}")
            
            if param_in == "path":
                path_params.append((param_name, param_schema))
            elif param_in == "query":
                query_params.append((param_name, param_schema, param_required))
        
        # Constructors return an instance of the class
        return_type = class_name
        
        params_str = ", ".join(method_params)
        
        # Generate method implementation if base_url is provided
        if self.base_url:
            lines = []
            lines.append(f"  static async {method_name}({params_str}): Promise<{return_type}> {{")
            
            # Build the URL
            url_path = path
            # Replace path parameters
            for param_name, param_schema in path_params:
                url_path = url_path.replace(f"{{{param_name}}}", f"${{{param_name}}}")
            
            lines.append(f"    const url = new URL(`{url_path}`, '{self.base_url}');")
            
            # Add query parameters
            if query_params:
                for param_name, param_schema, required in query_params:
                    if required:
                        lines.append(f"    url.searchParams.append('{param_name}', String({param_name}));")
                    else:
                        lines.append(f"    if ({param_name} !== undefined) url.searchParams.append('{param_name}', String({param_name}));")
            
            # Make the fetch call
            lines.append(f"    const response = await fetch(url.toString());")
            lines.append(f"    if (!response.ok) throw new Error(`HTTP error! status: ${{response.status}}`);")
            lines.append(f"    const data = await response.json();")
            lines.append(f"    const instance = new {class_name}();")
            lines.append(f"    Object.assign(instance, data.return || data);")
            lines.append(f"    return instance;")
            lines.append(f"  }}")
            return "\n".join(lines)
        else:
            # Generate abstract method signature without implementation
            return f"  static {method_name}({params_str}): Promise<{return_type}>;"
    
    def _generate_class_method(self, method_info: Dict[str, Any], class_name: str) -> str:
        """
        Generate a TypeScript class method from an operation.
        
        Args:
            method_info: Dictionary containing operation information
            class_name: The class name for this method
            
        Returns:
            TypeScript method definition
        """
        operation = method_info["operation"]
        path = method_info["path"]
        http_method = method_info["http_method"]
        
        # Extract method name from path (last segment)
        method_name = path.split("/")[-1].replace("{", "").replace("}", "")
        
        # Build parameter list
        params = operation.get("parameters", [])
        method_params = []
        query_params = []
        path_params = []
        has_self_param = False
        
        for param in params:
            param_name = param.get("name", "")
            param_schema = param.get("schema", {})
            param_required = param.get("required", False)
            param_in = param.get("in", "query")
            
            # Handle 'self' parameter specially
            if param_name == "self":
                has_self_param = True
                path_params.append((param_name, param_schema))
                continue
            
            param_type = self._openapi_type_to_ts(param_schema)
            optional_marker = "" if param_required else "?"
            method_params.append(f"{param_name}{optional_marker}: {param_type}")
            
            if param_in == "path":
                path_params.append((param_name, param_schema))
            elif param_in == "query":
                query_params.append((param_name, param_schema, param_required))
        
        # Determine return type from responses
        return_type = "void"
        response_has_return = False
        responses = operation.get("responses", {})
        
        if "200" in responses:
            content = responses["200"].get("content", {})
            app_json = content.get("application/json", {})
            schema = app_json.get("schema", {})
            
            if schema:
                # The response is an object with properties
                props = schema.get("properties", {})
                if "return" in props:
                    return_type = self._openapi_type_to_ts(props["return"])
                    response_has_return = True
                elif props:
                    # Return the entire response object
                    return_type = self._openapi_type_to_ts(schema)
                else:
                    return_type = "void"
        
        params_str = ", ".join(method_params)
        
        # Generate method implementation if base_url is provided
        if self.base_url:
            lines = []
            
            # Check if this is an enum namespace (static methods)
            is_enum = class_name in self.enum_schemas
            static_modifier = "static " if is_enum else ""
            
            lines.append(f"  {static_modifier}async {method_name}({params_str}): Promise<{return_type}> {{")
            
            # Build the URL
            url_path = path
            # Replace path parameters
            for param_name, param_schema in path_params:
                if param_name == "self":
                    url_path = url_path.replace("{self}", "${this.ptr}")
                else:
                    url_path = url_path.replace(f"{{{param_name}}}", f"${{{param_name}}}")
            
            lines.append(f"    const url = new URL(`{url_path}`, '{self.base_url}');")
            
            # Add query parameters
            if query_params:
                for param_name, param_schema, required in query_params:
                    if required:
                        lines.append(f"    url.searchParams.append('{param_name}', String({param_name}));")
                    else:
                        lines.append(f"    if ({param_name} !== undefined) url.searchParams.append('{param_name}', String({param_name}));")
            
            # Make the fetch call
            lines.append(f"    const response = await fetch(url.toString());")
            lines.append(f"    if (!response.ok) throw new Error(`HTTP error! status: ${{response.status}}`);")
            
            if return_type != "void":
                lines.append(f"    const data = await response.json();")
                if response_has_return:
                    lines.append(f"    return data.return;")
                else:
                    lines.append(f"    return data;")
            
            lines.append(f"  }}")
            return "\n".join(lines)
        else:
            # Generate abstract method signature without implementation
            is_enum = class_name in self.enum_schemas
            static_modifier = "static " if is_enum else ""
            return f"  {static_modifier}{method_name}({params_str}): Promise<{return_type}>;"
    
    
    def _generate_class(self, class_name: str) -> str:
        """
        Generate a TypeScript class with methods from operations.
        
        Args:
            class_name: The class name (from tag)
            
        Returns:
            TypeScript class definition
        """
        lines = []
        
        # Check if this is an enum with methods
        is_enum = class_name in self.enum_schemas
        
        if is_enum:
            # Enums with methods are already generated as namespaces in _generate_interface
            # We need to extend the namespace with methods
            lines.append(f"export namespace {class_name} {{")
            
            # Add methods as static methods in the namespace
            if class_name in self.class_methods:
                for method_info in self.class_methods[class_name]:
                    method_def = self._generate_class_method(method_info, class_name)
                    lines.append(method_def)
            
            lines.append("}")
            return "\n".join(lines)
        
        # Check if there's a corresponding schema for this class
        schema = self.schemas.get(class_name)
        
        if schema:
            # Generate as a class that implements the interface
            lines.append(f"export class {class_name} {{")
            
            # Add properties from the interface
            properties = schema.get("properties", {})
            required = schema.get("required", [])
            
            # Handle allOf for inheritance
            if "allOf" in schema:
                all_of = schema["allOf"]
                for item in all_of:
                    if "type" in item and item["type"] == "object":
                        properties = item.get("properties", {})
                        break
            
            for prop_name, prop_schema in properties.items():
                is_required = prop_name in required
                prop_type = self._openapi_type_to_ts(prop_schema)
                # Use definite assignment assertion for required properties
                assertion = "!" if is_required else "?"
                lines.append(f"  {prop_name}{assertion}: {prop_type};")
            
            lines.append("")
        else:
            lines.append(f"export class {class_name} {{")
        
        # Add constructor factory methods (static methods)
        if class_name in self.class_constructors:
            for method_info in self.class_constructors[class_name]:
                factory_def = self._generate_static_factory(method_info, class_name)
                lines.append(factory_def)
            if self.class_constructors[class_name]:  # Add spacing if we added constructors
                lines.append("")
        
        # Add methods
        if class_name in self.class_methods:
            for method_info in self.class_methods[class_name]:
                method_def = self._generate_class_method(method_info, class_name)
                lines.append(method_def)
        
        lines.append("}")
        
        return "\n".join(lines)
    
    def generate(self) -> str:
        """
        Generate complete TypeScript bindings.
        
        Returns:
            TypeScript code as a string
        """
        output = []
        
        # Header comment
        title = self.schema.get("info", {}).get("title", "API")
        version = self.schema.get("info", {}).get("version", "1.0")
        
        output.append("/**")
        output.append(f" * {title}")
        output.append(f" * Version: {version}")
        output.append(" * Auto-generated by girest-ts")
        output.append(" */")
        output.append("")
        
        # Generate interfaces for all schemas (includes enum namespaces)
        for schema_name, schema_def in self.schemas.items():
            interface_def = self._generate_interface(schema_name, schema_def)
            
            # If this is an enum with methods, append the methods to the namespace
            if schema_name in self.enum_schemas and schema_name in self.class_methods:
                # The namespace was already started, now add methods
                lines = interface_def.split("\n")
                # Find where the first closing brace is (end of namespace)
                namespace_end_idx = -1
                for i, line in enumerate(lines):
                    if line.strip() == "}":
                        namespace_end_idx = i
                        break
                
                if namespace_end_idx >= 0:
                    # Insert methods before the closing brace
                    methods_lines = []
                    for method_info in self.class_methods[schema_name]:
                        method_def = self._generate_class_method(method_info, schema_name)
                        methods_lines.extend(method_def.split("\n"))
                    
                    # Rebuild the output
                    output_lines = lines[:namespace_end_idx]  # Everything before closing brace
                    output_lines.extend(methods_lines)  # Add methods
                    output_lines.extend(lines[namespace_end_idx:])  # Add closing brace and rest
                    interface_def = "\n".join(output_lines)
            
            output.append(interface_def)
            output.append("")
        
        # Generate classes for schemas that have methods (but not enums, they're already done)
        for class_name in self.class_methods.keys():
            if class_name not in self.enum_schemas:
                class_def = self._generate_class(class_name)
                output.append(class_def)
                output.append("")
        
        return "\n".join(output)
