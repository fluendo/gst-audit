"""
TypeScript bindings generator for GIRest OpenAPI schemas using Jinja2 templates.

This module converts OpenAPI schemas generated by GIRest into TypeScript
bindings with proper class structure, inheritance, and type definitions.

Refactored to use a type-oriented approach similar to main.py where each
x-gi-type (object, struct, enum, callback, etc.) is handled by dedicated methods.
"""
import os
from typing import Dict, List, Set, Optional, Any
from jinja2 import Environment, FileSystemLoader, Template

try:
    from .utils import parse_operation_id
except ImportError:
    # Fallback for when module is imported directly (e.g., in tests)
    from utils import parse_operation_id


class TypeScriptGenerator:
    """Generates TypeScript bindings from OpenAPI schema using Jinja2 templates."""
    
    # Reserved keywords in TypeScript/JavaScript
    RESERVED_KEYWORDS = {
        "function", "var", "let", "const", "class", "interface", "enum", "type",
        "namespace", "module", "import", "export", "default", "async", "await",
        "break", "case", "catch", "continue", "debugger", "delete", "do", "else",
        "finally", "for", "if", "in", "instanceof", "new", "return", "switch",
        "this", "throw", "try", "typeof", "void", "while", "with", "yield",
        "package", "implements", "private", "public", "protected", "static",
        "eval", "arguments",
        # Common variable names that might conflict
        "data", "response", "error", "result", "value", "url"
    }
    
    def __init__(self, openapi_schema: Dict[str, Any], host: str = "localhost", port: int = 9000, base_path: str = ""):
        """
        Initialize the generator with an OpenAPI schema.
        
        Args:
            openapi_schema: The OpenAPI schema dictionary from GIRest
            host: Host for REST API calls (default: 'localhost')
            port: Port for REST API calls (default: 9000)
            base_path: Base path for REST API calls (default: '')
        """
        self.schema = openapi_schema
        self.components = openapi_schema.get("components", {})
        self.schemas = self.components.get("schemas", {})
        self.paths = openapi_schema.get("paths", {})
        self.host = host
        self.port = port
        self.base_path = base_path
        self.base_url = f"http://{host}:{port}{base_path}"
        
        # Setup Jinja2 environment
        self.template_dir = os.path.join(os.path.dirname(__file__), 'templates')
        self.jinja_env = Environment(
            loader=FileSystemLoader(self.template_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
    
    def _safe_property_name(self, name: str) -> str:
        """Convert a schema property name to a safe TypeScript identifier."""
        if name in self.RESERVED_KEYWORDS:
            return f"{name}_"
        return name
    
    def _is_enum_schema(self, schema_name: str, schema_def: Dict[str, Any]) -> bool:
        """Check if a schema is an enum type."""
        gi_type = schema_def.get("x-gi-type", "")
        return gi_type in ["enum", "flags"] or (gi_type == "" and "enum" in schema_def and schema_def.get("type") == "string")
    
    def _is_callback_schema(self, schema_name: str, schema_def: Dict[str, Any]) -> bool:
        """Check if a schema is a callback type."""
        return schema_def.get("x-gi-type", "") == "callback"
    
    def _is_gobject_type(self, schema_name: str, schema_def: Dict[str, Any]) -> bool:
        """Check if a type is derived from GObject."""
        if schema_def.get("x-gi-type") != "object":
            return False
            
        if schema_name == "GObjectObject":
            return True
        
        if "allOf" in schema_def:
            for item in schema_def["allOf"]:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        parent_schema = self.schemas.get(parent_name, {})
                        if self._is_gobject_type(parent_name, parent_schema):
                            return True
        return False
    
    def _get_operations_for_schema(self, schema_name: str) -> Dict[str, List[Dict[str, Any]]]:
        """Get all operations for a specific schema based on tag matching."""
        operations = {
            "methods": [],
            "constructors": [],
            "fields": {},
            "destructors": []
        }
        
        for path, path_operations in self.paths.items():
            for method, operation in path_operations.items():
                if method.lower() not in ["get", "post", "put", "delete", "patch"]:
                    continue
                
                tags = operation.get("tags", [])
                if not tags or tags[0] != schema_name:
                    continue
                
                method_info = {
                    "path": path,
                    "http_method": method,
                    "operation": operation,
                    "operation_id": operation.get("operationId", "")
                }
                
                is_constructor = operation.get("x-gi-constructor", False)
                is_destructor = operation.get("x-gi-destructor", False)
                is_field = operation.get("x-gi-field", False)
                
                if is_field:
                    # Parse field operations
                    parsed = parse_operation_id(operation.get("operationId", ""))
                    if parsed and len(parsed) == 4:
                        namespace, parsed_class_name, field_name, operator = parsed
                        
                        if field_name not in operations["fields"]:
                            operations["fields"][field_name] = {}
                        
                        if operator in ['get', 'put']:
                            operations["fields"][field_name][operator] = method_info
                elif is_constructor:
                    operations["constructors"].append(method_info)
                elif is_destructor:
                    operations["destructors"].append(method_info)
                else:
                    operations["methods"].append(method_info)
        
        return operations
    
    def _openapi_type_to_ts(self, schema: Dict[str, Any], nullable: bool = False) -> str:
        """Convert an OpenAPI schema type to TypeScript type."""
        if not schema:
            return "any"
        
        if "$ref" in schema:
            ref_path = schema["$ref"]
            if ref_path.startswith("#/components/schemas/"):
                type_name = ref_path.split("/")[-1]
                # Check if this is an enum with methods by looking for operations
                schema_def = self.schemas.get(type_name, {})
                if self._is_enum_schema(type_name, schema_def):
                    operations = self._get_operations_for_schema(type_name)
                    if len(operations["methods"]) > 0:
                        type_name = type_name + "Value"
                return type_name + (" | null" if nullable else "")
        
        if "oneOf" in schema:
            types = [self._openapi_type_to_ts(s) for s in schema["oneOf"]]
            union = " | ".join(types)
            return f"({union})" + (" | null" if nullable else "")
        
        schema_type = schema.get("type")
        
        if schema_type == "string":
            enum_values = schema.get("enum")
            if enum_values:
                literals = " | ".join([f'"{v}"' for v in enum_values])
                return literals + (" | null" if nullable else "")
            return "string" + (" | null" if nullable else "")
        
        elif schema_type == "integer" or schema_type == "number":
            return "number" + (" | null" if nullable else "")
        
        elif schema_type == "boolean":
            return "boolean" + (" | null" if nullable else "")
        
        elif schema_type == "array":
            items = schema.get("items", {})
            item_type = self._openapi_type_to_ts(items)
            return f"{item_type}[]" + (" | null" if nullable else "")
        
        elif schema_type == "object":
            properties = schema.get("properties", {})
            if properties:
                prop_types = []
                required = schema.get("required", [])
                for prop_name, prop_schema in properties.items():
                    is_required = prop_name in required
                    prop_type = self._openapi_type_to_ts(prop_schema)
                    optional_marker = "" if is_required else "?"
                    safe_name = self._safe_property_name(prop_name)
                    prop_types.append(f"{safe_name}{optional_marker}: {prop_type}")
                return "{ " + "; ".join(prop_types) + " }" + (" | null" if nullable else "")
            return "object" + (" | null" if nullable else "")
        
        return "any" + (" | null" if nullable else "")
    
    # Type-specific generation methods
    def _generate_enum(self, schema_name: str, schema_def: Dict[str, Any]) -> str:
        """Generate TypeScript code for enum types."""
        operations = self._get_operations_for_schema(schema_name)
        has_methods = len(operations["methods"]) > 0
        
        template = self._get_template_for_schema(schema_name, schema_def, "enum")
        data = self._prepare_enum_data(schema_name, schema_def)
        
        if has_methods:
            # Enum with methods - generate as enum + namespace
            data["is_enum_with_methods"] = True
            data["is_enum"] = False
            
            # Add methods to enum namespace
            method_template = self.jinja_env.get_template('method.ts.j2')
            methods = []
            for method_info in operations["methods"]:
                method_data = self._prepare_method_data(method_info, schema_name)
                method_data["is_namespace_function"] = True
                methods.append(method_template.render(method_data).rstrip())
            data["methods"] = methods
        else:
            # Simple enum - generate as type alias
            data["is_enum_with_methods"] = False
            data["is_enum"] = True
            data["methods"] = []
        
        return template.render(data).rstrip()
    
    def _generate_struct(self, schema_name: str, schema_def: Dict[str, Any]) -> str:
        """Generate TypeScript code for struct types."""
        template = self._get_template_for_schema(schema_name, schema_def, "struct")
        operations = self._get_operations_for_schema(schema_name)
        data = self._prepare_struct_data(schema_name, schema_def, operations)
        
        generated_code = template.render(data).rstrip()
        
        # Add finalization registry if this struct has destructors
        if len(operations["destructors"]) > 0:
            destructor_info = operations["destructors"][0]  # Take the first destructor
            destructor_method_data = self._prepare_method_data(destructor_info, schema_name)
            method_path = destructor_method_data["path"]
            registry_path = self._convert_method_path_to_registry_path(method_path)
            
            finalization_template = self.jinja_env.get_template('finalization.ts.j2')
            finalization_code = finalization_template.render({
                "class_name": schema_name,
                "registry_name": f"{schema_name.lower()}Registry",
                "registry_path": registry_path
            })
            
            generated_code = finalization_code + "\n" + generated_code
        
        return generated_code
    
    def _generate_object(self, schema_name: str, schema_def: Dict[str, Any]) -> str:
        """Generate TypeScript code for object types."""
        operations = self._get_operations_for_schema(schema_name)
        has_methods = len(operations["methods"]) > 0 or len(operations["constructors"]) > 0
        
        if has_methods:
            # Object with methods - generate as class
            template = self._get_template_for_schema(schema_name, schema_def, "object")
            data = self._prepare_object_data(schema_name, schema_def, operations)
            generated_code = template.render(data).rstrip()
            
            # Add finalization registry if this object has destructors
            if len(operations["destructors"]) > 0:
                destructor_info = operations["destructors"][0]  # Take the first destructor
                destructor_method_data = self._prepare_method_data(destructor_info, schema_name)
                method_path = destructor_method_data["path"]
                registry_path = self._convert_method_path_to_registry_path(method_path)
                
                finalization_template = self.jinja_env.get_template('finalization.ts.j2')
                finalization_code = finalization_template.render({
                    "class_name": schema_name,
                    "registry_name": f"{schema_name.lower()}Registry",
                    "registry_path": registry_path
                })
                
                generated_code = finalization_code + "\n" + generated_code
        else:
            # Object without methods - generate as interface
            template = self._get_template_for_schema(schema_name, schema_def, "interface")
            data = self._prepare_interface_data(schema_name, schema_def)
            generated_code = template.render(data).rstrip()
        
        return generated_code
    
    def _generate_callback(self, schema_name: str, schema_def: Dict[str, Any]) -> str:
        """Generate TypeScript code for callback types."""
        template = self._get_template_for_schema(schema_name, schema_def, "callback")
        data = self._prepare_callback_data(schema_name, schema_def)
        return template.render(data).rstrip()
    
    def _generate_flags(self, schema_name: str, schema_def: Dict[str, Any]) -> str:
        """Generate TypeScript code for flags types."""
        template = self._get_template_for_schema(schema_name, schema_def, "flags")
        data = self._prepare_flags_data(schema_name, schema_def)
        return template.render(data).rstrip()
    
    # Data preparation methods for each type
    def _prepare_enum_data(self, schema_name: str, schema_def: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare data for enum template."""
        enum_values = schema_def.get("enum", [])
        
        data = {
            "name": schema_name,
            "is_enum_with_methods": False,  # Will be set by caller if methods exist
            "is_enum": True
        }
        
        data["enum_values"] = [
            {
                "const_name": value.upper().replace("-", "_").replace(".", "_"),
                "value": value
            }
            for value in enum_values
        ]
        literals = " | ".join([f'"{v}"' for v in enum_values])
        data["enum_value_union"] = literals
        
        return data
    
    def _prepare_struct_data(self, schema_name: str, schema_def: Dict[str, Any], operations: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare data for struct template."""
        parent_class = self._get_direct_parent(schema_name)
        has_destructor = len(operations["destructors"]) > 0
        
        data = {
            "name": schema_name,
            "parent_class": parent_class,
            "has_destructor": has_destructor,
            "destructor_registry": f"{schema_name.lower()}Registry" if has_destructor else "",
            "properties": [],
            "constructors": [],
            "methods": []
        }
        
        # Add constructors
        self._add_constructors_to_data(schema_name, data, operations["constructors"])
        
        # Add methods
        self._add_methods_to_data(schema_name, data, operations["methods"])
        
        # Add field getter/setter methods
        self._add_field_methods_to_data(schema_name, data, operations["fields"])
        
        return data
    
    def _prepare_object_data(self, schema_name: str, schema_def: Dict[str, Any], operations: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare data for object template."""
        parent_class = self._get_direct_parent(schema_name)
        extends_gobject = self._is_gobject_type(schema_name, schema_def)
        
        data = {
            "name": schema_name,
            "extends_gobject": extends_gobject,
            "parent_class": parent_class,
            "has_destructor": False,  # Objects use ref counting, not destructors
            "properties": [],
            "constructors": [],
            "methods": []
        }
        
        # Add constructors
        self._add_constructors_to_data(schema_name, data, operations["constructors"])
        
        # Add methods
        self._add_methods_to_data(schema_name, data, operations["methods"])
        
        # Add field getter/setter methods
        self._add_field_methods_to_data(schema_name, data, operations["fields"])
        
        return data
    
    def _prepare_interface_data(self, schema_name: str, schema_def: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare data for interface template."""
        data = {"name": schema_name}
        
        # Handle allOf (inheritance)
        if "allOf" in schema_def:
            all_of = schema_def["allOf"]
            parent_refs = []
            own_props = {}
            
            for item in all_of:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        parent_refs.append(parent_name)
                elif "type" in item and item["type"] == "object":
                    own_props = item.get("properties", {})
            
            if parent_refs:
                data["has_parent"] = True
                data["parent"] = ", ".join(parent_refs)
                required = schema_def.get("required", [])
                data["properties"] = [
                    {
                        "name": self._safe_property_name(prop_name),
                        "optional": "" if prop_name in required else "?",
                        "type": self._openapi_type_to_ts(prop_schema)
                    }
                    for prop_name, prop_schema in own_props.items()
                ]
            else:
                data["properties"] = []
        else:
            # Regular object
            properties = schema_def.get("properties", {})
            required = schema_def.get("required", [])
            data["properties"] = [
                {
                    "name": self._safe_property_name(prop_name),
                    "optional": "" if prop_name in required else "?",
                    "type": self._openapi_type_to_ts(prop_schema)
                }
                for prop_name, prop_schema in properties.items()
            ]
        
        return data
    
    def _prepare_callback_data(self, schema_name: str, schema_def: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare data for callback template."""
        callback_signature = self._get_callback_type_signature(f"#/components/schemas/{schema_name}")
        return {
            "name": schema_name,
            "callback_signature": callback_signature
        }
    
    def _prepare_flags_data(self, schema_name: str, schema_def: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare data for flags template."""
        # Flags are similar to enums but allow bitwise operations
        return self._prepare_enum_data(schema_name, schema_def)
    
    def _prepare_method_data(self, method_info: Dict[str, Any], class_name: str, is_constructor: bool = False) -> Dict[str, Any]:
        """Prepare data for method template."""
        operation = method_info["operation"]
        path = method_info["path"]
        
        # Extract method name from path
        method_name = self._extract_method_name_from_path(path)
        
        # Build parameter list and other method data
        params = operation.get("parameters", [])
        required_params = []
        optional_params = []
        query_params = []
        path_params = []
        has_self_param = False
        
        # Check if this method has callbacks
        callbacks = operation.get("x-gi-callbacks", {})
        callback_params = []
        
        for param in params:
            param_name = param.get("name", "")
            param_schema = param.get("schema", {})
            param_required = param.get("required", False)
            param_in = param.get("in", "query")
            param_transfer = param.get("x-gi-transfer", "none")
            param_style = param.get("style", "form" if param_in == "query" else "simple")
            param_explode = param.get("explode", True if param_style == "form" else False)
            
            if param_name == "self":
                has_self_param = True
                path_params.append((param_name, param_schema, param_style, param_explode))
                continue
            
            ts_param_name = self._safe_property_name(param_name)
            param_type = self._openapi_type_to_ts(param_schema)
            optional_marker = "" if param_required else "?"
            param_str = f"{ts_param_name}{optional_marker}: {param_type}"
            
            if param_required:
                required_params.append(param_str)
            else:
                optional_params.append(param_str)
            
            # Check if this parameter is a GObject type (needs ref counting)
            is_gobject_param = False
            is_object_param = False
            if "$ref" in param_schema:
                ref_path = param_schema["$ref"]
                if ref_path.startswith("#/components/schemas/"):
                    type_name = ref_path.split("/")[-1]
                    param_schema_def = self.schemas.get(type_name, {})
                    is_gobject_param = self._is_gobject_type(type_name, param_schema_def)
                    if param_schema_def.get("type") == "object" or "allOf" in param_schema_def:
                        is_object_param = True
            
            if param_in == "path":
                path_params.append((param_name, param_schema, param_style, param_explode))
            elif param_in == "query":
                query_params.append({
                    "name": ts_param_name,
                    "api_name": param_name,
                    "required": param_required,
                    "transfer": param_transfer,
                    "is_gobject": is_gobject_param,
                    "is_object": is_object_param,
                    "style": param_style,
                    "explode": param_explode
                })
        
        # Add callback parameters to method signature
        for callback_name, callback_ref in callbacks.items():
            callback_type_name = self._get_callback_type_name(callback_ref)
            safe_callback_name = self._safe_property_name(callback_name)
            required_params.append(f"{safe_callback_name}: {callback_type_name}")
            callback_params.append({
                "name": safe_callback_name,
                "api_name": callback_name,
                "type_ref": callback_ref
            })
        
        # Combine required and optional parameters (required first)
        method_params = required_params + optional_params
        
        # Determine return type
        return_type = "void"
        response_has_return = False
        return_is_object = False
        return_class_name = None
        return_transfer = "none"
        return_is_gobject = False
        responses = operation.get("responses", {})
        
        if "200" in responses:
            content = responses["200"].get("content", {})
            app_json = content.get("application/json", {})
            schema = app_json.get("schema", {})
            
            if schema:
                props = schema.get("properties", {})
                if "return" in props:
                    return_props = props["return"]
                    return_transfer = return_props.get("x-gi-transfer", "none")
                    
                    if is_constructor:
                        return_type = class_name
                        return_is_object = True
                        return_class_name = class_name
                        return_is_gobject = self._is_gobject_type(class_name, self.schemas.get(class_name, {}))
                    else:
                        return_type = self._openapi_type_to_ts(return_props)
                        if "$ref" in return_props:
                            ref_path = return_props["$ref"]
                            if ref_path.startswith("#/components/schemas/"):
                                type_name = ref_path.split("/")[-1]
                                schema_def = self.schemas.get(type_name, {})
                                return_is_gobject = self._is_gobject_type(type_name, schema_def)
                                if (schema_def.get("type") == "object" or "allOf" in schema_def):
                                    # Check if it has operations (methods/fields) or exists in schemas
                                    type_operations = self._get_operations_for_schema(type_name)
                                    if (len(type_operations["methods"]) > 0 or len(type_operations["fields"]) > 0 or 
                                        type_name in self.schemas):
                                        return_is_object = True
                                        return_class_name = type_name
                    response_has_return = True
                elif props:
                    return_type = self._openapi_type_to_ts(schema)
                else:
                    return_type = "void"
        
        # Build URL path - serialize parameters based on style/explode
        url_path = path
        for param_tuple in path_params:
            param_name = param_tuple[0]
            param_schema = param_tuple[1]
            param_style = param_tuple[2] if len(param_tuple) > 2 else "simple"
            param_explode = param_tuple[3] if len(param_tuple) > 3 else False
            
            # Check if this is an object type
            is_object = False
            if "$ref" in param_schema:
                ref_path = param_schema["$ref"]
                if ref_path.startswith("#/components/schemas/"):
                    type_name = ref_path.split("/")[-1]
                    schema_def = self.schemas.get(type_name, {})
                    if schema_def.get("type") == "object" or "allOf" in schema_def:
                        is_object = True
            
            if param_name == "self":
                if is_object:
                    if param_explode:
                        url_path = url_path.replace("{self}", "ptr=${this.ptr}")
                    else:
                        url_path = url_path.replace("{self}", "ptr,${this.ptr}")
                else:
                    url_path = url_path.replace("{self}", "${this.ptr}")
            else:
                if is_object:
                    if param_explode:
                        url_path = url_path.replace(f"{{{param_name}}}", f"ptr=${{{param_name}.ptr}}")
                    else:
                        url_path = url_path.replace(f"{{{param_name}}}", f"ptr,${{{param_name}.ptr}}")
                else:
                    url_path = url_path.replace(f"{{{param_name}}}", f"${{{param_name}}}")
        
        is_enum = self._is_enum_schema(class_name, self.schemas.get(class_name, {}))
        
        return {
            "name": method_name,
            "params": ", ".join(method_params),
            "return_type": return_type,
            "is_static": is_constructor or is_enum or not has_self_param,
            "with_impl": True,
            "base_url": self.base_url,
            "host": self.host,
            "port": self.port,
            "base_path": self.base_path,
            "path": url_path,
            "query_params": query_params,
            "callback_params": callback_params,
            "is_constructor": is_constructor,
            "has_return": response_has_return,
            "return_is_object": return_is_object,
            "return_class_name": return_class_name,
            "return_transfer": return_transfer,
            "return_is_gobject": return_is_gobject,
            "class_name": class_name
        }
    
    # Helper methods
    def _add_constructors_to_data(self, schema_name: str, data: Dict[str, Any], constructors: List[Dict[str, Any]]):
        """Add constructor methods to class data."""
        if constructors:
            parent_constructor_signatures = self._get_parent_constructor_signatures(schema_name)
            current_constructor_names = set()
            
            for constructor_info in constructors:
                constructor_data = self._prepare_method_data(constructor_info, schema_name, is_constructor=True)
                original_name = constructor_data.get("name")
                current_signature = self._get_method_signature(constructor_data)
                
                if original_name in parent_constructor_signatures:
                    parent_signature = parent_constructor_signatures[original_name]
                    if current_signature != parent_signature:
                        parent_constructor_names = set(parent_constructor_signatures.keys())
                        unique_name = self._find_unique_method_name(original_name, parent_constructor_names | current_constructor_names)
                        constructor_data["name"] = unique_name
                
                current_constructor_names.add(constructor_data["name"])
                method_template = self._get_method_template(schema_name, original_name)
                data["constructors"].append(method_template.render(constructor_data).rstrip())
    
    def _add_methods_to_data(self, schema_name: str, data: Dict[str, Any], methods: List[Dict[str, Any]]):
        """Add regular methods to class data."""
        if methods:
            parent_method_signatures = self._get_parent_method_signatures(schema_name)
            current_method_names = set()
            
            for method_info in methods:
                method_data = self._prepare_method_data(method_info, schema_name)
                original_name = method_data.get("name")
                current_signature = self._get_method_signature(method_data)
                
                # Skip 'unref' method for GObjectObject as it's provided by the base class
                if schema_name == "GObjectObject" and original_name == "unref":
                    continue
                
                if original_name in parent_method_signatures:
                    parent_signature = parent_method_signatures[original_name]
                    if current_signature != parent_signature:
                        parent_method_names = set(parent_method_signatures.keys())
                        unique_name = self._find_unique_method_name(original_name, parent_method_names | current_method_names)
                        method_data["name"] = unique_name
                
                current_method_names.add(method_data["name"])
                method_template = self._get_method_template(schema_name, original_name)
                data["methods"].append(method_template.render(method_data).rstrip())
    
    def _add_field_methods_to_data(self, schema_name: str, data: Dict[str, Any], fields: Dict[str, Dict[str, Any]]):
        """Add field getter/setter methods to class data."""
        if fields:
            for field_name, field_operations in fields.items():
                field_methods = self._prepare_field_methods(schema_name, field_name, field_operations)
                data["methods"].extend(field_methods)
    
    def _prepare_field_methods(self, class_name: str, field_name: str, field_operations: Dict[str, Dict]) -> List[str]:
        """Prepare getter and setter methods for a field."""
        methods = []
        
        # Prepare getter method (if GET operation exists)
        if 'get' in field_operations:
            get_info = field_operations['get']
            operation = get_info['operation']
            return_type = "any"
            return_is_object = False
            return_class_name = None
            return_transfer = "none"
            return_is_gobject = False
            
            responses = operation.get("responses", {})
            if "200" in responses:
                content = responses["200"].get("content", {})
                app_json = content.get("application/json", {})
                schema = app_json.get("schema", {})
                if schema:
                    props = schema.get("properties", {})
                    if "return" in props:
                        return_props = props["return"]
                        return_type = self._openapi_type_to_ts(return_props)
                        return_transfer = return_props.get("x-gi-transfer", "none")
                        
                        if "$ref" in return_props:
                            ref_path = return_props["$ref"]
                            if ref_path.startswith("#/components/schemas/"):
                                type_name = ref_path.split("/")[-1]
                                schema_def = self.schemas.get(type_name, {})
                                return_is_gobject = self._is_gobject_type(type_name, schema_def)
                                if (schema_def.get("type") == "object" or "allOf" in schema_def):
                                    # Check if it has operations or exists in schemas
                                    type_operations = self._get_operations_for_schema(type_name)
                                    if (len(type_operations["methods"]) > 0 or len(type_operations["fields"]) > 0 or 
                                        type_name in self.schemas):
                                        return_is_object = True
                                        return_class_name = type_name
            
            get_method_data = {
                "name": f"get_{field_name}",
                "params": "",
                "return_type": return_type,
                "is_static": False,
                "with_impl": True,
                "base_url": self.base_url,
                "host": self.host,
                "port": self.port,
                "base_path": self.base_path,
                "path": get_info['path'].replace('{self}', 'ptr,${this.ptr}'),
                "query_params": [],
                "callback_params": [],
                "is_constructor": False,
                "has_return": True,
                "return_is_object": return_is_object,
                "return_class_name": return_class_name,
                "return_transfer": return_transfer,
                "return_is_gobject": return_is_gobject,
                "class_name": class_name
            }
            
            method_template = self._get_method_template(class_name, f"get_{field_name}")
            methods.append(method_template.render(get_method_data).rstrip())
        
        # Prepare setter method (if PUT operation exists)
        if 'put' in field_operations:
            put_info = field_operations['put']
            operation = put_info['operation']
            value_type = "any"
            params = operation.get("parameters", [])
            for param in params:
                if param.get("name") == "value":
                    param_schema = param.get("schema", {})
                    value_type = self._openapi_type_to_ts(param_schema)
                    break
            
            put_method_data = {
                "name": f"set_{field_name}",
                "params": f"value_: {value_type}",
                "return_type": "void",
                "is_static": False,
                "with_impl": True,
                "base_url": self.base_url,
                "host": self.host,
                "port": self.port,
                "base_path": self.base_path,
                "path": put_info['path'].replace('{self}', 'ptr,${this.ptr}'),
                "query_params": [{"name": "value_", "original_name": "value", "type": value_type, "required": True, "description": f"Value to set for {field_name}"}],
                "callback_params": [],
                "is_constructor": False,
                "has_return": False,
                "return_is_object": False,
                "return_class_name": None,
                "return_transfer": "none",
                "return_is_gobject": False,
                "class_name": class_name
            }
            
            method_template = self._get_method_template(class_name, f"set_{field_name}")
            methods.append(method_template.render(put_method_data).rstrip())
        
        return methods
    
    def _get_direct_parent(self, class_name: str) -> Optional[str]:
        """Get the direct parent class from the schema's allOf."""
        schema = self.schemas.get(class_name, {})
        if "allOf" in schema:
            for item in schema["allOf"]:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        return ref_path.split("/")[-1]
        return None
    
    def _extract_method_name_from_path(self, path: str) -> str:
        """Extract method name from a path."""
        return path.split("/")[-1].replace("{", "").replace("}", "")
    
    def _get_parent_method_signatures(self, class_name: str) -> Dict[str, str]:
        """Get all method signatures from the entire parent chain."""
        method_signatures = {}
        parent = self._get_direct_parent(class_name)
        
        while parent:
            parent_operations = self._get_operations_for_schema(parent)
            for method_info in parent_operations["methods"]:
                method_data = self._prepare_method_data(method_info, parent)
                method_name = method_data.get("name")
                signature = self._get_method_signature(method_data)
                
                if method_name not in method_signatures:
                    method_signatures[method_name] = signature
            
            parent = self._get_direct_parent(parent)
        
        return method_signatures
    
    def _get_parent_constructor_signatures(self, class_name: str) -> Dict[str, str]:
        """Get all constructor signatures from the entire parent chain."""
        constructor_signatures = {}
        parent = self._get_direct_parent(class_name)
        
        while parent:
            parent_operations = self._get_operations_for_schema(parent)
            for constructor_info in parent_operations["constructors"]:
                constructor_data = self._prepare_method_data(constructor_info, parent, is_constructor=True)
                constructor_name = constructor_data.get("name")
                signature = self._get_method_signature(constructor_data)
                
                if constructor_name not in constructor_signatures:
                    constructor_signatures[constructor_name] = signature
            
            parent = self._get_direct_parent(parent)
        
        return constructor_signatures
    
    def _get_method_signature(self, method_data: Dict[str, Any]) -> str:
        """Generate a method signature for comparison purposes."""
        name = method_data.get("name", "")
        params = method_data.get("params", "")
        return_type = method_data.get("return_type", "void")
        is_static = method_data.get("is_static", False)
        
        static_prefix = "static " if is_static else ""
        return f"{static_prefix}{name}({params}): {return_type}"
    
    def _find_unique_method_name(self, base_name: str, existing_names: Set[str]) -> str:
        """Find a unique method name by appending a suffix number if needed."""
        if base_name not in existing_names:
            return base_name
        
        suffix = 2
        while True:
            candidate = f"{base_name}_{suffix}"
            if candidate not in existing_names:
                return candidate
            suffix += 1
    
    def _get_callback_type_name(self, callback_ref: str) -> str:
        """Get the TypeScript type name for a callback reference."""
        if not callback_ref.startswith("#/components/schemas/"):
            return "Function"
        
        callback_name = callback_ref.split("/")[-1]
        callback_schema = self.schemas.get(callback_name, {})
        
        if not callback_schema or not self._is_callback_schema(callback_name, callback_schema):
            return "Function"
        
        return callback_name
    
    def _get_callback_type_signature(self, callback_ref: str) -> str:
        """Generate TypeScript function signature for a callback."""
        if not callback_ref.startswith("#/components/schemas/"):
            return "Function"
        
        callback_name = callback_ref.split("/")[-1]
        callback_schema = self.schemas.get(callback_name, {})
        
        if not callback_schema or not self._is_callback_schema(callback_name, callback_schema):
            return "Function"
        
        properties = callback_schema.get("properties", {})
        param_list = []
        return_type = "void"
        
        for prop_name, prop_schema in properties.items():
            is_return = prop_schema.get("x-gi-is-return", False)
            
            if is_return:
                clean_schema = {k: v for k, v in prop_schema.items() if k != "x-gi-is-return"}
                return_type = self._openapi_type_to_ts(clean_schema)
            else:
                ts_param_name = self._safe_property_name(prop_name)
                clean_schema = {k: v for k, v in prop_schema.items() if k not in ["x-gi-transfer", "x-gi-is-return"]}
                param_type = self._openapi_type_to_ts(clean_schema)
                param_list.append(f"{ts_param_name}: {param_type}")
        
        params_str = ", ".join(param_list)
        return f"({params_str}) => {return_type}"
    
    def _convert_method_path_to_registry_path(self, method_path: str) -> str:
        """Convert a method path to a registry path for FinalizationRegistry."""
        registry_path = method_path.replace("${this.ptr}", "' + ptr + '")
        import re
        registry_path = re.sub(r'\$\{[^}]*\.ptr\}', "' + ptr + '", registry_path)
        return registry_path
    
    def _get_method_template(self, class_name: str, method_name: str) -> Template:
        """Get the appropriate template for a method."""
        method_template_name = f"{class_name}{method_name}.ts.j2"
        if os.path.exists(os.path.join(self.template_dir, method_template_name)):
            return self.jinja_env.get_template(method_template_name)
        
        return self.jinja_env.get_template('method.ts.j2')

    def _get_template_for_schema(self, schema_name: str, schema_def: Dict[str, Any], fallback_type: str = "") -> Template:
        """Get the appropriate template for a schema."""
        # First try to find a specific template by name
        specific_template_name = f"{schema_name}.ts.j2"
        if os.path.exists(os.path.join(self.template_dir, specific_template_name)):
            return self.jinja_env.get_template(specific_template_name)
        
        # Fall back to type-based templates
        gi_type = schema_def.get("x-gi-type", fallback_type)
        
        type_template_map = {
            "enum": "enum.ts.j2",
            "flags": "flags.ts.j2", 
            "struct": "struct.ts.j2",
            "object": "object.ts.j2",
            "callback": "callback.ts.j2",
            "interface": "interface.ts.j2"
        }
        
        template_name = type_template_map.get(gi_type)
        if template_name:
            return self.jinja_env.get_template(template_name)
        
        # Default fallback
        if "enum" in schema_def and schema_def.get("type") == "string":
            return self.jinja_env.get_template("enum.ts.j2")
        
        return self.jinja_env.get_template("object.ts.j2")
    
    def _generate_schemas(self) -> Dict[str, str]:
        """Generate TypeScript code for all schemas based on their types."""
        generated_schemas = {}
        
        # Collect all schema names that need to be generated
        schemas_to_generate = set()
        
        for schema_name, schema_def in self.schemas.items():
            gi_type = schema_def.get("x-gi-type", "")
            
            # Always generate enums, flags, and callbacks
            if gi_type in ["enum", "flags", "callback"] or self._is_enum_schema(schema_name, schema_def):
                schemas_to_generate.add(schema_name)
            
            # Generate structs as classes (whether they have methods or not)
            elif gi_type == "struct":
                schemas_to_generate.add(schema_name)
                # Add parent classes in inheritance chain
                parent = self._get_direct_parent(schema_name)
                while parent:
                    if parent in self.schemas:
                        schemas_to_generate.add(parent)
                    parent = self._get_direct_parent(parent)
            
            # Generate objects - check if they have operations
            elif gi_type == "object":
                operations = self._get_operations_for_schema(schema_name)
                if len(operations["methods"]) > 0 or len(operations["constructors"]) > 0:
                    # Object with methods - generate as class
                    schemas_to_generate.add(schema_name)
                    # Add parent classes in inheritance chain
                    parent = self._get_direct_parent(schema_name)
                    while parent:
                        if parent in self.schemas:
                            schemas_to_generate.add(parent)
                        parent = self._get_direct_parent(parent)
                else:
                    # Object without methods - generate as interface
                    schemas_to_generate.add(schema_name)
        
        # Generate schemas in dependency order (parents before children)
        generated = set()
        
        def generate_schema_with_parents(schema_name: str):
            """Recursively generate a schema and its parents."""
            if schema_name in generated:
                return
            
            # First generate the parent
            parent = self._get_direct_parent(schema_name)
            if parent and parent in schemas_to_generate:
                generate_schema_with_parents(parent)
            
            # Then generate this schema
            schema_def = self.schemas.get(schema_name, {})
            gi_type = schema_def.get("x-gi-type", "")
            
            # Route to appropriate generation method based on type
            if gi_type == "enum" or self._is_enum_schema(schema_name, schema_def):
                generated_code = self._generate_enum(schema_name, schema_def)
            elif gi_type == "flags":
                generated_code = self._generate_flags(schema_name, schema_def)
            elif gi_type == "callback":
                generated_code = self._generate_callback(schema_name, schema_def)
            elif gi_type == "struct":
                generated_code = self._generate_struct(schema_name, schema_def)
            elif gi_type == "object":
                generated_code = self._generate_object(schema_name, schema_def)
            else:
                # Fallback to interface generation
                template = self._get_template_for_schema(schema_name, schema_def, "interface")
                data = self._prepare_interface_data(schema_name, schema_def)
                generated_code = template.render(data).rstrip()
            
            generated_schemas[schema_name] = generated_code
            generated.add(schema_name)
        
        # Generate all schemas
        for schema_name in sorted(schemas_to_generate):
            generate_schema_with_parents(schema_name)
        
        return generated_schemas
    
    def generate(self) -> str:
        """Generate complete TypeScript bindings."""
        title = self.schema.get("info", {}).get("title", "API")
        version = self.schema.get("info", {}).get("version", "1.0")
        
        # Generate all schemas using the new type-oriented approach
        generated_schemas = self._generate_schemas()
        
        # Split generated schemas into interfaces and classes
        interfaces = []
        classes = []
        
        for schema_name, code in generated_schemas.items():
            if code.strip().startswith("export class"):
                classes.append(code)
            else:
                interfaces.append(code)
        
        # Generate standalone functions namespace by finding operations without matching schema tags
        standalone_functions = []
        for path, path_operations in self.paths.items():
            for method, operation in path_operations.items():
                if method.lower() not in ["get", "post", "put", "delete", "patch"]:
                    continue
                
                tags = operation.get("tags", [])
                if not tags:
                    # No tags - this is a standalone function
                    method_info = {
                        "path": path,
                        "http_method": method,
                        "operation": operation,
                        "operation_id": operation.get("operationId", "")
                    }
                    standalone_functions.append(method_info)
        
        standalone_namespace = ""
        if standalone_functions:
            first_func = standalone_functions[0]
            op_id = first_func.get("operation_id", "")
            namespace_name = op_id.split("-")[0] if op_id else "Functions"
            
            method_template = self.jinja_env.get_template('method.ts.j2')
            methods = []
            for func_info in standalone_functions:
                method_data = self._prepare_method_data(func_info, namespace_name)
                method_data["is_namespace_function"] = True
                methods.append(method_template.render(method_data).rstrip())
            
            standalone_namespace = f"export namespace {namespace_name} {{\n"
            standalone_namespace += "\n".join(methods)
            standalone_namespace += "\n}"
        
        # Generate main file
        main_template = self.jinja_env.get_template('main.ts.j2')
        return main_template.render(
            title=title,
            version=version,
            base_url=self.base_url,
            host=self.host,
            port=self.port,
            base_path=self.base_path,
            interfaces=interfaces,
            classes=classes,
            standalone_namespace=standalone_namespace
        )