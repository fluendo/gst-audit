"""
TypeScript bindings generator for GIRest OpenAPI schemas using Jinja2 templates.

This module converts OpenAPI schemas generated by GIRest into TypeScript
bindings with proper class structure, inheritance, and type definitions.
"""
import os
from typing import Dict, List, Set, Optional, Any
from jinja2 import Environment, FileSystemLoader, Template


class TypeScriptGenerator:
    """Generates TypeScript bindings from OpenAPI schema using Jinja2 templates."""
    
    def __init__(self, openapi_schema: Dict[str, Any], base_url: Optional[str] = None):
        """
        Initialize the generator with an OpenAPI schema.
        
        Args:
            openapi_schema: The OpenAPI schema dictionary from GIRest
            base_url: Optional base URL for REST API calls (e.g., 'http://localhost:8000')
        """
        self.schema = openapi_schema
        self.components = openapi_schema.get("components", {})
        self.schemas = self.components.get("schemas", {})
        self.paths = openapi_schema.get("paths", {})
        self.base_url = base_url
        self.enum_schemas: Set[str] = set()
        self.class_methods: Dict[str, List[Dict]] = {}
        self.class_constructors: Dict[str, List[Dict]] = {}
        self.gobject_types: Set[str] = set()  # Track GObject-derived types
        
        # Setup Jinja2 environment
        template_dir = os.path.join(os.path.dirname(__file__), 'templates')
        self.jinja_env = Environment(
            loader=FileSystemLoader(template_dir),
            trim_blocks=False,
            lstrip_blocks=False
        )
        
        # Identify enum schemas and GObject types
        self._identify_special_schemas()
        
        # Parse operations and organize by tag (class)
        self._parse_operations()
    
    def _identify_special_schemas(self):
        """Identify which schemas are enums and which are GObject-based."""
        for schema_name, schema_def in self.schemas.items():
            # Identify enums
            if "enum" in schema_def and schema_def.get("type") == "string":
                self.enum_schemas.add(schema_name)
            
            # Identify GObject-based types by checking inheritance chain
            if self._is_gobject_type(schema_name, schema_def):
                self.gobject_types.add(schema_name)
    
    def _is_gobject_type(self, schema_name: str, schema_def: Dict[str, Any]) -> bool:
        """Check if a type is derived from GObject."""
        if schema_name.startswith("GObject"):
            return True
        
        if "allOf" in schema_def:
            for item in schema_def["allOf"]:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        if parent_name.startswith("GObject"):
                            return True
                        parent_schema = self.schemas.get(parent_name, {})
                        if self._is_gobject_type(parent_name, parent_schema):
                            return True
        return False
    
    def _parse_operations(self):
        """Parse all operations and organize them by tag (class name)."""
        for path, operations in self.paths.items():
            for method, operation in operations.items():
                if method.lower() not in ["get", "post", "put", "delete", "patch"]:
                    continue
                
                tags = operation.get("tags", [])
                if tags:
                    class_name = tags[0]
                    method_info = {
                        "path": path,
                        "http_method": method,
                        "operation": operation,
                        "operation_id": operation.get("operationId", "")
                    }
                    
                    is_constructor = operation.get("x-gi-constructor", False)
                    
                    if is_constructor:
                        if class_name not in self.class_constructors:
                            self.class_constructors[class_name] = []
                        self.class_constructors[class_name].append(method_info)
                    else:
                        if class_name not in self.class_methods:
                            self.class_methods[class_name] = []
                        self.class_methods[class_name].append(method_info)
    
    def _openapi_type_to_ts(self, schema: Dict[str, Any], nullable: bool = False) -> str:
        """Convert an OpenAPI schema type to TypeScript type."""
        if not schema:
            return "any"
        
        if "$ref" in schema:
            ref_path = schema["$ref"]
            if ref_path.startswith("#/components/schemas/"):
                type_name = ref_path.split("/")[-1]
                return type_name + (" | null" if nullable else "")
        
        if "oneOf" in schema:
            types = [self._openapi_type_to_ts(s) for s in schema["oneOf"]]
            union = " | ".join(types)
            return f"({union})" + (" | null" if nullable else "")
        
        schema_type = schema.get("type")
        
        if schema_type == "string":
            enum_values = schema.get("enum")
            if enum_values:
                literals = " | ".join([f'"{v}"' for v in enum_values])
                return literals + (" | null" if nullable else "")
            return "string" + (" | null" if nullable else "")
        
        elif schema_type == "integer" or schema_type == "number":
            return "number" + (" | null" if nullable else "")
        
        elif schema_type == "boolean":
            return "boolean" + (" | null" if nullable else "")
        
        elif schema_type == "array":
            items = schema.get("items", {})
            item_type = self._openapi_type_to_ts(items)
            return f"{item_type}[]" + (" | null" if nullable else "")
        
        elif schema_type == "object":
            properties = schema.get("properties", {})
            if properties:
                prop_types = []
                required = schema.get("required", [])
                for prop_name, prop_schema in properties.items():
                    is_required = prop_name in required
                    prop_type = self._openapi_type_to_ts(prop_schema)
                    optional_marker = "" if is_required else "?"
                    prop_types.append(f"{prop_name}{optional_marker}: {prop_type}")
                return "{ " + "; ".join(prop_types) + " }" + (" | null" if nullable else "")
            return "object" + (" | null" if nullable else "")
        
        return "any" + (" | null" if nullable else "")
    
    def _prepare_interface_data(self, name: str, schema: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare data for interface template."""
        data = {"name": name}
        
        # Handle enums
        if "enum" in schema and schema.get("type") == "string":
            enum_values = schema["enum"]
            has_methods = name in self.class_methods
            
            if has_methods:
                data["is_enum_with_methods"] = True
                data["enum_values"] = [
                    {
                        "const_name": value.upper().replace("-", "_").replace(".", "_"),
                        "value": value
                    }
                    for value in enum_values
                ]
                literals = " | ".join([f'"{v}"' for v in enum_values])
                data["enum_value_union"] = literals
            else:
                data["is_enum"] = True
                literals = " | ".join([f'"{v}"' for v in enum_values])
                data["enum_value_union"] = literals
            
            return data
        
        # Handle allOf (inheritance)
        if "allOf" in schema:
            all_of = schema["allOf"]
            parent_refs = []
            own_props = {}
            
            for item in all_of:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        parent_refs.append(parent_name)
                elif "type" in item and item["type"] == "object":
                    own_props = item.get("properties", {})
            
            if parent_refs:
                data["has_parent"] = True
                data["parent"] = ", ".join(parent_refs)
                required = schema.get("required", [])
                data["properties"] = [
                    {
                        "name": prop_name,
                        "optional": "" if prop_name in required else "?",
                        "type": self._openapi_type_to_ts(prop_schema)
                    }
                    for prop_name, prop_schema in own_props.items()
                ]
            else:
                data["properties"] = []
        else:
            # Regular object
            properties = schema.get("properties", {})
            required = schema.get("required", [])
            data["properties"] = [
                {
                    "name": prop_name,
                    "optional": "" if prop_name in required else "?",
                    "type": self._openapi_type_to_ts(prop_schema)
                }
                for prop_name, prop_schema in properties.items()
            ]
        
        return data
    
    def _prepare_method_data(self, method_info: Dict[str, Any], class_name: str, is_constructor: bool = False) -> Dict[str, Any]:
        """Prepare data for method template."""
        operation = method_info["operation"]
        path = method_info["path"]
        
        # Extract method name from path
        method_name = path.split("/")[-1].replace("{", "").replace("}", "")
        
        # Build parameter list
        params = operation.get("parameters", [])
        method_params = []
        query_params = []
        path_params = []
        has_self_param = False
        
        for param in params:
            param_name = param.get("name", "")
            param_schema = param.get("schema", {})
            param_required = param.get("required", False)
            param_in = param.get("in", "query")
            param_transfer = param.get("x-gi-transfer", "none")
            
            if param_name == "self":
                has_self_param = True
                path_params.append((param_name, param_schema))
                continue
            
            param_type = self._openapi_type_to_ts(param_schema)
            optional_marker = "" if param_required else "?"
            method_params.append(f"{param_name}{optional_marker}: {param_type}")
            
            # Check if this parameter is a GObject type (needs ref counting)
            is_gobject_param = False
            if "$ref" in param_schema:
                ref_path = param_schema["$ref"]
                if ref_path.startswith("#/components/schemas/"):
                    type_name = ref_path.split("/")[-1]
                    is_gobject_param = type_name in self.gobject_types
            
            if param_in == "path":
                path_params.append((param_name, param_schema))
            elif param_in == "query":
                query_params.append({
                    "name": param_name,
                    "required": param_required,
                    "transfer": param_transfer,
                    "is_gobject": is_gobject_param
                })
        
        # Determine return type
        return_type = "void"
        response_has_return = False
        responses = operation.get("responses", {})
        
        if "200" in responses:
            content = responses["200"].get("content", {})
            app_json = content.get("application/json", {})
            schema = app_json.get("schema", {})
            
            if schema:
                props = schema.get("properties", {})
                if "return" in props:
                    if is_constructor:
                        return_type = class_name
                    else:
                        return_type = self._openapi_type_to_ts(props["return"])
                    response_has_return = True
                elif props:
                    return_type = self._openapi_type_to_ts(schema)
                else:
                    return_type = "void"
        
        # Build URL path
        url_path = path
        for param_name, param_schema in path_params:
            if param_name == "self":
                url_path = url_path.replace("{self}", "${this.ptr}")
            else:
                url_path = url_path.replace(f"{{{param_name}}}", f"${{{param_name}}}")
        
        is_enum = class_name in self.enum_schemas
        
        return {
            "name": method_name,
            "params": ", ".join(method_params),
            "return_type": return_type,
            "is_static": is_constructor or is_enum,
            "with_impl": self.base_url is not None,
            "base_url": self.base_url or "",
            "path": url_path,
            "query_params": query_params,
            "is_constructor": is_constructor,
            "has_return": response_has_return,
            "class_name": class_name
        }
    
    def _prepare_class_data(self, class_name: str) -> Dict[str, Any]:
        """Prepare data for class template."""
        is_enum = class_name in self.enum_schemas
        schema = self.schemas.get(class_name, {})
        extends_gobject = class_name in self.gobject_types
        has_interface = class_name in self.schemas and not is_enum
        
        data = {
            "name": class_name,
            "is_enum": is_enum,
            "base_url": self.base_url,
            "extends_gobject": extends_gobject,
            "has_interface": has_interface,
            "properties": [],
            "constructors": [],
            "methods": []
        }
        
        if is_enum:
            # Enum namespace with methods
            if class_name in self.class_methods:
                method_template = self.jinja_env.get_template('method.ts.j2')
                for method_info in self.class_methods[class_name]:
                    method_data = self._prepare_method_data(method_info, class_name)
                    data["methods"].append(method_template.render(method_data))
        else:
            # Regular class
            if schema and (not self.base_url or not extends_gobject):
                # Add properties if not using GObjectBase
                properties = schema.get("properties", {})
                required = schema.get("required", [])
                
                if "allOf" in schema:
                    all_of = schema["allOf"]
                    for item in all_of:
                        if "type" in item and item["type"] == "object":
                            properties = item.get("properties", {})
                            break
                
                data["properties"] = [
                    {
                        "name": prop_name,
                        "assertion": "!" if prop_name in required else "?",
                        "type": self._openapi_type_to_ts(prop_schema)
                    }
                    for prop_name, prop_schema in properties.items()
                ]
            
            # Add constructors
            if class_name in self.class_constructors:
                method_template = self.jinja_env.get_template('method.ts.j2')
                for constructor_info in self.class_constructors[class_name]:
                    constructor_data = self._prepare_method_data(constructor_info, class_name, is_constructor=True)
                    data["constructors"].append(method_template.render(constructor_data).rstrip())
            
            # Add methods
            if class_name in self.class_methods:
                method_template = self.jinja_env.get_template('method.ts.j2')
                for method_info in self.class_methods[class_name]:
                    method_data = self._prepare_method_data(method_info, class_name)
                    data["methods"].append(method_template.render(method_data).rstrip())
        
        return data
    
    def generate(self) -> str:
        """
        Generate complete TypeScript bindings.
        
        Returns:
            TypeScript code as a string
        """
        title = self.schema.get("info", {}).get("title", "API")
        version = self.schema.get("info", {}).get("version", "1.0")
        
        # Generate interfaces
        interface_template = self.jinja_env.get_template('interface.ts.j2')
        interfaces = []
        
        for schema_name, schema_def in self.schemas.items():
            # Check if this schema has a corresponding class
            has_class = schema_name in self.class_methods
            gi_type = schema_def.get("x-gi-type", "")
            
            # Skip interface generation for objects that have classes
            # We only need interfaces for:
            # 1. Enums (always generate type aliases)
            # 2. Structs without methods (pure data structures)
            # 3. Special types like Pointer
            if gi_type == "object" and has_class:
                # Skip - class will be generated instead
                continue
            
            interface_data = self._prepare_interface_data(schema_name, schema_def)
            interface_code = interface_template.render(interface_data)
            
            # If this is an enum with methods, append the methods
            if schema_name in self.enum_schemas and schema_name in self.class_methods:
                method_template = self.jinja_env.get_template('method.ts.j2')
                methods = []
                for method_info in self.class_methods[schema_name]:
                    method_data = self._prepare_method_data(method_info, schema_name)
                    methods.append(method_template.render(method_data))
                
                # Insert methods into the namespace
                lines = interface_code.split("\n")
                namespace_end_idx = -1
                for i, line in enumerate(lines):
                    if line.strip() == "}":
                        namespace_end_idx = i
                        break
                
                if namespace_end_idx >= 0:
                    output_lines = lines[:namespace_end_idx]
                    output_lines.extend(methods)
                    output_lines.extend(lines[namespace_end_idx:])
                    interface_code = "\n".join(output_lines)
            
            interfaces.append(interface_code)
        
        # Generate classes
        class_template = self.jinja_env.get_template('class.ts.j2')
        classes = []
        
        for class_name in self.class_methods.keys():
            if class_name not in self.enum_schemas:
                class_data = self._prepare_class_data(class_name)
                classes.append(class_template.render(class_data))
        
        # Generate main file
        main_template = self.jinja_env.get_template('main.ts.j2')
        return main_template.render(
            title=title,
            version=version,
            base_url=self.base_url,
            interfaces=interfaces,
            classes=classes
        )
