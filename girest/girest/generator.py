"""
TypeScript bindings generator for GIRest OpenAPI schemas using Jinja2 templates.

This module converts OpenAPI schemas generated by GIRest into TypeScript
bindings with proper class structure, inheritance, and type definitions.
"""
import os
from typing import Dict, List, Set, Optional, Any
from jinja2 import Environment, FileSystemLoader, Template

try:
    from .utils import parse_operation_id
except ImportError:
    # Fallback for when module is imported directly (e.g., in tests)
    from utils import parse_operation_id


class TypeScriptGenerator:
    """Generates TypeScript bindings from OpenAPI schema using Jinja2 templates."""
    
    # Reserved keywords in TypeScript/JavaScript
    RESERVED_KEYWORDS = {
        "function", "var", "let", "const", "class", "interface", "enum", "type",
        "namespace", "module", "import", "export", "default", "async", "await",
        "break", "case", "catch", "continue", "debugger", "delete", "do", "else",
        "finally", "for", "if", "in", "instanceof", "new", "return", "switch",
        "this", "throw", "try", "typeof", "void", "while", "with", "yield",
        "package", "implements", "private", "public", "protected", "static",
        "eval", "arguments",
        # Common variable names that might conflict
        "data", "response", "error", "result", "value", "url"
    }
    
    def __init__(self, openapi_schema: Dict[str, Any], host: str = "localhost", port: int = 9000, base_path: str = ""):
        """
        Initialize the generator with an OpenAPI schema.
        
        Args:
            openapi_schema: The OpenAPI schema dictionary from GIRest
            host: Host for REST API calls (default: 'localhost')
            port: Port for REST API calls (default: 9000)
            base_path: Base path for REST API calls (default: '')
        """
        self.schema = openapi_schema
        self.components = openapi_schema.get("components", {})
        self.schemas = self.components.get("schemas", {})
        self.paths = openapi_schema.get("paths", {})
        self.host = host
        self.port = port
        self.base_path = base_path
        self.base_url = f"http://{host}:{port}{base_path}"
        self.enum_schemas: Set[str] = set()
        self.class_methods: Dict[str, List[Dict]] = {}
        self.class_constructors: Dict[str, List[Dict]] = {}
        self.class_fields: Dict[str, Dict[str, Dict]] = {}  # Track field operations: {class_name: {field_name: {get: method_info, put: method_info}}}
        self.gobject_types: Set[str] = set()  # Track GObject-derived types
        self.callback_schemas: Set[str] = set()  # Track callback types
        self.standalone_functions: List[Dict] = []  # Track standalone functions without tags
        self.struct_destructors: Dict[str, Dict] = {}  # Track structs with destructors (free methods)
        
        # Setup Jinja2 environment
        self.template_dir = os.path.join(os.path.dirname(__file__), 'templates')
        self.jinja_env = Environment(
            loader=FileSystemLoader(self.template_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        # Identify enum schemas and GObject types
        self._identify_special_schemas()
        
        # Parse operations and organize by tag (class)
        self._parse_operations()
    
    def _safe_property_name(self, name: str) -> str:
        """
        Convert a schema property name to a safe TypeScript/JavaScript identifier.
        
        Appends an underscore to reserved keywords to avoid syntax errors.
        This method should be used for all property names in schemas (enums,
        structs, objects, callbacks, functions, etc).
        
        Args:
            name: The property name from the schema
            
        Returns:
            Safe TypeScript identifier (may have underscore appended)
        """
        if name in self.RESERVED_KEYWORDS:
            return f"{name}_"
        return name
    
    def _identify_special_schemas(self):
        """Identify which schemas are enums, callbacks, and which are GObject-based."""
        for schema_name, schema_def in self.schemas.items():
            # Identify enums
            if "enum" in schema_def and schema_def.get("type") == "string":
                self.enum_schemas.add(schema_name)
            
            # Identify callbacks
            if schema_def.get("x-gi-type") == "callback":
                self.callback_schemas.add(schema_name)
            
            # Identify GObject-based types by checking inheritance chain
            if self._is_gobject_type(schema_name, schema_def):
                self.gobject_types.add(schema_name)
    
    def _is_gobject_type(self, schema_name: str, schema_def: Dict[str, Any]) -> bool:
        """Check if a type is derived from GObject."""
        # Only types with x-gi-type: "object" are actual GObject types
        # Structs like GObjectTypeInstance should not be considered GObject types
        if schema_def.get("x-gi-type") != "object":
            return False
            
        # Check if this is GObject.Object itself or inherits from it
        if schema_name == "GObjectObject":
            return True
        
        if "allOf" in schema_def:
            for item in schema_def["allOf"]:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        parent_schema = self.schemas.get(parent_name, {})
                        if self._is_gobject_type(parent_name, parent_schema):
                            return True
        return False
    
    def _parse_operations(self):
        """Parse all operations and organize them by tag (class name)."""
        for path, operations in self.paths.items():
            for method, operation in operations.items():
                if method.lower() not in ["get", "post", "put", "delete", "patch"]:
                    continue
                
                tags = operation.get("tags", [])
                method_info = {
                    "path": path,
                    "http_method": method,
                    "operation": operation,
                    "operation_id": operation.get("operationId", "")
                }
                
                if tags:
                    class_name = tags[0]
                    is_constructor = operation.get("x-gi-constructor", False)
                    is_destructor = operation.get("x-gi-destructor", False)
                    is_field = operation.get("x-gi-field", False)
                    
                    if is_field:
                        # Parse field operations - use the tag as class name, not the parsed class name
                        parsed = parse_operation_id(operation.get("operationId", ""))
                        if parsed and len(parsed) == 4:
                            namespace, parsed_class_name, field_name, operator = parsed
                            
                            # Use the tag as the class name (which includes namespace prefix)
                            field_class_name = class_name  # This comes from tags[0]
                            
                            # Initialize class fields if not exists
                            if field_class_name not in self.class_fields:
                                self.class_fields[field_class_name] = {}
                            
                            # Initialize field if not exists
                            if field_name not in self.class_fields[field_class_name]:
                                self.class_fields[field_class_name][field_name] = {}
                            
                            # Store the operation by type (get/put)
                            if operator in ['get', 'put']:
                                self.class_fields[field_class_name][field_name][operator] = method_info
                    elif is_constructor:
                        if class_name not in self.class_constructors:
                            self.class_constructors[class_name] = []
                        self.class_constructors[class_name].append(method_info)
                    elif is_destructor:
                        # Track destructors for finalization registry only
                        # Do not add to class_methods - consumer should not call destructors
                        self.struct_destructors[class_name] = method_info
                    else:
                        if class_name not in self.class_methods:
                            self.class_methods[class_name] = []
                        self.class_methods[class_name].append(method_info)
                else:
                    # Standalone function without tags
                    self.standalone_functions.append(method_info)
    
    def _get_callback_type_name(self, callback_ref: str) -> str:
        """Get the TypeScript type name for a callback reference."""
        if not callback_ref.startswith("#/components/schemas/"):
            return "Function"
        
        callback_name = callback_ref.split("/")[-1]
        callback_schema = self.schemas.get(callback_name, {})
        
        if not callback_schema or callback_schema.get("x-gi-type") != "callback":
            return "Function"
        
        return callback_name
    
    def _get_callback_type_signature(self, callback_ref: str) -> str:
        """Generate TypeScript function signature for a callback."""
        if not callback_ref.startswith("#/components/schemas/"):
            return "Function"
        
        callback_name = callback_ref.split("/")[-1]
        callback_schema = self.schemas.get(callback_name, {})
        
        if not callback_schema or callback_schema.get("x-gi-type") != "callback":
            return "Function"
        
        # Get callback properties
        properties = callback_schema.get("properties", {})
        param_list = []
        return_type = "void"
        
        # Iterate through properties to get parameters and return type
        for prop_name, prop_schema in properties.items():
            is_return = prop_schema.get("x-gi-is-return", False)
            
            if is_return:
                # This is the return type
                # Remove x-gi-is-return from schema before converting
                clean_schema = {k: v for k, v in prop_schema.items() if k != "x-gi-is-return"}
                return_type = self._openapi_type_to_ts(clean_schema)
            else:
                # This is a parameter
                # Use safe property name to handle reserved keywords
                ts_param_name = self._safe_property_name(prop_name)
                # Remove x-gi-transfer and x-gi-is-return from schema before converting
                clean_schema = {k: v for k, v in prop_schema.items() if k not in ["x-gi-transfer", "x-gi-is-return"]}
                param_type = self._openapi_type_to_ts(clean_schema)
                param_list.append(f"{ts_param_name}: {param_type}")
        
        params_str = ", ".join(param_list)
        return f"({params_str}) => {return_type}"
    
    def _openapi_type_to_ts(self, schema: Dict[str, Any], nullable: bool = False) -> str:
        """Convert an OpenAPI schema type to TypeScript type."""
        if not schema:
            return "any"
        
        if "$ref" in schema:
            ref_path = schema["$ref"]
            if ref_path.startswith("#/components/schemas/"):
                type_name = ref_path.split("/")[-1]
                # If this is an enum with methods, use the Value suffix
                if type_name in self.enum_schemas and type_name in self.class_methods:
                    type_name = type_name + "Value"
                return type_name + (" | null" if nullable else "")
        
        if "oneOf" in schema:
            types = [self._openapi_type_to_ts(s) for s in schema["oneOf"]]
            union = " | ".join(types)
            return f"({union})" + (" | null" if nullable else "")
        
        schema_type = schema.get("type")
        
        if schema_type == "string":
            enum_values = schema.get("enum")
            if enum_values:
                literals = " | ".join([f'"{v}"' for v in enum_values])
                return literals + (" | null" if nullable else "")
            return "string" + (" | null" if nullable else "")
        
        elif schema_type == "integer" or schema_type == "number":
            return "number" + (" | null" if nullable else "")
        
        elif schema_type == "boolean":
            return "boolean" + (" | null" if nullable else "")
        
        elif schema_type == "array":
            items = schema.get("items", {})
            item_type = self._openapi_type_to_ts(items)
            return f"{item_type}[]" + (" | null" if nullable else "")
        
        elif schema_type == "object":
            properties = schema.get("properties", {})
            if properties:
                prop_types = []
                required = schema.get("required", [])
                for prop_name, prop_schema in properties.items():
                    is_required = prop_name in required
                    prop_type = self._openapi_type_to_ts(prop_schema)
                    optional_marker = "" if is_required else "?"
                    safe_name = self._safe_property_name(prop_name)
                    prop_types.append(f"{safe_name}{optional_marker}: {prop_type}")
                return "{ " + "; ".join(prop_types) + " }" + (" | null" if nullable else "")
            return "object" + (" | null" if nullable else "")
        
        return "any" + (" | null" if nullable else "")
    
    def _convert_method_path_to_registry_path(self, method_path: str) -> str:
        """
        Convert a method path (for instance methods) to a registry path (for FinalizationRegistry).
        
        Method paths use template literals like ${this.ptr}, but registry paths need
        string concatenation like ' + ptr + '.
        
        Args:
            method_path: Path from _prepare_method_data with ${this.ptr} format
            
        Returns:
            Path suitable for FinalizationRegistry with ' + ptr + ' format
        """
        # Convert ${this.ptr} to ' + ptr + '
        registry_path = method_path.replace("${this.ptr}", "' + ptr + '")
        
        # Convert ${param.ptr} to ' + ptr + ' (for multi-parameter destructors)
        # This is a simplification - for complex destructors with multiple params,
        # we'd need the actual parameter values, but most destructors only use self
        import re
        registry_path = re.sub(r'\$\{[^}]*\.ptr\}', "' + ptr + '", registry_path)
        
        return registry_path
    
    def _prepare_interface_data(self, name: str, schema: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare data for interface template."""
        data = {"name": name}
        
        # Handle enums
        if "enum" in schema and schema.get("type") == "string":
            enum_values = schema["enum"]
            has_methods = name in self.class_methods
            
            if has_methods:
                data["is_enum_with_methods"] = True
                data["enum_values"] = [
                    {
                        "const_name": value.upper().replace("-", "_").replace(".", "_"),
                        "value": value
                    }
                    for value in enum_values
                ]
                literals = " | ".join([f'"{v}"' for v in enum_values])
                data["enum_value_union"] = literals
            else:
                data["is_enum"] = True
                literals = " | ".join([f'"{v}"' for v in enum_values])
                data["enum_value_union"] = literals
            
            return data
        
        # Handle allOf (inheritance)
        if "allOf" in schema:
            all_of = schema["allOf"]
            parent_refs = []
            own_props = {}
            
            for item in all_of:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        parent_refs.append(parent_name)
                elif "type" in item and item["type"] == "object":
                    own_props = item.get("properties", {})
            
            if parent_refs:
                data["has_parent"] = True
                data["parent"] = ", ".join(parent_refs)
                required = schema.get("required", [])
                data["properties"] = [
                    {
                        "name": prop_name,
                        "optional": "" if prop_name in required else "?",
                        "type": self._openapi_type_to_ts(prop_schema)
                    }
                    for prop_name, prop_schema in own_props.items()
                ]
            else:
                data["properties"] = []
        else:
            # Regular object
            properties = schema.get("properties", {})
            required = schema.get("required", [])
            data["properties"] = [
                {
                    "name": self._safe_property_name(prop_name),
                    "optional": "" if prop_name in required else "?",
                    "type": self._openapi_type_to_ts(prop_schema)
                }
                for prop_name, prop_schema in properties.items()
            ]
        
        return data
    
    def _prepare_method_data(self, method_info: Dict[str, Any], class_name: str, is_constructor: bool = False) -> Dict[str, Any]:
        """Prepare data for method template."""
        operation = method_info["operation"]
        path = method_info["path"]
        
        # Extract method name from path using helper method
        method_name = self._extract_method_name_from_path(path)
        
        # Build parameter list
        params = operation.get("parameters", [])
        required_params = []
        optional_params = []
        query_params = []
        path_params = []
        has_self_param = False
        
        # Check if this method has callbacks
        callbacks = operation.get("x-gi-callbacks", {})
        callback_params = []
        
        for param in params:
            param_name = param.get("name", "")
            param_schema = param.get("schema", {})
            param_required = param.get("required", False)
            param_in = param.get("in", "query")
            param_transfer = param.get("x-gi-transfer", "none")
            # Get style and explode settings from OpenAPI spec
            param_style = param.get("style", "form" if param_in == "query" else "simple")
            param_explode = param.get("explode", True if param_style == "form" else False)
            
            if param_name == "self":
                has_self_param = True
                path_params.append((param_name, param_schema, param_style, param_explode))
                continue
            
            # Use safe property name to handle reserved keywords
            ts_param_name = self._safe_property_name(param_name)
            
            param_type = self._openapi_type_to_ts(param_schema)
            optional_marker = "" if param_required else "?"
            param_str = f"{ts_param_name}{optional_marker}: {param_type}"
            
            # Separate required and optional parameters
            if param_required:
                required_params.append(param_str)
            else:
                optional_params.append(param_str)
            
            # Check if this parameter is a GObject type (needs ref counting)
            is_gobject_param = False
            is_object_param = False
            if "$ref" in param_schema:
                ref_path = param_schema["$ref"]
                if ref_path.startswith("#/components/schemas/"):
                    type_name = ref_path.split("/")[-1]
                    is_gobject_param = type_name in self.gobject_types
                    # Check if this is an object type that needs serialization
                    schema_def = self.schemas.get(type_name, {})
                    if schema_def.get("type") == "object" or "allOf" in schema_def:
                        is_object_param = True
            
            if param_in == "path":
                path_params.append((param_name, param_schema, param_style, param_explode))
            elif param_in == "query":
                query_params.append({
                    "name": ts_param_name,  # Use renamed parameter
                    "api_name": param_name,  # Original name for API call
                    "required": param_required,
                    "transfer": param_transfer,
                    "is_gobject": is_gobject_param,
                    "is_object": is_object_param,
                    "style": param_style,
                    "explode": param_explode
                })
        
        # Add callback parameters to method signature
        for callback_name, callback_ref in callbacks.items():
            # Use the callback type name instead of the full function signature
            callback_type_name = self._get_callback_type_name(callback_ref)
            safe_callback_name = self._safe_property_name(callback_name)
            required_params.append(f"{safe_callback_name}: {callback_type_name}")
            callback_params.append({
                "name": safe_callback_name,
                "api_name": callback_name,  # Original name for API
                "type_ref": callback_ref
            })
        
        # Combine required and optional parameters (required first)
        method_params = required_params + optional_params
        
        # Determine return type
        return_type = "void"
        response_has_return = False
        return_is_object = False  # Track if return type is an object/struct that needs instantiation
        return_class_name = None  # The class name to instantiate if return_is_object is True
        return_transfer = "none"  # Default transfer mode
        return_is_gobject = False  # Track if return type is a GObject type
        responses = operation.get("responses", {})
        
        if "200" in responses:
            content = responses["200"].get("content", {})
            app_json = content.get("application/json", {})
            schema = app_json.get("schema", {})
            
            if schema:
                props = schema.get("properties", {})
                if "return" in props:
                    return_props = props["return"]
                    
                    # Extract transfer information
                    return_transfer = return_props.get("x-gi-transfer", "none")
                    
                    if is_constructor:
                        return_type = class_name
                        return_is_object = True
                        return_class_name = class_name
                        return_is_gobject = class_name in self.gobject_types
                    else:
                        return_type = self._openapi_type_to_ts(return_props)
                        # Check if the return type is a class that needs instantiation
                        if "$ref" in return_props:
                            ref_path = return_props["$ref"]
                            if ref_path.startswith("#/components/schemas/"):
                                type_name = ref_path.split("/")[-1]
                                schema_def = self.schemas.get(type_name, {})
                                # Check if this is a GObject type
                                return_is_gobject = type_name in self.gobject_types
                                # Check if this is an object type (class) or struct with methods
                                # Objects/structs have type=object or allOf (inheritance)
                                # Also check if it's in class_methods (has methods, so it's a class)
                                if (schema_def.get("type") == "object" or "allOf" in schema_def) and \
                                   type_name in self.class_methods:
                                    return_is_object = True
                                    return_class_name = type_name
                    response_has_return = True
                elif props:
                    return_type = self._openapi_type_to_ts(schema)
                else:
                    return_type = "void"
        
        # Build URL path - serialize parameters based on style/explode
        url_path = path
        for param_tuple in path_params:
            param_name = param_tuple[0]
            param_schema = param_tuple[1]
            param_style = param_tuple[2] if len(param_tuple) > 2 else "simple"
            param_explode = param_tuple[3] if len(param_tuple) > 3 else False
            
            # Check if this is an object type (has $ref to a schema with type=object or allOf)
            is_object = False
            if "$ref" in param_schema:
                ref_path = param_schema["$ref"]
                if ref_path.startswith("#/components/schemas/"):
                    type_name = ref_path.split("/")[-1]
                    schema_def = self.schemas.get(type_name, {})
                    if schema_def.get("type") == "object" or "allOf" in schema_def:
                        is_object = True
            
            if param_name == "self":
                if is_object:
                    # For objects, serialize based on style/explode
                    if param_explode:
                        # explode=true: ptr=${this.ptr}
                        url_path = url_path.replace("{self}", "ptr=${this.ptr}")
                    else:
                        # explode=false (default): ptr,${this.ptr}
                        url_path = url_path.replace("{self}", "ptr,${this.ptr}")
                else:
                    # For primitives, just use the value
                    url_path = url_path.replace("{self}", "${this.ptr}")
            else:
                if is_object:
                    # For objects, serialize based on style/explode
                    if param_explode:
                        # explode=true: ptr=${param.ptr}
                        url_path = url_path.replace(f"{{{param_name}}}", f"ptr=${{{param_name}.ptr}}")
                    else:
                        # explode=false (default): ptr,${param.ptr}
                        url_path = url_path.replace(f"{{{param_name}}}", f"ptr,${{{param_name}.ptr}}")
                else:
                    # For primitives, just use the value
                    url_path = url_path.replace(f"{{{param_name}}}", f"${{{param_name}}}")
        
        is_enum = class_name in self.enum_schemas
        
        return {
            "name": method_name,
            "params": ", ".join(method_params),
            "return_type": return_type,
            "is_static": is_constructor or is_enum or not has_self_param,
            "with_impl": True,
            "base_url": self.base_url,
            "host": self.host,
            "port": self.port,
            "base_path": self.base_path,
            "path": url_path,
            "query_params": query_params,
            "callback_params": callback_params,
            "is_constructor": is_constructor,
            "has_return": response_has_return,
            "return_is_object": return_is_object,
            "return_class_name": return_class_name,
            "return_transfer": return_transfer,
            "return_is_gobject": return_is_gobject,
            "class_name": class_name
        }
    
    def _prepare_field_methods(self, class_name: str, field_name: str, field_operations: Dict[str, Dict]) -> List[str]:
        """Prepare getter and setter methods for a field."""
        methods = []
        
        # Prepare getter method (if GET operation exists)
        if 'get' in field_operations:
            get_info = field_operations['get']
            
            # Get the return type from the operation response
            operation = get_info['operation']
            return_type = "any"
            responses = operation.get("responses", {})
            if "200" in responses:
                content = responses["200"].get("content", {})
                app_json = content.get("application/json", {})
                schema = app_json.get("schema", {})
                if schema:
                    props = schema.get("properties", {})
                    if "return" in props:
                        return_props = props["return"]
                        return_type = self._openapi_type_to_ts(return_props)
            
            # Create custom method data for field getter
            get_method_data = {
                "name": f"get_{field_name}",
                "params": "",  # No parameters for getter
                "return_type": return_type,
                "is_static": False,
                "with_impl": True,
                "base_url": self.base_url,
                "host": self.host,
                "port": self.port,
                "base_path": self.base_path,
                "path": get_info['path'].replace('{self}', 'ptr,${this.ptr}'),  # Replace {self} with proper path parameter
                "query_params": [],
                "callback_params": [],
                "is_constructor": False,
                "has_return": True,  # Field operations return values
                "return_is_object": False,
                "return_class_name": None,
                "return_transfer": "none",
                "return_is_gobject": False,
                "class_name": class_name
            }
            
            # Try to find method-specific template first, fallback to default method template
            method_template = self._get_method_template(class_name, f"get_{field_name}")
            methods.append(method_template.render(get_method_data).rstrip())
        
        # Prepare setter method (if PUT operation exists)
        if 'put' in field_operations:
            put_info = field_operations['put']
            
            # Get the value parameter type
            operation = put_info['operation']
            value_type = "any"
            params = operation.get("parameters", [])
            for param in params:
                if param.get("name") == "value":
                    param_schema = param.get("schema", {})
                    value_type = self._openapi_type_to_ts(param_schema)
                    break
            
            # Create custom method data for field setter
            put_method_data = {
                "name": f"set_{field_name}",
                "params": f"value_: {value_type}",  # Single parameter for setter
                "return_type": "void",
                "is_static": False,
                "with_impl": True,
                "base_url": self.base_url,
                "host": self.host,
                "port": self.port,
                "base_path": self.base_path,
                "path": put_info['path'].replace('{self}', 'ptr,${this.ptr}'),  # Replace {self} with proper path parameter
                "query_params": [{"name": "value_", "original_name": "value", "type": value_type, "required": True, "description": f"Value to set for {field_name}"}],
                "callback_params": [],
                "is_constructor": False,
                "has_return": False,  # Setter operations don't return values
                "return_is_object": False,
                "return_class_name": None,
                "return_transfer": "none",
                "return_is_gobject": False,
                "class_name": class_name
            }
            
            # Try to find method-specific template first, fallback to default method template
            method_template = self._get_method_template(class_name, f"set_{field_name}")
            methods.append(method_template.render(put_method_data).rstrip())
        
        return methods
    
    def _get_direct_parent(self, class_name: str) -> Optional[str]:
        """Get the direct parent class from the schema's allOf."""
        schema = self.schemas.get(class_name, {})
        if "allOf" in schema:
            for item in schema["allOf"]:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        return ref_path.split("/")[-1]
        return None
    
    def _extract_method_name_from_path(self, path: str) -> str:
        """
        Extract method name from a path.
        
        Args:
            path: The path string from which to extract the method name
            
        Returns:
            The method name extracted from the path
        """
        return path.split("/")[-1].replace("{", "").replace("}", "")
    
    def _get_parent_method_names(self, class_name: str) -> Set[str]:
        """
        Get all method names from the entire parent chain.
        
        Args:
            class_name: The class name to start from
            
        Returns:
            Set of all method names defined in parent classes
        """
        method_names = set()
        parent = self._get_direct_parent(class_name)
        
        while parent:
            # Add methods from this parent
            if parent in self.class_methods:
                for method_info in self.class_methods[parent]:
                    path = method_info.get("path", "")
                    method_name = self._extract_method_name_from_path(path)
                    method_names.add(method_name)
            
            # Move up the chain
            parent = self._get_direct_parent(parent)
        
        return method_names
    
    def _get_parent_method_signatures(self, class_name: str) -> Dict[str, str]:
        """
        Get all method signatures from the entire parent chain.
        
        Args:
            class_name: The class name to start from
            
        Returns:
            Dict mapping method names to their full signatures from parent classes
        """
        method_signatures = {}
        parent = self._get_direct_parent(class_name)
        
        while parent:
            # Add methods from this parent
            if parent in self.class_methods:
                for method_info in self.class_methods[parent]:
                    method_data = self._prepare_method_data(method_info, parent)
                    method_name = method_data.get("name")
                    signature = self._get_method_signature(method_data)
                    
                    # Only track the first occurrence (closest parent wins)
                    if method_name not in method_signatures:
                        method_signatures[method_name] = signature
            
            # Move up the chain
            parent = self._get_direct_parent(parent)
        
        return method_signatures
    
    def _get_parent_constructor_signatures(self, class_name: str) -> Dict[str, str]:
        """
        Get all constructor signatures from the entire parent chain.
        
        Args:
            class_name: The class name to start from
            
        Returns:
            Dict mapping constructor names to their full signatures from parent classes
        """
        constructor_signatures = {}
        parent = self._get_direct_parent(class_name)
        
        while parent:
            # Add constructors from this parent
            if parent in self.class_constructors:
                for constructor_info in self.class_constructors[parent]:
                    constructor_data = self._prepare_method_data(constructor_info, parent, is_constructor=True)
                    constructor_name = constructor_data.get("name")
                    signature = self._get_method_signature(constructor_data)
                    
                    # Only track the first occurrence (closest parent wins)
                    if constructor_name not in constructor_signatures:
                        constructor_signatures[constructor_name] = signature
            
            # Move up the chain
            parent = self._get_direct_parent(parent)
        
        return constructor_signatures
    
    def _get_parent_method_names(self, class_name: str) -> Set[str]:
        """
        Get all constructor names from the entire parent chain.
        
        Args:
            class_name: The class name to start from
            
        Returns:
            Set of all constructor names defined in parent classes
        """
        constructor_names = set()
        parent = self._get_direct_parent(class_name)
        
        while parent:
            # Add constructors from this parent
            if parent in self.class_constructors:
                for constructor_info in self.class_constructors[parent]:
                    path = constructor_info.get("path", "")
                    constructor_name = self._extract_method_name_from_path(path)
                    constructor_names.add(constructor_name)
            
            # Move up the chain
            parent = self._get_direct_parent(parent)
        
        return constructor_names
    
    def _get_method_signature(self, method_data: Dict[str, Any]) -> str:
        """
        Generate a method signature for comparison purposes.
        
        Args:
            method_data: Method data from _prepare_method_data
            
        Returns:
            String representation of method signature (name + params + return_type)
        """
        name = method_data.get("name", "")
        params = method_data.get("params", "")
        return_type = method_data.get("return_type", "void")
        is_static = method_data.get("is_static", False)
        
        # Include static modifier in signature to distinguish static vs instance methods
        static_prefix = "static " if is_static else ""
        return f"{static_prefix}{name}({params}): {return_type}"
    
    def _find_unique_method_name(self, base_name: str, existing_names: Set[str]) -> str:
        """
        Find a unique method name by appending a suffix number if needed.
        
        This method recursively tries to find a unique name by appending _2, _3, etc.
        until a name is found that doesn't exist in the existing_names set.
        
        Args:
            base_name: The original method name
            existing_names: Set of method names that already exist
            
        Returns:
            A unique method name (either base_name or base_name with suffix)
        """
        if base_name not in existing_names:
            return base_name
        
        # Try appending numbers until we find a unique name
        suffix = 2
        while True:
            candidate = f"{base_name}_{suffix}"
            if candidate not in existing_names:
                return candidate
            suffix += 1
    
    def _prepare_class_data(self, class_name: str) -> Dict[str, Any]:
        """Prepare data for class template."""
        is_enum = class_name in self.enum_schemas
        schema = self.schemas.get(class_name, {})
        extends_gobject = class_name in self.gobject_types
        has_interface = class_name in self.schemas and not is_enum
        
        # Get the direct parent for inheritance
        parent_class = self._get_direct_parent(class_name)
        
        # Check if this struct has a destructor
        has_destructor = class_name in self.struct_destructors
        
        data = {
            "name": class_name,
            "is_enum": is_enum,
            "extends_gobject": extends_gobject,
            "parent_class": parent_class,
            "has_destructor": has_destructor,
            "destructor_registry": f"{class_name.lower()}Registry" if has_destructor else "",
            "properties": [],
            "constructors": [],
            "methods": []
        }
        
        if is_enum:
            # Enum namespace with methods
            if class_name in self.class_methods:
                method_template = self.jinja_env.get_template('method.ts.j2')
                for method_info in self.class_methods[class_name]:
                    method_data = self._prepare_method_data(method_info, class_name)
                    data["methods"].append(method_template.render(method_data))
        else:
            # Regular class (struct or object)
            # Properties should only be added for interface generation, not for classes
            # Structs and objects get their ptr fields from:
            # - Destructor handling (if has_destructor)
            # - Inheritance chain (for GObject types)
            # - Template-specific logic (not from schema properties)
            data["properties"] = []
            
            # Add constructors
            if class_name in self.class_constructors:
                # Get all constructor signatures from parent chain to check for overrides
                parent_constructor_signatures = self._get_parent_constructor_signatures(class_name)
                current_constructor_names = set()
                
                for constructor_info in self.class_constructors[class_name]:
                    constructor_data = self._prepare_method_data(constructor_info, class_name, is_constructor=True)
                    original_name = constructor_data.get("name")
                    current_signature = self._get_method_signature(constructor_data)
                    
                    # Check if constructor name conflicts with parent chain
                    if original_name in parent_constructor_signatures:
                        parent_signature = parent_constructor_signatures[original_name]
                        if current_signature == parent_signature:
                            # Same signature - allow override (keep original name)
                            pass
                        else:
                            # Different signature - find unique name by appending suffix
                            parent_constructor_names = set(parent_constructor_signatures.keys())
                            unique_name = self._find_unique_method_name(original_name, parent_constructor_names | current_constructor_names)
                            constructor_data["name"] = unique_name
                    
                    # Track this constructor name for potential conflicts with subsequent constructors
                    current_constructor_names.add(constructor_data["name"])
                    
                    # Try to find method-specific template first, fallback to default method template
                    method_template = self._get_method_template(class_name, original_name)
                    data["constructors"].append(method_template.render(constructor_data).rstrip())
            
            # Add methods
            if class_name in self.class_methods:
                # Get all method signatures from parent chain to check for overrides
                parent_method_signatures = self._get_parent_method_signatures(class_name)
                current_method_names = set()
                
                for method_info in self.class_methods[class_name]:
                    method_data = self._prepare_method_data(method_info, class_name)
                    original_name = method_data.get("name")
                    current_signature = self._get_method_signature(method_data)
                    
                    # Skip 'unref' method for GObjectObject as it's provided by the base class
                    if class_name == "GObjectObject" and original_name == "unref":
                        continue
                    
                    # Check if method name conflicts with parent chain
                    if original_name in parent_method_signatures:
                        parent_signature = parent_method_signatures[original_name]
                        if current_signature == parent_signature:
                            # Same signature - allow override (keep original name)
                            pass
                        else:
                            # Different signature - find unique name by appending suffix
                            parent_method_names = set(parent_method_signatures.keys())
                            unique_name = self._find_unique_method_name(original_name, parent_method_names | current_method_names)
                            method_data["name"] = unique_name
                    
                    # Track this method name for potential conflicts with subsequent methods
                    current_method_names.add(method_data["name"])
                    
                    # Try to find method-specific template first, fallback to default method template
                    method_template = self._get_method_template(class_name, original_name)
                    data["methods"].append(method_template.render(method_data).rstrip())
            
            # Add field getter/setter methods
            if class_name in self.class_fields:
                for field_name, field_operations in self.class_fields[class_name].items():
                    field_methods = self._prepare_field_methods(class_name, field_name, field_operations)
                    data["methods"].extend(field_methods)
        
        return data
    
    def _get_method_template(self, class_name: str, method_name: str) -> Template:
        """
        Get the appropriate template for a method.
        
        First tries to find a method-specific template (e.g., GObjectObjectref.ts.j2),
        then falls back to the default method template (method.ts.j2).
        
        Args:
            class_name: The name of the class
            method_name: The name of the method
            
        Returns:
            Jinja2 Template object
        """
        # Try method-specific template first: {basename}{object}{method}.ts.j2
        method_template_name = f"{class_name}{method_name}.ts.j2"
        if os.path.exists(os.path.join(self.template_dir, method_template_name)):
            return self.jinja_env.get_template(method_template_name)
        
        # Fall back to default method template
        return self.jinja_env.get_template('method.ts.j2')

    def _get_template_for_schema(self, schema_name: str, schema_def: Dict[str, Any]) -> Template:
        """
        Get the appropriate template for a schema.
        
        First tries to find a specific template by name (e.g., GObjectObject.ts.j2),
        then falls back to type-based templates (e.g., object.ts.j2).
        
        Args:
            schema_name: The name of the schema
            schema_def: The schema definition
            
        Returns:
            Jinja2 Template object
        """
        # First try to find a specific template by name
        specific_template_name = f"{schema_name}.ts.j2"
        if os.path.exists(os.path.join(self.template_dir, specific_template_name)):
            return self.jinja_env.get_template(specific_template_name)
        
        # Fall back to type-based templates
        gi_type = schema_def.get("x-gi-type", "")
        
        # Map x-gi-type to template names
        type_template_map = {
            "enum": "enum.ts.j2",
            "flags": "flags.ts.j2", 
            "struct": "struct.ts.j2",
            "object": "object.ts.j2",
            "callback": "callback.ts.j2"
        }
        
        template_name = type_template_map.get(gi_type)
        if template_name:
            return self.jinja_env.get_template(template_name)
        
        # Default fallback (should not happen in normal cases)
        if "enum" in schema_def and schema_def.get("type") == "string":
            return self.jinja_env.get_template("enum.ts.j2")
        
        # For unknown types, use object template as fallback
        return self.jinja_env.get_template("object.ts.j2")
    
    def _generate_schemas(self) -> Dict[str, str]:
        """
        Generate TypeScript code for all schemas based on their types.
        
        Returns:
            Dictionary mapping schema names to generated TypeScript code
        """
        generated_schemas = {}
        
        # Collect all schema names that need to be generated
        # Include classes with methods and all parent classes in the inheritance chain
        schemas_to_generate = set()
        
        for schema_name, schema_def in self.schemas.items():
            gi_type = schema_def.get("x-gi-type", "")
            
            # Always generate enums, flags, and callbacks as interfaces/types
            if gi_type in ["enum", "flags", "callback"]:
                schemas_to_generate.add(schema_name)
            
            # Generate structs as classes (whether they have methods or not)
            elif gi_type == "struct":
                schemas_to_generate.add(schema_name)
                # Add parent classes in inheritance chain
                parent = self._get_direct_parent(schema_name)
                while parent:
                    if parent in self.schemas:
                        schemas_to_generate.add(parent)
                    parent = self._get_direct_parent(parent)
            
            # Generate objects as classes if they have methods
            elif gi_type == "object":
                if schema_name in self.class_methods or schema_name in self.class_constructors:
                    schemas_to_generate.add(schema_name)
                    # Add parent classes in inheritance chain
                    parent = self._get_direct_parent(schema_name)
                    while parent:
                        if parent in self.schemas:
                            schemas_to_generate.add(parent)
                        parent = self._get_direct_parent(parent)
                else:
                    # Object without methods - generate as interface
                    schemas_to_generate.add(schema_name)
        
        # Generate schemas in dependency order (parents before children)
        generated = set()
        
        def generate_schema_with_parents(schema_name: str):
            """Recursively generate a schema and its parents."""
            if schema_name in generated:
                return
            
            # First generate the parent
            parent = self._get_direct_parent(schema_name)
            if parent and parent in schemas_to_generate:
                generate_schema_with_parents(parent)
            
            # Then generate this schema
            schema_def = self.schemas.get(schema_name, {})
            gi_type = schema_def.get("x-gi-type", "")
            
            # Determine how to generate this schema
            is_enum = schema_name in self.enum_schemas
            has_methods = schema_name in self.class_methods or schema_name in self.class_constructors
            
            if gi_type == "callback":
                # Generate callback as type alias
                template = self._get_template_for_schema(schema_name, schema_def)
                # Generate callback signature
                callback_signature = self._get_callback_type_signature(f"#/components/schemas/{schema_name}")
                data = {"name": schema_name, "callback_signature": callback_signature}
                
            elif is_enum and has_methods:
                # Enum with methods - use enum template
                template = self._get_template_for_schema(schema_name, schema_def)
                data = self._prepare_interface_data(schema_name, schema_def)
                
                # Add methods to enum namespace
                method_template = self.jinja_env.get_template('method.ts.j2')
                methods = []
                for method_info in self.class_methods.get(schema_name, []):
                    method_data = self._prepare_method_data(method_info, schema_name)
                    # In namespaces, we don't use the static keyword
                    method_data["is_namespace_function"] = True
                    methods.append(method_template.render(method_data).rstrip())
                data["methods"] = methods
                
            elif gi_type in ["struct", "object"] and (has_methods or gi_type == "struct"):
                # Generate as class (all structs are classes, objects with methods are classes)
                template = self._get_template_for_schema(schema_name, schema_def)
                data = self._prepare_class_data(schema_name)
                
            else:
                # Generate as interface/type
                template = self._get_template_for_schema(schema_name, schema_def)
                data = self._prepare_interface_data(schema_name, schema_def)
            
            generated_schemas[schema_name] = template.render(data).rstrip()
            generated.add(schema_name)
        
        # Generate all schemas
        for schema_name in sorted(schemas_to_generate):
            generate_schema_with_parents(schema_name)
        
        return generated_schemas
    
    def generate(self) -> str:
        """
        Generate complete TypeScript bindings.
        
        Returns:
            TypeScript code as a string
        """
        title = self.schema.get("info", {}).get("title", "API")
        version = self.schema.get("info", {}).get("version", "1.0")
        
        # Generate all schemas using the new schema-based approach
        generated_schemas = self._generate_schemas()
        
        # Split generated schemas into interfaces and classes
        interfaces = []
        classes = []
        
        for schema_name, code in generated_schemas.items():
            schema_def = self.schemas.get(schema_name, {})
            gi_type = schema_def.get("x-gi-type", "")
            has_methods = schema_name in self.class_methods or schema_name in self.class_constructors
            
            # Determine if this is an interface or class based on content
            if code.strip().startswith("export class"):
                classes.append(code)
            else:
                interfaces.append(code)
        
        # Generate standalone functions namespace
        standalone_namespace = ""
        if self.standalone_functions:
            # Extract namespace name from the first function's operation_id
            # Format: {namespace}--{function_name}
            first_func = self.standalone_functions[0]
            op_id = first_func.get("operation_id", "")
            namespace_name = op_id.split("-")[0] if op_id else "Functions"
            
            method_template = self.jinja_env.get_template('method.ts.j2')
            methods = []
            for func_info in self.standalone_functions:
                method_data = self._prepare_method_data(func_info, namespace_name)
                # Standalone functions are namespace functions (no static keyword)
                method_data["is_namespace_function"] = True
                methods.append(method_template.render(method_data).rstrip())
            
            standalone_namespace = f"export namespace {namespace_name} {{\n"
            standalone_namespace += "\n".join(methods)
            standalone_namespace += "\n}"
        
        # Prepare struct registries for finalization
        struct_registries = []
        for class_name, destructor_info in self.struct_destructors.items():
            # Process destructor as a regular method to get the properly formatted path
            destructor_method_data = self._prepare_method_data(destructor_info, class_name)
            method_path = destructor_method_data["path"]
            
            # Convert method path format to registry path format
            registry_path = self._convert_method_path_to_registry_path(method_path)
            
            struct_registries.append({
                "name": f"{class_name.lower()}Registry",
                "class_name": class_name,
                "path": registry_path
            })
        
        # Generate main file
        main_template = self.jinja_env.get_template('main.ts.j2')
        return main_template.render(
            title=title,
            version=version,
            base_url=self.base_url,
            host=self.host,
            port=self.port,
            base_path=self.base_path,
            interfaces=interfaces,
            classes=classes,
            standalone_namespace=standalone_namespace,
            struct_registries=struct_registries
        )
