"""
TypeScript bindings generator for GIRest OpenAPI schemas using Jinja2 templates.

This module converts OpenAPI schemas generated by GIRest into TypeScript
bindings with proper class structure, inheritance, and type definitions.
"""
import os
from typing import Dict, List, Set, Optional, Any
from jinja2 import Environment, FileSystemLoader, Template

try:
    from .utils import parse_operation_id
except ImportError:
    # Fallback for when module is imported directly (e.g., in tests)
    from utils import parse_operation_id


class TypeScriptGenerator:
    """Generates TypeScript bindings from OpenAPI schema using Jinja2 templates."""
    
    # Reserved keywords in TypeScript/JavaScript
    RESERVED_KEYWORDS = {
        "function", "var", "let", "const", "class", "interface", "enum", "type",
        "namespace", "module", "import", "export", "default", "async", "await",
        "break", "case", "catch", "continue", "debugger", "delete", "do", "else",
        "finally", "for", "if", "in", "instanceof", "new", "return", "switch",
        "this", "throw", "try", "typeof", "void", "while", "with", "yield",
        "package", "implements", "private", "public", "protected", "static",
        # Common variable names that might conflict
        "data", "response", "error", "result", "value", "url"
    }
    
    def __init__(self, openapi_schema: Dict[str, Any], host: str = "localhost", port: int = 9000):
        """
        Initialize the generator with an OpenAPI schema.
        
        Args:
            openapi_schema: The OpenAPI schema dictionary from GIRest
            host: Host for REST API calls (default: 'localhost')
            port: Port for REST API calls (default: 9000)
        """
        self.schema = openapi_schema
        self.components = openapi_schema.get("components", {})
        self.schemas = self.components.get("schemas", {})
        self.paths = openapi_schema.get("paths", {})
        self.host = host
        self.port = port
        self.base_url = f"http://{host}:{port}"
        self.enum_schemas: Set[str] = set()
        self.class_methods: Dict[str, List[Dict]] = {}
        self.class_constructors: Dict[str, List[Dict]] = {}
        self.gobject_types: Set[str] = set()  # Track GObject-derived types
        self.callback_schemas: Set[str] = set()  # Track callback types
        self.standalone_functions: List[Dict] = []  # Track standalone functions without tags
        self.struct_destructors: Dict[str, Dict] = {}  # Track structs with destructors (free methods)
        
        # Setup Jinja2 environment
        template_dir = os.path.join(os.path.dirname(__file__), 'templates')
        self.jinja_env = Environment(
            loader=FileSystemLoader(template_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        # Identify enum schemas and GObject types
        self._identify_special_schemas()
        
        # Parse operations and organize by tag (class)
        self._parse_operations()
    
    def _safe_property_name(self, name: str) -> str:
        """
        Convert a schema property name to a safe TypeScript/JavaScript identifier.
        
        Appends an underscore to reserved keywords to avoid syntax errors.
        This method should be used for all property names in schemas (enums,
        structs, objects, callbacks, functions, etc).
        
        Args:
            name: The property name from the schema
            
        Returns:
            Safe TypeScript identifier (may have underscore appended)
        """
        if name in self.RESERVED_KEYWORDS:
            return f"{name}_"
        return name
    
    def _identify_special_schemas(self):
        """Identify which schemas are enums, callbacks, and which are GObject-based."""
        for schema_name, schema_def in self.schemas.items():
            # Identify enums
            if "enum" in schema_def and schema_def.get("type") == "string":
                self.enum_schemas.add(schema_name)
            
            # Identify callbacks
            if schema_def.get("x-gi-type") == "callback":
                self.callback_schemas.add(schema_name)
            
            # Identify GObject-based types by checking inheritance chain
            if self._is_gobject_type(schema_name, schema_def):
                self.gobject_types.add(schema_name)
    
    def _is_gobject_type(self, schema_name: str, schema_def: Dict[str, Any]) -> bool:
        """Check if a type is derived from GObject."""
        if schema_name.startswith("GObject"):
            return True
        
        if "allOf" in schema_def:
            for item in schema_def["allOf"]:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        if parent_name.startswith("GObject"):
                            return True
                        parent_schema = self.schemas.get(parent_name, {})
                        if self._is_gobject_type(parent_name, parent_schema):
                            return True
        return False
    
    def _parse_operations(self):
        """Parse all operations and organize them by tag (class name)."""
        for path, operations in self.paths.items():
            for method, operation in operations.items():
                if method.lower() not in ["get", "post", "put", "delete", "patch"]:
                    continue
                
                tags = operation.get("tags", [])
                method_info = {
                    "path": path,
                    "http_method": method,
                    "operation": operation,
                    "operation_id": operation.get("operationId", "")
                }
                
                if tags:
                    class_name = tags[0]
                    is_constructor = operation.get("x-gi-constructor", False)
                    is_destructor = operation.get("x-gi-destructor", False)
                    
                    if is_constructor:
                        if class_name not in self.class_constructors:
                            self.class_constructors[class_name] = []
                        self.class_constructors[class_name].append(method_info)
                    else:
                        if class_name not in self.class_methods:
                            self.class_methods[class_name] = []
                        self.class_methods[class_name].append(method_info)
                    
                    # Track destructors for struct finalization
                    if is_destructor:
                        self.struct_destructors[class_name] = method_info
                else:
                    # Standalone function without tags
                    self.standalone_functions.append(method_info)
    
    def _get_callback_type_signature(self, callback_ref: str) -> str:
        """Generate TypeScript function signature for a callback."""
        if not callback_ref.startswith("#/components/schemas/"):
            return "Function"
        
        callback_name = callback_ref.split("/")[-1]
        callback_schema = self.schemas.get(callback_name, {})
        
        if not callback_schema or callback_schema.get("x-gi-type") != "callback":
            return "Function"
        
        # Get callback properties
        properties = callback_schema.get("properties", {})
        param_list = []
        return_type = "void"
        
        # Iterate through properties to get parameters and return type
        for prop_name, prop_schema in properties.items():
            is_return = prop_schema.get("x-gi-is-return", False)
            
            if is_return:
                # This is the return type
                # Remove x-gi-is-return from schema before converting
                clean_schema = {k: v for k, v in prop_schema.items() if k != "x-gi-is-return"}
                return_type = self._openapi_type_to_ts(clean_schema)
            else:
                # This is a parameter
                # Use safe property name to handle reserved keywords
                ts_param_name = self._safe_property_name(prop_name)
                # Remove x-gi-transfer and x-gi-is-return from schema before converting
                clean_schema = {k: v for k, v in prop_schema.items() if k not in ["x-gi-transfer", "x-gi-is-return"]}
                param_type = self._openapi_type_to_ts(clean_schema)
                param_list.append(f"{ts_param_name}: {param_type}")
        
        params_str = ", ".join(param_list)
        return f"({params_str}) => {return_type}"
    
    def _openapi_type_to_ts(self, schema: Dict[str, Any], nullable: bool = False) -> str:
        """Convert an OpenAPI schema type to TypeScript type."""
        if not schema:
            return "any"
        
        if "$ref" in schema:
            ref_path = schema["$ref"]
            if ref_path.startswith("#/components/schemas/"):
                type_name = ref_path.split("/")[-1]
                # If this is an enum with methods, use the Value suffix
                if type_name in self.enum_schemas and type_name in self.class_methods:
                    type_name = type_name + "Value"
                return type_name + (" | null" if nullable else "")
        
        if "oneOf" in schema:
            types = [self._openapi_type_to_ts(s) for s in schema["oneOf"]]
            union = " | ".join(types)
            return f"({union})" + (" | null" if nullable else "")
        
        schema_type = schema.get("type")
        
        if schema_type == "string":
            enum_values = schema.get("enum")
            if enum_values:
                literals = " | ".join([f'"{v}"' for v in enum_values])
                return literals + (" | null" if nullable else "")
            return "string" + (" | null" if nullable else "")
        
        elif schema_type == "integer" or schema_type == "number":
            return "number" + (" | null" if nullable else "")
        
        elif schema_type == "boolean":
            return "boolean" + (" | null" if nullable else "")
        
        elif schema_type == "array":
            items = schema.get("items", {})
            item_type = self._openapi_type_to_ts(items)
            return f"{item_type}[]" + (" | null" if nullable else "")
        
        elif schema_type == "object":
            properties = schema.get("properties", {})
            if properties:
                prop_types = []
                required = schema.get("required", [])
                for prop_name, prop_schema in properties.items():
                    is_required = prop_name in required
                    prop_type = self._openapi_type_to_ts(prop_schema)
                    optional_marker = "" if is_required else "?"
                    safe_name = self._safe_property_name(prop_name)
                    prop_types.append(f"{safe_name}{optional_marker}: {prop_type}")
                return "{ " + "; ".join(prop_types) + " }" + (" | null" if nullable else "")
            return "object" + (" | null" if nullable else "")
        
        return "any" + (" | null" if nullable else "")
    
    def _prepare_interface_data(self, name: str, schema: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare data for interface template."""
        data = {"name": name}
        
        # Handle enums
        if "enum" in schema and schema.get("type") == "string":
            enum_values = schema["enum"]
            has_methods = name in self.class_methods
            
            if has_methods:
                data["is_enum_with_methods"] = True
                data["enum_values"] = [
                    {
                        "const_name": value.upper().replace("-", "_").replace(".", "_"),
                        "value": value
                    }
                    for value in enum_values
                ]
                literals = " | ".join([f'"{v}"' for v in enum_values])
                data["enum_value_union"] = literals
            else:
                data["is_enum"] = True
                literals = " | ".join([f'"{v}"' for v in enum_values])
                data["enum_value_union"] = literals
            
            return data
        
        # Handle allOf (inheritance)
        if "allOf" in schema:
            all_of = schema["allOf"]
            parent_refs = []
            own_props = {}
            
            for item in all_of:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        parent_name = ref_path.split("/")[-1]
                        parent_refs.append(parent_name)
                elif "type" in item and item["type"] == "object":
                    own_props = item.get("properties", {})
            
            if parent_refs:
                data["has_parent"] = True
                data["parent"] = ", ".join(parent_refs)
                required = schema.get("required", [])
                data["properties"] = [
                    {
                        "name": prop_name,
                        "optional": "" if prop_name in required else "?",
                        "type": self._openapi_type_to_ts(prop_schema)
                    }
                    for prop_name, prop_schema in own_props.items()
                ]
            else:
                data["properties"] = []
        else:
            # Regular object
            properties = schema.get("properties", {})
            required = schema.get("required", [])
            data["properties"] = [
                {
                    "name": self._safe_property_name(prop_name),
                    "optional": "" if prop_name in required else "?",
                    "type": self._openapi_type_to_ts(prop_schema)
                }
                for prop_name, prop_schema in properties.items()
            ]
        
        return data
    
    def _prepare_method_data(self, method_info: Dict[str, Any], class_name: str, is_constructor: bool = False) -> Dict[str, Any]:
        """Prepare data for method template."""
        operation = method_info["operation"]
        path = method_info["path"]
        
        # Extract method name from path
        method_name = path.split("/")[-1].replace("{", "").replace("}", "")
        
        # Build parameter list
        params = operation.get("parameters", [])
        required_params = []
        optional_params = []
        query_params = []
        path_params = []
        has_self_param = False
        
        # Check if this method has callbacks
        callbacks = operation.get("x-gi-callbacks", {})
        callback_params = []
        
        for param in params:
            param_name = param.get("name", "")
            param_schema = param.get("schema", {})
            param_required = param.get("required", False)
            param_in = param.get("in", "query")
            param_transfer = param.get("x-gi-transfer", "none")
            param_style = param.get("style", "form" if param_in == "query" else "simple")
            param_explode = param.get("explode", True if param_style == "form" else False)
            
            if param_name == "self":
                has_self_param = True
                path_params.append((param_name, param_schema, param_style, param_explode))
                continue
            
            # Use safe property name to handle reserved keywords
            ts_param_name = self._safe_property_name(param_name)
            
            param_type = self._openapi_type_to_ts(param_schema)
            optional_marker = "" if param_required else "?"
            param_str = f"{ts_param_name}{optional_marker}: {param_type}"
            
            # Separate required and optional parameters
            if param_required:
                required_params.append(param_str)
            else:
                optional_params.append(param_str)
            
            # Check if this parameter is a GObject type (needs ref counting)
            is_gobject_param = False
            is_object_param = False
            if "$ref" in param_schema:
                ref_path = param_schema["$ref"]
                if ref_path.startswith("#/components/schemas/"):
                    type_name = ref_path.split("/")[-1]
                    is_gobject_param = type_name in self.gobject_types
                    # Check if this is an object type that needs serialization
                    schema_def = self.schemas.get(type_name, {})
                    if schema_def.get("type") == "object" or "allOf" in schema_def:
                        is_object_param = True
            
            if param_in == "path":
                path_params.append((param_name, param_schema, param_style, param_explode))
            elif param_in == "query":
                query_params.append({
                    "name": ts_param_name,  # Use renamed parameter
                    "api_name": param_name,  # Original name for API call
                    "required": param_required,
                    "transfer": param_transfer,
                    "is_gobject": is_gobject_param,
                    "is_object": is_object_param,
                    "style": param_style,
                    "explode": param_explode
                })
        
        # Add callback parameters to method signature
        for callback_name, callback_ref in callbacks.items():
            callback_type = self._get_callback_type_signature(callback_ref)
            safe_callback_name = self._safe_property_name(callback_name)
            required_params.append(f"{safe_callback_name}: {callback_type}")
            callback_params.append({
                "name": safe_callback_name,
                "api_name": callback_name,  # Original name for API
                "type_ref": callback_ref
            })
        
        # Combine required and optional parameters (required first)
        method_params = required_params + optional_params
        
        # Determine return type
        return_type = "void"
        response_has_return = False
        responses = operation.get("responses", {})
        
        if "200" in responses:
            content = responses["200"].get("content", {})
            app_json = content.get("application/json", {})
            schema = app_json.get("schema", {})
            
            if schema:
                props = schema.get("properties", {})
                if "return" in props:
                    if is_constructor:
                        return_type = class_name
                    else:
                        return_type = self._openapi_type_to_ts(props["return"])
                    response_has_return = True
                elif props:
                    return_type = self._openapi_type_to_ts(schema)
                else:
                    return_type = "void"
        
        # Build URL path with proper serialization for object parameters
        url_path = path
        path_param_info = []
        for param_tuple in path_params:
            param_name = param_tuple[0]
            param_schema = param_tuple[1]
            param_style = param_tuple[2] if len(param_tuple) > 2 else "simple"
            param_explode = param_tuple[3] if len(param_tuple) > 3 else False
            
            # Check if this is an object type
            is_object_param = False
            if "$ref" in param_schema:
                ref_path = param_schema["$ref"]
                if ref_path.startswith("#/components/schemas/"):
                    type_name = ref_path.split("/")[-1]
                    schema_def = self.schemas.get(type_name, {})
                    if schema_def.get("type") == "object" or "allOf" in schema_def:
                        is_object_param = True
            
            if param_name == "self":
                if is_object_param:
                    # For object types in path, serialize according to style/explode
                    # style=simple, explode=false (default): {ptr: "0x123"} -> "ptr,0x123"
                    url_path = url_path.replace("{self}", "${serializeParam(this, 'simple', false)}")
                else:
                    url_path = url_path.replace("{self}", "${this.ptr}")
                path_param_info.append({"name": param_name, "is_object": is_object_param, "style": param_style, "explode": param_explode})
            else:
                if is_object_param:
                    url_path = url_path.replace(f"{{{param_name}}}", f"${{serializeParam({param_name}, '{param_style}', {str(param_explode).lower()})}}")
                else:
                    url_path = url_path.replace(f"{{{param_name}}}", f"${{{param_name}}}")
                path_param_info.append({"name": param_name, "is_object": is_object_param, "style": param_style, "explode": param_explode})
        
        is_enum = class_name in self.enum_schemas
        
        return {
            "name": method_name,
            "params": ", ".join(method_params),
            "return_type": return_type,
            "is_static": is_constructor or is_enum,
            "with_impl": True,
            "base_url": self.base_url,
            "host": self.host,
            "port": self.port,
            "path": url_path,
            "query_params": query_params,
            "callback_params": callback_params,
            "is_constructor": is_constructor,
            "has_return": response_has_return,
            "class_name": class_name
        }
    
    def _get_direct_parent(self, class_name: str) -> Optional[str]:
        """Get the direct parent class from the schema's allOf."""
        schema = self.schemas.get(class_name, {})
        if "allOf" in schema:
            for item in schema["allOf"]:
                if "$ref" in item:
                    ref_path = item["$ref"]
                    if ref_path.startswith("#/components/schemas/"):
                        return ref_path.split("/")[-1]
        return None
    
    def _prepare_class_data(self, class_name: str) -> Dict[str, Any]:
        """Prepare data for class template."""
        is_enum = class_name in self.enum_schemas
        schema = self.schemas.get(class_name, {})
        extends_gobject = class_name in self.gobject_types
        has_interface = class_name in self.schemas and not is_enum
        
        # Get the direct parent for inheritance
        parent_class = None
        if extends_gobject and self.base_url:
            parent_class = self._get_direct_parent(class_name)
        
        # Check if this struct has a destructor
        has_destructor = class_name in self.struct_destructors
        destructor_info = self.struct_destructors.get(class_name, {})
        destructor_path = ""
        destructor_method_name = "free"
        destructor_registry = ""
        
        if has_destructor:
            # Get the destructor path and method name
            destructor_path = destructor_info.get("path", "")
            operation = destructor_info.get("operation", {})
            operation_id = operation.get("operationId", "")
            # Extract method name from operation ID using shared utility
            parsed = parse_operation_id(operation_id)
            if parsed and parsed[2]:
                destructor_method_name = parsed[2]
            destructor_registry = f"{class_name.lower()}Registry"
        
        data = {
            "name": class_name,
            "is_enum": is_enum,
            "base_url": self.base_url,
            "host": self.host,
            "port": self.port,
            "extends_gobject": extends_gobject,
            "parent_class": parent_class,
            "has_interface": has_interface,
            "has_destructor": has_destructor,
            "destructor_path": destructor_path,
            "destructor_method_name": destructor_method_name,
            "destructor_registry": destructor_registry,
            "properties": [],
            "constructors": [],
            "methods": []
        }
        
        if is_enum:
            # Enum namespace with methods
            if class_name in self.class_methods:
                method_template = self.jinja_env.get_template('method.ts.j2')
                for method_info in self.class_methods[class_name]:
                    method_data = self._prepare_method_data(method_info, class_name)
                    data["methods"].append(method_template.render(method_data))
        else:
            # Regular class
            if schema and (not self.base_url or not extends_gobject):
                # Add properties if not using GObjectBase
                properties = schema.get("properties", {})
                required = schema.get("required", [])
                
                if "allOf" in schema:
                    all_of = schema["allOf"]
                    for item in all_of:
                        if "type" in item and item["type"] == "object":
                            properties = item.get("properties", {})
                            break
                
                data["properties"] = [
                    {
                        "name": prop_name,
                        "assertion": "!" if prop_name in required else "?",
                        "type": self._openapi_type_to_ts(prop_schema)
                    }
                    for prop_name, prop_schema in properties.items()
                ]
            
            # Add constructors
            if class_name in self.class_constructors:
                method_template = self.jinja_env.get_template('method.ts.j2')
                for constructor_info in self.class_constructors[class_name]:
                    constructor_data = self._prepare_method_data(constructor_info, class_name, is_constructor=True)
                    data["constructors"].append(method_template.render(constructor_data).rstrip())
            
            # Add methods
            if class_name in self.class_methods:
                method_template = self.jinja_env.get_template('method.ts.j2')
                for method_info in self.class_methods[class_name]:
                    method_data = self._prepare_method_data(method_info, class_name)
                    # Skip 'unref' method for GObjectObject as it's provided by the base class
                    if class_name == "GObjectObject" and method_data.get("name") == "unref":
                        continue
                    # Skip destructor method for structs as it's provided by the class constructor
                    if has_destructor and method_data.get("name") == destructor_method_name:
                        continue
                    data["methods"].append(method_template.render(method_data).rstrip())
        
        return data
    
    def generate(self) -> str:
        """
        Generate complete TypeScript bindings.
        
        Returns:
            TypeScript code as a string
        """
        title = self.schema.get("info", {}).get("title", "API")
        version = self.schema.get("info", {}).get("version", "1.0")
        
        # Generate type aliases (only for enums)
        interface_template = self.jinja_env.get_template('interface.ts.j2')
        interfaces = []
        
        for schema_name, schema_def in self.schemas.items():
            gi_type = schema_def.get("x-gi-type", "")
            
            # Generate type definitions for enums, flags, and structs
            # Skip object types - they will have classes
            if gi_type not in ["enum", "flags", "struct"]:
                continue
            
            # Skip structs with methods - they will be generated as classes
            if gi_type == "struct" and schema_name in self.class_methods:
                continue
            
            interface_data = self._prepare_interface_data(schema_name, schema_def)
            interface_code = interface_template.render(interface_data).rstrip()
            
            # If this is an enum with methods, append the methods
            if schema_name in self.enum_schemas and schema_name in self.class_methods:
                method_template = self.jinja_env.get_template('method.ts.j2')
                methods = []
                for method_info in self.class_methods[schema_name]:
                    method_data = self._prepare_method_data(method_info, schema_name)
                    # In namespaces, we don't use the static keyword
                    method_data["is_namespace_function"] = True
                    methods.append(method_template.render(method_data).rstrip())
                
                # Insert methods into the namespace
                lines = interface_code.split("\n")
                namespace_end_idx = -1
                for i, line in enumerate(lines):
                    if line.strip() == "}":
                        namespace_end_idx = i
                        break
                
                if namespace_end_idx >= 0:
                    output_lines = lines[:namespace_end_idx]
                    output_lines.extend(methods)
                    output_lines.extend(lines[namespace_end_idx:])
                    interface_code = "\n".join(output_lines)
            
            interfaces.append(interface_code)
        
        # Generate classes
        class_template = self.jinja_env.get_template('class.ts.j2')
        classes = []
        
        # Collect all class names that need to be generated
        # Include classes with methods and all GObject types in the inheritance chain
        classes_to_generate = set()
        for class_name in self.class_methods.keys():
            if class_name not in self.enum_schemas:
                classes_to_generate.add(class_name)
                # Add all parent classes in the inheritance chain
                parent = self._get_direct_parent(class_name)
                while parent:
                    if parent in self.gobject_types:
                        classes_to_generate.add(parent)
                    parent = self._get_direct_parent(parent)
        
        # Generate classes in dependency order (parents before children)
        # We need to ensure parent classes are defined before child classes
        generated = set()
        
        def generate_class_with_parents(class_name: str):
            """Recursively generate a class and its parents."""
            if class_name in generated:
                return
            
            # First generate the parent
            parent = self._get_direct_parent(class_name)
            if parent and parent in classes_to_generate:
                generate_class_with_parents(parent)
            
            # Then generate this class
            class_data = self._prepare_class_data(class_name)
            classes.append(class_template.render(class_data))
            generated.add(class_name)
        
        # Generate all classes
        for class_name in sorted(classes_to_generate):
            generate_class_with_parents(class_name)
        
        # Generate standalone functions namespace
        standalone_namespace = ""
        if self.standalone_functions:
            # Extract namespace name from the first function's operation_id
            # Format: {namespace}--{function_name}
            first_func = self.standalone_functions[0]
            op_id = first_func.get("operation_id", "")
            namespace_name = op_id.split("-")[0] if op_id else "Functions"
            
            method_template = self.jinja_env.get_template('method.ts.j2')
            methods = []
            for func_info in self.standalone_functions:
                method_data = self._prepare_method_data(func_info, namespace_name)
                # Standalone functions are namespace functions (no static keyword)
                method_data["is_namespace_function"] = True
                methods.append(method_template.render(method_data).rstrip())
            
            standalone_namespace = f"export namespace {namespace_name} {{\n"
            standalone_namespace += "\n".join(methods)
            standalone_namespace += "\n}"
        
        # Prepare struct registries for finalization
        struct_registries = []
        for class_name, destructor_info in self.struct_destructors.items():
            destructor_path = destructor_info.get("path", "")
            struct_registries.append({
                "name": f"{class_name.lower()}Registry",
                "class_name": class_name,
                "path": destructor_path
            })
        
        # Generate main file
        main_template = self.jinja_env.get_template('main.ts.j2')
        return main_template.render(
            title=title,
            version=version,
            base_url=self.base_url,
            host=self.host,
            port=self.port,
            interfaces=interfaces,
            classes=classes,
            standalone_namespace=standalone_namespace,
            struct_registries=struct_registries
        )
