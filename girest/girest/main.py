import argparse
import json

import gi
gi.require_version("GIRepository", "2.0")
from gi.repository import GIRepository
from apispec import APISpec


class GIRest():
    pointer_schema = {
        "oneOf": [
            {"type": "integer"},
            {"type": "string", "pattern": "^0x[0-9a-fA-F]+$|^[0-9]+$"}
        ],
    }

    def __init__(self, ns, ns_version):
        self.ns = ns
        self.ns_version = ns_version
        # To keep track of schemas already registered
        self.schemas = {}
        self.spec = APISpec(
            title=f"{ns} REST API",
            version=f"{ns_version}",
            openapi_version="3.0.2",
            info={
                "description": "API schema autogenerated by giREST"
            },
        )
        # Include the Pointer definition
        self.spec.components.schema("Pointer", GIRest.pointer_schema)
        # Load the corresponding Gir file
        self.repo = GIRepository.Repository()
        self.repo.require(ns, ns_version, 0)

    def _type_to_schema(self, t):
        """Convert GIRepository type to OpenAPI schema"""
        tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(t))
        
        # Check if it's an interface type
        if tag == "interface":
            interface = GIRepository.type_info_get_interface(t)
            if interface:
                info_type = interface.get_type()
                if info_type == GIRepository.InfoType.ENUM or info_type == GIRepository.InfoType.FLAGS:
                    # Generate the enum schema if not already generated
                    self._generate_enum(interface)
                    # Return reference to the enum schema
                    full_name = f"{interface.get_namespace()}{interface.get_name()}"
                    return {"$ref": f"#/components/schemas/{full_name}"}
                elif info_type == GIRepository.InfoType.OBJECT:
                    # Generate the object schema if not already generated
                    self._generate_object(interface)
                    # Return reference to the object schema
                    full_name = f"{interface.get_namespace()}{interface.get_name()}"
                    return {"$ref": f"#/components/schemas/{full_name}"}
                elif info_type == GIRepository.InfoType.STRUCT:
                    # Check if this is a GType struct - these are not exposed in the schema
                    if GIRepository.struct_info_is_gtype_struct(interface):
                        # GType structs are treated as opaque pointers
                        return {"$ref": "#/components/schemas/Pointer"}
                    # Generate the struct schema if not already generated
                    self._generate_struct(interface)
                    # Return reference to the struct schema
                    full_name = f"{interface.get_namespace()}{interface.get_name()}"
                    return {"$ref": f"#/components/schemas/{full_name}"}
                elif info_type == GIRepository.InfoType.CALLBACK:
                    # Callbacks are represented as integers (callback IDs)
                    return {"type": "integer"}
        
        # Map GIRepository type tags to OpenAPI types
        # Note: OpenAPI 3.0 doesn't distinguish between signed and unsigned integers
        # at the schema level - both use 'integer' type. Format specifications (int32, int64)
        # indicate precision but not signedness. For consistency, we:
        # - Omit format for 8/16-bit integers (no standard OpenAPI format exists)
        # - Use format: int32 for gint32 (most common)
        # - Omit format for guint32 (to avoid implying signedness)
        # - Use format: int64 for both gint64/guint64 (indicates 64-bit precision)
        type_map = {
            "gboolean": {"type": "boolean"},
            "gint8": {"type": "integer"},
            "guint8": {"type": "integer"},
            "gint16": {"type": "integer"},
            "guint16": {"type": "integer"},
            "gint32": {"type": "integer", "format": "int32"},
            "guint32": {"type": "integer"},
            "gint64": {"type": "integer", "format": "int64"},
            "guint64": {"type": "integer", "format": "int64"},
            "utf8": {"type": "string"},
            "gfloat": {"type": "number", "format": "float"},
            "gdouble": {"type": "number", "format": "double"},
            "void": None
        }
        
        return type_map.get(tag, {"$ref": "#/components/schemas/Pointer"})

    def _generate_function(self, bim, bi=None):
        api = f"/{bim.get_namespace()}"
        if bi:
            api += f"/{bi.get_name()}"
        if GIRepository.function_info_get_flags(bim) & 1:
            api += "/{self}"
        api += f"/{bim.get_name()}"
        
        # Handle the parameters
        params = []
        response_props = {}
        
        # Add self parameter for methods
        if GIRepository.function_info_get_flags(bim) & 1:
            params.append({
               "name": "self",
               "in": "path",
               "required": True,
               "schema": {"$ref": f"#/components/schemas/{bi.get_namespace()}{bi.get_name()}"},
               "description": ""
            })
        
        # Get number of arguments
        n_args = GIRepository.callable_info_get_n_args(bim)
        
        # First pass: identify which arguments should be skipped
        skip_indices = set()
        for i in range(n_args):
            arg = GIRepository.callable_info_get_arg(bim, i)
            arg_type = GIRepository.arg_info_get_type(arg)
            tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(arg_type))
            
            # Check if this is a callback
            if tag == "interface":
                interface = GIRepository.type_info_get_interface(arg_type)
                if interface and interface.get_type() == GIRepository.InfoType.CALLBACK:
                    # Mark closure and destroy arguments to be skipped
                    closure_idx = GIRepository.arg_info_get_closure(arg)
                    if closure_idx >= 0:
                        skip_indices.add(closure_idx)
                    destroy_idx = GIRepository.arg_info_get_destroy(arg)
                    if destroy_idx >= 0:
                        skip_indices.add(destroy_idx)
        
        # Second pass: process all arguments
        for i in range(n_args):
            arg = GIRepository.callable_info_get_arg(bim, i)
            arg_type = GIRepository.arg_info_get_type(arg)
            arg_name = arg.get_name()
            arg_direction = GIRepository.arg_info_get_direction(arg)
            
            # Skip arguments that are marked as skipped
            if i in skip_indices:
                continue
            
            # Check if this is a callback
            tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(arg_type))
            if tag == "interface":
                interface = GIRepository.type_info_get_interface(arg_type)
                if interface and interface.get_type() == GIRepository.InfoType.CALLBACK:
                    # Add callback ID to response
                    response_props[arg_name] = {"type": "integer", "description": "Callback ID"}
                    continue
            
            # Handle output parameters - they go in the response
            if arg_direction == GIRepository.Direction.OUT:
                schema = self._type_to_schema(arg_type)
                if schema:
                    response_props[arg_name] = schema
                continue
            
            # Handle input and inout parameters
            schema = self._type_to_schema(arg_type)
            if not schema:
                continue
                
            # INOUT parameters go in both request and response
            if arg_direction == GIRepository.Direction.INOUT:
                response_props[arg_name] = schema
            
            # Add as query parameter
            param_schema = schema.copy()
            may_be_null = GIRepository.arg_info_may_be_null(arg)
            
            # Get transfer ownership information
            transfer = GIRepository.arg_info_get_ownership_transfer(arg)
            if transfer == GIRepository.Transfer.NOTHING:
                transfer_str = "none"
            elif transfer == GIRepository.Transfer.CONTAINER:
                transfer_str = "container"
            elif transfer == GIRepository.Transfer.EVERYTHING:
                transfer_str = "full"
            else:
                transfer_str = "none"
            
            params.append({
                "name": arg_name,
                "in": "query",
                "required": not may_be_null,
                "schema": param_schema,
                "description": "",
                "x-gi-transfer": transfer_str
            })
        
        # Handle the return value
        return_type = GIRepository.callable_info_get_return_type(bim)
        return_schema = self._type_to_schema(return_type)
        if return_schema:
            response_props["return"] = return_schema
        
        # Build response schema
        responses = {}
        if response_props:
            responses["200"] = {
                "description": "Success",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "properties": response_props
                        }
                    }
                }
            }
        else:
            responses["204"] = {"description": "No Content"}
        
        # Check if this is a constructor method
        flags = GIRepository.function_info_get_flags(bim)
        is_constructor = bool(flags & GIRepository.FunctionInfoFlags.IS_CONSTRUCTOR)
        
        # Build operation definition
        operation = {
            "summary": "",
            "description": "",
            "operationId": f"{bim.get_namespace()}-{bi.get_name() if bi else ''}-{bim.get_name()}",
            "tags": [f"{bi.get_namespace()}{bi.get_name()}"] if bi else [],
            "parameters": params,
            "responses": responses,
            "x-gi-constructor": is_constructor
        }
        
        # Add paths, components, etc. programmatically
        self.spec.path(path=api, operations={
            "get": operation
        })

    def _generate_object(self, bi):
        # If we already registered that, skip it
        full_name = f"{bi.get_namespace()}{bi.get_name()}"
        if full_name in self.schemas:
            return
        
        # Mark as generated early to prevent circular dependencies
        self.schemas[full_name] = True
        
        # Generate the type for every parent
        parent = GIRepository.object_info_get_parent(bi)
        if parent:
            self._generate_object(parent)
            full_parent_name = f"{parent.get_namespace()}{parent.get_name()}"
            self.spec.components.schema(
                full_name,
                {
                    "allOf": [
                        {"$ref": f"#/components/schemas/{full_parent_name}"},
                        {
                            "type": "object",
                        }
                    ],
                    "x-gi-type": "object"
                }
           )
        else:
            self.spec.components.schema(
                full_name,
                {
                    "type": "object",
                    "properties": {
                        "ptr": {"$ref": "#/components/schemas/Pointer"},
                    },
                    "required": ["ptr"],
                    "x-gi-type": "object"
                }
            )
        # Now the member functions
        for i in range(0, GIRepository.object_info_get_n_methods(bi)):
            bim = GIRepository.object_info_get_method(bi, i)
            self._generate_function(bim, bi)

    def _generate_struct(self, bi):
        if GIRepository.struct_info_is_gtype_struct(bi):
            return
        # TODO Structs with private fields can not be serialized
        # TODO Structs with a constructor can not be serialized
        # TODO Get free_function
        
        # For now, generate a basic schema for structs as opaque pointer types
        # This prevents dangling references when structs are used as parameters
        full_name = f"{bi.get_namespace()}{bi.get_name()}"
        if full_name in self.schemas:
            return
        
        self.spec.components.schema(
            full_name,
            {
                "type": "object",
                "properties": {
                    "ptr": {"$ref": "#/components/schemas/Pointer"},
                },
                "required": ["ptr"],
                "x-gi-type": "struct"
            }
        )
        
        # Mark as generated
        self.schemas[full_name] = True

    def _generate_enum(self, bi):
        """Generate OpenAPI schema for an enum"""
        full_name = f"{bi.get_namespace()}{bi.get_name()}"
        if full_name in self.schemas:
            return
        
        # Mark as generated early to prevent circular dependencies
        self.schemas[full_name] = True
        
        # Get all enum values
        n_values = GIRepository.enum_info_get_n_values(bi)
        enum_values = []
        for i in range(n_values):
            value_info = GIRepository.enum_info_get_value(bi, i)
            enum_values.append(value_info.get_name())
        
        # Create enum schema with string values
        # OpenAPI will accept string values, but we'll need to convert them
        # to integers when calling Frida
        info_type = bi.get_type()
        gi_type = "enum" if info_type == GIRepository.InfoType.ENUM else "flags"
        
        self.spec.components.schema(
            full_name,
            {
                "type": "string",
                "enum": enum_values,
                "description": f"Enum values for {bi.get_name()}",
                "x-gi-type": gi_type
            }
        )
        
        # Generate endpoints for enum methods
        for i in range(0, GIRepository.enum_info_get_n_methods(bi)):
            bim = GIRepository.enum_info_get_method(bi, i)
            self._generate_function(bim, bi)

    def generate(self):
        # Generate the types
        for i in range(0, self.repo.get_n_infos(self.ns)):
            info = self.repo.get_info(self.ns, i)
            info_type = info.get_type()
            if info_type == GIRepository.InfoType.OBJECT:
                self._generate_object(info)
            elif info_type == GIRepository.InfoType.STRUCT:
                self._generate_struct(info)
            elif info_type == GIRepository.InfoType.ENUM:
                self._generate_enum(info)
            elif info_type == GIRepository.InfoType.FLAGS:
                self._generate_enum(info)
            elif info_type == GIRepository.InfoType.FUNCTION:
                self._generate_function(info)
        return self.spec





def run():
    # Parse the args
    ns = "Gst"
    ns_version = "1.0"

    girest = GIRest(ns, ns_version)
    spec = girest.generate()
    # Export to dict (for JSON/YAML serialization)
    openapi_schema = spec.to_dict()
    print(json.dumps(openapi_schema, indent=2))


# FIXME remove this once launched through poetry
if __name__ == "__main__":
    run()
