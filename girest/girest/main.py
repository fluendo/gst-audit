import argparse
import json

import connexion
import gi
gi.require_version("GIRepository", "2.0")
from gi.repository import GIRepository
from apispec import APISpec


class GIRest():
    pointer_schema = {
        "oneOf": [
            {"type": "integer"},
            {"type": "string", "pattern": "^0x[0-9a-fA-F]+$|^[0-9]+$"}
        ],
    }

    def __init__(self, ns, ns_version):
        self.ns = ns
        self.ns_version = ns_version
        # To keep track of schemas already registered
        self.schemas = {}
        self.spec = APISpec(
            title=f"{ns} REST API",
            version=f"{ns_version}",
            openapi_version="3.0.2",
            info={
                "description": "API schema autogenerated by giREST"
            },
        )
        # Include the Pointer definition
        self.spec.components.schema("Pointer", GIRest.pointer_schema)
        # Load the corresponding Gir file
        self.repo = GIRepository.Repository()
        self.repo.require(ns, ns_version, 0)

    def _type_to_schema(self, t):
        """Convert GIRepository type to OpenAPI schema"""
        tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(t))
        
        # Check if it's an interface type
        if tag == "interface":
            interface = GIRepository.type_info_get_interface(t)
            if interface:
                info_type = interface.get_type()
                if info_type == GIRepository.InfoType.ENUM or info_type == GIRepository.InfoType.FLAGS:
                    # Return integer for enums
                    return {"type": "integer"}
                elif info_type == GIRepository.InfoType.OBJECT or info_type == GIRepository.InfoType.STRUCT:
                    # Return reference to the object schema
                    full_name = f"{interface.get_namespace()}{interface.get_name()}"
                    return {"$ref": f"#/components/schemas/{full_name}"}
                elif info_type == GIRepository.InfoType.CALLBACK:
                    # Callbacks are represented as integers (callback IDs)
                    return {"type": "integer"}
        
        # Map GIRepository type tags to OpenAPI types
        # Note: OpenAPI 3.0 doesn't have specific formats for 8/16-bit integers
        # or unsigned integers, so we use the closest representations
        type_map = {
            "gboolean": {"type": "boolean"},
            "gint8": {"type": "integer"},
            "guint8": {"type": "integer"},
            "gint16": {"type": "integer"},
            "guint16": {"type": "integer"},
            "gint32": {"type": "integer", "format": "int32"},
            "guint32": {"type": "integer"},
            "gint64": {"type": "integer", "format": "int64"},
            "guint64": {"type": "integer", "format": "int64"},
            "utf8": {"type": "string"},
            "gfloat": {"type": "number", "format": "float"},
            "gdouble": {"type": "number", "format": "double"},
            "void": None
        }
        
        return type_map.get(tag, {"$ref": "#/components/schemas/Pointer"})

    def _generate_function(self, bim, bi=None):
        api = f"/{bim.get_namespace()}"
        if bi:
            api += f"/{bi.get_name()}"
        if GIRepository.function_info_get_flags(bim) & 1:
            api += "/{self}"
        api += f"/{bim.get_name()}"
        
        # Handle the parameters
        params = []
        response_props = {}
        
        # Add self parameter for methods
        if GIRepository.function_info_get_flags(bim) & 1:
            params.append({
               "name": "self",
               "in": "path",
               "required": True,
               "schema": {"$ref": f"#/components/schemas/{bi.get_namespace()}{bi.get_name()}"},
               "description": ""
            })
        
        # Get number of arguments
        n_args = GIRepository.callable_info_get_n_args(bim)
        
        # First pass: identify which arguments should be skipped
        skip_indices = set()
        for i in range(n_args):
            arg = GIRepository.callable_info_get_arg(bim, i)
            arg_type = GIRepository.arg_info_get_type(arg)
            tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(arg_type))
            
            # Check if this is a callback
            if tag == "interface":
                interface = GIRepository.type_info_get_interface(arg_type)
                if interface and interface.get_type() == GIRepository.InfoType.CALLBACK:
                    # Mark closure and destroy arguments to be skipped
                    closure_idx = GIRepository.arg_info_get_closure(arg)
                    if closure_idx >= 0:
                        skip_indices.add(closure_idx)
                    destroy_idx = GIRepository.arg_info_get_destroy(arg)
                    if destroy_idx >= 0:
                        skip_indices.add(destroy_idx)
        
        # Second pass: process all arguments
        for i in range(n_args):
            arg = GIRepository.callable_info_get_arg(bim, i)
            arg_type = GIRepository.arg_info_get_type(arg)
            arg_name = arg.get_name()
            arg_direction = GIRepository.arg_info_get_direction(arg)
            
            # Skip arguments that are marked as skipped
            if i in skip_indices:
                continue
            
            # Check if this is a callback
            tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(arg_type))
            if tag == "interface":
                interface = GIRepository.type_info_get_interface(arg_type)
                if interface and interface.get_type() == GIRepository.InfoType.CALLBACK:
                    # Add callback ID to response
                    response_props[arg_name] = {"type": "integer", "description": "Callback ID"}
                    continue
            
            # Handle output parameters - they go in the response
            if arg_direction == GIRepository.Direction.OUT:
                schema = self._type_to_schema(arg_type)
                if schema:
                    response_props[arg_name] = schema
                continue
            
            # Handle input and inout parameters
            schema = self._type_to_schema(arg_type)
            if not schema:
                continue
                
            # INOUT parameters go in both request and response
            if arg_direction == GIRepository.Direction.INOUT:
                response_props[arg_name] = schema
            
            # Add as query parameter
            param_schema = schema.copy()
            may_be_null = GIRepository.arg_info_may_be_null(arg)
            
            params.append({
                "name": arg_name,
                "in": "query",
                "required": not may_be_null,
                "schema": param_schema,
                "description": ""
            })
        
        # Handle the return value
        return_type = GIRepository.callable_info_get_return_type(bim)
        return_schema = self._type_to_schema(return_type)
        if return_schema:
            response_props["return"] = return_schema
        
        # Build response schema
        responses = {}
        if response_props:
            responses["200"] = {
                "description": "Success",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "properties": response_props
                        }
                    }
                }
            }
        else:
            responses["204"] = {"description": "No Content"}
        
        # Add paths, components, etc. programmatically
        self.spec.path(path=api, operations={
            "get": {
                "summary": "",
                "description": "",
                "operationId": f"{bim.get_namespace()}_{bi.get_name() if bi else ''}_{bim.get_name()}",
                "tags": [f"{bi.get_namespace()}{bi.get_name()}"] if bi else [],
                "parameters": params,
                "responses": responses,
            }
        })

    def _generate_object(self, bi):
        # If we already registered that, skip it
        full_name = f"{bi.get_namespace()}{bi.get_name()}"
        if full_name in self.schemas:
            return
        # Generate the type for every parent
        parent = GIRepository.object_info_get_parent(bi)
        if parent:
            self._generate_object(parent)
            full_parent_name = f"{parent.get_namespace()}{parent.get_name()}"
            self.spec.components.schema(
                full_name,
                {
                    "allOf": [
                        {"$ref": f"#/components/schemas/{full_parent_name}"},
                        {
                            "type": "object",
                        }
                    ]
                }
           )
        else:
            self.spec.components.schema(
                full_name,
                {
                    "type": "object",
                    "properties": {
                        "ptr": {"$ref": "#/components/schemas/Pointer"},
                    },
                    "required": ["ptr"]
                }
            )
        # Now the member functions
        for i in range(0, GIRepository.object_info_get_n_methods(bi)):
            bim = GIRepository.object_info_get_method(bi, i)
            self._generate_function(bim, bi)
        # Mark it as generated
        self.schemas[full_name] = True

    def _generate_struct(self, bi):
        if GIRepository.struct_info_is_gtype_struct(bi):
            return
        # TODO Structs with private fields can not be serialized
        # TODO Structs with a constructor can not be serialized
        # TODO Get free_function

    def generate(self):
        # Generate the types
        for i in range(0, self.repo.get_n_infos(self.ns)):
            info = self.repo.get_info(self.ns, i)
            info_type = info.get_type()
            if info_type == GIRepository.InfoType.OBJECT:
                self._generate_object(info)
            elif info_type == GIRepository.InfoType.STRUCT:
                self._generate_struct(info)
            elif info_type == GIRepository.InfoType.FUNCTION:
                self._generate_function(info)
        return self.spec


class FridaResolver(connexion.resolver.Resolver):
    """
    Resolver for Connexion that uses Frida to call functions in a remote process.
    
    This resolver generates JSON representations of GIRepository function/method
    definitions that are compatible with the gstaudit.js Frida script. The JSON
    format matches the one generated by gstaudit/router.py.
    
    The resolver:
    1. Connects to a target process via Frida
    2. Loads the gstaudit.js script
    3. For each API operation, finds the corresponding GIRepository function
    4. Generates a JSON representation of the function signature
    5. Creates a handler that calls the Frida script with the JSON and arguments
    
    Example JSON format:
    {
        "arguments": [
            {
                "name": "this",
                "skipped": false,
                "closure": -1,
                "is_closure": false,
                "destroy": -1,
                "is_destroy": false,
                "direction": 0,
                "type": "pointer",
                "subtype": null
            }
        ],
        "is_method": true,
        "returns": "int32"
    }
    """
    def __init__(self, girest: GIRest, pid: int):
        self.girest = girest
        self.pid = pid
        self.script = None
        self.session = None
        # Connect to the corresponding process
        self._connect_frida()
        super().__init__()
 
    def _connect_frida(self):
        """Connect to the target process using Frida"""
        import frida
        import os
        
        # Attach to the process
        self.session = frida.attach(self.pid)
        
        # Load the JavaScript file (same as in gstaudit/main.py)
        # We need to find the gstaudit.js file
        script_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'gstaudit.js')
        with open(script_path, 'r') as f:
            self.script = self.session.create_script(f.read())
        
        # Set up message handler
        self.script.on('message', self._on_message)
        
        # Load and initialize the script
        self.script.load()
        self.script.exports_sync.init()
    
    def _on_message(self, message, data):
        """Handle messages from the Frida script"""
        # For now, just log the messages
        if message["type"] != "send":
            return
        # TODO: handle callbacks like in gstaudit/main.py if needed
        print(f"Message from Frida: {message}")
    
    def _type_to_json(self, t):
        """Convert GIRepository type to JSON type string"""
        # Get the type tag
        tag_enum = GIRepository.type_info_get_tag(t)
        tag = GIRepository.type_tag_to_string(tag_enum)
        
        # Check if it's an interface type
        if tag == "interface":
            interface = GIRepository.type_info_get_interface(t)
            if interface:
                info_type = interface.get_type()
                if info_type == GIRepository.InfoType.CALLBACK:
                    return "callback"
                elif info_type == GIRepository.InfoType.ENUM or info_type == GIRepository.InfoType.FLAGS:
                    return "int32"
        
        # Map GIRepository type tags to JSON type strings
        type_map = {
            "boolean": "bool",
            "int8": "int8",
            "uint8": "uint8",
            "int16": "int16",
            "uint16": "uint16",
            "int32": "int32",
            "uint32": "uint32",
            "int64": "int64",
            "uint64": "uint64",
            "utf8": "string",
            "float": "float",
            "double": "double",
            "void": "void"
        }
        
        return type_map.get(tag, "pointer")
    
    def _arg_to_json(self, arg):
        """Convert argument info to JSON representation"""
        arg_type = GIRepository.arg_info_get_type(arg)
        ret = {
            "name": arg.get_name(),
            "skipped": False,
            "closure": GIRepository.arg_info_get_closure(arg),
            "is_closure": False,
            "destroy": GIRepository.arg_info_get_destroy(arg),
            "is_destroy": False,
            "direction": GIRepository.arg_info_get_direction(arg),
            "type": self._type_to_json(arg_type),
            "subtype": None
        }
        
        # Handle callbacks
        if ret["type"] == "callback":
            interface = GIRepository.type_info_get_interface(arg_type)
            ret["subtype"] = self._callable_to_json(interface)
        
        return ret
    
    def _callable_to_json(self, cb, is_method=False):
        """Convert callable info to JSON representation"""
        ret = {
            "arguments": [],
            "is_method": is_method,
            "returns": self._type_to_json(GIRepository.callable_info_get_return_type(cb))
        }
        
        if is_method:
            # Prepend self argument
            ra = {
                "name": "this",
                "skipped": False,
                "closure": -1,
                "is_closure": False,
                "destroy": -1,
                "is_destroy": False,
                "direction": GIRepository.Direction.IN,
                "type": "pointer",
                "subtype": None
            }
            ret["arguments"].append(ra)
        
        # Add all arguments
        n_args = GIRepository.callable_info_get_n_args(cb)
        for i in range(n_args):
            arg = GIRepository.callable_info_get_arg(cb, i)
            ra = self._arg_to_json(arg)
            ret["arguments"].append(ra)
        
        # Mark skipped arguments
        for r in ret["arguments"]:
            if r["closure"] >= 0:
                ret["arguments"][r["closure"]]["skipped"] = True
                ret["arguments"][r["closure"]]["is_closure"] = True
            if r["destroy"] >= 0:
                ret["arguments"][r["destroy"]]["skipped"] = True
                ret["arguments"][r["destroy"]]["is_destroy"] = True
            if r["direction"] == GIRepository.Direction.OUT:
                r["skipped"] = True
        
        return ret
    
    def _method_to_json(self, method):
        """Generate complete method JSON representation"""
        flags = GIRepository.function_info_get_flags(method)
        is_method = bool(flags & GIRepository.FunctionInfoFlags.IS_METHOD)
        return self._callable_to_json(method, is_method=is_method)
    
    def _find_function_info(self, operation_id):
        """Find function info from operation_id"""
        # operation_id format: {namespace}_{object_name}_{method_name}
        # or {namespace}__{function_name} for standalone functions
        
        parts = operation_id.split('_')
        if len(parts) < 2:
            return None
        
        namespace = parts[0]
        
        # Search through the repository
        n_infos = self.girest.repo.get_n_infos(namespace)
        for i in range(n_infos):
            info = self.girest.repo.get_info(namespace, i)
            info_type = info.get_type()
            
            if info_type == GIRepository.InfoType.FUNCTION:
                # Standalone function: namespace__function_name
                if len(parts) == 3 and parts[1] == '' and info.get_name() == parts[2]:
                    return info
            elif info_type in [GIRepository.InfoType.OBJECT, GIRepository.InfoType.STRUCT]:
                # Method: namespace_objectname_methodname
                if len(parts) == 3 and info.get_name() == parts[1]:
                    # Search for the method
                    n_methods = GIRepository.object_info_get_n_methods(info) if info_type == GIRepository.InfoType.OBJECT else GIRepository.struct_info_get_n_methods(info)
                    for j in range(n_methods):
                        method = GIRepository.object_info_get_method(info, j) if info_type == GIRepository.InfoType.OBJECT else GIRepository.struct_info_get_method(info, j)
                        if method.get_name() == parts[2]:
                            return method
        
        return None

    def create_frida_handler(self):
        """Create handler that calls Frida with the method JSON"""
        def frida_resolver_handler(_symbol=None, _type=None, *args, **kwargs):
            # Call the Frida script with the symbol and method JSON
            result = self.script.exports_sync.call(_symbol, _type, *kwargs.values())
            return result

        return frida_resolver_handler

    def resolve_function_from_operation_id(self, operation_id):
        """Resolve function from operation_id and return handler"""
        # Find the function info
        method_info = self._find_function_info(operation_id)
        if not method_info:
            # Endpoints are generated by introspection, so this should never happen
            raise RuntimeError(f"Function not found for operation_id: {operation_id}")
        
        # Get the symbol name for the function
        symbol = GIRepository.function_info_get_symbol(method_info)
        
        # Generate the JSON representation
        method_json = self._method_to_json(method_info)
        
        # Create and return the handler
        ret = self.create_frida_handler()
        ret.__defaults__ = (symbol, method_json)
        return ret


class DummyResolver(connexion.resolver.Resolver):
    def resolve_function_from_operation_id(self, operation_id):
        def dummy_resolver_handler(*args, **kwargs):
            return {"received": kwargs}

        return dummy_resolver_handler


def run():
    # Parse the args
    ns = "Gst"
    ns_version = "1.0"

    girest = GIRest(ns, ns_version)
    spec = girest.generate()
    # Export to dict (for JSON/YAML serialization)
    openapi_schema = spec.to_dict()
    print(json.dumps(openapi_schema, indent=2))


# FIXME remove this once launched through poetry
if __name__ == "__main__":
    run()
