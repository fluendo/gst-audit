import logging

import gi
gi.require_version("GIRepository", "2.0")
from gi.repository import GIRepository
from apispec import APISpec

logger = logging.getLogger("girest")

class GIRest():
    pointer_schema = {
        "type": "string",
        "pattern": "^0x[0-9a-fA-F]+$|^[0-9]+$"
    }
    event_schema = {
        "type": "object",
        "required": ["data"],
        "properties": {
            "data": {
                "type": "string"
            }
        }
    }

    def __init__(self, ns, ns_version, sse_only=False):
        self.ns = ns
        self.ns_version = ns_version
        self.sse_only = sse_only  # If True, use SSE-style callbacks (old behavior)
        # To keep track of schemas already registered
        self.schemas = {}
        self.spec = APISpec(
            title=f"{ns} REST API",
            version=f"{ns_version}",
            openapi_version="3.0.2",
            info={
                "description": "API schema autogenerated by giREST",
                "x-girest-callback-mode": "sse" if sse_only else "url"
            },
        )
        # Include the Pointer and Event definitions
        self.spec.components.schema("Pointer", GIRest.pointer_schema)
        self.spec.components.schema("Event", GIRest.event_schema)
        # Load the corresponding Gir file
        self.repo = GIRepository.Repository()
        self.repo.require(ns, ns_version, 0)
        
        # Discover and load namespace dependencies
        self.namespaces = []
        # Start with the dependencies
        dependencies = self.repo.get_immediate_dependencies(ns)
        for dep in dependencies:
            dep_ns, dep_version = dep.split('-', 1)
            self.repo.require(dep_ns, dep_version, 0)
            self.namespaces.append((dep_ns, dep_version))
        self.namespaces.append((ns, ns_version))
        # Generate the generic callback endpoint
        # TODO define all callbacks as events as defined in 
        # https://spec.openapis.org/oas/v3.2.0.html#server-sent-event-streams
        operation = {
            "summary": "Callback emitters",
            "description": "",
            "operationId": "GIRest--callbacks",
            "tags": ["GIRest"],
            "responses": {
                "200": {
                    "description": "Success",
                    "content": {
                        "text/event-stream": {
                            "schema": {
                                "$ref": "#/components/schemas/Event"
                            }
                        }
                    }
                }
            },
        }
        self.spec.path(path="/GIRest/callbacks", operations={
            "get": operation
        })

    def _get_container_element_type_schema(self, container_type_info):
        """
        Get the element type schema from a container type (GList, GSList, etc.).
        
        Args:
            container_type_info: GIRepository type info for the container
            
        Returns:
            dict: Element type schema or None if not available
        """
        # Get the element type (parameter 0 for containers)
        element_type_info = GIRepository.type_info_get_param_type(container_type_info, 0)
        if element_type_info:
            return self._type_to_schema(element_type_info)
        
        return None

    def _type_to_schema(self, t):
        """Convert GIRepository type to OpenAPI schema"""
        tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(t))
        
        if tag == "void" and GIRepository.type_info_is_pointer(t):
            # Check if this is a void pointer (gpointer)
            # In GIRepository, gpointer is represented as void type with is_pointer=True
            return {"$ref": "#/components/schemas/Pointer"}
        elif tag == "void":
            # Handle void type (return None for non-pointer void, which indicates no return value)
            return None
        elif tag == "glist":
            # Handle GList type - generate GLibList schema if needed
            # GList is a struct in GLib that should be generated
            repo = GIRepository.Repository.get_default()
            list_info = repo.find_by_name("GLib", "List")
            if list_info:
                self._generate_struct(list_info)
            
            # Get element type schema
            element_type_schema = self._get_container_element_type_schema(t)
            schema = {"$ref": "#/components/schemas/GLibList"}
            
            # Add vendor-specific tag if element type is available
            if element_type_schema:
                schema["x-gi-element-type"] = element_type_schema
                
            return schema
        elif tag == "gslist":
            # Handle GSList type - generate GLibSList schema if needed
            repo = GIRepository.Repository.get_default()
            slist_info = repo.find_by_name("GLib", "SList")
            if slist_info:
                self._generate_struct(slist_info)
            
            # Get element type schema
            element_type_schema = self._get_container_element_type_schema(t)
            schema = {"$ref": "#/components/schemas/GLibSList"}
            
            # Add vendor-specific tag if element type is available
            if element_type_schema:
                schema["x-gi-element-type"] = element_type_schema
                
            return schema
        elif tag == "array":
            # Handle array type - only export C arrays for now
            array_type = GIRepository.type_info_get_array_type(t)
            
            # Only handle C arrays (GI_ARRAY_TYPE_C)
            if array_type != GIRepository.ArrayType.C:
                # Skip other array types (GArray, PtrArray, ByteArray, etc.)
                return None
            
            # Get element type schema
            element_type_schema = self._get_container_element_type_schema(t)
            
            schema = {"type": "array"}
            
            # Add items schema if element type is available
            if element_type_schema:
                schema["items"] = element_type_schema
                # Add vendor-specific tag for consistency with other containers
                schema["x-gi-element-type"] = element_type_schema
            else:
                # Default to any type if element type is not available
                schema["items"] = {}
            
            # Add vendor-specific tag for zero-terminated arrays
            schema["x-gi-array-null-terminated"] = GIRepository.type_info_is_zero_terminated(t)
                
            return schema
        elif tag == "interface":
            # Check if it's an interface type
            interface = GIRepository.type_info_get_interface(t)
            if interface:
                info_type = interface.get_type()
                if info_type == GIRepository.InfoType.ENUM or info_type == GIRepository.InfoType.FLAGS:
                    # Generate the enum schema if not already generated
                    self._generate_enum(interface)
                    # Return reference to the enum schema
                    full_name = f"{interface.get_namespace()}{interface.get_name()}"
                    return {"$ref": f"#/components/schemas/{full_name}"}
                elif info_type == GIRepository.InfoType.OBJECT:
                    # Generate the object schema if not already generated
                    self._generate_object(interface)
                    # Return reference to the object schema
                    full_name = f"{interface.get_namespace()}{interface.get_name()}"
                    return {"$ref": f"#/components/schemas/{full_name}"}
                elif info_type == GIRepository.InfoType.STRUCT:
                    # Check if this is a GType struct - these are not exposed in the schema
                    if GIRepository.struct_info_is_gtype_struct(interface):
                        # GType structs are treated as opaque pointers
                        return {"$ref": "#/components/schemas/Pointer"}
                    # Generate the struct schema if not already generated
                    self._generate_struct(interface)
                    # Return reference to the struct schema
                    full_name = f"{interface.get_namespace()}{interface.get_name()}"
                    return {"$ref": f"#/components/schemas/{full_name}"}
                elif info_type == GIRepository.InfoType.CALLBACK:
                    # Generate the callback schema if not already generated
                    self._generate_callback(interface)
                    # Return reference to the callback schema
                    full_name = f"{interface.get_namespace()}{interface.get_name()}"
                    return {"$ref": f"#/components/schemas/{full_name}"}
        
        # Map GIRepository type tags to OpenAPI types
        # Note: OpenAPI 3.0 doesn't distinguish between signed and unsigned integers
        # at the schema level - both use 'integer' type. Format specifications (int32, int64)
        # indicate precision but not signedness. For consistency, we:
        # - Omit format for 8/16-bit integers (no standard OpenAPI format exists)
        # - Use format: int32 for gint32 (most common)
        # - Omit format for guint32 (to avoid implying signedness)
        # - Use format: int64 for both gint64/guint64 (indicates 64-bit precision)
        type_map = {
            "gboolean": {"type": "boolean"},
            "gint8": {"type": "integer"},
            "guint8": {"type": "integer"},
            "gint16": {"type": "integer"},
            "guint16": {"type": "integer"},
            "gint32": {"type": "integer", "format": "int32"},
            "guint32": {"type": "integer"},
            "gint64": {"type": "integer", "format": "int64"},
            "guint64": {"type": "integer", "format": "int64"},
            "utf8": {"type": "string"},
            "gfloat": {"type": "number", "format": "float"},
            "gdouble": {"type": "number", "format": "double"},
            "gsize": {"type": "number", "format": "int64"},
            "gpointer": {"$ref": "#/components/schemas/Pointer"},
            "GType": {"type": "string"}, # FIXME beware ot this
        }
        
        
        ret = type_map.get(tag, {"$ref": "#/components/schemas/Pointer"})
        if not ret:
            logger.warning(f"Unknown type tag: {tag}")
        return ret

    def _transfer_to_str(self, transfer):
        if transfer == GIRepository.Transfer.NOTHING:
            transfer_str = "none"
        elif transfer == GIRepository.Transfer.CONTAINER:
            transfer_str = "container"
        elif transfer == GIRepository.Transfer.EVERYTHING:
            transfer_str = "full"
        else:
            transfer_str = "none"
        return transfer_str
 
    def _generate_function(self, bim, bi=None, is_constructor=False, is_destructor=False, is_copy=False):
        api = f"/{bim.get_namespace()}"
        if bi:
            api += f"/{bi.get_name()}"
        if GIRepository.function_info_get_flags(bim) & 1:
            api += "/{self}"
        api += f"/{bim.get_name()}"
        
        # Handle the parameters
        params = []
        response_props = {}
        
        # Add self parameter for methods
        if GIRepository.function_info_get_flags(bim) & 1:
            params.append({
               "name": "self",
               "in": "path",
               "required": True,
               "schema": {"$ref": f"#/components/schemas/{bi.get_namespace()}{bi.get_name()}"},
               "description": ""
            })
        
        # Get number of arguments
        n_args = GIRepository.callable_info_get_n_args(bim)
        
        # Track callbacks found in this method
        method_callbacks = []
        
        # First pass: identify which arguments should be skipped
        skip_indices = set()
        
        # Check return type for arrays with length parameters
        return_type = GIRepository.callable_info_get_return_type(bim)
        return_tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(return_type))
        if return_tag == "array":
            array_type = GIRepository.type_info_get_array_type(return_type)
            if array_type == GIRepository.ArrayType.C:
                length_idx = GIRepository.type_info_get_array_length(return_type)
                if length_idx >= 0:
                    skip_indices.add(length_idx)
        
        # Check all parameters for arrays with length parameters
        for i in range(n_args):
            arg = GIRepository.callable_info_get_arg(bim, i)
            arg_type = GIRepository.arg_info_get_type(arg)
            tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(arg_type))
            
            # Check if this parameter is an array with a length parameter
            if tag == "array":
                array_type = GIRepository.type_info_get_array_type(arg_type)
                if array_type == GIRepository.ArrayType.C:
                    length_idx = GIRepository.type_info_get_array_length(arg_type)
                    if length_idx >= 0:
                        skip_indices.add(length_idx)
            
            # Check if this is a callback
            if tag == "interface":
                interface = GIRepository.type_info_get_interface(arg_type)
                if interface and interface.get_type() == GIRepository.InfoType.CALLBACK:
                    # Mark closure and destroy arguments to be skipped
                    closure_idx = GIRepository.arg_info_get_closure(arg)
                    if closure_idx >= 0:
                        skip_indices.add(closure_idx)
                    destroy_idx = GIRepository.arg_info_get_destroy(arg)
                    if destroy_idx >= 0:
                        skip_indices.add(destroy_idx)
        
        # Second pass: process all arguments
        for i in range(n_args):
            arg = GIRepository.callable_info_get_arg(bim, i)
            arg_type = GIRepository.arg_info_get_type(arg)
            arg_name = arg.get_name()
            arg_direction = GIRepository.arg_info_get_direction(arg)
            
            # Skip arguments that are marked as skipped
            if i in skip_indices:
                continue
            
            # Check if this is a callback
            tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(arg_type))
            if tag == "interface":
                interface = GIRepository.type_info_get_interface(arg_type)
                if interface and interface.get_type() == GIRepository.InfoType.CALLBACK:
                    # Generate the callback schema (needed in both modes)
                    self._generate_callback(interface)
                    full_name = f"{interface.get_namespace()}{interface.get_name()}"
                    
                    if self.sse_only:
                        # SSE-only mode: check scope and skip sync callbacks
                        scope = GIRepository.arg_info_get_scope(arg)
                        is_sync = (scope == GIRepository.ScopeType.CALL)
                        
                        if is_sync:
                            # Skip methods with synchronous callbacks in SSE-only mode
                            return
                        
                        # For async callbacks in SSE-only mode, add callback ID to response (old behavior)
                        response_props[arg_name] = {
                            "type": "integer",
                            "description": "Callback ID",
                            "x-gi-callback": f"#/components/schemas/{full_name}"
                        }
                    else:
                        # Standard mode: generate full callback specification
                        # Generate OpenAPI callback specification
                        # Pass the arg (ArgInfo) so we can get the scope
                        callback_param, callbacks_obj, is_sync = self._generate_callback_argument(interface, arg, arg_name)
                        
                        # Add callback parameter to method
                        params.append(callback_param)
                        
                        # Store callback info for later
                        method_callbacks.append({
                            'name': arg_name,
                            'interface': interface,
                            'callbacks_obj': callbacks_obj,
                            'is_synchronous': is_sync
                        })
                    
                    continue
            
            # Handle output parameters - they go in the response
            if arg_direction == GIRepository.Direction.OUT:
                # unless the caller allocates and is not a struct or an object
                if tag != "interface" or (interface.get_type() in [GIRepository.InfoType.STRUCT, GIRepository.InfoType.OBJECT] and not GIRepository.arg_info_is_caller_allocates):
                    schema = self._type_to_schema(arg_type)
                    if schema:
                        response_props[arg_name] = schema
                    continue
            
            # Handle input and inout parameters
            schema = self._type_to_schema(arg_type)
            if not schema:
                continue
                
            # INOUT parameters go in both request and response
            if arg_direction == GIRepository.Direction.INOUT:
                response_props[arg_name] = schema
            
            # Add as query parameter
            param_schema = schema.copy()
            may_be_null = GIRepository.arg_info_may_be_null(arg)
            
            # Get transfer ownership information
            transfer_str = self._transfer_to_str(GIRepository.arg_info_get_ownership_transfer(arg))
           
            params.append({
                "name": arg_name,
                "in": "query",
                "required": not may_be_null,
                "schema": param_schema,
                "description": "",
                "x-gi-transfer": transfer_str,
                "style": "form",
                "explode": False
            })
        
        # Handle the return value
        return_type = GIRepository.callable_info_get_return_type(bim)
        return_schema = self._type_to_schema(return_type)
        if return_schema:
            # Get return value transfer ownership information
            return_transfer_str = self._transfer_to_str(GIRepository.callable_info_get_caller_owns(bim))
            # Add transfer information to return schema
            response_props["return"] = {
                **return_schema,
                "x-gi-transfer": return_transfer_str,
                "x-gi-null": GIRepository.callable_info_may_return_null(bim)
            }
        
        # Build response schema
        responses = {}
        if response_props:
            responses["200"] = {
                "description": "Success",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "properties": response_props
                        }
                    }
                }
            }
        else:
            responses["204"] = {"description": "No Content"}
        
        # Override constructor detection if explicitly passed
        if not is_constructor:
            flags = GIRepository.function_info_get_flags(bim)
            is_constructor = bool(flags & GIRepository.FunctionInfoFlags.IS_CONSTRUCTOR)
        
        # Build operation definition
        operation = {
            "summary": "",
            "description": "",
            "operationId": f"{bim.get_namespace()}-{bi.get_name() if bi else ''}-{bim.get_name()}",
            "tags": [f"{bi.get_namespace()}{bi.get_name()}"] if bi else [f"{bim.get_namespace()}"],
            "parameters": params,
            "responses": responses,
        }
        
        # Add callbacks if any were found
        if method_callbacks:
            callbacks_spec = {}
            for cb_info in method_callbacks:
                callbacks_spec.update(cb_info['callbacks_obj'])
            operation['callbacks'] = callbacks_spec
            
            # Add header parameters for callback authentication
            operation['parameters'].extend([
                {
                    'name': 'session-id',
                    'in': 'header',
                    'required': True if method_callbacks else False,
                    'schema': {'type': 'string'},
                    'description': 'Session identifier for callback routing'
                },
                {
                    'name': 'callback-secret',
                    'in': 'header',
                    'required': True if method_callbacks else False,
                    'schema': {'type': 'string'},
                    'description': 'Shared secret for callback HMAC signatures'
                }
            ])

        
        # Only add vendor-specific attributes when they are True
        if is_constructor:
            operation["x-gi-constructor"] = True
        if is_destructor:
            operation["x-gi-destructor"] = True
        if is_copy:
            operation["x-gi-copy"] = True
        
        # Add paths, components, etc. programmatically
        self.spec.path(path=api, operations={
            "get": operation
        })

    def _generate_object(self, bi):
        # If we already registered that, skip it
        full_name = f"{bi.get_namespace()}{bi.get_name()}"
        if full_name in self.schemas:
            return
        
        # Mark as generated early to prevent circular dependencies
        self.schemas[full_name] = True
        
        # Generate the type for every parent
        # In of GObject, use GTypeInstance as parent
        if bi.get_name() in ["Object","ParamSpec"] and bi.get_namespace() == "GObject":
            parent = self.repo.find_by_name("GObject", "TypeInstance")
        else:
            parent = GIRepository.object_info_get_parent(bi)

        # Now the class struct
        class_struct = GIRepository.object_info_get_class_struct(bi)
        if class_struct:
            self._generate_struct(class_struct, generate_class=True, class_of=bi)
        else:
            logger.warning(f"Object {bi.get_namespace()}.{bi.get_name()} has no class struct")

        if parent:
            full_parent_name = f"{parent.get_namespace()}{parent.get_name()}"
            self.spec.components.schema(
                full_name,
                {
                    "allOf": [
                        {"$ref": f"#/components/schemas/{full_parent_name}"},
                        {
                            "type": "object",
                        }
                    ],
                    "x-gi-type": "object",
                    "x-gi-namespace": f"{bi.get_namespace()}",
                    "x-gi-name": f"{bi.get_name()}",
                    "x-gi-class": f"{class_struct.get_namespace()}{class_struct.get_name()}" if class_struct else None
                }
           )
        else:
            self.spec.components.schema(
                full_name,
                {
                    "type": "object",
                    "properties": {
                        "ptr": {"$ref": "#/components/schemas/Pointer"},
                    },
                    "required": ["ptr"],
                    "x-gi-type": "object",
                    "x-gi-namespace": f"{bi.get_namespace()}",
                    "x-gi-name": f"{bi.get_name()}",
                    "x-gi-class": f"{class_struct.get_namespace()}{class_struct.get_name()}" if class_struct else None
                }
            )
        
        # Get official ref and unref function names from GIRepository API
        ref_func_name = None
        unref_func_name = None
        
        try:
            ref_func = GIRepository.object_info_get_ref_function(bi)
            if ref_func:
                ref_func_name = ref_func.get_name()
        except AttributeError:
            # API not available for older GIRepository versions
            pass
            
        try:
            unref_func = GIRepository.object_info_get_unref_function(bi)
            if unref_func:
                unref_func_name = unref_func.get_name()
        except AttributeError:
            # API not available for older GIRepository versions
            pass
        
        # Now the member functions
        found_unref_func = False
        found_ref_func = False
        for i in range(0, GIRepository.object_info_get_n_methods(bi)):
            bim = GIRepository.object_info_get_method(bi, i)
            method_name = bim.get_name()
            
            # Determine if this is a ref or unref method
            is_copy = False
            is_destructor = False
            
            # Check ref function
            if ref_func_name and method_name == ref_func_name:
                is_copy = True
                found_ref_func = True
            elif not ref_func_name and method_name in ['ref', 'ref_sink']:
                logger.warning(f"Using fallback detection for ref function '{method_name}' in {bi.get_namespace()}.{bi.get_name()}")
                is_copy = True
                found_ref_func = True
            
            # Check unref function    
            if unref_func_name and method_name == unref_func_name:
                is_destructor = True
                found_unref_func = True
            elif not unref_func_name and method_name == 'unref':
                logger.warning(f"Using fallback detection for unref function '{method_name}' in {bi.get_namespace()}.{bi.get_name()}")
                is_destructor = True
                found_unref_func = True
                
            self._generate_function(bim, bi, is_copy=is_copy, is_destructor=is_destructor)
        if not found_ref_func and ref_func_name:
            logger.warning(f"Ref function '{ref_func_name}' not found in methods of {bi.get_namespace()}.{bi.get_name()}")
        if not found_unref_func and unref_func_name:
            logger.warning(f"Unref function '{unref_func_name}' not found in methods of {bi.get_namespace()}.{bi.get_name()}")
        # The type function
        self._generate_get_type_function(bi)

        # Custom cases
        # ParamSpec does not export the ref/unref
        if bi.get_name() == "ParamSpec" and bi.get_namespace() == "GObject":
            if not found_ref_func:
                self._generate_generic_object_ref(bi)
            if not found_unref_func:
                self._generate_generic_object_unref(bi)

    def _generate_struct(self, bi, generate_class=False, class_of=None):
        # Only generate struct for classes when invoked from the object
        # This allows us to identify the object and the class with x-gi-class
        # and x-gi-class-of
        if not generate_class and GIRepository.struct_info_is_gtype_struct(bi):
            return
        # TODO Structs with a constructor can not be serialized

        # For now, generate a basic schema for structs as opaque pointer types
        # This prevents dangling references when structs are used as parameters
        full_name = f"{bi.get_namespace()}{bi.get_name()}"
        if full_name in self.schemas:
            return

        # Generate the type for every parent
        # If GObjectClass, use GTypeClass as parent
        if bi.get_name() in ["ObjectClass"] and bi.get_namespace() == "GObject":
            parent = self.repo.find_by_name("GObject", "TypeClass")
        elif class_of:
            # Get the parent of the class_of and get the class atribute there
            parent_instance = GIRepository.object_info_get_parent(class_of)
            if not parent_instance:
                parent = self.repo.find_by_name("GObject", "TypeClass")
            else:
                parent = GIRepository.object_info_get_class_struct(parent_instance)
        else:
            parent = None

        schema = {
            "x-gi-type": "struct",
            "x-gi-namespace": f"{bi.get_namespace()}",
            "x-gi-name": f"{bi.get_name()}"
        }

        if parent:
            full_parent_name = f"{parent.get_namespace()}{parent.get_name()}"
            schema["allOf"] = [
                {"$ref": f"#/components/schemas/{full_parent_name}"},
                {
                    "type": "object",
                }
            ]
        else:
            schema["type"] = "object"
            schema["properties"] = {
                "ptr": {"$ref": "#/components/schemas/Pointer"},
            }
            schema["required"] = ["ptr"]

        if generate_class and class_of:
            schema["x-gi-class-of"] = f"{class_of.get_namespace()}{class_of.get_name()}"

        self.spec.components.schema(
            full_name,
            schema
        )
        
        # Mark as generated
        self.schemas[full_name] = True
        
        # Generate endpoints for struct methods
        n_methods = GIRepository.struct_info_get_n_methods(bi)
        
        # Only process structs with methods
        if n_methods == 0:
            return
        
        # Get official copy and free function names from GIRepository API
        copy_func_name = None
        free_func_name = None
        
        try:
            copy_func = GIRepository.struct_info_get_copy_function(bi)
            if copy_func:
                copy_func_name = copy_func.get_name()
        except AttributeError:
            # API not available for older GIRepository versions (< 1.76)
            pass
            
        try:
            free_func = GIRepository.struct_info_get_free_function(bi)
            if free_func:
                free_func_name = free_func.get_name()
        except AttributeError:
            # API not available for older GIRepository versions (< 1.76)
            pass
        
        # Check existing methods for constructors/free and generate endpoints for struct methods
        has_constructor = False
        has_destructor = False
        for i in range(0, n_methods):
            bim = GIRepository.struct_info_get_method(bi, i)
            flags = GIRepository.function_info_get_flags(bim)
            is_constructor = bool(flags & GIRepository.FunctionInfoFlags.IS_CONSTRUCTOR)
            method_name = bim.get_name()
            
            # Check for constructor
            if is_constructor or method_name == 'new':
                has_constructor = True
            
            # Check for destructor using API first, then fallback
            if free_func_name and method_name == free_func_name:
                has_destructor = True
            elif not free_func_name and method_name == 'free':
                has_destructor = True
            
            # Determine if this is a copy or destructor method
            is_copy = False
            is_destructor = False
            
            # Check copy function
            if copy_func_name and method_name == copy_func_name:
                is_copy = True
            elif not copy_func_name and method_name in ['copy', 'ref']:
                logger.warning(f"Using fallback detection for copy function '{method_name}' in {bi.get_namespace()}.{bi.get_name()}")
                is_copy = True
                
            # Check destructor function  
            if free_func_name and method_name == free_func_name:
                is_destructor = True
            elif not free_func_name and method_name == 'free':
                logger.warning(f"Using fallback detection for free function '{method_name}' in {bi.get_namespace()}.{bi.get_name()}")
                is_destructor = True
                
            self._generate_function(bim, bi, is_constructor=is_constructor, is_copy=is_copy, is_destructor=is_destructor)
        
        # Generate endpoints for struct fields
        n_fields = GIRepository.struct_info_get_n_fields(bi)
        for i in range(n_fields):
            field_info = GIRepository.struct_info_get_field(bi, i)
            self._generate_field_endpoints(field_info, bi)
        
        # Generate get_type function if the struct has a registered GType
        self._generate_get_type_function(bi)

        # Custom cases
        # Avoid the Type generic free/new because those are not needed and GI explictly marks them
        # as not exported
        if bi.get_name() in ["TypeInstance", "TypeClass"]:
            return
        # Avoid the generic constructors/destructors for GObject classes
        if GIRepository.struct_info_is_gtype_struct(bi):
            return
        # Generate generic new/free endpoints if struct doesn't have constructor/free
        if not has_constructor:
            self._generate_generic_struct_new(bi)
        
        if not has_destructor:
            self._generate_generic_struct_free(bi)

    def _generate_callback(self, bi):
        """Generate OpenAPI schema for a callback"""
        full_name = f"{bi.get_namespace()}{bi.get_name()}"
        if full_name in self.schemas:
            return
        
        # Mark as generated early to prevent circular dependencies
        self.schemas[full_name] = True
        
        # Get callback parameters
        n_args = GIRepository.callable_info_get_n_args(bi)
        properties = {}
        
        for i in range(n_args):
            arg = GIRepository.callable_info_get_arg(bi, i)
            arg_type = GIRepository.arg_info_get_type(arg)
            arg_name = arg.get_name()
            
            # Get transfer ownership information
            transfer = GIRepository.arg_info_get_ownership_transfer(arg)
            if transfer == GIRepository.Transfer.NOTHING:
                transfer_str = "none"
            elif transfer == GIRepository.Transfer.CONTAINER:
                transfer_str = "container"
            elif transfer == GIRepository.Transfer.EVERYTHING:
                transfer_str = "full"
            else:
                transfer_str = "none"
            
            param_schema = self._type_to_schema(arg_type)
            # Ensure param_schema always has a value
            if not param_schema:
                param_schema = {"$ref": "#/components/schemas/Pointer"}
            
            # Add parameter as a property with transfer information
            properties[arg_name] = {
                **param_schema,
                "x-gi-transfer": transfer_str,
                "x-gi-is-return": False
            }
        
        # Get return type
        return_type = GIRepository.callable_info_get_return_type(bi)
        return_schema = self._type_to_schema(return_type)
        
        # Add return type to properties if it exists
        if return_schema:
            properties["return"] = {
                **return_schema,
                "x-gi-is-return": True
            }
            
            # Create a separate return value schema for HTTP responses (not in SSE-only mode)
            # This wraps the return value in an object with a "return" property
            # for consistency with how function returns work (which include out params)
            if not self.sse_only:
                return_schema_name = f"{full_name}Return"
                return_wrapper_schema = {
                    "type": "object",
                    "properties": {
                        "return": return_schema
                    }
                }
                self.spec.components.schema(return_schema_name, return_wrapper_schema)
        
        # Add HTTP callback invocation properties only in standard mode (not SSE-only)
        # These are used when the callback is invoked via HTTP POST
        if not self.sse_only:
            properties["sessionId"] = {
                "type": "string",
                "description": "Session identifier for routing"
            }
            properties["callbackName"] = {
                "type": "string",
                "description": "Name of the callback being invoked",
            }
            properties["args"] = {
                "type": "array",
                "description": "Callback arguments in order",
                "items": {}
            }
            properties["isComplete"] = {
                "type": "boolean",
                "description": "True when no more invocations will occur",
                "default": False
            }
            properties["invocationNumber"] = {
                "type": "integer",
                "description": "Sequential invocation counter"
            }
            properties["timestamp"] = {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp of callback invocation"
            }
        
        # Create callback schema
        callback_schema = {
            "type": "object",
            "x-gi-type": "callback",
            "properties": properties
        }
        
        # Add required fields only in standard mode
        if not self.sse_only:
            callback_schema["required"] = ["sessionId", "callbackName", "args"]
        
        self.spec.components.schema(full_name, callback_schema)
    
    def _generate_callback_argument(self, callback_info, arg_info, callback_arg_name):
        """
        Generate OpenAPI callback argument specification for a GObject callback.
        
        This creates the callback URL parameter and the callbacks object that
        describes what the server will POST to the client's callback URL.
        
        Args:
            callback_info: GIRepository callback info (the callback type)
            arg_info: GIRepository arg info (the parameter that has this callback type)
            callback_arg_name: Name of the callback argument (e.g., 'func', 'callback')
            
        Returns:
            tuple: (callback_param, callbacks_object, is_sync)
        """
        callback_name = callback_info.get_name()
        full_name = f"{callback_info.get_namespace()}{callback_name}"

        # Get the scope from the argument, not the callback type
        # According to GI, scope can be: call (sync), async, notified, forever
        scope = GIRepository.arg_info_get_scope(arg_info)
        
        # Determine if synchronous based on scope
        # GI_SCOPE_TYPE_CALL (0) means the callback is called synchronously
        # Other scopes are asynchronous:
        #   - GI_SCOPE_TYPE_ASYNC: fire and forget
        #   - GI_SCOPE_TYPE_NOTIFIED: called multiple times until destroyed
        #   - GI_SCOPE_TYPE_FOREVER: never destroyed
        is_sync = (scope == GIRepository.ScopeType.CALL)


        # Create callback URL parameter
        callback_param = {
            'name': f'{callback_arg_name}_url',
            'in': 'query',
            'required': True,
            'schema': {
                'type': 'string',
                'format': 'uri',
                'description': f'URL to invoke for {callback_name} callback'
            },
            'description': f'Callback URL that will be invoked with {callback_name} events',
            'x-gi-callback': f'#/components/schemas/{full_name}',
            'x-gi-callback-style': 'sync' if is_sync else 'async'
        }

        # Reference the callback schema which now includes invocation properties
        callback_schema_ref = f'#/components/schemas/{full_name}'
        
        # Build response schema based on sync/async
        if is_sync:
            # Synchronous callback: check if it has a return value
            return_type = GIRepository.callable_info_get_return_type(callback_info)
            return_schema = self._type_to_schema(return_type)
            
            if return_schema:
                # Reference the return value schema created in _generate_callback
                return_schema_name = f"{full_name}Return"
                return_schema_ref = f'#/components/schemas/{return_schema_name}'
                
                # Has return value: respond with 200 and the return value directly
                responses = {
                    '200': {
                        'description': 'Callback processed successfully, returns callback result',
                        'content': {
                            'application/json': {
                                'schema': {'$ref': return_schema_ref}
                            }
                        }
                    },
                    '400': {
                        'description': 'Invalid callback request'
                    },
                    '401': {
                        'description': 'Invalid signature or authentication failed'
                    },
                    '500': {
                        'description': 'Callback processing error'
                    }
                }
            else:
                # No return value: respond with 204 No Content
                responses = {
                    '204': {
                        'description': 'Callback processed successfully (no content)'
                    },
                    '400': {
                        'description': 'Invalid callback request'
                    },
                    '401': {
                        'description': 'Invalid signature or authentication failed'
                    },
                    '500': {
                        'description': 'Callback processing error'
                    }
                }
        else:
            # Asynchronous callback: fire-and-forget with 204 No Content
            responses = {
                '204': {
                    'description': 'Callback received (no content)'
                },
                '400': {
                    'description': 'Invalid callback request'
                },
                '401': {
                    'description': 'Invalid signature or authentication failed'
                },
                '500': {
                    'description': 'Callback processing error'
                }
            }

        # Build OpenAPI callback/webhook schema
        callback_schema_obj = {
            callback_name: {
                '{$request.query.' + callback_param['name'] + '}': {
                    'post': {
                        'summary': f'Callback for {callback_name}',
                        'description': f'Invoked by the server when {callback_name} callback fires',
                        'requestBody': {
                            'required': True,
                            'content': {
                                'application/json': {
                                    'schema': {'$ref': callback_schema_ref}
                                }
                            }
                        },
                        'responses': responses,
                        'security': [
                            {
                                'callbackSignature': []
                            }
                        ]
                    }
                }
            }
        }
        
        # For async callbacks, also register as webhook
        if not is_sync:
            webhook_schema = {
                'post': {
                    'summary': f'Webhook for {callback_name}',
                    'description': f'Asynchronous notification when {callback_name} fires',
                    'requestBody': {
                        'required': True,
                        'content': {
                            'application/json': {
                                'schema': {'$ref': callback_schema_ref}
                            }
                        }
                    },
                    'responses': responses
                }
            }

        return callback_param, callback_schema_obj, is_sync

    def _generate_generic_struct_new(self, bi):
        """Generate a generic 'new' endpoint for structs without constructors"""
        namespace = bi.get_namespace()
        name = bi.get_name()
        
        # Create API path: /{namespace}/{name}/new
        api = f"/{namespace}/{name}/new"
        
        # Build operation definition for the generic constructor
        operation = {
            "summary": f"Allocate memory for {name} struct",
            "description": f"Generic constructor for {name}",
            "operationId": f"{namespace}-{name}-new",
            "tags": [f"{namespace}{name}"],
            "parameters": [],
            "responses": {
                "200": {
                    "description": "Success",
                    "content": {
                        "application/json": {
                            "schema": {
                                "type": "object",
                                "properties": {
                                    "return": {"$ref": f"#/components/schemas/{namespace}{name}"}
                                }
                            }
                        }
                    }
                }
            },
            "x-gi-constructor": True
        }
        
        self.spec.path(path=api, operations={"get": operation})
    
    def _generate_generic_struct_free(self, bi):
        """Generate a generic 'free' endpoint for structs without free methods"""
        namespace = bi.get_namespace()
        name = bi.get_name()
        
        # Create API path: /{namespace}/{name}/{self}/free
        api = f"/{namespace}/{name}/{{self}}/free"
        
        # Build operation definition for the generic destructor
        operation = {
            "summary": f"Free memory for {name} struct",
            "description": f"Generic destructor that frees memory for {name}",
            "operationId": f"{namespace}-{name}-free",
            "tags": [f"{namespace}{name}"],
            "parameters": [
                {
                    "name": "self",
                    "in": "path",
                    "required": True,
                    "schema": {"$ref": f"#/components/schemas/{namespace}{name}"},
                    "description": "Pointer to the struct to free"
                }
            ],
            "responses": {
                "204": {"description": "No Content"}
            },
            "x-gi-destructor": True
        }
        
        self.spec.path(path=api, operations={"get": operation})

    def _generate_get_type_function(self, bi):
        """Generate get_type function for registered types (objects, structs, enums)"""
        # Get the type init function name (e.g., "gst_bin_get_type")
        type_init_func = GIRepository.registered_type_info_get_type_init(bi)
        if not type_init_func:
            return
            
        namespace = bi.get_namespace()
        # Build the API path (e.g., "/Gst/bin_get_type")
        api = f"/{namespace}/{bi.get_name()}/get_type"      
        # Build operation definition
        operation = {
            "summary": f"Get GType for {bi.get_name()}",
            "description": f"Returns the GType for {bi.get_name()}",
            "operationId": f"{namespace}-{bi.get_name()}-get_type",
            "tags": [f"{bi.get_namespace()}{bi.get_name()}"],
            "parameters": [],
            "responses": {
                "200": {
                    "description": "Success",
                    "content": {
                        "application/json": {
                            "schema": {
                                "type": "object",
                                "properties": {
                                    "return": {"type": "string" }
                                }
                            }
                        }
                    }
                }
            },
        }
        
        self.spec.path(path=api, operations={"get": operation})

    def _generate_generic_object_ref(self, bi):
        """Generate a generic 'ref' endpoint for objects that don't export it through GI"""
        namespace = bi.get_namespace()
        name = bi.get_name()
        
        # Create API path: /{namespace}/{name}/{self}/ref
        api = f"/{namespace}/{name}/{{self}}/ref"
        
        # Build operation definition for the ref function
        operation = {
            "summary": f"Increment reference count for {name}",
            "description": f"Generic ref function for {name}",
            "operationId": f"{namespace}-{name}-ref",
            "tags": [f"{namespace}{name}"],
            "parameters": [
                {
                    "name": "self",
                    "in": "path",
                    "required": True,
                    "schema": {"$ref": f"#/components/schemas/{namespace}{name}"},
                    "description": "Pointer to the object"
                }
            ],
            "responses": {
                "200": {
                    "description": "Success",
                    "content": {
                        "application/json": {
                            "schema": {
                                "type": "object",
                                "properties": {
                                    "return": {
                                        "$ref": f"#/components/schemas/{namespace}{name}",
                                        "x-gi-transfer": "none",
                                        "x-gi-null": False
                                    }
                                }
                            }
                        }
                    }
                }
            },
            "x-gi-copy": True
        }
        
        self.spec.path(path=api, operations={"get": operation})

    def _generate_generic_object_unref(self, bi):
        """Generate a generic 'unref' endpoint for objects that don't export it through GI"""
        namespace = bi.get_namespace()
        name = bi.get_name()
        
        # Create API path: /{namespace}/{name}/{self}/unref
        api = f"/{namespace}/{name}/{{self}}/unref"
        
        # Build operation definition for the unref function
        operation = {
            "summary": f"Decrement reference count for {name}",
            "description": f"Generic unref function for {name}",
            "operationId": f"{namespace}-{name}-unref",
            "tags": [f"{namespace}{name}"],
            "parameters": [
                {
                    "name": "self",
                    "in": "path",
                    "required": True,
                    "schema": {"$ref": f"#/components/schemas/{namespace}{name}"},
                    "description": "Pointer to the object"
                }
            ],
            "responses": {
                "204": {"description": "No Content"}
            },
            "x-gi-destructor": True
        }
        
        self.spec.path(path=api, operations={"get": operation})

    def _generate_field_endpoints(self, field_info, struct_info):
        """Generate GET and PUT endpoints for struct fields based on writability"""
        namespace = struct_info.get_namespace()
        struct_name = struct_info.get_name()
        field_name = field_info.get_name()

        is_writable = bool(GIRepository.field_info_get_flags(field_info) & GIRepository.FieldInfoFlags.WRITABLE)

        # Do not generate getters/setters iif there is already a method named the same way
        n_methods = GIRepository.struct_info_get_n_methods(struct_info)
        for i in range(0, n_methods):
            bim = GIRepository.struct_info_get_method(struct_info, i)
            method_name = bim.get_name()
            if method_name == f"get_{field_name}":
                logger.warning(f"Skipping field {field_name} of struct {struct_name} as it has a getter already")
                return
            if is_writable and method_name == f"set_{field_name}":
                logger.warning(f"Skipping field {field_name} of struct {struct_name} as it has a setter already")
                return

        
        # Get field type and offset
        field_type = GIRepository.field_info_get_type(field_info)
        field_offset = GIRepository.field_info_get_offset(field_info)
        
        # Convert field type to schema
        field_schema = self._type_to_schema(field_type)
        if not field_schema:
            # Skip fields with unsupported types
            logger.warning(f"Skipping field {field_name} of struct {struct_name} due to unsupported type")
            return
        
        # Generate GET endpoint (always available for readable fields)
        # Use 'fields' prefix to avoid collision with method endpoints
        get_api = f"/{namespace}/{struct_name}/{{self}}/fields/{field_name}"
        get_operation = {
            "summary": f"Get {field_name} field from {struct_name}",
            "description": f"Reads the {field_name} field at offset {field_offset}",
            "operationId": f"{namespace}-{struct_name}-{field_name}-get",
            "tags": [f"{namespace}{struct_name}"],
            "parameters": [
                {
                    "name": "self",
                    "in": "path",
                    "required": True,
                    "schema": {"$ref": f"#/components/schemas/{namespace}{struct_name}"},
                    "description": "Pointer to the struct instance"
                }
            ],
            "responses": {
                "200": {
                    "description": "Success",
                    "content": {
                        "application/json": {
                            "schema": {
                                "type": "object",
                                "properties": {
                                    "return": {
                                        **field_schema,
                                        "x-gi-null": True if "$ref" in field_schema else False,
                                    }
                                }
                            }
                        }
                    }
                }
            },
            "x-gi-field": True
        }
        
        self.spec.path(path=get_api, operations={"get": get_operation})
        
        # Generate PUT endpoint only if the field is writable
        if is_writable:
            # Use 'fields' prefix to avoid collision with method endpoints
            put_api = f"/{namespace}/{struct_name}/{{self}}/fields/{field_name}"
            put_operation = {
                "summary": f"Set {field_name} field in {struct_name}",
                "description": f"Writes to the {field_name} field at offset {field_offset}",
                "operationId": f"{namespace}-{struct_name}-{field_name}-put",
                "tags": [f"{namespace}{struct_name}"],
                "parameters": [
                    {
                        "name": "self",
                        "in": "path",
                        "required": True,
                        "schema": {"$ref": f"#/components/schemas/{namespace}{struct_name}"},
                        "description": "Pointer to the struct instance"
                    },
                    {
                        "name": "value",
                        "in": "query",
                        "required": True,
                        "schema": field_schema,
                        "description": f"Value to write to {field_name}"
                    }
                ],
                "responses": {
                    "204": {"description": "No Content"}
                },
                "x-gi-field": True
            }
            
            self.spec.path(path=put_api, operations={"put": put_operation})

    def _generate_enum(self, bi):
        """Generate OpenAPI schema for an enum"""
        full_name = f"{bi.get_namespace()}{bi.get_name()}"
        if full_name in self.schemas:
            return
        
        # Mark as generated early to prevent circular dependencies
        self.schemas[full_name] = True
        
        # Get all enum values
        n_values = GIRepository.enum_info_get_n_values(bi)
        enum_values = []
        for i in range(n_values):
            value_info = GIRepository.enum_info_get_value(bi, i)
            enum_values.append(value_info.get_name())
        
        # Create enum schema with string values
        # OpenAPI will accept string values, but we'll need to convert them
        # to integers when calling Frida
        info_type = bi.get_type()
        gi_type = "enum" if info_type == GIRepository.InfoType.ENUM else "flags"
        
        self.spec.components.schema(
            full_name,
            {
                "type": "string",
                "enum": enum_values,
                "description": f"Enum values for {bi.get_name()}",
                "x-gi-type": gi_type,
                "x-gi-namespace": f"{bi.get_namespace()}",
                "x-gi-name": f"{bi.get_name()}",
            }
        )
        
        # Generate endpoints for enum methods
        for i in range(0, GIRepository.enum_info_get_n_methods(bi)):
            bim = GIRepository.enum_info_get_method(bi, i)
            self._generate_function(bim, bi)
        
        # Generate get_type function for the enum
        self._generate_get_type_function(bi)

    def generate(self):
        # Generate the types for all namespaces (primary + dependencies)
        for namespace, version in self.namespaces:
            for i in range(0, self.repo.get_n_infos(namespace)):
                info = self.repo.get_info(namespace, i)
                info_type = info.get_type()
                if info_type == GIRepository.InfoType.OBJECT:
                    self._generate_object(info)
                elif info_type == GIRepository.InfoType.STRUCT:
                    self._generate_struct(info)
                elif info_type == GIRepository.InfoType.ENUM:
                    self._generate_enum(info)
                elif info_type == GIRepository.InfoType.FLAGS:
                    self._generate_enum(info)
                elif info_type == GIRepository.InfoType.FUNCTION:
                    self._generate_function(info)
        
        return self.spec
