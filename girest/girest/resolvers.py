import asyncio
import connexion
import gi
gi.require_version("GIRepository", "2.0")
from gi.repository import GIRepository

# Import for type hints
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from main import GIRest


class FridaResolver(connexion.resolver.Resolver):
    """
    Resolver for Connexion that uses Frida to call functions in a remote process.
    
    This resolver generates JSON representations of GIRepository function/method
    definitions that are compatible with the gstaudit.js Frida script. The JSON
    format matches the one generated by gstaudit/router.py.
    
    The resolver:
    1. Connects to a target process via Frida
    2. Loads the gstaudit.js script
    3. For each API operation, finds the corresponding GIRepository function
    4. Generates a JSON representation of the function signature
    5. Creates a handler that calls the Frida script with the JSON and arguments
    
    Example JSON format:
    {
        "arguments": [
            {
                "name": "this",
                "skipped": false,
                "closure": -1,
                "is_closure": false,
                "destroy": -1,
                "is_destroy": false,
                "direction": 0,
                "type": "pointer",
                "subtype": null
            }
        ],
        "is_method": true,
        "returns": "int32"
    }
    """
    def __init__(self, girest: "GIRest", pid: int):
        self.girest = girest
        self.pid = pid
        self.script = None
        self.session = None
        # Build enum value mappings for converting string names to integers
        self.enum_mappings = {}
        self._build_enum_mappings()
        # Connect to the corresponding process
        self._connect_frida()
        super().__init__()
 
    def _build_enum_mappings(self):
        """Build mappings from enum string names to integer values"""
        for i in range(0, self.girest.repo.get_n_infos(self.girest.ns)):
            info = self.girest.repo.get_info(self.girest.ns, i)
            info_type = info.get_type()
            if info_type == GIRepository.InfoType.ENUM or info_type == GIRepository.InfoType.FLAGS:
                full_name = f"{info.get_namespace()}{info.get_name()}"
                mapping = {}
                n_values = GIRepository.enum_info_get_n_values(info)
                for j in range(n_values):
                    value_info = GIRepository.enum_info_get_value(info, j)
                    mapping[value_info.get_name()] = GIRepository.value_info_get_value(value_info)
                self.enum_mappings[full_name] = mapping

 
    def _connect_frida(self):
        """Connect to the target process using Frida"""
        import frida
        import os
        
        # Attach to the process
        self.session = frida.attach(self.pid)
        
        # Load the JavaScript file (same as in gstaudit/main.py)
        # We need to find the gstaudit.js file
        script_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'gstaudit.js')
        with open(script_path, 'r') as f:
            self.script = self.session.create_script(f.read())
        
        # Set up message handler
        self.script.on('message', self._on_message)
        
        # Load and initialize the script
        self.script.load()
        self.script.exports_sync.init()
    
    def _on_message(self, message, data):
        """Handle messages from the Frida script"""
        if message["type"] != "send":
            return
        payload = message.get("payload", {})
        kind = payload.get("kind")
        
        # Handle callbacks by pushing them to the SSE buffer
        if kind == "callback":
            self.girest.push_sse_event(payload["data"])
        # Handle pipeline discovery messages
        elif kind == "pipeline":
            self.girest.add_pipeline(payload["data"])
        else:
            # For now, just log other messages
            print(f"Message from Frida: {message}")
    
    def _type_to_json(self, t):
        """Convert GIRepository type to JSON type string"""
        # Get the type tag
        tag_enum = GIRepository.type_info_get_tag(t)
        tag = GIRepository.type_tag_to_string(tag_enum)
        
        # Check if it's an interface type
        if tag == "interface":
            interface = GIRepository.type_info_get_interface(t)
            if interface:
                info_type = interface.get_type()
                if info_type == GIRepository.InfoType.CALLBACK:
                    return "callback"
                elif info_type == GIRepository.InfoType.ENUM or info_type == GIRepository.InfoType.FLAGS:
                    return "int32"
        
        # Map GIRepository type tags to JSON type strings
        type_map = {
            "gboolean": "bool",
            "gint8": "int8",
            "guint8": "uint8",
            "gint16": "int16",
            "guint16": "uint16",
            "gint32": "int32",
            "guint32": "uint32",
            "gint64": "int64",
            "guint64": "uint64",
            "utf8": "string",
            "gfloat": "float",
            "gdouble": "double",
            "void": "void"
        }

        return type_map.get(tag, "pointer")
    
    def _arg_to_json(self, arg):
        """Convert argument info to JSON representation"""
        arg_type = GIRepository.arg_info_get_type(arg)
        ret = {
            "name": arg.get_name(),
            "skipped": False,
            "closure": GIRepository.arg_info_get_closure(arg),
            "is_closure": False,
            "destroy": GIRepository.arg_info_get_destroy(arg),
            "is_destroy": False,
            "direction": GIRepository.arg_info_get_direction(arg),
            "type": self._type_to_json(arg_type),
            "subtype": None
        }
        
        # Handle callbacks
        if ret["type"] == "callback":
            interface = GIRepository.type_info_get_interface(arg_type)
            ret["subtype"] = self._callable_to_json(interface)
        
        return ret
    
    def _callable_to_json(self, cb, is_method=False):
        """Convert callable info to JSON representation"""
        ret = {
            "arguments": [],
            "is_method": is_method,
            "returns": self._type_to_json(GIRepository.callable_info_get_return_type(cb))
        }
        
        if is_method:
            # Prepend self argument
            ra = {
                "name": "this",
                "skipped": False,
                "closure": -1,
                "is_closure": False,
                "destroy": -1,
                "is_destroy": False,
                "direction": GIRepository.Direction.IN,
                "type": "pointer",
                "subtype": None
            }
            ret["arguments"].append(ra)
        
        # Add all arguments
        n_args = GIRepository.callable_info_get_n_args(cb)
        for i in range(n_args):
            arg = GIRepository.callable_info_get_arg(cb, i)
            ra = self._arg_to_json(arg)
            ret["arguments"].append(ra)
        
        # Mark skipped arguments
        for r in ret["arguments"]:
            if r["closure"] >= 0:
                ret["arguments"][r["closure"]]["skipped"] = True
                ret["arguments"][r["closure"]]["is_closure"] = True
            if r["destroy"] >= 0:
                ret["arguments"][r["destroy"]]["skipped"] = True
                ret["arguments"][r["destroy"]]["is_destroy"] = True
            if r["direction"] == GIRepository.Direction.OUT:
                r["skipped"] = True
        
        return ret
    
    def _method_to_json(self, method):
        """Generate complete method JSON representation"""
        flags = GIRepository.function_info_get_flags(method)
        is_method = bool(flags & GIRepository.FunctionInfoFlags.IS_METHOD)
        return self._callable_to_json(method, is_method=is_method)
    
    def _parse_operation_id(self, operation_id):
        """Parse operation_id into namespace, class/struct name, and method name.
        
        Returns:
            tuple: (namespace, class_name, method_name) or None if invalid format
        """
        parts = operation_id.split('-')
        if len(parts) < 2:
            return None
        
        if len(parts) == 3:
            return (parts[0], parts[1], parts[2])
        
        return None
    
    def _find_function_info(self, operation_id):
        """Find function info from operation_id"""
        # operation_id format: {namespace}_{object_name}_{method_name}
        # or {namespace}__{function_name} for standalone functions
        
        parts = operation_id.split('-')
        if len(parts) < 2:
            return None
        
        namespace = parts[0]
        
        # Search through the repository
        n_infos = self.girest.repo.get_n_infos(namespace)
        for i in range(n_infos):
            info = self.girest.repo.get_info(namespace, i)
            info_type = info.get_type()
            
            if info_type == GIRepository.InfoType.FUNCTION:
                # Standalone function: namespace__function_name
                if len(parts) == 3 and parts[1] == '' and info.get_name() == parts[2]:
                    return info
            elif info_type == GIRepository.InfoType.OBJECT:
                # Method: namespace_objectname_methodname
                if len(parts) == 3 and info.get_name() == parts[1]:
                    # Search for the method
                    n_methods = GIRepository.object_info_get_n_methods(info)
                    for j in range(n_methods):
                        method = GIRepository.object_info_get_method(info, j)
                        if method.get_name() == parts[2]:
                            return method
            elif info_type == GIRepository.InfoType.STRUCT:
                # Method: namespace_objectname_methodname
                if len(parts) == 3 and info.get_name() == parts[1]:
                    # Search for the method
                    n_methods = GIRepository.struct_info_get_n_methods(info)
                    for j in range(n_methods):
                        method = GIRepository.struct_info_get_method(info, j)
                        if method.get_name() == parts[2]:
                            return method
            elif info_type in [GIRepository.InfoType.ENUM, GIRepository.InfoType.FLAGS]:
                # Method: namespace_objectname_methodname
                if len(parts) == 3 and info.get_name() == parts[1]:
                    # Search for the method
                    n_methods = GIRepository.enum_info_get_n_methods(info)
                    for j in range(n_methods):
                        method = GIRepository.enum_info_get_method(info, j)
                        if method.get_name() == parts[2]:
                            return method
        
        return None

    def _create_generic_new_handler(self, struct_info):
        """Create handler for generic struct allocation"""
        size = GIRepository.struct_info_get_size(struct_info)
        
        async def generic_new_handler(*args, **kwargs):
            # Call the Frida script's generic alloc function
            result = await asyncio.to_thread(
                self.script.exports_sync.alloc, size
            )
            return {"return": result}
        
        return generic_new_handler
    
    def _create_generic_free_handler(self, struct_info):
        """Create handler for generic struct deallocation"""
        async def generic_free_handler(*args, **kwargs):
            # Extract the self parameter (pointer to free)
            ptr = kwargs.get('self')
            if ptr is None:
                raise ValueError("Missing 'self' parameter for free operation")
            
            # Call the Frida script's generic free function
            await asyncio.to_thread(
                self.script.exports_sync.free, ptr
            )
            return None
        
        return generic_free_handler

    def create_frida_handler(self):
        """Create handler that calls Frida with the method JSON, converting enum strings to integers"""
        async def frida_resolver_handler(_method=None, _type=None, *args, **kwargs):
            # Get the symbol from the method info
            symbol = GIRepository.function_info_get_symbol(_method)
            
            # Convert enum string values to integers before calling Frida
            converted_kwargs = {}
            n_args = GIRepository.callable_info_get_n_args(_method)
            
            for i in range(n_args):
                arg = GIRepository.callable_info_get_arg(_method, i)
                arg_name = arg.get_name()
                
                if arg_name in kwargs:
                    arg_type = GIRepository.arg_info_get_type(arg)
                    tag = GIRepository.type_tag_to_string(GIRepository.type_info_get_tag(arg_type))
                    
                    # Check if this is an enum type
                    if tag == "interface":
                        interface = GIRepository.type_info_get_interface(arg_type)
                        if interface and (interface.get_type() == GIRepository.InfoType.ENUM or 
                                         interface.get_type() == GIRepository.InfoType.FLAGS):
                            # Convert string enum name to integer value
                            full_name = f"{interface.get_namespace()}{interface.get_name()}"
                            enum_mapping = self.enum_mappings.get(full_name, {})
                            value = kwargs[arg_name]
                            if isinstance(value, str) and value in enum_mapping:
                                converted_kwargs[arg_name] = enum_mapping[value]
                            else:
                                converted_kwargs[arg_name] = value
                        else:
                            converted_kwargs[arg_name] = kwargs[arg_name]
                    else:
                        converted_kwargs[arg_name] = kwargs[arg_name]
            
            # Call the Frida script with the symbol and method JSON
            # Use asyncio.to_thread to avoid blocking the event loop with the sync Frida call
            result = await asyncio.to_thread(
                self.script.exports_sync.call, symbol, _type, *converted_kwargs.values()
            )
            return result

        return frida_resolver_handler

    def resolve_function_from_operation_id(self, operation_id):
        """Resolve function from operation_id and return handler"""
        # Check if this is a generic new/free operation
        # Format: {namespace}-{name}-{new|free}
        parsed = self._parse_operation_id(operation_id)
        if parsed:
            namespace, struct_name, operation = parsed
            
            # Check if operation is 'new' or 'free'
            if operation in ['new', 'free']:
                # Try to find the struct info
                struct_info = None
                n_infos = self.girest.repo.get_n_infos(namespace)
                for i in range(n_infos):
                    info = self.girest.repo.get_info(namespace, i)
                    if info.get_type() == GIRepository.InfoType.STRUCT and info.get_name() == struct_name:
                        struct_info = info
                        break
                
                if struct_info:
                    # Check if this struct has the actual method
                    method_info = self._find_function_info(operation_id)
                    
                    # If method doesn't exist, this is a generic operation
                    if not method_info:
                        if operation == 'new':
                            return self._create_generic_new_handler(struct_info)
                        elif operation == 'free':
                            return self._create_generic_free_handler(struct_info)
        
        # Find the function info
        method_info = self._find_function_info(operation_id)
        if not method_info:
            # Endpoints are generated by introspection, so this should never happen
            raise RuntimeError(f"Function not found for operation_id: {operation_id}")
        
        # Generate the JSON representation
        method_json = self._method_to_json(method_info)
        
        # Create and return the handler with method_info and method_json as defaults
        ret = self.create_frida_handler()
        ret.__defaults__ = (method_info, method_json)
        return ret


class DummyResolver(connexion.resolver.Resolver):
    def resolve_function_from_operation_id(self, operation_id):
        async def dummy_resolver_handler(*args, **kwargs):
            return {"received": kwargs}

        return dummy_resolver_handler
