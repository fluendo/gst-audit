/**
 * Gst REST API
 * Version: 1.0
 * Auto-generated by girest-ts
 */

export interface Pointer {
}

export interface GstAllocationParams {
  ptr: Pointer;
}

export interface GObjectObject {
  ptr: Pointer;
}

export interface GObjectTypeInterface {
  ptr: Pointer;
}

export interface GObjectParamSpec {
  ptr: Pointer;
}

export interface GObjectValue {
  ptr: Pointer;
}

export type GObjectBindingFlags = "default" | "bidirectional" | "sync_create" | "invert_boolean";

export interface GObjectBinding extends GObjectObject {
}

export interface GObjectClosure {
  ptr: Pointer;
}

export interface GObjectInitiallyUnowned extends GObjectObject {
}

export interface GstObject extends GObjectInitiallyUnowned {
}

export interface GstControlBinding extends GstObject {
}

export interface GstAllocator extends GstObject {
}

export interface GstMemory {
  ptr: Pointer;
}

export type GstAllocatorFlags = "custom_alloc" | "no_copy" | "last";

export interface GstAllocatorPrivate {
  ptr: Pointer;
}

export interface GstAtomicQueue {
  ptr: Pointer;
}

export interface GstElement extends GstObject {
}

export type GstURIType = "unknown" | "sink" | "src";

export interface GstPlugin extends GstObject {
}

export type GstPluginDependencyFlags = "none" | "recurse" | "paths_are_default_only" | "file_name_is_suffix" | "file_name_is_prefix" | "paths_are_relative_to_exe";

export interface GstStructure {
  ptr: Pointer;
}

export type GstStateChangeReturn = "failure" | "success" | "async" | "no_preroll";

export type GstState = "void_pending" | "null" | "ready" | "paused" | "playing";

export interface GstPad extends GstObject {
}

export type GstPadDirection = "unknown" | "src" | "sink";

export interface GstStaticPadTemplate {
  ptr: Pointer;
}

export interface GstPadTemplate extends GstObject {
}

export type GstPadPresence = "always" | "sometimes" | "request";

export interface GstCaps {
  ptr: Pointer;
}

export type GstPadLinkReturn = "ok" | "wrong_hierarchy" | "was_linked" | "wrong_direction" | "noformat" | "nosched" | "refused";

export namespace GstPadMode {
  export const NONE: 'none' = 'none';
  export const PUSH: 'push' = 'push';
  export const PULL: 'pull' = 'pull';
  static get_name(mode: GstPadMode): Promise<string>;
}
export type GstPadModeValue = "none" | "push" | "pull";

export type GstPadProbeType = "invalid" | "idle" | "block" | "buffer" | "buffer_list" | "event_downstream" | "event_upstream" | "event_flush" | "query_downstream" | "query_upstream" | "push" | "pull" | "blocking" | "data_downstream" | "data_upstream" | "data_both" | "block_downstream" | "block_upstream" | "event_both" | "query_both" | "all_both" | "scheduling";

export interface GstBuffer {
  ptr: Pointer;
}

export type GstFlowReturn = "custom_success_2" | "custom_success_1" | "custom_success" | "ok" | "not_linked" | "flushing" | "eos" | "not_negotiated" | "error" | "not_supported" | "custom_error" | "custom_error_1" | "custom_error_2";

export interface GstBufferList {
  ptr: Pointer;
}

export interface GstEvent {
  ptr: Pointer;
}

export namespace GstEventType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const FLUSH_START: 'flush_start' = 'flush_start';
  export const FLUSH_STOP: 'flush_stop' = 'flush_stop';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const CAPS: 'caps' = 'caps';
  export const SEGMENT: 'segment' = 'segment';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const TAG: 'tag' = 'tag';
  export const BUFFERSIZE: 'buffersize' = 'buffersize';
  export const SINK_MESSAGE: 'sink_message' = 'sink_message';
  export const STREAM_GROUP_DONE: 'stream_group_done' = 'stream_group_done';
  export const EOS: 'eos' = 'eos';
  export const TOC: 'toc' = 'toc';
  export const PROTECTION: 'protection' = 'protection';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const GAP: 'gap' = 'gap';
  export const INSTANT_RATE_CHANGE: 'instant_rate_change' = 'instant_rate_change';
  export const QOS: 'qos' = 'qos';
  export const SEEK: 'seek' = 'seek';
  export const NAVIGATION: 'navigation' = 'navigation';
  export const LATENCY: 'latency' = 'latency';
  export const STEP: 'step' = 'step';
  export const RECONFIGURE: 'reconfigure' = 'reconfigure';
  export const TOC_SELECT: 'toc_select' = 'toc_select';
  export const SELECT_STREAMS: 'select_streams' = 'select_streams';
  export const INSTANT_RATE_SYNC_TIME: 'instant_rate_sync_time' = 'instant_rate_sync_time';
  export const CUSTOM_UPSTREAM: 'custom_upstream' = 'custom_upstream';
  export const CUSTOM_DOWNSTREAM: 'custom_downstream' = 'custom_downstream';
  export const CUSTOM_DOWNSTREAM_OOB: 'custom_downstream_oob' = 'custom_downstream_oob';
  export const CUSTOM_DOWNSTREAM_STICKY: 'custom_downstream_sticky' = 'custom_downstream_sticky';
  export const CUSTOM_BOTH: 'custom_both' = 'custom_both';
  export const CUSTOM_BOTH_OOB: 'custom_both_oob' = 'custom_both_oob';
  static get_flags(type: GstEventType): Promise<GstEventTypeFlags>;
  static get_name(type: GstEventType): Promise<string>;
  static to_quark(type: GstEventType): Promise<number>;
  static to_sticky_ordering(type: GstEventType): Promise<number>;
}
export type GstEventTypeValue = "unknown" | "flush_start" | "flush_stop" | "stream_start" | "caps" | "segment" | "stream_collection" | "tag" | "buffersize" | "sink_message" | "stream_group_done" | "eos" | "toc" | "protection" | "segment_done" | "gap" | "instant_rate_change" | "qos" | "seek" | "navigation" | "latency" | "step" | "reconfigure" | "toc_select" | "select_streams" | "instant_rate_sync_time" | "custom_upstream" | "custom_downstream" | "custom_downstream_oob" | "custom_downstream_sticky" | "custom_both" | "custom_both_oob";

export type GstEventTypeFlags = "upstream" | "downstream" | "serialized" | "sticky" | "sticky_multi";

export interface GstStream extends GstObject {
}

export namespace GstStreamType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const AUDIO: 'audio' = 'audio';
  export const VIDEO: 'video' = 'video';
  export const CONTAINER: 'container' = 'container';
  export const TEXT: 'text' = 'text';
  static get_name(stype: GstStreamType): Promise<string>;
}
export type GstStreamTypeValue = "unknown" | "audio" | "video" | "container" | "text";

export type GstStreamFlags = "none" | "sparse" | "select" | "unselect";

export interface GstTagList {
  ptr: Pointer;
}

export type GstTaskState = "started" | "stopped" | "paused";

export interface GstIterator {
  ptr: Pointer;
}

export type GstPadLinkCheck = "nothing" | "hierarchy" | "template_caps" | "caps" | "no_reconfigure" | "default";

export interface GstQuery {
  ptr: Pointer;
}

export namespace GstFormat {
  export const UNDEFINED: 'undefined' = 'undefined';
  export const DEFAULT: 'default' = 'default';
  export const BYTES: 'bytes' = 'bytes';
  export const TIME: 'time' = 'time';
  export const BUFFERS: 'buffers' = 'buffers';
  export const PERCENT: 'percent' = 'percent';
  static get_by_nick(nick: string): Promise<GstFormat>;
  static get_details(format: GstFormat): Promise<GstFormatDefinition>;
  static get_name(format: GstFormat): Promise<string>;
  static iterate_definitions(): Promise<GstIterator>;
  static register(nick: string, description: string): Promise<GstFormat>;
  static to_quark(format: GstFormat): Promise<number>;
}
export type GstFormatValue = "undefined" | "default" | "bytes" | "time" | "buffers" | "percent";

export interface GstFormatDefinition {
  ptr: Pointer;
}

export namespace GstStateChange {
  export const NULL_TO_READY: 'null_to_ready' = 'null_to_ready';
  export const READY_TO_PAUSED: 'ready_to_paused' = 'ready_to_paused';
  export const PAUSED_TO_PLAYING: 'paused_to_playing' = 'paused_to_playing';
  export const PLAYING_TO_PAUSED: 'playing_to_paused' = 'playing_to_paused';
  export const PAUSED_TO_READY: 'paused_to_ready' = 'paused_to_ready';
  export const READY_TO_NULL: 'ready_to_null' = 'ready_to_null';
  export const NULL_TO_NULL: 'null_to_null' = 'null_to_null';
  export const READY_TO_READY: 'ready_to_ready' = 'ready_to_ready';
  export const PAUSED_TO_PAUSED: 'paused_to_paused' = 'paused_to_paused';
  export const PLAYING_TO_PLAYING: 'playing_to_playing' = 'playing_to_playing';
  static get_name(transition: GstStateChange): Promise<string>;
}
export type GstStateChangeValue = "null_to_ready" | "ready_to_paused" | "paused_to_playing" | "playing_to_paused" | "paused_to_ready" | "ready_to_null" | "null_to_null" | "ready_to_ready" | "paused_to_paused" | "playing_to_playing";

export interface GstBus extends GstObject {
}

export interface GstMessage {
  ptr: Pointer;
}

export interface GLibSource {
  ptr: Pointer;
}

export interface GLibPollFD {
  ptr: Pointer;
}

export namespace GstMessageType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const EOS: 'eos' = 'eos';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const INFO: 'info' = 'info';
  export const TAG: 'tag' = 'tag';
  export const BUFFERING: 'buffering' = 'buffering';
  export const STATE_CHANGED: 'state_changed' = 'state_changed';
  export const STATE_DIRTY: 'state_dirty' = 'state_dirty';
  export const STEP_DONE: 'step_done' = 'step_done';
  export const CLOCK_PROVIDE: 'clock_provide' = 'clock_provide';
  export const CLOCK_LOST: 'clock_lost' = 'clock_lost';
  export const NEW_CLOCK: 'new_clock' = 'new_clock';
  export const STRUCTURE_CHANGE: 'structure_change' = 'structure_change';
  export const STREAM_STATUS: 'stream_status' = 'stream_status';
  export const APPLICATION: 'application' = 'application';
  export const ELEMENT: 'element' = 'element';
  export const SEGMENT_START: 'segment_start' = 'segment_start';
  export const SEGMENT_DONE: 'segment_done' = 'segment_done';
  export const DURATION_CHANGED: 'duration_changed' = 'duration_changed';
  export const LATENCY: 'latency' = 'latency';
  export const ASYNC_START: 'async_start' = 'async_start';
  export const ASYNC_DONE: 'async_done' = 'async_done';
  export const REQUEST_STATE: 'request_state' = 'request_state';
  export const STEP_START: 'step_start' = 'step_start';
  export const QOS: 'qos' = 'qos';
  export const PROGRESS: 'progress' = 'progress';
  export const TOC: 'toc' = 'toc';
  export const RESET_TIME: 'reset_time' = 'reset_time';
  export const STREAM_START: 'stream_start' = 'stream_start';
  export const NEED_CONTEXT: 'need_context' = 'need_context';
  export const HAVE_CONTEXT: 'have_context' = 'have_context';
  export const EXTENDED: 'extended' = 'extended';
  export const DEVICE_ADDED: 'device_added' = 'device_added';
  export const DEVICE_REMOVED: 'device_removed' = 'device_removed';
  export const PROPERTY_NOTIFY: 'property_notify' = 'property_notify';
  export const STREAM_COLLECTION: 'stream_collection' = 'stream_collection';
  export const STREAMS_SELECTED: 'streams_selected' = 'streams_selected';
  export const REDIRECT: 'redirect' = 'redirect';
  export const DEVICE_CHANGED: 'device_changed' = 'device_changed';
  export const INSTANT_RATE_REQUEST: 'instant_rate_request' = 'instant_rate_request';
  export const ANY: 'any' = 'any';
  static get_name(type: GstMessageType): Promise<string>;
  static to_quark(type: GstMessageType): Promise<number>;
}
export type GstMessageTypeValue = "unknown" | "eos" | "error" | "warning" | "info" | "tag" | "buffering" | "state_changed" | "state_dirty" | "step_done" | "clock_provide" | "clock_lost" | "new_clock" | "structure_change" | "stream_status" | "application" | "element" | "segment_start" | "segment_done" | "duration_changed" | "latency" | "async_start" | "async_done" | "request_state" | "step_start" | "qos" | "progress" | "toc" | "reset_time" | "stream_start" | "need_context" | "have_context" | "extended" | "device_added" | "device_removed" | "property_notify" | "stream_collection" | "streams_selected" | "redirect" | "device_changed" | "instant_rate_request" | "any";

export type GstBusSyncReply = "drop" | "pass" | "async";

export interface GstClock extends GstObject {
}

export type GstClockReturn = "ok" | "early" | "unscheduled" | "busy" | "badtime" | "error" | "unsupported" | "done";

export interface GstContext {
  ptr: Pointer;
}

export interface GstPluginFeature extends GstObject {
}

export interface GstElementFactory extends GstPluginFeature {
}

export type GstRank = "none" | "marginal" | "secondary" | "primary";

export type GstSeekFlags = "none" | "flush" | "accurate" | "key_unit" | "segment" | "trickmode" | "skip" | "snap_before" | "snap_after" | "snap_nearest" | "trickmode_key_units" | "trickmode_no_audio" | "trickmode_forward_predicted" | "instant_rate_change";

export type GstSeekType = "none" | "set" | "end";

export interface GstBin extends GstElement {
}

export type GstElementFlags = "locked_state" | "sink" | "source" | "provide_clock" | "require_clock" | "indexable" | "last";

export type GstBinFlags = "no_resync" | "streams_aware" | "last";

export interface GstBinPrivate {
  ptr: Pointer;
}

export interface GstBitmask {
  ptr: Pointer;
}

export type GstBufferCopyFlags = "none" | "flags" | "timestamps" | "meta" | "memory" | "merge" | "deep";

export type GstBufferFlags = "live" | "decode_only" | "discont" | "resync" | "corrupted" | "marker" | "header" | "gap" | "droppable" | "delta_unit" | "tag_memory" | "sync_after" | "non_droppable" | "last";

export interface GstBufferPool extends GstObject {
}

export interface GstBufferPoolAcquireParams {
  ptr: Pointer;
}

export type GstBufferPoolAcquireFlags = "none" | "key_unit" | "dontwait" | "discont" | "last";

export interface GstBufferPoolPrivate {
  ptr: Pointer;
}

export type GstBufferingMode = "stream" | "download" | "timeshift" | "live";

export type GstBusFlags = "flushing" | "flag_last";

export interface GstBusPrivate {
  ptr: Pointer;
}

export interface GstByteArrayInterface {
  ptr: Pointer;
}

export interface GstCapsFeatures {
  ptr: Pointer;
}

export type GstCapsFlags = "any";

export type GstCapsIntersectMode = "zig_zag" | "first";

export interface GstClockEntry {
  ptr: Pointer;
}

export type GstClockEntryType = "single" | "periodic";

export type GstClockFlags = "can_do_single_sync" | "can_do_single_async" | "can_do_periodic_sync" | "can_do_periodic_async" | "can_set_resolution" | "can_set_master" | "needs_startup_sync" | "last";

export interface GstClockPrivate {
  ptr: Pointer;
}

export type GstClockType = "realtime" | "monotonic" | "other" | "tai";

export interface GstControlBindingPrivate {
  ptr: Pointer;
}

export interface GstControlSource extends GstObject {
}

export namespace GstCoreError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const STATE_CHANGE: 'state_change' = 'state_change';
  export const PAD: 'pad' = 'pad';
  export const THREAD: 'thread' = 'thread';
  export const NEGOTIATION: 'negotiation' = 'negotiation';
  export const EVENT: 'event' = 'event';
  export const SEEK: 'seek' = 'seek';
  export const CAPS: 'caps' = 'caps';
  export const TAG: 'tag' = 'tag';
  export const MISSING_PLUGIN: 'missing_plugin' = 'missing_plugin';
  export const CLOCK: 'clock' = 'clock';
  export const DISABLED: 'disabled' = 'disabled';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  static quark(): Promise<number>;
}
export type GstCoreErrorValue = "failed" | "too_lazy" | "not_implemented" | "state_change" | "pad" | "thread" | "negotiation" | "event" | "seek" | "caps" | "tag" | "missing_plugin" | "clock" | "disabled" | "num_errors";

export interface GstCustomMeta {
  ptr: Pointer;
}

export interface GstDateTime {
  ptr: Pointer;
}

export interface GstDebugCategory {
  ptr: Pointer;
}

export type GstDebugColorFlags = "fg_black" | "fg_red" | "fg_green" | "fg_yellow" | "fg_blue" | "fg_magenta" | "fg_cyan" | "fg_white" | "bg_black" | "bg_red" | "bg_green" | "bg_yellow" | "bg_blue" | "bg_magenta" | "bg_cyan" | "bg_white" | "bold" | "underline";

export type GstDebugColorMode = "off" | "on" | "unix";

export type GstDebugGraphDetails = "media_type" | "caps_details" | "non_default_params" | "states" | "full_params" | "all" | "verbose";

export namespace GstDebugLevel {
  export const NONE: 'none' = 'none';
  export const ERROR: 'error' = 'error';
  export const WARNING: 'warning' = 'warning';
  export const FIXME: 'fixme' = 'fixme';
  export const INFO: 'info' = 'info';
  export const DEBUG: 'debug' = 'debug';
  export const LOG: 'log' = 'log';
  export const TRACE: 'trace' = 'trace';
  export const MEMDUMP: 'memdump' = 'memdump';
  export const COUNT: 'count' = 'count';
  static get_name(level: GstDebugLevel): Promise<string>;
}
export type GstDebugLevelValue = "none" | "error" | "warning" | "fixme" | "info" | "debug" | "log" | "trace" | "memdump" | "count";

export interface GstDebugMessage {
  ptr: Pointer;
}

export interface GstDevice extends GstObject {
}

export interface GstDeviceMonitor extends GstObject {
}

export interface GstDeviceMonitorPrivate {
  ptr: Pointer;
}

export interface GstDevicePrivate {
  ptr: Pointer;
}

export interface GstDeviceProvider extends GstObject {
}

export interface GstDeviceProviderFactory extends GstPluginFeature {
}

export interface GstDeviceProviderPrivate {
  ptr: Pointer;
}

export interface GstDoubleRange {
  ptr: Pointer;
}

export interface GstDynamicTypeFactory extends GstPluginFeature {
}

export interface GstFlagSet {
  ptr: Pointer;
}

export interface GstFraction {
  ptr: Pointer;
}

export interface GstFractionRange {
  ptr: Pointer;
}

export type GstGapFlags = "data";

export interface GstProxyPad extends GstPad {
}

export interface GstGhostPad extends GstProxyPad {
}

export interface GstGhostPadPrivate {
  ptr: Pointer;
}

export interface GstInt64Range {
  ptr: Pointer;
}

export interface GstIntRange {
  ptr: Pointer;
}

export type GstIteratorItem = "skip" | "pass" | "end";

export type GstIteratorResult = "done" | "ok" | "resync" | "error";

export namespace GstLibraryError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const INIT: 'init' = 'init';
  export const SHUTDOWN: 'shutdown' = 'shutdown';
  export const SETTINGS: 'settings' = 'settings';
  export const ENCODE: 'encode' = 'encode';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  static quark(): Promise<number>;
}
export type GstLibraryErrorValue = "failed" | "too_lazy" | "init" | "shutdown" | "settings" | "encode" | "num_errors";

export type GstLockFlags = "read" | "write" | "exclusive" | "last";

export type GstMapFlags = "read" | "write" | "flag_last";

export interface GstMapInfo {
  ptr: Pointer;
}

export type GstMemoryFlags = "readonly" | "no_share" | "zero_prefixed" | "zero_padded" | "physically_contiguous" | "not_mappable" | "last";

export interface GstMeta {
  ptr: Pointer;
}

export type GstMetaFlags = "none" | "readonly" | "pooled" | "locked" | "last";

export interface GstMetaInfo {
  ptr: Pointer;
}

export interface GstMetaTransformCopy {
  ptr: Pointer;
}

export interface GstMiniObject {
  ptr: Pointer;
}

export type GstMiniObjectFlags = "lockable" | "lock_readonly" | "may_be_leaked" | "last";

export type GstObjectFlags = "may_be_leaked" | "constructed" | "last";

export type GstPadFlags = "blocked" | "flushing" | "eos" | "blocking" | "need_parent" | "need_reconfigure" | "pending_events" | "fixed_caps" | "proxy_caps" | "proxy_allocation" | "proxy_scheduling" | "accept_intersect" | "accept_template" | "last";

export interface GstPadPrivate {
  ptr: Pointer;
}

export interface GstPadProbeInfo {
  ptr: Pointer;
}

export type GstPadProbeReturn = "drop" | "ok" | "remove" | "pass" | "handled";

export type GstPadTemplateFlags = "last";

export interface GstParamArray extends GObjectParamSpec {
}

export interface GstParamFraction extends GObjectParamSpec {
}

export interface GstParamSpecArray {
  ptr: Pointer;
}

export interface GstParamSpecFraction {
  ptr: Pointer;
}

export interface GstParentBufferMeta {
  ptr: Pointer;
}

export interface GstParseContext {
  ptr: Pointer;
}

export namespace GstParseError {
  export const SYNTAX: 'syntax' = 'syntax';
  export const NO_SUCH_ELEMENT: 'no_such_element' = 'no_such_element';
  export const NO_SUCH_PROPERTY: 'no_such_property' = 'no_such_property';
  export const LINK: 'link' = 'link';
  export const COULD_NOT_SET_PROPERTY: 'could_not_set_property' = 'could_not_set_property';
  export const EMPTY_BIN: 'empty_bin' = 'empty_bin';
  export const EMPTY: 'empty' = 'empty';
  export const DELAYED_LINK: 'delayed_link' = 'delayed_link';
  static quark(): Promise<number>;
}
export type GstParseErrorValue = "syntax" | "no_such_element" | "no_such_property" | "link" | "could_not_set_property" | "empty_bin" | "empty" | "delayed_link";

export type GstParseFlags = "none" | "fatal_errors" | "no_single_element_bins" | "place_in_bin";

export interface GstPipeline extends GstBin {
}

export type GstPipelineFlags = "fixed_clock" | "last";

export interface GstPipelinePrivate {
  ptr: Pointer;
}

export type GstPluginAPIFlags = "members";

export interface GstPluginDesc {
  ptr: Pointer;
}

export namespace GstPluginError {
  export const MODULE: 'module' = 'module';
  export const DEPENDENCIES: 'dependencies' = 'dependencies';
  export const NAME_MISMATCH: 'name_mismatch' = 'name_mismatch';
  static quark(): Promise<number>;
}
export type GstPluginErrorValue = "module" | "dependencies" | "name_mismatch";

export type GstPluginFlags = "cached" | "blacklisted";

export interface GstPoll {
  ptr: Pointer;
}

export interface GstPollFD {
  ptr: Pointer;
}

export type GstProgressType = "start" | "continue" | "complete" | "canceled" | "error";

export interface GstPromise {
  ptr: Pointer;
}

export type GstPromiseResult = "pending" | "interrupted" | "replied" | "expired";

export interface GstProtectionMeta {
  ptr: Pointer;
}

export interface GstProxyPadPrivate {
  ptr: Pointer;
}

export type GstQOSType = "overflow" | "underflow" | "throttle";

export namespace GstQueryType {
  export const UNKNOWN: 'unknown' = 'unknown';
  export const POSITION: 'position' = 'position';
  export const DURATION: 'duration' = 'duration';
  export const LATENCY: 'latency' = 'latency';
  export const JITTER: 'jitter' = 'jitter';
  export const RATE: 'rate' = 'rate';
  export const SEEKING: 'seeking' = 'seeking';
  export const SEGMENT: 'segment' = 'segment';
  export const CONVERT: 'convert' = 'convert';
  export const FORMATS: 'formats' = 'formats';
  export const BUFFERING: 'buffering' = 'buffering';
  export const CUSTOM: 'custom' = 'custom';
  export const URI: 'uri' = 'uri';
  export const ALLOCATION: 'allocation' = 'allocation';
  export const SCHEDULING: 'scheduling' = 'scheduling';
  export const ACCEPT_CAPS: 'accept_caps' = 'accept_caps';
  export const CAPS: 'caps' = 'caps';
  export const DRAIN: 'drain' = 'drain';
  export const CONTEXT: 'context' = 'context';
  export const BITRATE: 'bitrate' = 'bitrate';
  export const SELECTABLE: 'selectable' = 'selectable';
  static get_flags(type: GstQueryType): Promise<GstQueryTypeFlags>;
  static get_name(type: GstQueryType): Promise<string>;
  static to_quark(type: GstQueryType): Promise<number>;
}
export type GstQueryTypeValue = "unknown" | "position" | "duration" | "latency" | "jitter" | "rate" | "seeking" | "segment" | "convert" | "formats" | "buffering" | "custom" | "uri" | "allocation" | "scheduling" | "accept_caps" | "caps" | "drain" | "context" | "bitrate" | "selectable";

export type GstQueryTypeFlags = "upstream" | "downstream" | "serialized";

export interface GstReferenceTimestampMeta {
  ptr: Pointer;
}

export interface GstRegistry extends GstObject {
}

export interface GstRegistryPrivate {
  ptr: Pointer;
}

export namespace GstResourceError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_FOUND: 'not_found' = 'not_found';
  export const BUSY: 'busy' = 'busy';
  export const OPEN_READ: 'open_read' = 'open_read';
  export const OPEN_WRITE: 'open_write' = 'open_write';
  export const OPEN_READ_WRITE: 'open_read_write' = 'open_read_write';
  export const CLOSE: 'close' = 'close';
  export const READ: 'read' = 'read';
  export const WRITE: 'write' = 'write';
  export const SEEK: 'seek' = 'seek';
  export const SYNC: 'sync' = 'sync';
  export const SETTINGS: 'settings' = 'settings';
  export const NO_SPACE_LEFT: 'no_space_left' = 'no_space_left';
  export const NOT_AUTHORIZED: 'not_authorized' = 'not_authorized';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  static quark(): Promise<number>;
}
export type GstResourceErrorValue = "failed" | "too_lazy" | "not_found" | "busy" | "open_read" | "open_write" | "open_read_write" | "close" | "read" | "write" | "seek" | "sync" | "settings" | "no_space_left" | "not_authorized" | "num_errors";

export interface GstSample {
  ptr: Pointer;
}

export type GstSchedulingFlags = "seekable" | "sequential" | "bandwidth_limited";

export type GstSearchMode = "exact" | "before" | "after";

export interface GstSegment {
  ptr: Pointer;
}

export type GstSegmentFlags = "none" | "reset" | "trickmode" | "skip" | "segment" | "trickmode_key_units" | "trickmode_forward_predicted" | "trickmode_no_audio";

export type GstSerializeFlags = "none" | "backward_compat" | "strict";

export interface GstTaskPool extends GstObject {
}

export interface GstSharedTaskPool extends GstTaskPool {
}

export interface GstSharedTaskPoolPrivate {
  ptr: Pointer;
}

export type GstStackTraceFlags = "none" | "full";

export interface GstStaticCaps {
  ptr: Pointer;
}

export interface GstStreamCollection extends GstObject {
}

export interface GstStreamCollectionPrivate {
  ptr: Pointer;
}

export namespace GstStreamError {
  export const FAILED: 'failed' = 'failed';
  export const TOO_LAZY: 'too_lazy' = 'too_lazy';
  export const NOT_IMPLEMENTED: 'not_implemented' = 'not_implemented';
  export const TYPE_NOT_FOUND: 'type_not_found' = 'type_not_found';
  export const WRONG_TYPE: 'wrong_type' = 'wrong_type';
  export const CODEC_NOT_FOUND: 'codec_not_found' = 'codec_not_found';
  export const DECODE: 'decode' = 'decode';
  export const ENCODE: 'encode' = 'encode';
  export const DEMUX: 'demux' = 'demux';
  export const MUX: 'mux' = 'mux';
  export const FORMAT: 'format' = 'format';
  export const DECRYPT: 'decrypt' = 'decrypt';
  export const DECRYPT_NOKEY: 'decrypt_nokey' = 'decrypt_nokey';
  export const NUM_ERRORS: 'num_errors' = 'num_errors';
  static quark(): Promise<number>;
}
export type GstStreamErrorValue = "failed" | "too_lazy" | "not_implemented" | "type_not_found" | "wrong_type" | "codec_not_found" | "decode" | "encode" | "demux" | "mux" | "format" | "decrypt" | "decrypt_nokey" | "num_errors";

export interface GstStreamPrivate {
  ptr: Pointer;
}

export type GstStreamStatusType = "create" | "enter" | "leave" | "destroy" | "start" | "pause" | "stop";

export type GstStructureChangeType = "link" | "unlink";

export interface GstSystemClock extends GstClock {
}

export interface GstSystemClockPrivate {
  ptr: Pointer;
}

export type GstTagFlag = "undefined" | "meta" | "encoded" | "decoded" | "count";

export type GstTagMergeMode = "undefined" | "replace_all" | "replace" | "append" | "prepend" | "keep" | "keep_all" | "count";

export type GstTagScope = "stream" | "global";

export interface GstTask extends GstObject {
}

export interface GLibRecMutex {
  ptr: Pointer;
}

export interface GstTaskPrivate {
  ptr: Pointer;
}

export interface GstTimedValue {
  ptr: Pointer;
}

export interface GstToc {
  ptr: Pointer;
}

export interface GstTocEntry {
  ptr: Pointer;
}

export namespace GstTocEntryType {
  export const ANGLE: 'angle' = 'angle';
  export const VERSION: 'version' = 'version';
  export const EDITION: 'edition' = 'edition';
  export const INVALID: 'invalid' = 'invalid';
  export const TITLE: 'title' = 'title';
  export const TRACK: 'track' = 'track';
  export const CHAPTER: 'chapter' = 'chapter';
  static get_nick(type: GstTocEntryType): Promise<string>;
}
export type GstTocEntryTypeValue = "angle" | "version" | "edition" | "invalid" | "title" | "track" | "chapter";

export type GstTocLoopType = "none" | "forward" | "reverse" | "ping_pong";

export type GstTocScope = "global" | "current";

export interface GstTracer extends GstObject {
}

export interface GstTracerFactory extends GstPluginFeature {
}

export interface GstTracerPrivate {
  ptr: Pointer;
}

export interface GstTracerRecord extends GstObject {
}

export type GstTracerValueFlags = "none" | "optional" | "aggregated";

export type GstTracerValueScope = "process" | "thread" | "element" | "pad";

export interface GstTypeFind {
  ptr: Pointer;
}

export interface GstTypeFindFactory extends GstPluginFeature {
}

export type GstTypeFindProbability = "none" | "minimum" | "possible" | "likely" | "nearly_certain" | "maximum";

export namespace GstURIError {
  export const UNSUPPORTED_PROTOCOL: 'unsupported_protocol' = 'unsupported_protocol';
  export const BAD_URI: 'bad_uri' = 'bad_uri';
  export const BAD_STATE: 'bad_state' = 'bad_state';
  export const BAD_REFERENCE: 'bad_reference' = 'bad_reference';
  static quark(): Promise<number>;
}
export type GstURIErrorValue = "unsupported_protocol" | "bad_uri" | "bad_state" | "bad_reference";

export interface GstUri {
  ptr: Pointer;
}

export interface GstValueArray {
  ptr: Pointer;
}

export interface GstValueList {
  ptr: Pointer;
}

export interface GstValueTable {
  ptr: Pointer;
}

export type GObjectParamFlags = "readable" | "writable" | "readwrite" | "construct" | "construct_only" | "lax_validation" | "static_name" | "private" | "static_nick" | "static_blurb" | "explicit_notify" | "deprecated";

export interface GObjectValueArray {
  ptr: Pointer;
}

export class GObjectObject {
  ptr!: Pointer;

  static newv(object_type: Pointer, n_parameters: number, parameters: Pointer): Promise<GObjectObject>;

  compat_control(what: number): Promise<number>;
  interface_find_property(g_iface: GObjectTypeInterface, property_name: string): Promise<GObjectParamSpec>;
  interface_install_property(g_iface: GObjectTypeInterface, pspec: GObjectParamSpec): Promise<void>;
  interface_list_properties(g_iface: GObjectTypeInterface): Promise<Pointer>;
  bind_property(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlags): Promise<GObjectBinding>;
  bind_property_full(source_property: string, target: GObjectObject, target_property: string, flags: GObjectBindingFlags, transform_to: GObjectClosure, transform_from: GObjectClosure): Promise<GObjectBinding>;
  force_floating(): Promise<void>;
  freeze_notify(): Promise<void>;
  get_data(key: string): Promise<void>;
  get_property(property_name: string, value: GObjectValue): Promise<void>;
  get_qdata(quark: number): Promise<void>;
  getv(n_properties: number, names: Pointer, values: Pointer): Promise<void>;
  is_floating(): Promise<boolean>;
  notify(property_name: string): Promise<void>;
  notify_by_pspec(pspec: GObjectParamSpec): Promise<void>;
  ref(): Promise<GObjectObject>;
  ref_sink(): Promise<GObjectObject>;
  run_dispose(): Promise<void>;
  set_data(key: string): Promise<void>;
  set_property(property_name: string, value: GObjectValue): Promise<void>;
  steal_data(key: string): Promise<void>;
  steal_qdata(quark: number): Promise<void>;
  thaw_notify(): Promise<void>;
  unref(): Promise<void>;
  watch_closure(closure: GObjectClosure): Promise<void>;
}

export class GObjectParamSpec {
  ptr!: Pointer;

  is_valid_name(name: string): Promise<boolean>;
  get_blurb(): Promise<string>;
  get_default_value(): Promise<GObjectValue>;
  get_name(): Promise<string>;
  get_name_quark(): Promise<number>;
  get_nick(): Promise<string>;
  get_qdata(quark: number): Promise<void>;
  get_redirect_target(): Promise<GObjectParamSpec>;
  set_qdata(quark: number): Promise<void>;
  sink(): Promise<void>;
  steal_qdata(quark: number): Promise<void>;
}

export class GObjectBinding {

  dup_source(): Promise<GObjectObject>;
  dup_target(): Promise<GObjectObject>;
  get_flags(): Promise<GObjectBindingFlags>;
  get_source(): Promise<GObjectObject>;
  get_source_property(): Promise<string>;
  get_target(): Promise<GObjectObject>;
  get_target_property(): Promise<string>;
  unbind(): Promise<void>;
}

export class GstObject {

  check_uniqueness(list: Pointer, name: string): Promise<boolean>;
  default_deep_notify(object: GObjectObject, orig: GstObject, pspec: GObjectParamSpec, excluded_props?: Pointer): Promise<void>;
  replace(oldobj?: GstObject, newobj?: GstObject): Promise<boolean>;
  add_control_binding(binding: GstControlBinding): Promise<boolean>;
  default_error(error: Pointer, debug?: string): Promise<void>;
  get_control_binding(property_name: string): Promise<GstControlBinding>;
  get_control_rate(): Promise<number>;
  get_g_value_array(property_name: string, timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean>;
  get_name(): Promise<string>;
  get_parent(): Promise<GstObject>;
  get_path_string(): Promise<string>;
  get_value(property_name: string, timestamp: number): Promise<GObjectValue>;
  has_active_control_bindings(): Promise<boolean>;
  has_ancestor(ancestor: GstObject): Promise<boolean>;
  has_as_ancestor(ancestor: GstObject): Promise<boolean>;
  has_as_parent(parent: GstObject): Promise<boolean>;
  ref(): Promise<GstObject>;
  remove_control_binding(binding: GstControlBinding): Promise<boolean>;
  set_control_binding_disabled(property_name: string, disabled: boolean): Promise<void>;
  set_control_bindings_disabled(disabled: boolean): Promise<void>;
  set_control_rate(control_rate: number): Promise<void>;
  set_name(name?: string): Promise<boolean>;
  set_parent(parent: GstObject): Promise<boolean>;
  suggest_next_sync(): Promise<number>;
  sync_values(timestamp: number): Promise<boolean>;
  unparent(): Promise<void>;
  unref(): Promise<void>;
}

export class GstControlBinding {

  get_g_value_array(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean>;
  get_value(timestamp: number): Promise<GObjectValue>;
  is_disabled(): Promise<boolean>;
  set_disabled(disabled: boolean): Promise<void>;
  sync_values(object: GstObject, timestamp: number, last_sync: number): Promise<boolean>;
}

export class GstAllocator {

  find(name?: string): Promise<GstAllocator>;
  register(name: string, allocator: GstAllocator): Promise<void>;
  alloc(size: number, params?: GstAllocationParams): Promise<GstMemory>;
  free(memory: GstMemory): Promise<void>;
  set_default(): Promise<void>;
}

export class GstElement {

  make_from_uri(type: GstURIType, uri: string, elementname?: string): Promise<GstElement>;
  register(plugin?: GstPlugin, name: string, rank: number, type: Pointer): Promise<boolean>;
  state_change_return_get_name(state_ret: GstStateChangeReturn): Promise<string>;
  state_get_name(state: GstState): Promise<string>;
  type_set_skip_documentation(type: Pointer): Promise<void>;
  abort_state(): Promise<void>;
  add_pad(pad: GstPad): Promise<boolean>;
  add_property_deep_notify_watch(property_name?: string, include_value: boolean): Promise<number>;
  add_property_notify_watch(property_name?: string, include_value: boolean): Promise<number>;
  call_async(): Promise<{ func?: number }>;
  change_state(transition: GstStateChange): Promise<GstStateChangeReturn>;
  continue_state(ret: GstStateChangeReturn): Promise<GstStateChangeReturn>;
  create_all_pads(): Promise<void>;
  decorate_stream_id(stream_id: string): Promise<string>;
  foreach_pad(): Promise<boolean>;
  foreach_sink_pad(): Promise<boolean>;
  foreach_src_pad(): Promise<boolean>;
  get_base_time(): Promise<number>;
  get_bus(): Promise<GstBus>;
  get_clock(): Promise<GstClock>;
  get_compatible_pad(pad: GstPad, caps?: GstCaps): Promise<GstPad>;
  get_compatible_pad_template(compattempl: GstPadTemplate): Promise<GstPadTemplate>;
  get_context(context_type: string): Promise<GstContext>;
  get_context_unlocked(context_type: string): Promise<GstContext>;
  get_contexts(): Promise<Pointer>;
  get_current_clock_time(): Promise<number>;
  get_current_running_time(): Promise<number>;
  get_factory(): Promise<GstElementFactory>;
  get_metadata(key: string): Promise<string>;
  get_pad_template(name: string): Promise<GstPadTemplate>;
  get_pad_template_list(): Promise<Pointer>;
  get_request_pad(name: string): Promise<GstPad>;
  get_start_time(): Promise<number>;
  get_state(timeout: number): Promise<GstStateChangeReturn>;
  get_static_pad(name: string): Promise<GstPad>;
  is_locked_state(): Promise<boolean>;
  iterate_pads(): Promise<GstIterator>;
  iterate_sink_pads(): Promise<GstIterator>;
  iterate_src_pads(): Promise<GstIterator>;
  link(dest: GstElement): Promise<boolean>;
  link_filtered(dest: GstElement, filter?: GstCaps): Promise<boolean>;
  link_pads(srcpadname?: string, dest: GstElement, destpadname?: string): Promise<boolean>;
  link_pads_filtered(srcpadname?: string, dest: GstElement, destpadname?: string, filter?: GstCaps): Promise<boolean>;
  link_pads_full(srcpadname?: string, dest: GstElement, destpadname?: string, flags: GstPadLinkCheck): Promise<boolean>;
  lost_state(): Promise<void>;
  message_full(type: GstMessageType, domain: number, code: number, text?: string, debug?: string, file: string, function: string, line: number): Promise<void>;
  message_full_with_details(type: GstMessageType, domain: number, code: number, text?: string, debug?: string, file: string, function: string, line: number, structure: GstStructure): Promise<void>;
  no_more_pads(): Promise<void>;
  post_message(message: GstMessage): Promise<boolean>;
  provide_clock(): Promise<GstClock>;
  query(query: GstQuery): Promise<boolean>;
  query_convert(src_format: GstFormat, src_val: number, dest_format: GstFormat): Promise<boolean>;
  query_duration(format: GstFormat): Promise<boolean>;
  query_position(format: GstFormat): Promise<boolean>;
  release_request_pad(pad: GstPad): Promise<void>;
  remove_pad(pad: GstPad): Promise<boolean>;
  remove_property_notify_watch(watch_id: number): Promise<void>;
  request_pad(templ: GstPadTemplate, name?: string, caps?: GstCaps): Promise<GstPad>;
  request_pad_simple(name: string): Promise<GstPad>;
  seek(rate: number, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: number, stop_type: GstSeekType, stop: number): Promise<boolean>;
  seek_simple(format: GstFormat, seek_flags: GstSeekFlags, seek_pos: number): Promise<boolean>;
  send_event(event: GstEvent): Promise<boolean>;
  set_base_time(time: number): Promise<void>;
  set_bus(bus?: GstBus): Promise<void>;
  set_clock(clock?: GstClock): Promise<boolean>;
  set_context(context: GstContext): Promise<void>;
  set_locked_state(locked_state: boolean): Promise<boolean>;
  set_start_time(time: number): Promise<void>;
  set_state(state: GstState): Promise<GstStateChangeReturn>;
  sync_state_with_parent(): Promise<boolean>;
  unlink(dest: GstElement): Promise<void>;
  unlink_pads(srcpadname: string, dest: GstElement, destpadname: string): Promise<void>;
}

export class GstPlugin {

  list_free(list: Pointer): Promise<void>;
  load_by_name(name: string): Promise<GstPlugin>;
  load_file(filename: Pointer): Promise<GstPlugin>;
  register_static(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package: string, origin: string): Promise<boolean>;
  register_static_full(major_version: number, minor_version: number, name: string, description: string, version: string, license: string, source: string, package: string, origin: string): Promise<boolean>;
  add_dependency(env_vars?: Pointer, paths?: Pointer, names?: Pointer, flags: GstPluginDependencyFlags): Promise<void>;
  add_dependency_simple(env_vars?: string, paths?: string, names?: string, flags: GstPluginDependencyFlags): Promise<void>;
  add_status_error(message: string): Promise<void>;
  add_status_info(message: string): Promise<void>;
  add_status_warning(message: string): Promise<void>;
  get_cache_data(): Promise<GstStructure>;
  get_description(): Promise<string>;
  get_filename(): Promise<Pointer>;
  get_license(): Promise<string>;
  get_name(): Promise<string>;
  get_origin(): Promise<string>;
  get_package(): Promise<string>;
  get_release_date_string(): Promise<string>;
  get_source(): Promise<string>;
  get_status_errors(): Promise<Pointer>;
  get_status_infos(): Promise<Pointer>;
  get_status_warnings(): Promise<Pointer>;
  get_version(): Promise<string>;
  is_loaded(): Promise<boolean>;
  load(): Promise<GstPlugin>;
  set_cache_data(cache_data: GstStructure): Promise<void>;
}

export class GstPadTemplate {

  static new(name_template: string, direction: GstPadDirection, presence: GstPadPresence, caps: GstCaps): Promise<GstPadTemplate>;
  static new_from_static_pad_template_with_gtype(pad_template: GstStaticPadTemplate, pad_type: Pointer): Promise<GstPadTemplate>;
  static new_with_gtype(name_template: string, direction: GstPadDirection, presence: GstPadPresence, caps: GstCaps, pad_type: Pointer): Promise<GstPadTemplate>;

  get_caps(): Promise<GstCaps>;
  get_documentation_caps(): Promise<GstCaps>;
  pad_created(pad: GstPad): Promise<void>;
  set_documentation_caps(caps: GstCaps): Promise<void>;
}

export class GstPad {

  static new(name?: string, direction: GstPadDirection): Promise<GstPad>;
  static new_from_static_template(templ: GstStaticPadTemplate, name: string): Promise<GstPad>;
  static new_from_template(templ: GstPadTemplate, name?: string): Promise<GstPad>;

  link_get_name(ret: GstPadLinkReturn): Promise<string>;
  activate_mode(mode: GstPadMode, active: boolean): Promise<boolean>;
  add_probe(mask: GstPadProbeType): Promise<number>;
  can_link(sinkpad: GstPad): Promise<boolean>;
  chain(buffer: GstBuffer): Promise<GstFlowReturn>;
  chain_list(list: GstBufferList): Promise<GstFlowReturn>;
  check_reconfigure(): Promise<boolean>;
  create_stream_id(parent: GstElement, stream_id?: string): Promise<string>;
  event_default(parent?: GstObject, event: GstEvent): Promise<boolean>;
  forward(): Promise<boolean>;
  get_allowed_caps(): Promise<GstCaps>;
  get_current_caps(): Promise<GstCaps>;
  get_direction(): Promise<GstPadDirection>;
  get_element_private(): Promise<void>;
  get_last_flow_return(): Promise<GstFlowReturn>;
  get_offset(): Promise<number>;
  get_pad_template(): Promise<GstPadTemplate>;
  get_pad_template_caps(): Promise<GstCaps>;
  get_parent_element(): Promise<GstElement>;
  get_peer(): Promise<GstPad>;
  get_range(offset: number, size: number): Promise<GstFlowReturn>;
  get_single_internal_link(): Promise<GstPad>;
  get_sticky_event(event_type: GstEventType, idx: number): Promise<GstEvent>;
  get_stream(): Promise<GstStream>;
  get_stream_id(): Promise<string>;
  get_task_state(): Promise<GstTaskState>;
  has_current_caps(): Promise<boolean>;
  is_active(): Promise<boolean>;
  is_blocked(): Promise<boolean>;
  is_blocking(): Promise<boolean>;
  is_linked(): Promise<boolean>;
  iterate_internal_links(): Promise<GstIterator>;
  iterate_internal_links_default(parent?: GstObject): Promise<GstIterator>;
  link(sinkpad: GstPad): Promise<GstPadLinkReturn>;
  link_full(sinkpad: GstPad, flags: GstPadLinkCheck): Promise<GstPadLinkReturn>;
  link_maybe_ghosting(sink: GstPad): Promise<boolean>;
  link_maybe_ghosting_full(sink: GstPad, flags: GstPadLinkCheck): Promise<boolean>;
  mark_reconfigure(): Promise<void>;
  needs_reconfigure(): Promise<boolean>;
  pause_task(): Promise<boolean>;
  peer_query(query: GstQuery): Promise<boolean>;
  peer_query_accept_caps(caps: GstCaps): Promise<boolean>;
  peer_query_caps(filter?: GstCaps): Promise<GstCaps>;
  peer_query_convert(src_format: GstFormat, src_val: number, dest_format: GstFormat): Promise<boolean>;
  peer_query_duration(format: GstFormat): Promise<boolean>;
  peer_query_position(format: GstFormat): Promise<boolean>;
  proxy_query_accept_caps(query: GstQuery): Promise<boolean>;
  proxy_query_caps(query: GstQuery): Promise<boolean>;
  pull_range(offset: number, size: number): Promise<GstFlowReturn>;
  push(buffer: GstBuffer): Promise<GstFlowReturn>;
  push_event(event: GstEvent): Promise<boolean>;
  push_list(list: GstBufferList): Promise<GstFlowReturn>;
  query(query: GstQuery): Promise<boolean>;
  query_accept_caps(caps: GstCaps): Promise<boolean>;
  query_caps(filter?: GstCaps): Promise<GstCaps>;
  query_convert(src_format: GstFormat, src_val: number, dest_format: GstFormat): Promise<boolean>;
  query_default(parent?: GstObject, query: GstQuery): Promise<boolean>;
  query_duration(format: GstFormat): Promise<boolean>;
  query_position(format: GstFormat): Promise<boolean>;
  remove_probe(id: number): Promise<void>;
  send_event(event: GstEvent): Promise<boolean>;
  set_activate_function_full(): Promise<{ activate?: number }>;
  set_activatemode_function_full(): Promise<{ activatemode?: number }>;
  set_active(active: boolean): Promise<boolean>;
  set_chain_function_full(): Promise<{ chain?: number }>;
  set_chain_list_function_full(): Promise<{ chainlist?: number }>;
  set_element_private(): Promise<void>;
  set_event_full_function_full(): Promise<{ event?: number }>;
  set_event_function_full(): Promise<{ event?: number }>;
  set_getrange_function_full(): Promise<{ get?: number }>;
  set_iterate_internal_links_function_full(): Promise<{ iterintlink?: number }>;
  set_link_function_full(): Promise<{ link?: number }>;
  set_offset(offset: number): Promise<void>;
  set_query_function_full(): Promise<{ query?: number }>;
  set_unlink_function_full(): Promise<{ unlink?: number }>;
  start_task(): Promise<boolean>;
  sticky_events_foreach(): Promise<{ foreach_func?: number }>;
  stop_task(): Promise<boolean>;
  store_sticky_event(event: GstEvent): Promise<GstFlowReturn>;
  unlink(sinkpad: GstPad): Promise<boolean>;
  use_fixed_caps(): Promise<void>;
}

export class GstStream {

  static new(stream_id?: string, caps?: GstCaps, type: GstStreamType, flags: GstStreamFlags): Promise<GstStream>;

  get_caps(): Promise<GstCaps>;
  get_stream_flags(): Promise<GstStreamFlags>;
  get_stream_id(): Promise<string>;
  get_stream_type(): Promise<GstStreamType>;
  get_tags(): Promise<GstTagList>;
  set_caps(caps?: GstCaps): Promise<void>;
  set_stream_flags(flags: GstStreamFlags): Promise<void>;
  set_stream_type(stream_type: GstStreamType): Promise<void>;
  set_tags(tags?: GstTagList): Promise<void>;
}

export class GstBus {

  static new(): Promise<GstBus>;

  add_signal_watch(): Promise<void>;
  add_signal_watch_full(priority: number): Promise<void>;
  add_watch(priority: number): Promise<number>;
  async_signal_func(message: GstMessage): Promise<boolean>;
  create_watch(): Promise<GLibSource>;
  disable_sync_message_emission(): Promise<void>;
  enable_sync_message_emission(): Promise<void>;
  get_pollfd(): Promise<{ fd?: GLibPollFD }>;
  have_pending(): Promise<boolean>;
  peek(): Promise<GstMessage>;
  poll(events: GstMessageType, timeout: number): Promise<GstMessage>;
  pop(): Promise<GstMessage>;
  pop_filtered(types: GstMessageType): Promise<GstMessage>;
  post(message: GstMessage): Promise<boolean>;
  remove_signal_watch(): Promise<void>;
  remove_watch(): Promise<boolean>;
  set_flushing(flushing: boolean): Promise<void>;
  set_sync_handler(): Promise<{ func?: number }>;
  sync_signal_handler(message: GstMessage): Promise<GstBusSyncReply>;
  timed_pop(timeout: number): Promise<GstMessage>;
  timed_pop_filtered(timeout: number, types: GstMessageType): Promise<GstMessage>;
}

export class GstClock {

  id_compare_func(): Promise<number>;
  id_get_clock(): Promise<GstClock>;
  id_get_time(): Promise<number>;
  id_ref(): Promise<void>;
  id_unref(): Promise<void>;
  id_unschedule(): Promise<void>;
  id_uses_clock(clock: GstClock): Promise<boolean>;
  id_wait(): Promise<GstClockReturn>;
  id_wait_async(): Promise<GstClockReturn>;
  add_observation(slave: number, master: number): Promise<boolean>;
  add_observation_unapplied(slave: number, master: number): Promise<boolean>;
  adjust_unlocked(internal: number): Promise<number>;
  adjust_with_calibration(internal_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number>;
  get_calibration(): Promise<{ internal?: number; external?: number; rate_num?: number; rate_denom?: number }>;
  get_internal_time(): Promise<number>;
  get_master(): Promise<GstClock>;
  get_resolution(): Promise<number>;
  get_time(): Promise<number>;
  get_timeout(): Promise<number>;
  is_synced(): Promise<boolean>;
  new_periodic_id(start_time: number, interval: number): Promise<void>;
  new_single_shot_id(time: number): Promise<void>;
  periodic_id_reinit(start_time: number, interval: number): Promise<boolean>;
  set_calibration(internal: number, external: number, rate_num: number, rate_denom: number): Promise<void>;
  set_master(master?: GstClock): Promise<boolean>;
  set_resolution(resolution: number): Promise<number>;
  set_synced(synced: boolean): Promise<void>;
  set_timeout(timeout: number): Promise<void>;
  single_shot_id_reinit(time: number): Promise<boolean>;
  unadjust_unlocked(external: number): Promise<number>;
  unadjust_with_calibration(external_target: number, cinternal: number, cexternal: number, cnum: number, cdenom: number): Promise<number>;
  wait_for_sync(timeout: number): Promise<boolean>;
}

export class GstPluginFeature {

  list_copy(list: Pointer): Promise<Pointer>;
  list_debug(list: Pointer): Promise<void>;
  list_free(list: Pointer): Promise<void>;
  rank_compare_func(): Promise<number>;
  check_version(min_major: number, min_minor: number, min_micro: number): Promise<boolean>;
  get_plugin(): Promise<GstPlugin>;
  get_plugin_name(): Promise<string>;
  get_rank(): Promise<number>;
  load(): Promise<GstPluginFeature>;
  set_rank(rank: number): Promise<void>;
}

export class GstElementFactory {

  find(name: string): Promise<GstElementFactory>;
  list_filter(list: Pointer, caps: GstCaps, direction: GstPadDirection, subsetonly: boolean): Promise<Pointer>;
  list_get_elements(type: number, minrank: GstRank): Promise<Pointer>;
  make(factoryname: string, name?: string): Promise<GstElement>;
  make_with_properties(factoryname: string, n: number, names?: Pointer, values?: Pointer): Promise<GstElement>;
  can_sink_all_caps(caps: GstCaps): Promise<boolean>;
  can_sink_any_caps(caps: GstCaps): Promise<boolean>;
  can_src_all_caps(caps: GstCaps): Promise<boolean>;
  can_src_any_caps(caps: GstCaps): Promise<boolean>;
  create(name?: string): Promise<GstElement>;
  create_with_properties(n: number, names?: Pointer, values?: Pointer): Promise<GstElement>;
  get_element_type(): Promise<Pointer>;
  get_metadata(key: string): Promise<string>;
  get_metadata_keys(): Promise<Pointer>;
  get_num_pad_templates(): Promise<number>;
  get_skip_documentation(): Promise<boolean>;
  get_static_pad_templates(): Promise<Pointer>;
  get_uri_protocols(): Promise<Pointer>;
  get_uri_type(): Promise<GstURIType>;
  has_interface(interfacename: string): Promise<boolean>;
  list_is_type(type: number): Promise<boolean>;
}

export class GstBin {

  static new(name?: string): Promise<GstBin>;

  add(element: GstElement): Promise<boolean>;
  find_unlinked_pad(direction: GstPadDirection): Promise<GstPad>;
  get_by_interface(iface: Pointer): Promise<GstElement>;
  get_by_name(name: string): Promise<GstElement>;
  get_by_name_recurse_up(name: string): Promise<GstElement>;
  get_suppressed_flags(): Promise<GstElementFlags>;
  iterate_all_by_element_factory_name(factory_name: string): Promise<GstIterator>;
  iterate_all_by_interface(iface: Pointer): Promise<GstIterator>;
  iterate_elements(): Promise<GstIterator>;
  iterate_recurse(): Promise<GstIterator>;
  iterate_sinks(): Promise<GstIterator>;
  iterate_sorted(): Promise<GstIterator>;
  iterate_sources(): Promise<GstIterator>;
  recalculate_latency(): Promise<boolean>;
  remove(element: GstElement): Promise<boolean>;
  set_suppressed_flags(flags: GstElementFlags): Promise<void>;
  sync_children_states(): Promise<boolean>;
}

export class GstBufferPool {

  static new(): Promise<GstBufferPool>;

  config_add_option(config: GstStructure, option: string): Promise<void>;
  config_get_allocator(config: GstStructure): Promise<boolean>;
  config_get_option(config: GstStructure, index: number): Promise<string>;
  config_get_params(config: GstStructure): Promise<boolean>;
  config_has_option(config: GstStructure, option: string): Promise<boolean>;
  config_n_options(config: GstStructure): Promise<number>;
  config_set_allocator(config: GstStructure, allocator?: GstAllocator, params?: GstAllocationParams): Promise<void>;
  config_set_params(config: GstStructure, caps?: GstCaps, size: number, min_buffers: number, max_buffers: number): Promise<void>;
  config_validate_params(config: GstStructure, caps?: GstCaps, size: number, min_buffers: number, max_buffers: number): Promise<boolean>;
  acquire_buffer(params?: GstBufferPoolAcquireParams): Promise<GstFlowReturn>;
  get_config(): Promise<GstStructure>;
  get_options(): Promise<Pointer>;
  has_option(option: string): Promise<boolean>;
  is_active(): Promise<boolean>;
  release_buffer(buffer: GstBuffer): Promise<void>;
  set_active(active: boolean): Promise<boolean>;
  set_config(config: GstStructure): Promise<boolean>;
  set_flushing(flushing: boolean): Promise<void>;
}

export class GstControlSource {

  control_source_get_value(timestamp: number): Promise<boolean>;
  control_source_get_value_array(timestamp: number, interval: number, n_values: number, values: Pointer): Promise<boolean>;
}

export class GstDevice {

  create_element(name?: string): Promise<GstElement>;
  get_caps(): Promise<GstCaps>;
  get_device_class(): Promise<string>;
  get_display_name(): Promise<string>;
  get_properties(): Promise<GstStructure>;
  has_classes(classes: string): Promise<boolean>;
  has_classesv(classes: Pointer): Promise<boolean>;
  reconfigure_element(element: GstElement): Promise<boolean>;
}

export class GstDeviceMonitor {

  static new(): Promise<GstDeviceMonitor>;

  add_filter(classes?: string, caps?: GstCaps): Promise<number>;
  get_bus(): Promise<GstBus>;
  get_devices(): Promise<Pointer>;
  get_providers(): Promise<Pointer>;
  get_show_all_devices(): Promise<boolean>;
  remove_filter(filter_id: number): Promise<boolean>;
  set_show_all_devices(show_all: boolean): Promise<void>;
  start(): Promise<boolean>;
  stop(): Promise<void>;
}

export class GstDeviceProvider {

  register(plugin?: GstPlugin, name: string, rank: number, type: Pointer): Promise<boolean>;
  can_monitor(): Promise<boolean>;
  device_add(device: GstDevice): Promise<void>;
  device_changed(device: GstDevice, changed_device: GstDevice): Promise<void>;
  device_remove(device: GstDevice): Promise<void>;
  get_bus(): Promise<GstBus>;
  get_devices(): Promise<Pointer>;
  get_factory(): Promise<GstDeviceProviderFactory>;
  get_hidden_providers(): Promise<Pointer>;
  get_metadata(key: string): Promise<string>;
  hide_provider(name: string): Promise<void>;
  is_started(): Promise<boolean>;
  start(): Promise<boolean>;
  stop(): Promise<void>;
  unhide_provider(name: string): Promise<void>;
}

export class GstDeviceProviderFactory {

  find(name: string): Promise<GstDeviceProviderFactory>;
  get_by_name(factoryname: string): Promise<GstDeviceProvider>;
  list_get_device_providers(minrank: GstRank): Promise<Pointer>;
  get(): Promise<GstDeviceProvider>;
  get_device_provider_type(): Promise<Pointer>;
  get_metadata(key: string): Promise<string>;
  get_metadata_keys(): Promise<Pointer>;
  has_classes(classes?: string): Promise<boolean>;
  has_classesv(classes?: Pointer): Promise<boolean>;
}

export class GstDynamicTypeFactory {

  load(factoryname: string): Promise<Pointer>;
}

export class GstFlagSet {
  ptr!: Pointer;

  register(flags_type: Pointer): Promise<Pointer>;
}

export class GstProxyPad {

  chain_default(pad: GstPad, parent?: GstObject, buffer: GstBuffer): Promise<GstFlowReturn>;
  chain_list_default(pad: GstPad, parent?: GstObject, list: GstBufferList): Promise<GstFlowReturn>;
  getrange_default(pad: GstPad, parent: GstObject, offset: number, size: number): Promise<GstFlowReturn>;
  iterate_internal_links_default(pad: GstPad, parent?: GstObject): Promise<GstIterator>;
  get_internal(): Promise<GstProxyPad>;
}

export class GstGhostPad {

  static new(name?: string, target: GstPad): Promise<GstGhostPad>;
  static new_from_template(name?: string, target: GstPad, templ: GstPadTemplate): Promise<GstGhostPad>;
  static new_no_target(name?: string, dir: GstPadDirection): Promise<GstGhostPad>;
  static new_no_target_from_template(name?: string, templ: GstPadTemplate): Promise<GstGhostPad>;

  activate_mode_default(pad: GstPad, parent?: GstObject, mode: GstPadMode, active: boolean): Promise<boolean>;
  internal_activate_mode_default(pad: GstPad, parent?: GstObject, mode: GstPadMode, active: boolean): Promise<boolean>;
  construct(): Promise<boolean>;
  get_target(): Promise<GstPad>;
  set_target(newtarget?: GstPad): Promise<boolean>;
}

export class GstPipeline {

  static new(name?: string): Promise<GstPipeline>;

  auto_clock(): Promise<void>;
  get_auto_flush_bus(): Promise<boolean>;
  get_bus(): Promise<GstBus>;
  get_configured_latency(): Promise<number>;
  get_delay(): Promise<number>;
  get_latency(): Promise<number>;
  get_pipeline_clock(): Promise<GstClock>;
  is_live(): Promise<boolean>;
  set_auto_flush_bus(auto_flush: boolean): Promise<void>;
  set_delay(delay: number): Promise<void>;
  set_latency(latency: number): Promise<void>;
  use_clock(clock?: GstClock): Promise<void>;
}

export class GstRegistry {

  fork_is_enabled(): Promise<boolean>;
  fork_set_enabled(enabled: boolean): Promise<void>;
  get(): Promise<GstRegistry>;
  add_feature(feature: GstPluginFeature): Promise<boolean>;
  add_plugin(plugin: GstPlugin): Promise<boolean>;
  check_feature_version(feature_name: string, min_major: number, min_minor: number, min_micro: number): Promise<boolean>;
  feature_filter(first: boolean): Promise<Pointer>;
  find_feature(name: string, type: Pointer): Promise<GstPluginFeature>;
  find_plugin(name: string): Promise<GstPlugin>;
  get_feature_list(type: Pointer): Promise<Pointer>;
  get_feature_list_by_plugin(name: string): Promise<Pointer>;
  get_feature_list_cookie(): Promise<number>;
  get_plugin_list(): Promise<Pointer>;
  lookup(filename: string): Promise<GstPlugin>;
  lookup_feature(name: string): Promise<GstPluginFeature>;
  plugin_filter(first: boolean): Promise<Pointer>;
  remove_feature(feature: GstPluginFeature): Promise<void>;
  remove_plugin(plugin: GstPlugin): Promise<void>;
  scan_path(path: Pointer): Promise<boolean>;
}

export class GstTaskPool {

  static new(): Promise<GstTaskPool>;

  cleanup(): Promise<void>;
  dispose_handle(): Promise<void>;
  join(): Promise<void>;
  prepare(): Promise<void>;
  push(): Promise<{ func?: number }>;
}

export class GstSharedTaskPool {

  static new(): Promise<GstSharedTaskPool>;

  get_max_threads(): Promise<number>;
  set_max_threads(max_threads: number): Promise<void>;
}

export class GstStreamCollection {

  static new(upstream_id?: string): Promise<GstStreamCollection>;

  add_stream(stream: GstStream): Promise<boolean>;
  get_size(): Promise<number>;
  get_stream(index: number): Promise<GstStream>;
  get_upstream_id(): Promise<string>;
}

export class GstSystemClock {

  obtain(): Promise<GstClock>;
  set_default(new_clock?: GstClock): Promise<void>;
}

export class GstTask {

  static new(): Promise<GstTask>;

  cleanup_all(): Promise<void>;
  get_pool(): Promise<GstTaskPool>;
  get_state(): Promise<GstTaskState>;
  join(): Promise<boolean>;
  pause(): Promise<boolean>;
  resume(): Promise<boolean>;
  set_enter_callback(): Promise<{ enter_func?: number }>;
  set_leave_callback(): Promise<{ leave_func?: number }>;
  set_lock(mutex: GLibRecMutex): Promise<void>;
  set_pool(pool: GstTaskPool): Promise<void>;
  set_state(state: GstTaskState): Promise<boolean>;
  start(): Promise<boolean>;
  stop(): Promise<boolean>;
}

export class GstTracer {

  register(plugin?: GstPlugin, name: string, type: Pointer): Promise<boolean>;
}

export class GstTracerFactory {

  get_list(): Promise<Pointer>;
  get_tracer_type(): Promise<Pointer>;
}

export class GstTypeFindFactory {

  get_list(): Promise<Pointer>;
  call_function(find: GstTypeFind): Promise<void>;
  get_caps(): Promise<GstCaps>;
  get_extensions(): Promise<Pointer>;
  has_function(): Promise<boolean>;
}

export class GstValueArray {
  ptr!: Pointer;

  append_and_take_value(value: GObjectValue, append_value: GObjectValue): Promise<void>;
  append_value(value: GObjectValue, append_value: GObjectValue): Promise<void>;
  get_size(value: GObjectValue): Promise<number>;
  get_value(value: GObjectValue, index: number): Promise<GObjectValue>;
  init(value: GObjectValue, prealloc: number): Promise<GObjectValue>;
  prepend_value(value: GObjectValue, prepend_value: GObjectValue): Promise<void>;
}

export class GstValueList {
  ptr!: Pointer;

  append_and_take_value(value: GObjectValue, append_value: GObjectValue): Promise<void>;
  append_value(value: GObjectValue, append_value: GObjectValue): Promise<void>;
  concat(value1: GObjectValue, value2: GObjectValue): Promise<{ dest?: GObjectValue }>;
  get_size(value: GObjectValue): Promise<number>;
  get_value(value: GObjectValue, index: number): Promise<GObjectValue>;
  init(value: GObjectValue, prealloc: number): Promise<GObjectValue>;
  merge(value1: GObjectValue, value2: GObjectValue): Promise<{ dest?: GObjectValue }>;
  prepend_value(value: GObjectValue, prepend_value: GObjectValue): Promise<void>;
}
